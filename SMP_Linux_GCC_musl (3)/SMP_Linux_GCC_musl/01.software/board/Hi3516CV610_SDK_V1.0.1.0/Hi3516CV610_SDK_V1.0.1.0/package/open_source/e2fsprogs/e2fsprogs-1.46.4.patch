diff --git a/aclocal.m4 b/aclocal.m4
index 0f39d30..206d5b0 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -977,6 +977,12 @@ changequote([,])dnl
            [gl_cv_host_cpu_c_abi=i386])
          ;;
 
+changequote(,)dnl
+       sw_64* )
+changequote([,])dnl
+         gl_cv_host_cpu_c_abi=sw_64
+         ;;
+
 changequote(,)dnl
        alphaev[4-8] | alphaev56 | alphapca5[67] | alphaev6[78] )
 changequote([,])dnl
@@ -1242,6 +1248,9 @@ EOF
 #ifndef __x86_64__
 #undef __x86_64__
 #endif
+#ifndef __sw_64__
+#undef __sw_64__
+#endif
 #ifndef __alpha__
 #undef __alpha__
 #endif
@@ -1355,7 +1364,7 @@ AC_DEFUN([gl_HOST_CPU_C_ABI_32BIT],
        case "$gl_cv_host_cpu_c_abi" in
          i386 | x86_64-x32 | arm | armhf | arm64-ilp32 | hppa | ia64-ilp32 | mips | mipsn32 | powerpc | riscv*-ilp32* | s390 | sparc)
            gl_cv_host_cpu_c_abi_32bit=yes ;;
-         x86_64 | alpha | arm64 | hppa64 | ia64 | mips64 | powerpc64 | powerpc64-elfv2 | riscv*-lp64* | s390x | sparc64 )
+         x86_64 | sw_64 | alpha | arm64 | hppa64 | ia64 | mips64 | powerpc64 | powerpc64-elfv2 | riscv*-lp64* | s390x | sparc64 )
            gl_cv_host_cpu_c_abi_32bit=no ;;
          *)
            gl_cv_host_cpu_c_abi_32bit=unknown ;;
@@ -1385,7 +1394,7 @@ AC_DEFUN([gl_HOST_CPU_C_ABI_32BIT],
 
          # CPUs that only support a 64-bit ABI.
 changequote(,)dnl
-         alpha | alphaev[4-8] | alphaev56 | alphapca5[67] | alphaev6[78] \
+         sw_64* | alpha | alphaev[4-8] | alphaev56 | alphapca5[67] | alphaev6[78] \
          | mmix )
 changequote([,])dnl
            gl_cv_host_cpu_c_abi_32bit=no
diff --git a/configure b/configure
index 405b730..bc483dc 100755
--- a/configure
+++ b/configure
@@ -4462,7 +4462,7 @@ $as_echo_n "checking for additional special compiler flags... " >&6; }
 if test "$GCC" = yes
 then
     case "$host_cpu" in
-	alpha)		addcflags="-mieee" ;;
+	alpha | sw_64)		addcflags="-mieee" ;;
     esac
 fi
 if test "x$addcflags" != x
@@ -7552,7 +7552,7 @@ else
        case "$gl_cv_host_cpu_c_abi" in
          i386 | x86_64-x32 | arm | armhf | arm64-ilp32 | hppa | ia64-ilp32 | mips | mipsn32 | powerpc | riscv*-ilp32* | s390 | sparc)
            gl_cv_host_cpu_c_abi_32bit=yes ;;
-         x86_64 | alpha | arm64 | hppa64 | ia64 | mips64 | powerpc64 | powerpc64-elfv2 | riscv*-lp64* | s390x | sparc64 )
+         x86_64 | alpha | sw_64 | arm64 | hppa64 | ia64 | mips64 | powerpc64 | powerpc64-elfv2 | riscv*-lp64* | s390x | sparc64 )
            gl_cv_host_cpu_c_abi_32bit=no ;;
          *)
            gl_cv_host_cpu_c_abi_32bit=unknown ;;
@@ -7581,7 +7581,7 @@ else
            ;;
 
          # CPUs that only support a 64-bit ABI.
-         alpha | alphaev[4-8] | alphaev56 | alphapca5[67] | alphaev6[78] \
+         sw_64* | alpha | alphaev[4-8] | alphaev56 | alphapca5[67] | alphaev6[78] \
          | mmix )
            gl_cv_host_cpu_c_abi_32bit=no
            ;;
diff --git a/configure.ac b/configure.ac
index 824a93d..6f39955 100644
--- a/configure.ac
+++ b/configure.ac
@@ -113,7 +113,7 @@ AC_MSG_CHECKING(for additional special compiler flags)
 if test "$GCC" = yes
 then
     case "$host_cpu" in
-	alpha)		addcflags="-mieee" ;;
+	alpha | sw_64)		addcflags="-mieee" ;;
     esac
 fi
 if test "x$addcflags" != x
diff --git a/debugfs/debugfs.8.in b/debugfs/debugfs.8.in
index aa6128a..a3227a8 100644
--- a/debugfs/debugfs.8.in
+++ b/debugfs/debugfs.8.in
@@ -505,7 +505,7 @@ which is a hard link to
 .IR filespec .
 Note this does not adjust the inode reference counts.
 .TP
-.BI logdump " [-acsOS] [-b block] [-i filespec] [-f journal_file] [output_file]"
+.BI logdump " [-acsOS] [-b block] [-n num_trans ] [-i filespec] [-f journal_file] [output_file]"
 Dump the contents of the ext3 journal.  By default, dump the journal inode as
 specified in the superblock.  However, this can be overridden with the
 .I \-i
@@ -528,7 +528,7 @@ The
 .I \-a
 option causes the
 .B logdump
-program to print the contents of all of the descriptor blocks.
+to print the contents of all of the descriptor blocks.
 The
 .I \-b
 option causes
@@ -548,6 +548,15 @@ The
 option causes logdump to display old (checkpointed) journal entries.
 This can be used to try to track down journal problems even after the
 journal has been replayed.
+.IP
+The
+.I \-n
+option causes
+.B logdump
+to continue past a journal block which is missing a magic number.
+Instead, it will stop only when the entire log is printed or after
+.I num_trans
+transactions.
 .TP
 .BI ls " [-l] [-c] [-d] [-p] [-r] filespec"
 Print a listing of the files in the directory
diff --git a/debugfs/journal.c b/debugfs/journal.c
index 095fff0..5bac0d3 100644
--- a/debugfs/journal.c
+++ b/debugfs/journal.c
@@ -769,6 +769,8 @@ static errcode_t recover_ext3_journal(ext2_filsys fs)
 		mark_buffer_dirty(journal->j_sb_buffer);
 	}
 
+	journal->j_tail_sequence = journal->j_transaction_sequence;
+
 errout:
 	jbd2_journal_destroy_revoke(journal);
 	jbd2_journal_destroy_revoke_record_cache();
diff --git a/debugfs/logdump.c b/debugfs/logdump.c
index 74b8935..0e1939d 100644
--- a/debugfs/logdump.c
+++ b/debugfs/logdump.c
@@ -41,6 +41,7 @@ enum journal_location {JOURNAL_IS_INTERNAL, JOURNAL_IS_EXTERNAL};
 #define ANY_BLOCK ((blk64_t) -1)
 
 static int		dump_all, dump_super, dump_old, dump_contents, dump_descriptors;
+static int64_t		dump_counts;
 static blk64_t		block_to_dump, bitmap_to_dump, inode_block_to_dump;
 static unsigned int	group_to_dump, inode_offset_to_dump;
 static ext2_ino_t	inode_to_dump;
@@ -106,9 +107,10 @@ void do_logdump(int argc, char **argv, int sci_idx EXT2FS_ATTR((unused)),
 	bitmap_to_dump = -1;
 	inode_block_to_dump = ANY_BLOCK;
 	inode_to_dump = -1;
+	dump_counts = -1;
 
 	reset_getopt();
-	while ((c = getopt (argc, argv, "ab:ci:f:OsS")) != EOF) {
+	while ((c = getopt (argc, argv, "ab:ci:f:OsSn:")) != EOF) {
 		switch (c) {
 		case 'a':
 			dump_all++;
@@ -141,6 +143,14 @@ void do_logdump(int argc, char **argv, int sci_idx EXT2FS_ATTR((unused)),
 		case 'S':
 			dump_super++;
 			break;
+		case 'n':
+			dump_counts = strtol(optarg, &tmp, 10);
+			if (*tmp) {
+				com_err(argv[0], 0,
+					"Bad log counts number - %s", optarg);
+				return;
+			}
+			break;
 		default:
 			goto print_usage;
 		}
@@ -282,7 +292,7 @@ cleanup:
 	return;
 
 print_usage:
-	fprintf(stderr, "%s: Usage: logdump [-acsOS] [-b<block>] [-i<filespec>]\n\t"
+	fprintf(stderr, "%s: Usage: logdump [-acsOS] [-n<num_trans>] [-b<block>] [-i<filespec>]\n\t"
 		"[-f<journal_file>] [output_file]\n", argv[0]);
 }
 
@@ -362,6 +372,8 @@ static void dump_journal(char *cmdname, FILE *out_file,
 	int			fc_done;
 	__u64			total_len;
 	__u32			maxlen;
+	int64_t			cur_counts = 0;
+	bool			exist_no_magic = false;
 
 	/* First, check to see if there's an ext2 superblock header */
 	retval = read_journal_block(cmdname, source, 0, buf, 2048);
@@ -452,6 +464,9 @@ static void dump_journal(char *cmdname, FILE *out_file,
 	}
 
 	while (1) {
+		if (dump_old && (dump_counts != -1) && (cur_counts >= dump_counts))
+			break;
+
 		retval = read_journal_block(cmdname, source,
 				((ext2_loff_t) blocknr) * blocksize,
 				buf, blocksize);
@@ -465,8 +480,16 @@ static void dump_journal(char *cmdname, FILE *out_file,
 		blocktype = be32_to_cpu(header->h_blocktype);
 
 		if (magic != JBD2_MAGIC_NUMBER) {
-			fprintf (out_file, "No magic number at block %u: "
-				 "end of journal.\n", blocknr);
+			if (exist_no_magic == false) {
+				exist_no_magic = true;
+				fprintf(out_file, "No magic number at block %u: "
+					"end of journal.\n", blocknr);
+			}
+			if (dump_old && (dump_counts != -1)) {
+				blocknr++;
+				WRAP(jsb, blocknr, maxlen);
+				continue;
+			}
 			break;
 		}
 
@@ -493,6 +516,7 @@ static void dump_journal(char *cmdname, FILE *out_file,
 			continue;
 
 		case JBD2_COMMIT_BLOCK:
+			cur_counts++;
 			transaction++;
 			blocknr++;
 			WRAP(jsb, blocknr, maxlen);
diff --git a/e2fsck/journal.c b/e2fsck/journal.c
index fe4e018..83bb7a9 100644
--- a/e2fsck/journal.c
+++ b/e2fsck/journal.c
@@ -1444,10 +1444,12 @@ static errcode_t e2fsck_journal_fix_corrupt_super(e2fsck_t ctx,
 	return 0;
 }
 
-static void e2fsck_journal_release(e2fsck_t ctx, journal_t *journal,
+static errcode_t e2fsck_journal_release(e2fsck_t ctx, journal_t *journal,
 				   int reset, int drop)
 {
 	journal_superblock_t *jsb;
+	errcode_t err = 0;
+	errcode_t err2;
 
 	if (drop)
 		mark_buffer_clean(journal->j_sb_buffer);
@@ -1461,6 +1463,16 @@ static void e2fsck_journal_release(e2fsck_t ctx, journal_t *journal,
 	}
 	brelse(journal->j_sb_buffer);
 
+	if(reset == 1 && drop == 0) {
+		err = sync_blockdev(journal->j_fs_dev);
+		/* Make sure all replayed data is on permanent storage */
+		if (journal->j_flags & JBD2_BARRIER) {
+			err2 = blkdev_issue_flush(journal->j_fs_dev);
+			if (!err)
+				err = err2;
+		}
+	}
+
 	if (ctx->journal_io) {
 		if (ctx->fs && ctx->fs->io != ctx->journal_io)
 			io_channel_close(ctx->journal_io);
@@ -1474,6 +1486,8 @@ static void e2fsck_journal_release(e2fsck_t ctx, journal_t *journal,
 	if (journal->j_fs_dev)
 		ext2fs_free_mem(&journal->j_fs_dev);
 	ext2fs_free_mem(&journal);
+
+	return err;
 }
 
 /*
@@ -1612,6 +1626,7 @@ static errcode_t recover_ext3_journal(e2fsck_t ctx)
 	struct problem_context	pctx;
 	journal_t *journal;
 	errcode_t retval;
+	errcode_t recover_retval;
 
 	clear_problem_context(&pctx);
 
@@ -1636,6 +1651,13 @@ static errcode_t recover_ext3_journal(e2fsck_t ctx)
 		goto errout;
 
 	retval = -jbd2_journal_recover(journal);
+	if (retval == EIO || retval == ENOMEM || retval == EXT2_ET_NO_MEMORY) {
+		ctx->fs->flags &= ~EXT2_FLAG_VALID;
+		com_err(ctx->program_name, 0,
+				_("Journal recovery failed "
+				"on %s, retval=%d \n"), ctx->device_name, retval);
+		fatal_error(ctx, 0);
+	}
 	if (retval)
 		goto errout;
 
@@ -1652,7 +1674,14 @@ errout:
 	jbd2_journal_destroy_revoke(journal);
 	jbd2_journal_destroy_revoke_record_cache();
 	jbd2_journal_destroy_revoke_table_cache();
-	e2fsck_journal_release(ctx, journal, 1, 0);
+	recover_retval = e2fsck_journal_release(ctx, journal, 1, 0);
+	if(recover_retval == -EIO) {
+		ctx->fs->flags &= ~EXT2_FLAG_VALID;
+		com_err(ctx->program_name, 0,
+			_("e2fsck journal release failed "
+			"on %s, retval=%d \n"), ctx->device_name, recover_retval);
+		fatal_error(ctx, 0);
+	}
 	return retval;
 }
 
diff --git a/e2fsck/pass1.c b/e2fsck/pass1.c
index dde862a..d4606b8 100644
--- a/e2fsck/pass1.c
+++ b/e2fsck/pass1.c
@@ -3045,11 +3045,18 @@ report_problem:
 					}
 				}
 			}
+
+			int level_bak = ext2fs_current_level_get(ehandle);
+
 			scan_extent_node(ctx, pctx, pb, extent.e_lblk,
 					 last_lblk, eof_block, ehandle,
 					 next_try_repairs);
 			if (pctx->errcode)
 				return;
+
+			if (level_bak != ext2fs_current_level_get(ehandle))
+				return;
+
 			pctx->errcode = ext2fs_extent_get(ehandle,
 						  EXT2_EXTENT_UP, &extent);
 			if (pctx->errcode) {
diff --git a/e2fsck/super.c b/e2fsck/super.c
index 31e2ffb..ec28426 100644
--- a/e2fsck/super.c
+++ b/e2fsck/super.c
@@ -235,6 +235,10 @@ static int release_inode_blocks(e2fsck_t ctx, ext2_ino_t ino,
 	if (pb.truncated_blocks)
 		ext2fs_iblk_sub_blocks(fs, EXT2_INODE(inode),
 				pb.truncated_blocks);
+	
+	/* do not clean up file acl if the inode is truncating type */
+	if (inode->i_links_count)
+		return 0;
 
 	blk = ext2fs_file_acl_block(fs, EXT2_INODE(inode));
 	if (blk) {
diff --git a/lib/blkid/llseek.c b/lib/blkid/llseek.c
index 5929864..25c613b 100644
--- a/lib/blkid/llseek.c
+++ b/lib/blkid/llseek.c
@@ -88,7 +88,7 @@ static blkid_loff_t my_llseek(int fd, blkid_loff_t offset, int origin)
 	return (retval == -1 ? (blkid_loff_t) retval : result);
 }
 
-#endif	/* __alpha__ || __ia64__ */
+#endif	/* __alpha__ || __sw_64__ || __ia64__ */
 
 #endif /* HAVE_LLSEEK */
 
diff --git a/lib/ext2fs/closefs.c b/lib/ext2fs/closefs.c
index 69cbdd8..95f1de3 100644
--- a/lib/ext2fs/closefs.c
+++ b/lib/ext2fs/closefs.c
@@ -195,8 +195,9 @@ static errcode_t write_primary_superblock(ext2_filsys fs,
 	__u16		*old_super, *new_super;
 	int		check_idx, write_idx, size;
 	errcode_t	retval;
+	int is_unreliable_io = getenv("E2FS_UNRELIABLE_IO") ? 1 : 0;
 
-	if (!fs->io->manager->write_byte || !fs->orig_super) {
+	if (!fs->io->manager->write_byte || !fs->orig_super || is_unreliable_io) {
 	fallback:
 		io_channel_set_blksize(fs->io, SUPERBLOCK_OFFSET);
 		retval = io_channel_write_blk64(fs->io, 1, -SUPERBLOCK_SIZE,
diff --git a/lib/ext2fs/ext2fs.h b/lib/ext2fs/ext2fs.h
index 0ac3e45..6b318e3 100644
--- a/lib/ext2fs/ext2fs.h
+++ b/lib/ext2fs/ext2fs.h
@@ -1328,6 +1328,7 @@ extern errcode_t ext2fs_extent_open2(ext2_filsys fs, ext2_ino_t ino,
 extern void ext2fs_extent_free(ext2_extent_handle_t handle);
 extern errcode_t ext2fs_extent_get(ext2_extent_handle_t handle,
 				   int flags, struct ext2fs_extent *extent);
+extern int ext2fs_current_level_get(ext2_extent_handle_t handle);
 extern errcode_t ext2fs_extent_node_split(ext2_extent_handle_t handle);
 extern errcode_t ext2fs_extent_replace(ext2_extent_handle_t handle, int flags,
 				       struct ext2fs_extent *extent);
diff --git a/lib/ext2fs/extent.c b/lib/ext2fs/extent.c
index b324c7b..461120d 100644
--- a/lib/ext2fs/extent.c
+++ b/lib/ext2fs/extent.c
@@ -495,6 +495,10 @@ retry:
 			ext2fs_le16_to_cpu(eh->eh_entries);
 		newpath->max_entries = ext2fs_le16_to_cpu(eh->eh_max);
 
+		/* Make sure there is at least one extent present */
+		if (newpath->left <= 0)
+			return EXT2_ET_EXTENT_NO_DOWN;
+
 		if (path->left > 0) {
 			ix++;
 			newpath->end_blk = ext2fs_le32_to_cpu(ix->ei_block);
@@ -575,6 +579,11 @@ retry:
 	return 0;
 }
 
+int ext2fs_current_level_get(ext2_extent_handle_t handle)
+{
+	return handle->level;
+}
+
 static errcode_t update_path(ext2_extent_handle_t handle)
 {
 	blk64_t				blk;
@@ -1630,6 +1639,10 @@ errcode_t ext2fs_extent_delete(ext2_extent_handle_t handle, int flags)
 
 	cp = path->curr;
 
+	/* Sanity check before memmove() */
+	if (path->left < 0)
+		return EXT2_ET_EXTENT_LEAF_BAD;
+
 	if (path->left) {
 		memmove(cp, cp + sizeof(struct ext3_extent_idx),
 			path->left * sizeof(struct ext3_extent_idx));
diff --git a/lib/ext2fs/ismounted.c b/lib/ext2fs/ismounted.c
index aee7d72..463a82a 100644
--- a/lib/ext2fs/ismounted.c
+++ b/lib/ext2fs/ismounted.c
@@ -98,6 +98,7 @@ static errcode_t check_mntent_file(const char *mtab_file, const char *file,
 {
 	struct mntent 	*mnt;
 	struct stat	st_buf;
+	struct stat	dir_st_buf;
 	errcode_t	retval = 0;
 	dev_t		file_dev=0, file_rdev=0;
 	ino_t		file_ino=0;
@@ -144,8 +145,12 @@ static errcode_t check_mntent_file(const char *mtab_file, const char *file,
 		if (stat(mnt->mnt_fsname, &st_buf) == 0) {
 			if (ext2fsP_is_disk_device(st_buf.st_mode)) {
 #ifndef __GNU__
-				if (file_rdev && (file_rdev == st_buf.st_rdev))
-					break;
+				if (file_rdev && (file_rdev == st_buf.st_rdev)) {
+					if (stat(mnt->mnt_dir, &dir_st_buf) != 0)
+						continue;
+					if (file_rdev == dir_st_buf.st_dev)
+						break;
+				}
 				if (check_loop_mounted(mnt->mnt_fsname,
 						st_buf.st_rdev, file_dev,
 						file_ino) == 1)
diff --git a/lib/ext2fs/unix_io.c b/lib/ext2fs/unix_io.c
index d251c20..10d6934 100644
--- a/lib/ext2fs/unix_io.c
+++ b/lib/ext2fs/unix_io.c
@@ -210,7 +210,8 @@ static char *safe_getenv(const char *arg)
 static errcode_t raw_read_blk(io_channel channel,
 			      struct unix_private_data *data,
 			      unsigned long long block,
-			      int count, void *bufv)
+			      int count, void *bufv,
+			      int cache_lock)
 {
 	errcode_t	retval;
 	ssize_t		size;
@@ -331,16 +332,22 @@ error_unlock:
 	mutex_unlock(data, BOUNCE_MTX);
 	if (actual >= 0 && actual < size)
 		memset((char *) buf+actual, 0, size-actual);
-	if (channel->read_error)
+	if (channel->read_error) {
+		if (cache_lock)
+			mutex_unlock(data, CACHE_MTX);
 		retval = (channel->read_error)(channel, block, count, buf,
 					       size, actual, retval);
+		if (cache_lock)
+			mutex_lock(data, CACHE_MTX);
+	}
 	return retval;
 }
 
 static errcode_t raw_write_blk(io_channel channel,
 			       struct unix_private_data *data,
 			       unsigned long long block,
-			       int count, const void *bufv)
+			       int count, const void *bufv,
+			       int cache_lock)
 {
 	ssize_t		size;
 	ext2_loff_t	location;
@@ -482,9 +489,14 @@ bounce_write:
 error_unlock:
 	mutex_unlock(data, BOUNCE_MTX);
 error_out:
-	if (channel->write_error)
+	if (channel->write_error) {
+		if (cache_lock)
+			mutex_unlock(data, CACHE_MTX);
 		retval = (channel->write_error)(channel, block, count, buf,
 						size, actual, retval);
+		if (cache_lock)
+			mutex_lock(data, CACHE_MTX);
+	}
 	return retval;
 }
 
@@ -576,16 +588,22 @@ static struct unix_cache *find_cached_block(struct unix_private_data *data,
 /*
  * Reuse a particular cache entry for another block.
  */
-static void reuse_cache(io_channel channel, struct unix_private_data *data,
+static errcode_t reuse_cache(io_channel channel, struct unix_private_data *data,
 		 struct unix_cache *cache, unsigned long long block)
 {
-	if (cache->dirty && cache->in_use)
-		raw_write_blk(channel, data, cache->block, 1, cache->buf);
+	errcode_t               retval = 0;
+	if (cache->dirty && cache->in_use) {
+		retval = raw_write_blk(channel, data, cache->block, 1, cache->buf, 1);
+		if (retval)
+			return retval;
+	}
 
 	cache->in_use = 1;
 	cache->dirty = 0;
 	cache->block = block;
 	cache->access_time = ++data->access_time;
+
+	return retval;
 }
 
 #define FLUSH_INVALIDATE	0x01
@@ -616,7 +634,8 @@ static errcode_t flush_cached_blocks(io_channel channel,
 			continue;
 
 		retval = raw_write_blk(channel, data,
-				       cache->block, 1, cache->buf);
+				       cache->block, 1, cache->buf,
+				       !(flags & FLUSH_NOLOCK));
 		if (retval)
 			retval2 = retval;
 		else
@@ -786,7 +805,7 @@ static errcode_t unix_open_channel(const char *name, int fd,
 
 #ifdef __linux__
 #undef RLIM_INFINITY
-#if (defined(__alpha__) || ((defined(__sparc__) || defined(__mips__)) && (SIZEOF_LONG == 4)))
+#if (defined(__alpha__) || defined(__sw_64__) || ((defined(__sparc__) || defined(__mips__)) && (SIZEOF_LONG == 4)))
 #define RLIM_INFINITY	((unsigned long)(~0UL>>1))
 #else
 #define RLIM_INFINITY  (~0UL)
@@ -974,8 +993,8 @@ static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
 			       int count, void *buf)
 {
 	struct unix_private_data *data;
-	struct unix_cache *cache, *reuse[READ_DIRECT_SIZE];
-	errcode_t	retval = 0;
+	struct unix_cache *cache;
+	errcode_t	retval;
 	char		*cp;
 	int		i, j;
 
@@ -984,10 +1003,10 @@ static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
 	EXT2_CHECK_MAGIC(data, EXT2_ET_MAGIC_UNIX_IO_CHANNEL);
 
 #ifdef NO_IO_CACHE
-	return raw_read_blk(channel, data, block, count, buf);
+	return raw_read_blk(channel, data, block, count, buf, 0);
 #else
 	if (data->flags & IO_FLAG_NOCACHE)
-		return raw_read_blk(channel, data, block, count, buf);
+		return raw_read_blk(channel, data, block, count, buf, 0);
 	/*
 	 * If we're doing an odd-sized read or a very large read,
 	 * flush out the cache and then do a direct read.
@@ -995,14 +1014,14 @@ static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
 	if (count < 0 || count > WRITE_DIRECT_SIZE) {
 		if ((retval = flush_cached_blocks(channel, data, 0)))
 			return retval;
-		return raw_read_blk(channel, data, block, count, buf);
+		return raw_read_blk(channel, data, block, count, buf, 0);
 	}
 
 	cp = buf;
 	mutex_lock(data, CACHE_MTX);
 	while (count > 0) {
 		/* If it's in the cache, use it! */
-		if ((cache = find_cached_block(data, block, &reuse[0]))) {
+		if ((cache = find_cached_block(data, block, NULL))) {
 #ifdef DEBUG
 			printf("Using cached block %lu\n", block);
 #endif
@@ -1012,47 +1031,39 @@ static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
 			cp += channel->block_size;
 			continue;
 		}
-		if (count == 1) {
-			/*
-			 * Special case where we read directly into the
-			 * cache buffer; important in the O_DIRECT case
-			 */
-			cache = reuse[0];
-			reuse_cache(channel, data, cache, block);
-			if ((retval = raw_read_blk(channel, data, block, 1,
-						   cache->buf))) {
-				cache->in_use = 0;
-				break;
-			}
-			memcpy(cp, cache->buf, channel->block_size);
-			retval = 0;
-			break;
-		}
 
 		/*
 		 * Find the number of uncached blocks so we can do a
 		 * single read request
 		 */
 		for (i=1; i < count; i++)
-			if (find_cached_block(data, block+i, &reuse[i]))
+			if (find_cached_block(data, block+i, NULL))
 				break;
 #ifdef DEBUG
 		printf("Reading %d blocks starting at %lu\n", i, block);
 #endif
-		if ((retval = raw_read_blk(channel, data, block, i, cp)))
-			break;
+		mutex_unlock(data, CACHE_MTX);
+		if ((retval = raw_read_blk(channel, data, block, i, cp, 0)))
+			return retval;
+		mutex_lock(data, CACHE_MTX);
 
 		/* Save the results in the cache */
 		for (j=0; j < i; j++) {
+			if (!find_cached_block(data, block, &cache)) {
+				retval = reuse_cache(channel, data, cache, block);
+				if (retval) {
+					mutex_unlock(data, CACHE_MTX);
+					return retval;
+				}
+				memcpy(cache->buf, cp, channel->block_size);
+			}
 			count--;
-			cache = reuse[j];
-			reuse_cache(channel, data, cache, block++);
-			memcpy(cache->buf, cp, channel->block_size);
+			block++;
 			cp += channel->block_size;
 		}
 	}
 	mutex_unlock(data, CACHE_MTX);
-	return retval;
+	return 0;
 #endif /* NO_IO_CACHE */
 }
 
@@ -1076,10 +1087,10 @@ static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
 	EXT2_CHECK_MAGIC(data, EXT2_ET_MAGIC_UNIX_IO_CHANNEL);
 
 #ifdef NO_IO_CACHE
-	return raw_write_blk(channel, data, block, count, buf);
+	return raw_write_blk(channel, data, block, count, buf, 0);
 #else
 	if (data->flags & IO_FLAG_NOCACHE)
-		return raw_write_blk(channel, data, block, count, buf);
+		return raw_write_blk(channel, data, block, count, buf, 0);
 	/*
 	 * If we're doing an odd-sized write or a very large write,
 	 * flush out the cache completely and then do a direct write.
@@ -1088,7 +1099,7 @@ static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
 		if ((retval = flush_cached_blocks(channel, data,
 						  FLUSH_INVALIDATE)))
 			return retval;
-		return raw_write_blk(channel, data, block, count, buf);
+		return raw_write_blk(channel, data, block, count, buf, 0);
 	}
 
 	/*
@@ -1098,7 +1109,7 @@ static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
 	 */
 	writethrough = channel->flags & CHANNEL_FLAGS_WRITETHROUGH;
 	if (writethrough)
-		retval = raw_write_blk(channel, data, block, count, buf);
+		retval = raw_write_blk(channel, data, block, count, buf, 0);
 
 	cp = buf;
 	mutex_lock(data, CACHE_MTX);
@@ -1106,7 +1117,11 @@ static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
 		cache = find_cached_block(data, block, &reuse);
 		if (!cache) {
 			cache = reuse;
-			reuse_cache(channel, data, cache, block);
+			retval = reuse_cache(channel, data, cache, block);
+			if (retval) {
+				mutex_unlock(data, CACHE_MTX);
+				return retval;
+			}
 		}
 		if (cache->buf != cp)
 			memcpy(cache->buf, cp, channel->block_size);
diff --git a/lib/ss/get_readline.c b/lib/ss/get_readline.c
index 11c72b3..aa16157 100644
--- a/lib/ss/get_readline.c
+++ b/lib/ss/get_readline.c
@@ -37,7 +37,7 @@ static void ss_release_readline(ss_data *info)
 #endif
 
 /* Libraries we will try to use for readline/editline functionality */
-#define DEFAULT_LIBPATH "libreadline.so.7:libreadline.so.6:libreadline.so.5:libreadline.so.4:libreadline.so:libedit.so.2:libedit.so:libeditline.so.0:libeditline.so"
+#define DEFAULT_LIBPATH "libreadline.so.8:libreadline.so.7:libreadline.so.6:libreadline.so.5:libreadline.so.4:libreadline.so:libedit.so.2:libedit.so:libeditline.so.0:libeditline.so"
 
 #ifdef HAVE_DLOPEN
 void ss_get_readline(int sci_idx)
diff --git a/misc/e2mmpstatus.8.in b/misc/e2mmpstatus.8.in
index c7ed929..07a28ec 100644
--- a/misc/e2mmpstatus.8.in
+++ b/misc/e2mmpstatus.8.in
@@ -19,11 +19,7 @@ file system with the
 feature enabled.  The specified
 .I file system
 can be a device name (e.g.
-.IR /dev/hdc1 ", " /dev/sdb2 ),
-or an ext4 file system label or UUID, for example
-.B UUID=8868abf6-88c5-4a83-98b8-bfc24057f7bd
-or
-.BR LABEL=root .
+.IR /dev/hdc1 ", " /dev/sdb2 ).
 By default, the
 .B e2mmpstatus
 program checks whether it is safe to mount the file system without taking
diff --git a/misc/tune2fs.c b/misc/tune2fs.c
index 4200104..61044ab 100644
--- a/misc/tune2fs.c
+++ b/misc/tune2fs.c
@@ -3102,10 +3102,11 @@ _("Warning: The journal is dirty. You may wish to replay the journal like:\n\n"
 			com_err("tune2fs", retval,
 				"while recovering journal.\n");
 			printf(_("Please run e2fsck -fy %s.\n"), argv[1]);
-			if (fs)
-				ext2fs_close_free(&fs);
-			rc = 1;
-			goto closefs;
+			if (fs) {
+				rc = 1;
+				goto closefs;
+			}
+			exit(1);
 		}
 		sb = fs->super;
 	}
@@ -3241,6 +3242,7 @@ _("Warning: The journal is dirty. You may wish to replay the journal like:\n\n"
 			fputs(_("Error in using clear_mmp. "
 				"It must be used with -f\n"),
 			      stderr);
+			rc = 1;
 			goto closefs;
 		}
 	}
@@ -3445,5 +3447,5 @@ closefs:
 
 	if (feature_64bit)
 		convert_64bit(fs, feature_64bit);
-	return (ext2fs_close_free(&fs) ? 1 : 0);
+	return (ext2fs_close_free(&fs) ? 1 : rc);
 }
diff --git a/tests/f_large_dir/expect b/tests/f_large_dir/expect
index 028234c..495ea85 100644
--- a/tests/f_large_dir/expect
+++ b/tests/f_large_dir/expect
@@ -1,3 +1,4 @@
+128-byte inodes cannot handle dates beyond 2038 and are deprecated
 Creating filesystem with 108341 1k blocks and 65072 inodes
 Superblock backups stored on blocks: 
 	8193, 24577, 40961, 57345, 73729
diff --git a/tests/f_large_dir_csum/expect b/tests/f_large_dir_csum/expect
index aa9f33f..44770f7 100644
--- a/tests/f_large_dir_csum/expect
+++ b/tests/f_large_dir_csum/expect
@@ -1,3 +1,4 @@
+128-byte inodes cannot handle dates beyond 2038 and are deprecated
 Creating filesystem with 31002 1k blocks and 64 inodes
 Superblock backups stored on blocks: 
 	8193, 24577
diff --git a/tests/f_mmp_garbage/expect.1 b/tests/f_mmp_garbage/expect.1
index a8add10..4134eae 100644
--- a/tests/f_mmp_garbage/expect.1
+++ b/tests/f_mmp_garbage/expect.1
@@ -5,5 +5,5 @@ Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
 Pass 4: Checking reference counts
 Pass 5: Checking group summary information
-test_filesys: 11/64 files (0.0% non-contiguous), 13/100 blocks
+test_filesys: 11/64 files (0.0% non-contiguous), 15/100 blocks
 Exit status is 0
diff --git a/tests/f_mmp_garbage/expect.2 b/tests/f_mmp_garbage/expect.2
index 6630002..3bca182 100644
--- a/tests/f_mmp_garbage/expect.2
+++ b/tests/f_mmp_garbage/expect.2
@@ -3,5 +3,5 @@ Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
 Pass 4: Checking reference counts
 Pass 5: Checking group summary information
-test_filesys: 11/64 files (0.0% non-contiguous), 13/100 blocks
+test_filesys: 11/64 files (0.0% non-contiguous), 15/100 blocks
 Exit status is 0
diff --git a/tests/filter.sed b/tests/filter.sed
index 796186e..5fd68f3 100644
--- a/tests/filter.sed
+++ b/tests/filter.sed
@@ -20,6 +20,7 @@ s/\\015//g
 /^Maximum mount count:/d
 /^Next check after:/d
 /^Suggestion:/d
+/security.selinux/d
 /Reserved blocks uid:/s/ (user .*)//
 /Reserved blocks gid:/s/ (group .*)//
 /whichever comes first/d
diff --git a/tests/m_hugefile/expect b/tests/m_hugefile/expect
index ee33fe5..170387a 100644
--- a/tests/m_hugefile/expect
+++ b/tests/m_hugefile/expect
@@ -1,19 +1,19 @@
-mke2fs -F -T hugefile test.img 4T
-Creating filesystem with 1073741824 4k blocks and 1048576 inodes
+mke2fs -F -T hugefile test.img 1T
+Creating filesystem with 268435456 4k blocks and 262144 inodes
 Superblock backups stored on blocks: 
 
 Allocating group tables: done                            
-Writing inode tables:            done                            
+Writing inode tables:          done                            
 Creating 1 huge file(s) : done
-Writing superblocks and filesystem accounting information:            done
+Writing superblocks and filesystem accounting information:          done
 
 Pass 1: Checking inodes, blocks, and sizes
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
 Pass 4: Checking reference counts
 Pass 5: Checking group summary information
-test_filesys: 13/1048576 files (0.0% non-contiguous), 1073709417/1073741824 blocks
+test_filesys: 13/262144 files (0.0% non-contiguous), 268394593/268435456 blocks
 Exit status is 0
 debugfs -R "extents /store/big-data" test.img
-Last logical block: 1073610751
-Last physical block: 1073741823
+Last logical block: 268369919
+Last physical block: 268435455
diff --git a/tests/m_hugefile/script b/tests/m_hugefile/script
index fc1d115..5bb0b57 100644
--- a/tests/m_hugefile/script
+++ b/tests/m_hugefile/script
@@ -30,8 +30,8 @@ cat > $CONF << ENDL
 	}
 ENDL
 
-echo "mke2fs -F -T hugefile test.img 4T" > $OUT
-MKE2FS_CONFIG=$CONF $MKE2FS -F -T hugefile $TMPFILE 4T >> $OUT 2>&1
+echo "mke2fs -F -T hugefile test.img 1T" > $OUT
+MKE2FS_CONFIG=$CONF $MKE2FS -F -T hugefile $TMPFILE 1T >> $OUT 2>&1
 rm -f $CONF
 
 # check the file system if we get this far, we succeeded...
diff --git a/tests/m_rootdir_acl/expect b/tests/m_rootdir_acl/expect
index babd802..57f03e5 100644
--- a/tests/m_rootdir_acl/expect
+++ b/tests/m_rootdir_acl/expect
@@ -10,8 +10,8 @@ Filesystem OS type:       Linux
 Inode count:              1024
 Block count:              16384
 Reserved block count:     819
-Overhead clusters:        1543
-Free blocks:              14788
+Overhead clusters:        1799
+Free blocks:              14533
 Free inodes:              1003
 First block:              1
 Block size:               1024
@@ -21,14 +21,14 @@ Reserved GDT blocks:      127
 Blocks per group:         8192
 Fragments per group:      8192
 Inodes per group:         512
-Inode blocks per group:   128
+Inode blocks per group:   256
 Flex block group size:    16
 Mount count:              0
 Check interval:           15552000 (6 months)
 Reserved blocks uid:      0
 Reserved blocks gid:      0
 First inode:              11
-Inode size:	          256
+Inode size:	          512
 Required extra isize:     32
 Desired extra isize:      32
 Journal inode:            8
@@ -49,16 +49,16 @@ Group 0: (Blocks 1-8192)
   Reserved GDT blocks at 3-129
   Block bitmap at 130 (+129)
   Inode bitmap at 132 (+131)
-  Inode table at 134-261 (+133)
-  7750 free blocks, 491 free inodes, 5 directories, 491 unused inodes
-  Free blocks: 443-8192
+  Inode table at 134-389 (+133)
+  7495 free blocks, 491 free inodes, 5 directories, 491 unused inodes
+  Free blocks: 698-8192
   Free inodes: 22-512
 Group 1: (Blocks 8193-16383) [INODE_UNINIT]
   Backup superblock at 8193, Group descriptors at 8194-8194
   Reserved GDT blocks at 8195-8321
   Block bitmap at 131 (bg #0 + 130)
   Inode bitmap at 133 (bg #0 + 132)
-  Inode table at 262-389 (bg #0 + 261)
+  Inode table at 390-645 (bg #0 + 389)
   7038 free blocks, 512 free inodes, 0 directories, 512 unused inodes
   Free blocks: 9346-16383
   Free inodes: 513-1024
@@ -116,4 +116,4 @@ Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
 Pass 4: Checking reference counts
 Pass 5: Checking group summary information
-test.img: 21/1024 files (0.0% non-contiguous), 1596/16384 blocks
+test.img: 21/1024 files (0.0% non-contiguous), 1851/16384 blocks
diff --git a/tests/m_rootdir_acl/script b/tests/m_rootdir_acl/script
index e81c82c..a00e4c4 100644
--- a/tests/m_rootdir_acl/script
+++ b/tests/m_rootdir_acl/script
@@ -16,12 +16,10 @@ if [ "$os" = "GNU" ]; then
 	return 0
 fi
 
-MKFS_DIR=$TMPFILE.dir
+MKFS_DIR=$(mktemp -d ./$test_name-XXXXXX.tmp)
 OUT=$test_name.log
 EXP=$test_dir/expect
 
-rm -rf $MKFS_DIR
-mkdir -p $MKFS_DIR
 touch $MKFS_DIR/emptyfile
 dd if=/dev/zero bs=1024 count=32 2> /dev/null | tr '\0' 'a' > $MKFS_DIR/bigfile
 echo "M" | dd of=$MKFS_DIR/sparsefile bs=1 count=1 seek=1024 2> /dev/null
@@ -60,7 +58,14 @@ mask::r-x
 other::r-x
 EOF
 
-$MKE2FS -q -F -o Linux -T ext4 -O metadata_csum,inline_data,64bit -E lazy_itable_init=1 -b 1024 -d $MKFS_DIR $TMPFILE 16384 > $OUT 2>&1
+if ! getfattr -d -m - $MKFS_DIR/acl_dir | grep -q posix_acl; then
+	echo "$test_name: $test_description: skipped (no posix_acl xattrs)"
+	rm -rf $MKFS_DIR
+	return 0
+fi
+
+# use 512-byte inodes so with/out security.selinux xattr doesn't fail
+$MKE2FS -q -F -o Linux -T ext4 -I 512 -O metadata_csum,inline_data,64bit -E lazy_itable_init=1 -b 1024 -d $MKFS_DIR $TMPFILE 16384 > $OUT 2>&1
 
 $DUMPE2FS $TMPFILE >> $OUT 2>&1
 cat > $TMPFILE.cmd << ENDL
diff --git a/tests/u_direct_io/expect b/tests/u_direct_io/expect
index b0cdc73..830cbd7 100644
--- a/tests/u_direct_io/expect
+++ b/tests/u_direct_io/expect
@@ -19,8 +19,8 @@ Filesystem OS type:       Linux
 Inode count:              32768
 Block count:              32768
 Reserved block count:     1638
-Overhead clusters:        5131
-Free blocks:              27631
+Overhead clusters:        6155
+Free blocks:              26607
 Free inodes:              32757
 First block:              0
 Block size:               4096
@@ -29,27 +29,29 @@ Reserved GDT blocks:      7
 Blocks per group:         32768
 Fragments per group:      32768
 Inodes per group:         32768
-Inode blocks per group:   1024
+Inode blocks per group:   2048
 Flex block group size:    16
 Mount count:              0
 Check interval:           15552000 (6 months)
 Reserved blocks uid:      0
 Reserved blocks gid:      0
 First inode:              11
-Inode size:	          128
+Inode size:	          256
+Required extra isize:     32
+Desired extra isize:      32
 Journal inode:            8
 Default directory hash:   half_md4
 Journal backup:           inode blocks
 Directories:              2
  Group  0: block bitmap at 9, inode bitmap at 25, inode table at 41
-           27631 free blocks, 32757 free inodes, 2 used directories
+           26607 free blocks, 32757 free inodes, 2 used directories
 e2fsck -fn -N test_filesys $LOOP
 Pass 1: Checking inodes, blocks, and sizes
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
 Pass 4: Checking reference counts
 Pass 5: Checking group summary information
-test_filesys: 11/32768 files (9.1% non-contiguous), 5137/32768 blocks
+test_filesys: 11/32768 files (9.1% non-contiguous), 6161/32768 blocks
 Exit status is 0
 e2fsck -fn -N test_filesys $TMPFILE
 Pass 1: Checking inodes, blocks, and sizes
@@ -57,5 +59,5 @@ Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
 Pass 4: Checking reference counts
 Pass 5: Checking group summary information
-test_filesys: 11/32768 files (9.1% non-contiguous), 5137/32768 blocks
+test_filesys: 11/32768 files (9.1% non-contiguous), 6161/32768 blocks
 Exit status is 0
