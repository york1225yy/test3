diff --git a/bsp/gp_cipher/README.md b/bsp/gp_cipher/README.md
new file mode 100644
index 0000000..a722feb
--- /dev/null
+++ b/bsp/gp_cipher/README.md
@@ -0,0 +1,2 @@
+# optee_gpcipher
+
diff --git a/bsp/gp_cipher/include/gp_cipher.h b/bsp/gp_cipher/include/gp_cipher.h
new file mode 100644
index 0000000..161c62a
--- /dev/null
+++ b/bsp/gp_cipher/include/gp_cipher.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function related gp cipher interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#ifndef __GP_CIPHER_H
+#define __GP_CIPHER_H
+
+#include <crypto/crypto.h>
+#include <crypto/crypto_impl.h>
+#include <tee_api_types.h>
+#include "kapi_km.h"
+#include "kapi_pke.h"
+#include "kapi_pke_cal.h"
+#include "kapi_symc.h"
+
+#define BYTE_BITS 8
+#define KEY_128BIT_LEN 16
+#define KEY_192BIT_LEN 24
+#define KEY_256BIT_LEN 32
+#define MIN_PKE_LEN 256
+
+#ifndef cipher_chk_goto
+#define cipher_chk_goto(val, label, ...) \
+    do {                                 \
+        if ((val)) {                     \
+            __VA_ARGS__;                 \
+            goto label;                  \
+        }                                \
+    } while (0)
+#endif
+
+#ifndef cipher_chk_return
+#define cipher_chk_return(val, ret, ...) \
+    do {                                 \
+        if ((val)) {                     \
+            __VA_ARGS__;                 \
+            return (ret);                \
+        }                                \
+    } while (0)
+#endif
+
+td_s32 cipher_set_clear_key(crypto_symc_alg algo, crypto_handle keyslot_handle,
+                            const td_u8 *key, td_u32 keylen);
+
+td_s32 cipher_alloc_and_map(crypto_buf_attr *buf_attr, void **virt_addr,
+                            uint32_t size);
+
+void cipher_unmap_and_free(crypto_buf_attr *buf_attr, const void *virt_addr,
+                           uint32_t size);
+
+void get_bignum_data(const void *bignum, td_u8 *buf, td_u32 buf_len);
+
+td_u32 get_align_size(td_u32 a_len, td_u32 b_len, td_u32 c_len);
+
+bool bn_alloc_max(struct bignum **s);
+
+void dump_data(const drv_pke_data *data, const char *name);
+
+void dump_bignum_data(const void *bignum, const char *name);
+
+TEE_Result padding_data(drv_pke_data *data, td_u32 size_align,
+                        struct drvcrypt_buf *buf);
+#endif /* __GP_CIPHER_H */
diff --git a/bsp/gp_cipher/src/gp_cipher_asymc_dh.c b/bsp/gp_cipher/src/gp_cipher_asymc_dh.c
new file mode 100644
index 0000000..ab0a504
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_asymc_dh.c
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher dh interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <drvcrypt.h>
+#include <drvcrypt_acipher.h>
+#include <gp_cipher.h>
+#include <initcall.h>
+#include <mbedtls/bignum.h>
+#include <mbedtls/ctr_drbg.h>
+#include <mbedtls/dhm.h>
+#include <securec.h>
+#include <tee_api_defines_extensions.h>
+#include <tee_api_types.h>
+
+/******************************************************************************
+ * Message digest functions
+ ******************************************************************************/
+static struct drvcrypt_dh gp_cipher_asymc_dh_ops;
+
+static void set_bignum_data(void *bignum, drv_pke_data *data)
+{
+    mbedtls_mpi *buffer = bignum;
+
+    for (td_u32 i = 0; i < data->length; ++i) {
+        ((td_u8 *)buffer->p)[i] = (data->data)[data->length - 1 - i];
+    }
+}
+
+static TEE_Result gp_cipher_asymc_dh_alloc_keypair(
+    struct dh_keypair *s, size_t key_size_bits __unused)
+{
+    if (s == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    memset_s(s, sizeof(*s), 0, sizeof(*s));
+    if (!bn_alloc_max(&s->g)) {
+        goto err4;
+    }
+    if (!bn_alloc_max(&s->p)) {
+        goto err3;
+    }
+    if (!bn_alloc_max(&s->y)) {
+        goto err2;
+    }
+    if (!bn_alloc_max(&s->x)) {
+        goto err1;
+    }
+    if (!bn_alloc_max(&s->q)) {
+        goto err0;
+    }
+
+    return TEE_SUCCESS;
+err0:
+    crypto_bignum_free(&s->x);
+err1:
+    crypto_bignum_free(&s->y);
+err2:
+    crypto_bignum_free(&s->p);
+err3:
+    crypto_bignum_free(&s->g);
+err4:
+    return TEE_ERROR_OUT_OF_MEMORY;
+}
+
+static TEE_Result gp_cipher_asymc_dh_gen_keypair(struct dh_keypair *key,
+                                                 struct bignum *q,
+                                                 size_t size_bits)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    drv_pke_data p = {0};
+    drv_pke_data g = {0};
+    drv_pke_data x = {0};
+    drv_pke_data y = {0};
+    drv_pke_data arg_mod = {0};
+    td_u32 key_size = 0;
+    td_u32 key_size_q = 0;
+    td_u32 key_size_p = 0;
+    td_u32 size_align = 0;
+    td_u8 *buffer = NULL;
+
+    if (key == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    key_size_p = crypto_bignum_num_bytes(key->p);
+
+    if (size_bits) {
+        key_size = size_bits / BYTE_BITS;
+    }
+
+    if (q) {
+        key_size_q = crypto_bignum_num_bytes(q);
+    }
+
+    if (key_size) {
+        if (key_size > key_size_p || (q != NULL && key_size > key_size_q)) {
+            goto PKE_DEINIT;
+        }
+    } else {
+        key_size = q == NULL ? key_size_p : MIN(key_size_p, key_size_q);
+    }
+
+    size_align = (key_size + MIN_PKE_LEN - 1) / MIN_PKE_LEN * MIN_PKE_LEN;
+    arg_mod.length = size_align;
+    p.length = size_align;
+    g.length = size_align;
+    x.length = size_align;
+    y.length = size_align;
+    // The calculation need to alloc a big buffer which is 5 * size_align bytes.
+    buffer = calloc(5, size_align);
+    cipher_chk_goto(buffer == NULL, PKE_DEINIT);
+
+    p.data = buffer;
+    g.data = buffer + size_align;
+    // The address of y.data is buffer + 2 * size_align.
+    y.data = buffer + 2 * size_align;
+    // The address of x.data is buffer + 3 * size_align.
+    x.data = buffer + 3 * size_align;
+
+    get_bignum_data(key->p, p.data, size_align);
+    get_bignum_data(key->g, g.data, size_align);
+
+    if (q != NULL && key_size_q < key_size_p) {
+        // The address of arg_mod.data is buffer + 4 * size_align.
+        arg_mod.data = buffer + 4 * size_align;
+        get_bignum_data(q, arg_mod.data, size_align);
+    } else {
+        arg_mod.data = p.data;
+    }
+
+    cipher_chk_goto(crypto_rng_read(y.data + size_align - key_size, key_size) !=
+                        TEE_SUCCESS,
+                    ERR_EXIT, EMSG("crypto_rng_read failed!\n"));
+
+    cipher_chk_goto(kapi_cipher_pke_mod(&y, &arg_mod, &x) != TD_SUCCESS,
+                    ERR_EXIT, EMSG("kapi_cipher_pke_mod failed!\n"));
+
+    cipher_chk_goto(kapi_cipher_pke_exp_mod(&p, &x, &g, &y) != TD_SUCCESS,
+                    ERR_EXIT, EMSG("kapi_cipher_pke_exp_mod failed!\n"));
+
+    set_bignum_data(key->x, &x);
+    set_bignum_data(key->y, &y);
+
+    res = TEE_SUCCESS;
+
+ERR_EXIT:
+    // The big buffer whose size is 5 * size_align need to be memset to zero.
+    (void)memset_s(buffer, 5 * size_align, 0, 5 * size_align);
+    (void)free(buffer);
+PKE_DEINIT:
+    return res;
+}
+
+static TEE_Result gp_cipher_asymc_dh_shared_secret(
+    struct drvcrypt_secret_data *sdata)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    td_u32 length = 0;
+    drv_pke_data out = {0};
+    drv_pke_data in = {0};
+    drv_pke_data n = {0};
+    drv_pke_data k = {0};
+    struct dh_keypair *priv_key = NULL;
+    td_u32 size_align = 0;
+    td_u8 *buffer = NULL;
+
+    if (sdata == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    length = sdata->secret.length;
+    out.data = sdata->secret.data;
+    priv_key = sdata->key_priv;
+    size_align = get_align_size(crypto_bignum_num_bytes(sdata->key_pub),
+                                crypto_bignum_num_bytes(priv_key->x),
+                                crypto_bignum_num_bytes(priv_key->p));
+    out.length = size_align;
+    in.length = size_align;
+    n.length = size_align;
+    k.length = size_align;
+    // The calculation need to alloc a big buffer which is 4 * size_align bytes.
+    buffer = calloc(4, size_align);
+    cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+
+    in.data = buffer;
+    k.data = buffer + size_align;
+    // The address of n.data is buffer + 2 * size_align.
+    n.data = buffer + 2 * size_align;
+    get_bignum_data(sdata->key_pub, in.data, out.length);
+    get_bignum_data(priv_key->x, k.data, out.length);
+    get_bignum_data(priv_key->p, n.data, out.length);
+
+    if (length < size_align) {
+        // The address of out.data is buffer + 3 * size_align.
+        out.data = buffer + 3 * size_align;
+    }
+
+    cipher_chk_goto(kapi_cipher_pke_exp_mod(&n, &k, &in, &out) != TD_SUCCESS,
+                    PKE_DEINIT, EMSG("kapi_cipher_pke_exp_mod failed!\n"));
+
+    if (length < size_align) {
+        cipher_chk_goto(memcpy_s(sdata->secret.data, sdata->secret.length,
+                                 out.data + size_align - sdata->secret.length,
+                                 sdata->secret.length) != EOK,
+                        PKE_DEINIT, EMSG("memcpy_s failed!\n"));
+    }
+
+    res = TEE_SUCCESS;
+
+PKE_DEINIT:
+    // The big buffer whose size is 4 * size_align need to be memset to zero.
+    (void)memset_s(buffer, 4 * size_align, 0, 4 * size_align);
+    (void)free(buffer);
+    return res;
+}
+
+static struct drvcrypt_dh gp_cipher_asymc_dh_ops = {
+    .alloc_keypair = gp_cipher_asymc_dh_alloc_keypair,
+    .gen_keypair = gp_cipher_asymc_dh_gen_keypair,
+    .shared_secret = gp_cipher_asymc_dh_shared_secret,
+};
+
+static TEE_Result drv_gp_cipher_asymc_dh_init(void)
+{
+    drvcrypt_register_dh(&gp_cipher_asymc_dh_ops);
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(drv_gp_cipher_asymc_dh_init);
diff --git a/bsp/gp_cipher/src/gp_cipher_asymc_ecc.c b/bsp/gp_cipher/src/gp_cipher_asymc_ecc.c
new file mode 100644
index 0000000..04e75f5
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_asymc_ecc.c
@@ -0,0 +1,463 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher ecc interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <drvcrypt.h>
+#include <drvcrypt_acipher.h>
+#include <gp_cipher.h>
+#include <initcall.h>
+#include <mbedtls/bignum.h>
+#include <securec.h>
+#include <tee_api_defines_extensions.h>
+#include <tee_api_types.h>
+
+#if defined CFG_HI3516CV610
+#define MAX_ECC_LENGTH     72
+#define HW_ECC_P521_LENGTH 72
+#elif defined(CFG_HI3519DV500) || defined(CFG_HI3516DV500)
+#define MAX_ECC_LENGTH     68
+#define HW_ECC_P521_LENGTH 68
+#else
+#error "Not defined chip type"
+#endif
+#define SW_ECC_P521_LENGTH 66
+
+/******************************************************************************
+ * Message digest functions
+ ******************************************************************************/
+static struct drvcrypt_ecc gp_cipher_asymc_ecc_ops;
+
+typedef enum {
+    GEN_KEY = 0,
+    SHARED_SECRET,
+    SIGN,
+    VERIFY,
+} ecc_sw_operation;
+
+static TEE_Result gp_cipher_asymc_ecc_alloc_keypair(
+    struct ecc_keypair *s, size_t key_size_bits __unused)
+{
+    if (s == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (!bn_alloc_max(&s->d)) {
+        goto err2;
+    }
+    if (!bn_alloc_max(&s->x)) {
+        goto err1;
+    }
+    if (!bn_alloc_max(&s->y)) {
+        goto err0;
+    }
+
+    return TEE_SUCCESS;
+
+err0:
+    crypto_bignum_free(&s->x);
+err1:
+    crypto_bignum_free(&s->d);
+err2:
+    return TEE_ERROR_OUT_OF_MEMORY;
+}
+
+static TEE_Result gp_cipher_asymc_ecc_alloc_publickey(
+    struct ecc_public_key *s, size_t key_size_bits __unused)
+{
+    if (s == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (!bn_alloc_max(&s->x)) {
+        goto err1;
+    }
+    if (!bn_alloc_max(&s->y)) {
+        goto err0;
+    }
+
+    return TEE_SUCCESS;
+
+err0:
+    crypto_bignum_free(&s->x);
+err1:
+    return TEE_ERROR_OUT_OF_MEMORY;
+}
+
+static void gp_cipher_asymc_ecc_free_publickey(struct ecc_public_key *s)
+{
+    if (!s) {
+        return;
+    }
+
+    crypto_bignum_free(&s->x);
+    crypto_bignum_free(&s->y);
+}
+
+static void get_curve_type(td_u32 curve, drv_pke_ecc_curve_type *curve_type)
+{
+    switch (curve) {
+        case TEE_ECC_CURVE_NIST_P256:
+            *curve_type = DRV_PKE_ECC_TYPE_FIPS_P256R;
+            break;
+        case TEE_ECC_CURVE_NIST_P384:
+            *curve_type = DRV_PKE_ECC_TYPE_FIPS_P384R;
+            break;
+        case TEE_ECC_CURVE_NIST_P521:
+            *curve_type = DRV_PKE_ECC_TYPE_FIPS_P521R;
+            break;
+        default:
+            *curve_type = DRV_PKE_ECC_TYPE_INVALID;
+            break;
+    }
+}
+
+static TEE_Result sw_ecc_operation(uint32_t curve_type,
+                                   ecc_sw_operation operation,
+                                   uint32_t key_type, void *param,
+                                   uint32_t param_len)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    struct ecc_keypair priv_key = {0};
+    struct ecc_public_key pub_key = {0};
+    struct drvcrypt_secret_data *secret_data = NULL;
+    struct drvcrypt_sign_data *sign_data = NULL;
+    struct ecc_keypair *key = NULL;
+
+    switch (curve_type) {
+        case TEE_ECC_CURVE_NIST_P192:
+        case TEE_ECC_CURVE_NIST_P224:
+            break;
+        default:
+            return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (key_type == TEE_TYPE_ECDSA_KEYPAIR) {
+        res = crypto_asym_alloc_ecc_keypair(&priv_key, key_type, param_len);
+    } else {
+        res = crypto_asym_alloc_ecc_public_key(&pub_key, key_type, param_len);
+    }
+    cipher_chk_return(res != TEE_SUCCESS, res,
+                      EMSG("crypto_asym_alloc_ecc_key failed!\n"));
+
+    switch (operation) {
+        case GEN_KEY:
+            key = param;
+            res = priv_key.ops->generate(key, param_len);
+            break;
+        case SHARED_SECRET:
+            secret_data = param;
+            res = priv_key.ops->shared_secret(secret_data->key_priv,
+                                              secret_data->key_pub,
+                                              secret_data->secret.data,
+                                              &(secret_data->secret.length));
+            break;
+        case SIGN:
+            sign_data = param;
+            res = priv_key.ops->sign(sign_data->algo, sign_data->key,
+                                     sign_data->message.data,
+                                     sign_data->message.length,
+                                     sign_data->signature.data,
+                                     &(sign_data->signature.length));
+            break;
+        case VERIFY:
+            sign_data = param;
+            res = pub_key.ops->verify(sign_data->algo, sign_data->key,
+                                      sign_data->message.data,
+                                      sign_data->message.length,
+                                      sign_data->signature.data,
+                                      sign_data->signature.length);
+            break;
+        default:
+            res = TEE_ERROR_BAD_STATE;
+            break;
+    }
+
+    if (key_type == TEE_TYPE_ECDSA_KEYPAIR) {
+        crypto_bignum_free(&priv_key.x);
+        crypto_bignum_free(&priv_key.y);
+        crypto_bignum_free(&priv_key.d);
+    } else {
+        crypto_bignum_free(&pub_key.x);
+        crypto_bignum_free(&pub_key.y);
+    }
+
+    return res;
+}
+
+// When curve_type is ECC_P521, the key_size is 521bits.
+static TEE_Result gp_cipher_asymc_ecc_gen_keypair(struct ecc_keypair *key,
+                                                  size_t key_size)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    bool is_on_curve = false;
+    drv_pke_ecc_curve_type curve_type = {0};
+    td_u32 key_length = key_size == 521  // 521: refer to comment
+                            ? HW_ECC_P521_LENGTH
+                            : key_size / BYTE_BITS;
+    td_u8 d[MAX_ECC_LENGTH] = {0};
+    td_u8 x[MAX_ECC_LENGTH] = {0};
+    td_u8 y[MAX_ECC_LENGTH] = {0};
+    drv_pke_data priv_key = {
+        .data = d,
+    };
+    drv_pke_ecc_point pub_key = {
+        .x = x,
+        .y = y,
+    };
+
+    if (key == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    get_curve_type(key->curve, &curve_type);
+    if (curve_type == DRV_PKE_ECC_TYPE_INVALID) {
+        return sw_ecc_operation(key->curve, GEN_KEY, TEE_TYPE_ECDSA_KEYPAIR,
+                                key, key_size);
+    }
+
+    pub_key.length = key_length;
+    priv_key.length = key_length;
+
+    cipher_chk_goto(kapi_pke_ecc_gen_key(curve_type, NULL, &priv_key,
+                                         &pub_key) != TD_SUCCESS,
+                    PKE_DEINIT, EMSG("kapi_pke_ecc_gen_key failed!\n"));
+
+    cipher_chk_goto(kapi_pke_check_dot_on_curve(curve_type, &pub_key,
+                                                &is_on_curve) != TD_SUCCESS,
+                    PKE_DEINIT, EMSG("kapi_pke_check_dot_on_curve failed!\n"));
+
+    cipher_chk_goto(is_on_curve != true, PKE_DEINIT,
+                    EMSG("the dot is not on curve!\n"));
+
+    cipher_chk_goto(memcpy_s(((mbedtls_mpi *)(key->d))->p, priv_key.length,
+                             priv_key.data, priv_key.length) != EOK,
+                    PKE_DEINIT, EMSG("memcpy_s failed!\n"));
+    cipher_chk_goto(memcpy_s(((mbedtls_mpi *)(key->x))->p, pub_key.length,
+                             pub_key.x, pub_key.length) != EOK,
+                    PKE_DEINIT, EMSG("memcpy_s failed!\n"));
+    cipher_chk_goto(memcpy_s(((mbedtls_mpi *)(key->y))->p, pub_key.length,
+                             pub_key.y, pub_key.length) != EOK,
+                    PKE_DEINIT, EMSG("memcpy_s failed!\n"));
+    res = TEE_SUCCESS;
+
+PKE_DEINIT:
+    (void)memset_s(d, MAX_ECC_LENGTH, 0, MAX_ECC_LENGTH);
+    (void)memset_s(x, MAX_ECC_LENGTH, 0, MAX_ECC_LENGTH);
+    (void)memset_s(y, MAX_ECC_LENGTH, 0, MAX_ECC_LENGTH);
+
+    return res;
+}
+
+/* The calculation need to alloc a big buffer which is 3 * key_length bytes.
+  and the address of priv_key.data is buffer + 2 * key_length.
+ At last, the big buffer whose size is 3 * key_length need to be memset to zero.
+ */
+static TEE_Result gp_cipher_asymc_ecc_shared_secret(
+    struct drvcrypt_secret_data *sdata)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    drv_pke_ecc_curve_type curve_type = {0};
+    td_u8 data[HW_ECC_P521_LENGTH] = {0};
+    td_u32 key_length;
+    struct ecc_public_key *public_key;
+    struct ecc_keypair *private_key;
+    drv_pke_ecc_point pub_key;
+    drv_pke_data priv_key;
+    drv_pke_data share_key;
+    td_u8 *buffer = NULL;
+
+    if (sdata == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    key_length = sdata->size_sec == SW_ECC_P521_LENGTH ? HW_ECC_P521_LENGTH
+                                                       : sdata->size_sec;
+    public_key = sdata->key_pub;
+    private_key = sdata->key_priv;
+    pub_key.length = key_length;
+    priv_key.length = key_length;
+    share_key.length = key_length;
+    share_key.data =
+        key_length == HW_ECC_P521_LENGTH ? data : sdata->secret.data;
+
+    get_curve_type(public_key->curve, &curve_type);
+    if (curve_type == DRV_PKE_ECC_TYPE_INVALID) {
+        return sw_ecc_operation(public_key->curve, SHARED_SECRET,
+                                TEE_TYPE_ECDSA_KEYPAIR, sdata, key_length);
+    }
+
+    buffer = calloc(3, key_length);  // 3: refer to comment
+    cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+
+    pub_key.x = buffer;
+    pub_key.y = buffer + key_length;
+    priv_key.data = buffer + key_length * 2;  // 2: refer to comment
+    get_bignum_data(public_key->x, pub_key.x, key_length);
+    get_bignum_data(public_key->y, pub_key.y, key_length);
+    get_bignum_data(private_key->d, priv_key.data, key_length);
+
+    cipher_chk_goto(kapi_pke_ecc_gen_ecdh_key(curve_type, &pub_key, &priv_key,
+                                              &share_key) != TD_SUCCESS,
+                    PKE_DEINIT, EMSG("kapi_pke_ecc_gen_ecdh_key failed!\n"));
+
+    sdata->secret.length = share_key.length == HW_ECC_P521_LENGTH
+                               ? SW_ECC_P521_LENGTH
+                               : share_key.length;
+
+    if (key_length == HW_ECC_P521_LENGTH) {
+        cipher_chk_goto(memcpy_s(sdata->secret.data, SW_ECC_P521_LENGTH,
+                                 data + HW_ECC_P521_LENGTH - SW_ECC_P521_LENGTH,
+                                 SW_ECC_P521_LENGTH) != EOK,
+                        PKE_DEINIT, EMSG("memcpy_s failed!\n"));
+    }
+
+    res = TEE_SUCCESS;
+PKE_DEINIT:
+    (void)memset_s(buffer, 3 * key_length, 0,
+                   3 * key_length);  // 3: refer to comment
+    (void)free(buffer);
+    return res;
+}
+
+/* The calculation need to alloc a big buffer which is 2 * key_length bytes.
+The length of signature is 2 * SW_ECC_P521_LENGTH or 2 * length of
+out_sig. At last, the big buffer whose size is 2 * key_length need to be memset
+to zero. */
+static TEE_Result asymc_sign_or_verify(struct drvcrypt_sign_data *sdata,
+                                       bool sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 key_length = sdata->size_sec == SW_ECC_P521_LENGTH
+                            ? HW_ECC_P521_LENGTH
+                            : sdata->size_sec;
+    drv_pke_ecc_curve_type curve_type = {0};
+    drv_pke_ecc_point pub_key = {.length = key_length};
+    drv_pke_data priv_key = {.length = key_length};
+    drv_pke_data in_hash = {.data = sdata->message.data,
+                            .length = sdata->message.length};
+    drv_pke_ecc_sig out_sig = {.r = sdata->signature.data,
+                               .s = sdata->signature.data + key_length,
+                               .length = key_length};
+    td_u8 r[HW_ECC_P521_LENGTH] = {0};
+    td_u8 s[HW_ECC_P521_LENGTH] = {0};
+    td_u8 *buffer = NULL;
+
+    if (key_length == HW_ECC_P521_LENGTH) {
+        ret = memcpy_s(r + key_length - SW_ECC_P521_LENGTH, SW_ECC_P521_LENGTH,
+                       sdata->signature.data, SW_ECC_P521_LENGTH);
+        cipher_chk_return(ret != EOK, TEE_ERROR_BAD_STATE,
+                          EMSG("memcpy_s failed!\n"));
+
+        ret = memcpy_s(s + key_length - SW_ECC_P521_LENGTH, SW_ECC_P521_LENGTH,
+                       sdata->signature.data + SW_ECC_P521_LENGTH,
+                       SW_ECC_P521_LENGTH);
+        cipher_chk_return(ret != EOK, TEE_ERROR_BAD_STATE,
+                          EMSG("memcpy_s failed!\n"));
+
+        out_sig.r = r;
+        out_sig.s = s;
+    }
+
+    if (sign) {
+        struct ecc_keypair *pre_key = sdata->key;
+
+        get_curve_type(pre_key->curve, &curve_type);
+        if (curve_type == DRV_PKE_ECC_TYPE_INVALID) {
+            return sw_ecc_operation(pre_key->curve, SIGN,
+                                    TEE_TYPE_ECDSA_KEYPAIR, sdata, key_length);
+        }
+
+        buffer = calloc(2, key_length);  // 2:refer to comment
+        cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+        priv_key.data = buffer;
+        get_bignum_data(pre_key->d, priv_key.data, key_length);
+    } else {
+        struct ecc_public_key *pre_key = sdata->key;
+        get_curve_type(pre_key->curve, &curve_type);
+        if (curve_type == DRV_PKE_ECC_TYPE_INVALID) {
+            return sw_ecc_operation(pre_key->curve, VERIFY,
+                                    TEE_TYPE_ECDSA_PUBLIC_KEY, sdata,
+                                    key_length);
+        }
+
+        buffer = calloc(2, key_length);  // 2:refer to comment
+        cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+
+        pub_key.x = buffer;
+        pub_key.y = buffer + key_length;
+        get_bignum_data(pre_key->x, pub_key.x, key_length);
+        get_bignum_data(pre_key->y, pub_key.y, key_length);
+    }
+
+    if (sign) {
+        ret = kapi_pke_ecdsa_sign(curve_type, &priv_key, &in_hash, &out_sig);
+        sdata->signature.length =
+            sdata->size_sec == SW_ECC_P521_LENGTH
+                ? 2 * SW_ECC_P521_LENGTH  // 2:refer to comment
+                : out_sig.length * 2;     // 2:refer to comment
+    } else {
+        ret = kapi_pke_ecdsa_verify(curve_type, &pub_key, &in_hash, &out_sig);
+    }
+    cipher_chk_goto(ret != TD_SUCCESS, PKE_DEINIT,
+                    EMSG("kapi_pke_ecdsa_sign or kapi_pke_ecdsa_verify "
+                         "failed!\n"));
+
+    if (sign && sdata->size_sec == SW_ECC_P521_LENGTH) {
+        ret = memcpy_s(sdata->signature.data, SW_ECC_P521_LENGTH,
+                       r + key_length - SW_ECC_P521_LENGTH, SW_ECC_P521_LENGTH);
+        cipher_chk_goto(ret != EOK, PKE_DEINIT, EMSG("memcpy_s failed!\n"));
+
+        ret = memcpy_s(sdata->signature.data + SW_ECC_P521_LENGTH,
+                       SW_ECC_P521_LENGTH, s + key_length - SW_ECC_P521_LENGTH,
+                       SW_ECC_P521_LENGTH);
+        cipher_chk_goto(ret != EOK, PKE_DEINIT, EMSG("memcpy_s failed!\n"));
+    }
+
+PKE_DEINIT:
+    (void)memset_s(buffer, 2 * key_length, 0,  // 2:refer to comment
+                   2 * key_length);            // 2:refer to comment
+    (void)free(buffer);
+    return ret != TD_SUCCESS ? TEE_ERROR_BAD_STATE : TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_asymc_ecc_verify(struct drvcrypt_sign_data *sdata)
+{
+    if (sdata == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    return asymc_sign_or_verify(sdata, false);
+}
+
+static TEE_Result gp_cipher_asymc_ecc_sign(struct drvcrypt_sign_data *sdata)
+{
+    if (sdata == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    return asymc_sign_or_verify(sdata, true);
+}
+
+static struct drvcrypt_ecc gp_cipher_asymc_ecc_ops = {
+    .alloc_keypair = gp_cipher_asymc_ecc_alloc_keypair,
+    .alloc_publickey = gp_cipher_asymc_ecc_alloc_publickey,
+    .free_publickey = gp_cipher_asymc_ecc_free_publickey,
+    .gen_keypair = gp_cipher_asymc_ecc_gen_keypair,
+    .sign = gp_cipher_asymc_ecc_sign,
+    .verify = gp_cipher_asymc_ecc_verify,
+    .shared_secret = gp_cipher_asymc_ecc_shared_secret,
+};
+
+static TEE_Result drv_gp_cipher_asymc_ecc_init(void)
+{
+    drvcrypt_register_ecc(&gp_cipher_asymc_ecc_ops);
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(drv_gp_cipher_asymc_ecc_init);
diff --git a/bsp/gp_cipher/src/gp_cipher_asymc_rsa.c b/bsp/gp_cipher/src/gp_cipher_asymc_rsa.c
new file mode 100644
index 0000000..8ccfbc0
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_asymc_rsa.c
@@ -0,0 +1,594 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher rsa interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <drvcrypt.h>
+#include <drvcrypt_acipher.h>
+#include <gp_cipher.h>
+#include <initcall.h>
+#include <mbedtls/bignum.h>
+#include <securec.h>
+#include <tee_api_defines_extensions.h>
+#include <tee_api_types.h>
+
+#define MIN_RSA_LEN 256
+static struct drvcrypt_rsa gp_cipher_asymc_rsa_ops;
+
+static TEE_Result gp_cipher_asymc_rsa_alloc_keypair(
+    struct rsa_keypair *s, size_t key_size_bits __unused)
+{
+    if (s == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (!bn_alloc_max(&s->e)) {
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    if (!bn_alloc_max(&s->d) || !bn_alloc_max(&s->n) || !bn_alloc_max(&s->p) ||
+        !bn_alloc_max(&s->q) || !bn_alloc_max(&s->qp) ||
+        !bn_alloc_max(&s->dp) || !bn_alloc_max(&s->dq)) {
+        goto err;
+    }
+
+    return TEE_SUCCESS;
+err:
+    crypto_acipher_free_rsa_keypair(s);
+    return TEE_ERROR_OUT_OF_MEMORY;
+}
+
+static TEE_Result gp_cipher_asymc_rsa_alloc_publickey(
+    struct rsa_public_key *s, size_t key_size_bits __unused)
+{
+    if (s == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (!bn_alloc_max(&s->e)) {
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+    if (!bn_alloc_max(&s->n)) {
+        goto err;
+    }
+
+    return TEE_SUCCESS;
+err:
+    crypto_bignum_free(&s->e);
+    return TEE_ERROR_OUT_OF_MEMORY;
+}
+
+static void gp_cipher_asymc_rsa_free_publickey(struct rsa_public_key *s)
+{
+    if (!s) {
+        return;
+    }
+    crypto_bignum_free(&s->n);
+    crypto_bignum_free(&s->e);
+}
+
+static void gp_cipher_asymc_rsa_free_keypair(struct rsa_keypair *s)
+{
+    if (!s) {
+        return;
+    }
+
+    crypto_bignum_free(&s->e);
+    crypto_bignum_free(&s->d);
+    crypto_bignum_free(&s->n);
+    crypto_bignum_free(&s->p);
+    crypto_bignum_free(&s->q);
+    crypto_bignum_free(&s->qp);
+    crypto_bignum_free(&s->dp);
+    crypto_bignum_free(&s->dq);
+}
+
+static TEE_Result gp_cipher_asymc_rsa_gen_keypair(struct rsa_keypair *key,
+                                                  size_t key_size)
+{
+    if (key == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    return sw_crypto_acipher_gen_rsa_key(key, key_size);
+}
+
+static td_u32 get_out_size(drv_pke_data *data)
+{
+    td_u32 i = 0;
+
+    for (; i < data->length; ++i) {
+        if (data->data[i] != 0) {
+            break;
+        }
+    }
+
+    return data->length - i;
+}
+
+static TEE_Result hw_asymc_rsa_crypt_nopad_encrypt(
+    struct drvcrypt_rsa_ed *rsa_data)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    struct rsa_public_key *pub_key = rsa_data->key.key;
+    td_u32 size_align = get_align_size(crypto_bignum_num_bytes(pub_key->e),
+                                       crypto_bignum_num_bytes(pub_key->n),
+                                       rsa_data->message.length);
+    td_u32 size_out = rsa_data->key.n_size;
+    drv_pke_data in = {.length = size_align};
+    drv_pke_data out = {.length = size_align};
+    drv_pke_data n = {.length = size_align};
+    drv_pke_data k = {.length = size_align};
+    // The calculation need to alloc a big buffer which is 4 * size_align bytes.
+    td_u8 *buffer = calloc(4, size_align);
+    cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+
+    k.data = buffer;
+    n.data = buffer + size_align;
+    // The address of in.data is buffer + 2 * size_align.
+    in.data = buffer + 2 * size_align;
+    // The address of out.data is buffer + 3 * size_align.
+    out.data = buffer + 3 * size_align;
+    get_bignum_data(pub_key->e, k.data, size_align);
+    get_bignum_data(pub_key->n, n.data, size_align);
+
+    cipher_chk_goto(padding_data(&in, size_align, &rsa_data->message) !=
+                        TEE_SUCCESS,
+                    ERR_EXIT, EMSG("padding_data failed!\n"));
+
+    cipher_chk_goto(kapi_cipher_pke_exp_mod(&n, &k, &in, &out) != TD_SUCCESS,
+                    ERR_EXIT, EMSG("kapi_cipher_pke_exp_mod failed!\n"));
+
+    cipher_chk_goto(memcpy_s(rsa_data->cipher.data, rsa_data->cipher.length,
+                             out.data + out.length - size_out, size_out) != EOK,
+                    ERR_EXIT, EMSG("memcpy_s failed!"));
+
+    rsa_data->cipher.length = size_out;
+    res = TEE_SUCCESS;
+ERR_EXIT:
+    // The big buffer whose size is 4 * size_align need to be memset to zero.
+    (void)memset_s(buffer, size_align * 4, 0, size_align * 4);
+    (void)free(buffer);
+    return res;
+}
+
+static TEE_Result hw_asymc_rsa_crypt_nopad_decrypt(
+    struct drvcrypt_rsa_ed *rsa_data)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    struct rsa_keypair *priv_key = rsa_data->key.key;
+    td_u32 size_align = get_align_size(crypto_bignum_num_bytes(priv_key->d),
+                                       crypto_bignum_num_bytes(priv_key->n),
+                                       rsa_data->cipher.length);
+    td_u32 size_out = 0;
+    drv_pke_data in = {.length = size_align};
+    drv_pke_data out = {.length = size_align};
+    drv_pke_data n = {.length = size_align};
+    drv_pke_data k = {.length = size_align};
+    td_u8 *buffer;
+
+    if (priv_key->p && crypto_bignum_num_bytes(priv_key->p)) {
+        return sw_crypto_acipher_rsanopad_decrypt(priv_key,
+                                                  rsa_data->cipher.data,
+                                                  rsa_data->cipher.length,
+                                                  rsa_data->message.data,
+                                                  &rsa_data->message.length);
+    }
+
+    // The calculation need to alloc a big buffer which is 4 * size_align bytes.
+    buffer = calloc(4, size_align);
+    cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+
+    k.data = buffer;
+    n.data = buffer + size_align;
+    // The address of in.data is buffer + 2 * size_align.
+    in.data = buffer + 2 * size_align;
+    // The address of out.data is buffer + 3 * size_align.
+    out.data = buffer + 3 * size_align;
+
+    get_bignum_data(priv_key->d, k.data, size_align);
+    get_bignum_data(priv_key->n, n.data, size_align);
+
+    cipher_chk_goto(padding_data(&in, size_align, &rsa_data->cipher.data) !=
+                        TEE_SUCCESS,
+                    ERR_EXIT, EMSG("padding_data failed!\n"));
+
+    cipher_chk_goto(kapi_cipher_pke_exp_mod(&n, &k, &in, &out) != TD_SUCCESS,
+                    ERR_EXIT, EMSG("kapi_cipher_pke_exp_mod failed!\n"));
+
+    size_out = get_out_size(&out);
+
+    cipher_chk_goto(memcpy_s(rsa_data->message.data, rsa_data->message.length,
+                             out.data + out.length - size_out, size_out) != EOK,
+                    ERR_EXIT, EMSG("memcpy_s failed!"));
+
+    rsa_data->message.length = size_out;
+    res = TEE_SUCCESS;
+
+ERR_EXIT:
+    // The big buffer whose size is 4 * size_align need to be memset to zero.
+    (void)memset_s(buffer, size_align * 4, 0, size_align * 4);
+    (void)free(buffer);
+    return res;
+}
+
+static drv_pke_hash_type get_hash_type(uint32_t hash_algo)
+{
+    switch (hash_algo) {
+        case TEE_ALG_SHA256:
+            return DRV_PKE_HASH_TYPE_SHA256;
+        case TEE_ALG_SHA384:
+            return DRV_PKE_HASH_TYPE_SHA384;
+        case TEE_ALG_SHA512:
+            return DRV_PKE_HASH_TYPE_SHA512;
+        default:
+            break;
+    }
+
+    return DRV_PKE_HASH_TYPE_INVALID;
+}
+
+static TEE_Result hw_asymc_rsa_crypt_oaep_encrypt(
+    struct drvcrypt_rsa_ed *rsa_data)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    struct rsa_public_key *pub_key = rsa_data->key.key;
+    td_u32 size_align = get_align_size(rsa_data->message.length,
+                                       crypto_bignum_num_bytes(pub_key->e),
+                                       crypto_bignum_num_bytes(pub_key->n));
+    drv_pke_rsa_pub_key public_key = {.len = size_align};
+    drv_pke_data in = {.data = rsa_data->message.data,
+                       .length = rsa_data->message.length};
+    drv_pke_data out = {.data = rsa_data->cipher.data,
+                        .length = rsa_data->cipher.length};
+    drv_pke_data in_label = {.data = rsa_data->label.data,
+                             .length = rsa_data->label.length};
+    drv_pke_data *label = in_label.data == NULL ? NULL : &in_label;
+    drv_pke_rsa_scheme scheme = DRV_PKE_RSA_SCHEME_PKCS1_V21;
+    drv_pke_hash_type hash_type = {0};
+    td_u8 *buffer = NULL;
+
+    hash_type = get_hash_type(rsa_data->hash_algo);
+    if (hash_type == DRV_PKE_HASH_TYPE_INVALID) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // The calculation need to alloc a big buffer which is 2 * size_align bytes.
+    buffer = calloc(2, size_align);
+    cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+    public_key.e = buffer;
+    public_key.n = buffer + size_align;
+    get_bignum_data(pub_key->e, public_key.e, size_align);
+    get_bignum_data(pub_key->n, public_key.n, size_align);
+
+    cipher_chk_goto(kapi_pke_rsa_public_encrypt(scheme, hash_type, &public_key,
+                                                &in, label, &out) != TD_SUCCESS,
+                    ERR_EXIT, EMSG("kapi_pke_rsa_public_encrypt failed!\n"));
+
+    rsa_data->cipher.length = out.length;
+    res = TEE_SUCCESS;
+
+ERR_EXIT:
+    // The big buffer whose size is 2 * size_align need to be memset to zero.
+    (void)memset_s(buffer, 2 * size_align, 0, 2 * size_align);
+    (void)free(buffer);
+    return res;
+}
+static TEE_Result hw_asymc_rsa_crypt_oaep_decrypt(
+    struct drvcrypt_rsa_ed *rsa_data)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    struct rsa_keypair *priv_key = rsa_data->key.key;
+    td_u32 size_align = get_align_size(crypto_bignum_num_bytes(priv_key->n),
+                                       crypto_bignum_num_bytes(priv_key->e),
+                                       crypto_bignum_num_bytes(priv_key->d));
+    drv_pke_rsa_priv_key private_key = {.e_len = size_align,
+                                        .n_len = size_align,
+                                        .d_len = size_align};
+    drv_pke_data out = {.data = rsa_data->message.data,
+                        .length = rsa_data->message.length};
+    drv_pke_data in = {.data = rsa_data->cipher.data,
+                       .length = rsa_data->cipher.length};
+    drv_pke_data in_label = {.data = rsa_data->label.data,
+                             .length = rsa_data->label.length};
+    drv_pke_data *label = in_label.data == NULL ? NULL : &in_label;
+    drv_pke_rsa_scheme scheme = DRV_PKE_RSA_SCHEME_PKCS1_V21;
+    drv_pke_hash_type hash_type = {0};
+    td_u8 *buffer = NULL;
+
+    hash_type = get_hash_type(rsa_data->hash_algo);
+    if (hash_type == DRV_PKE_HASH_TYPE_INVALID) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (priv_key->p && crypto_bignum_num_bytes(priv_key->p)) {
+        return sw_crypto_acipher_rsaes_decrypt(rsa_data->algo, priv_key,
+                                               rsa_data->label.data,
+                                               rsa_data->label.length,
+                                               rsa_data->cipher.data,
+                                               rsa_data->cipher.length,
+                                               rsa_data->message.data,
+                                               &rsa_data->message.length);
+    }
+
+    // The calculation need to alloc a big buffer which is 3 * size_align bytes.
+    buffer = calloc(3, size_align);
+    cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+    private_key.e = buffer;
+    private_key.d = buffer + size_align;
+    // The address of private_key.n is buffer + 2 * size_align.
+    private_key.n = buffer + size_align * 2;
+
+    get_bignum_data(priv_key->e, private_key.e, size_align);
+    get_bignum_data(priv_key->d, private_key.d, size_align);
+    get_bignum_data(priv_key->n, private_key.n, size_align);
+
+    cipher_chk_goto(kapi_pke_rsa_private_decrypt(scheme, hash_type,
+                                                 &private_key, &in, label,
+                                                 &out) != TD_SUCCESS,
+                    ERR_EXIT, EMSG("kapi_pke_rsa_private_decrypt failed!\n"));
+
+    rsa_data->message.length = out.length;
+    res = TEE_SUCCESS;
+
+ERR_EXIT:
+    // The big buffer whose size is 3 * size_align need to be memset to zero.
+    (void)memset_s(buffer, 3 * size_align, 0, 3 * size_align);
+    (void)free(buffer);
+    return res;
+}
+
+static TEE_Result asymc_rsa_crypt(struct drvcrypt_rsa_ed *rsa_data,
+                                  bool encrypt)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+
+    if (rsa_data == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (rsa_data->rsa_id == DRVCRYPT_RSA_PKCS_V1_5 ||
+        rsa_data->rsa_id == DRVCRYPT_RSASSA_PKCS_V1_5 ||
+        rsa_data->hash_algo == TEE_ALG_SHA1 ||
+        rsa_data->hash_algo == TEE_ALG_SHA224
+#ifdef CFG_HI3516CV610
+        || rsa_data->hash_algo == TEE_ALG_SHA384 ||
+        rsa_data->hash_algo == TEE_ALG_SHA512
+#endif
+    ) {
+        return encrypt
+                   ? sw_crypto_acipher_rsaes_encrypt(rsa_data->algo,
+                                                     rsa_data->key.key,
+                                                     rsa_data->label.data,
+                                                     rsa_data->label.length,
+                                                     rsa_data->message.data,
+                                                     rsa_data->message.length,
+                                                     rsa_data->cipher.data,
+                                                     &rsa_data->cipher.length)
+                   : sw_crypto_acipher_rsaes_decrypt(rsa_data->algo,
+                                                     rsa_data->key.key,
+                                                     rsa_data->label.data,
+                                                     rsa_data->label.length,
+                                                     rsa_data->cipher.data,
+                                                     rsa_data->cipher.length,
+                                                     rsa_data->message.data,
+                                                     &rsa_data->message.length);
+    }
+
+    switch (rsa_data->rsa_id) {
+        case DRVCRYPT_RSA_NOPAD:
+            res = encrypt ? hw_asymc_rsa_crypt_nopad_encrypt(rsa_data)
+                          : hw_asymc_rsa_crypt_nopad_decrypt(rsa_data);
+            break;
+        case DRVCRYPT_RSA_OAEP:
+            res = encrypt ? hw_asymc_rsa_crypt_oaep_encrypt(rsa_data)
+                          : hw_asymc_rsa_crypt_oaep_decrypt(rsa_data);
+            break;
+        default:
+            res = TEE_ERROR_BAD_PARAMETERS;
+            break;
+    }
+
+    return res;
+}
+
+static TEE_Result gp_cipher_asymc_rsa_encrypt(struct drvcrypt_rsa_ed *rsa_data)
+{
+    return asymc_rsa_crypt(rsa_data, true);
+}
+
+static TEE_Result gp_cipher_asymc_rsa_decrypt(struct drvcrypt_rsa_ed *rsa_data)
+{
+    return asymc_rsa_crypt(rsa_data, false);
+}
+
+static TEE_Result asymc_rsa_ssa_sign(struct drvcrypt_rsa_ssa *rsa_ssa,
+                                     drv_pke_hash_type hash_type)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    struct rsa_keypair *priv_key = rsa_ssa->key.key;
+    td_u32 size_align = get_align_size(crypto_bignum_num_bytes(priv_key->d),
+                                       crypto_bignum_num_bytes(priv_key->e),
+                                       crypto_bignum_num_bytes(priv_key->n));
+    drv_pke_rsa_priv_key private_key = {.n_len = size_align,
+                                        .e_len = size_align,
+                                        .d_len = size_align};
+    drv_pke_rsa_scheme scheme = DRV_PKE_RSA_SCHEME_PKCS1_V21;
+    drv_pke_data in = {.data = rsa_ssa->message.data,
+                       .length = rsa_ssa->message.length};
+    drv_pke_data out = {.length = size_align};
+    td_u8 *buffer = NULL;
+
+    // The calculation need to alloc a big buffer which is 4 * size_align bytes.
+    buffer = calloc(4, size_align);
+    cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+
+    private_key.n = buffer;
+    private_key.e = buffer + size_align;
+    // The address of private_key.d is buffer + 2 * size_align.
+    private_key.d = buffer + 2 * size_align;
+    // The address of out.data is buffer + 3 * size_align.
+    out.data = buffer + 3 * size_align;
+    get_bignum_data(priv_key->n, private_key.n, size_align);
+    get_bignum_data(priv_key->e, private_key.e, size_align);
+    get_bignum_data(priv_key->d, private_key.d, size_align);
+
+    cipher_chk_goto(padding_data(&out, size_align, &rsa_ssa->signature) !=
+                        TEE_SUCCESS,
+                    ERR_EXIT, EMSG("padding_data failed!\n"));
+
+    cipher_chk_goto(kapi_pke_rsa_sign(&private_key, scheme, hash_type, &in,
+                                      &out) != TD_SUCCESS,
+                    ERR_EXIT, EMSG("kapi_pke_rsa_sign failed!\n"));
+
+    res = TEE_SUCCESS;
+ERR_EXIT:
+    // The big buffer whose size is 4 * size_align need to be memset to zero.
+    (void)memset_s(buffer, 4 * size_align, 0, 4 * size_align);
+    (void)free(buffer);
+    return res;
+}
+
+static TEE_Result asymc_rsa_ssa_verify(struct drvcrypt_rsa_ssa *rsa_ssa,
+                                       drv_pke_hash_type hash_type)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    struct rsa_public_key *pub_key = rsa_ssa->key.key;
+    td_u32 size_align = get_align_size(0, crypto_bignum_num_bytes(pub_key->e),
+                                       crypto_bignum_num_bytes(pub_key->n));
+    drv_pke_rsa_pub_key public_key = {.len = size_align};
+    drv_pke_rsa_scheme scheme = DRV_PKE_RSA_SCHEME_PKCS1_V21;
+    drv_pke_data in = {.data = rsa_ssa->message.data,
+                       .length = rsa_ssa->message.length};
+    drv_pke_data out = {.length = size_align};
+    // The calculation need to alloc a big buffer which is 3 * size_align bytes.
+    td_u8 *buffer = calloc(3, size_align);
+    cipher_chk_return(buffer == NULL, TEE_ERROR_OUT_OF_MEMORY);
+
+    public_key.e = buffer;
+    public_key.n = buffer + size_align;
+    // The address of out.data is buffer + 2 * size_align.
+    out.data = buffer + 2 * size_align;
+    get_bignum_data(pub_key->e, public_key.e, size_align);
+    get_bignum_data(pub_key->n, public_key.n, size_align);
+
+    cipher_chk_goto(padding_data(&out, size_align, &rsa_ssa->signature) !=
+                        TEE_SUCCESS,
+                    ERR_EXIT, EMSG("padding_data failed!\n"));
+
+    cipher_chk_goto(kapi_pke_rsa_verify(&public_key, scheme, hash_type, &in,
+                                        &out) != TD_SUCCESS,
+                    ERR_EXIT, EMSG("kapi_pke_rsa_verify failed!\n"));
+
+    res = TEE_SUCCESS;
+ERR_EXIT:
+    // The big buffer whose size is 3 * size_align need to be memset to zero.
+    (void)memset_s(buffer, 3 * size_align, 0, 3 * size_align);
+    (void)free(buffer);
+    return res;
+}
+
+static TEE_Result asymc_rsa_ssa(struct drvcrypt_rsa_ssa *rsa_ssa, bool sign)
+{
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    drv_pke_hash_type hash_type = {0};
+    struct rsa_keypair *priv_key;
+
+    if (rsa_ssa == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    switch (rsa_ssa->algo) {
+        case TEE_ALG_RSASSA_PKCS1_V1_5:
+        case TEE_ALG_RSASSA_PKCS1_V1_5_MD5:
+        case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:
+        case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:
+        case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:
+        case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:
+        case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:
+        case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:
+        case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:
+            goto SW_RSA_SSA;
+        case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:
+            break;
+        case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:
+        case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:
+#ifdef CFG_HI3516CV610
+            goto SW_RSA_SSA;
+#else
+            break;
+#endif
+        default:
+            return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    priv_key = rsa_ssa->key.isprivate ? rsa_ssa->key.key : NULL;
+    if (rsa_ssa->key.n_size < MIN_RSA_LEN ||
+        (priv_key && priv_key->p && crypto_bignum_num_bytes(priv_key->p))) {
+        goto SW_RSA_SSA;
+    }
+
+    hash_type = get_hash_type(rsa_ssa->hash_algo);
+    if (hash_type == DRV_PKE_HASH_TYPE_INVALID) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (sign) {
+        res = asymc_rsa_ssa_sign(rsa_ssa, hash_type);
+    } else {
+        res = asymc_rsa_ssa_verify(rsa_ssa, hash_type);
+    }
+
+    return res;
+
+SW_RSA_SSA:
+    return sign ? sw_crypto_acipher_rsassa_sign(rsa_ssa->algo, rsa_ssa->key.key,
+                                                rsa_ssa->salt_len,
+                                                rsa_ssa->message.data,
+                                                rsa_ssa->message.length,
+                                                rsa_ssa->signature.data,
+                                                &rsa_ssa->signature.length)
+                : sw_crypto_acipher_rsassa_verify(rsa_ssa->algo,
+                                                  rsa_ssa->key.key,
+                                                  rsa_ssa->salt_len,
+                                                  rsa_ssa->message.data,
+                                                  rsa_ssa->message.length,
+                                                  rsa_ssa->signature.data,
+                                                  rsa_ssa->signature.length);
+}
+
+static TEE_Result gp_cipher_asymc_rsa_ssa_verify(
+    struct drvcrypt_rsa_ssa *rsa_ssa)
+{
+    return asymc_rsa_ssa(rsa_ssa, false);
+}
+
+static TEE_Result gp_cipher_asymc_rsa_ssa_sign(struct drvcrypt_rsa_ssa *rsa_ssa)
+{
+    return asymc_rsa_ssa(rsa_ssa, true);
+}
+
+static struct drvcrypt_rsa gp_cipher_asymc_rsa_ops = {
+    .alloc_keypair = gp_cipher_asymc_rsa_alloc_keypair,
+    .alloc_publickey = gp_cipher_asymc_rsa_alloc_publickey,
+    .free_publickey = gp_cipher_asymc_rsa_free_publickey,
+    .free_keypair = gp_cipher_asymc_rsa_free_keypair,
+    .gen_keypair = gp_cipher_asymc_rsa_gen_keypair,
+    .encrypt = gp_cipher_asymc_rsa_encrypt,
+    .decrypt = gp_cipher_asymc_rsa_decrypt,
+    .optional.ssa_sign = gp_cipher_asymc_rsa_ssa_sign,
+    .optional.ssa_verify = gp_cipher_asymc_rsa_ssa_verify,
+};
+
+static TEE_Result drv_gp_cipher_asymc_rsa_init(void)
+{
+    drvcrypt_register_rsa(&gp_cipher_asymc_rsa_ops);
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(drv_gp_cipher_asymc_rsa_init);
diff --git a/bsp/gp_cipher/src/gp_cipher_authenc.c b/bsp/gp_cipher/src/gp_cipher_authenc.c
new file mode 100644
index 0000000..6138211
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_authenc.c
@@ -0,0 +1,466 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher hash interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <drvcrypt.h>
+#include <drvcrypt_authenc.h>
+#include <gp_cipher.h>
+#include <initcall.h>
+#include <securec.h>
+#include <tee_api_types.h>
+#include "kapi_symc.h"
+#include "mmz_ext.h"
+
+/******************************************************************************
+ * Message digest functions
+ ******************************************************************************/
+#define AAD_LEN        4096
+#define TAG_MAX_LENGTH 16
+
+struct gp_cipher_authenc_ctx {
+    struct drvcrypt_buf key;
+    crypto_symc_attr authenc_attr;
+    crypto_symc_ctrl_t authenc_ctrl;
+    crypto_symc_config_aes_ccm_gcm ccm_gcm_config;
+    td_handle authenc_handle;
+    td_handle keyslot_handle;
+    td_bool keyslot_created;
+    uint8_t aad[AAD_LEN];
+    bool config_set;
+    uint32_t current_ptlen;
+    uint32_t current_aadlen;
+};
+
+static struct drvcrypt_authenc gp_cipher_authenc_ops;
+
+static TEE_Result authenc_prepare_work_before_cal(
+    struct gp_cipher_authenc_ctx *authenc_ctx)
+{
+    td_s32 ret = TD_FAILURE;
+
+    /* 2. cipher create handle */
+    ret = kapi_cipher_symc_create(&authenc_ctx->authenc_handle,
+                                  &authenc_ctx->authenc_attr);
+    cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_symc_create failed\n"));
+
+    /* 3. create keyslot handle */
+    if (!authenc_ctx->keyslot_created) {
+        ret = kapi_keyslot_create(&authenc_ctx->keyslot_handle,
+                                  KM_KEYSLOT_TYPE_MCIPHER);
+        cipher_chk_goto((ret != TD_SUCCESS), CIPHER_DESTROY,
+                        EMSG("kapi_keyslot_create failed\n"));
+        authenc_ctx->keyslot_created = true;
+    }
+
+    /* 4. attach cipher handle & kslot handle */
+    ret = kapi_cipher_symc_attach(authenc_ctx->authenc_handle,
+                                  (td_handle)authenc_ctx->keyslot_handle);
+    cipher_chk_goto((ret != TD_SUCCESS), KEYSLOT_DESTROY,
+                    EMSG("kapi_cipher_symc_attach failed\n"));
+
+    /* 5. set clear key */
+    ret = cipher_set_clear_key(authenc_ctx->authenc_ctrl.symc_alg,
+                               authenc_ctx->keyslot_handle,
+                               authenc_ctx->key.data, authenc_ctx->key.length);
+    cipher_chk_goto((ret != TD_SUCCESS), KEYSLOT_DESTROY,
+                    EMSG("cipher_set_clear_key failed\n"));
+
+    return TEE_SUCCESS;
+
+KEYSLOT_DESTROY:
+    (void)kapi_keyslot_destroy(authenc_ctx->keyslot_handle);
+    authenc_ctx->keyslot_created = false;
+CIPHER_DESTROY:
+    (void)kapi_cipher_symc_destroy(authenc_ctx->authenc_handle);
+    return TEE_ERROR_BAD_STATE;
+}
+
+static TEE_Result gp_cipher_authenc_init(struct drvcrypt_authenc_init *dinit)
+{
+    struct gp_cipher_authenc_ctx *authenc_ctx;
+    td_s32 ret = TD_FAILURE;
+
+    if (dinit == NULL || dinit->ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (dinit->aad_len > AAD_LEN) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    authenc_ctx = dinit->ctx;
+    authenc_ctx->key = dinit->key;
+    authenc_ctx->authenc_attr.symc_type = CRYPTO_SYMC_TYPE_NORMAL;
+    authenc_ctx->authenc_attr.is_long_term = TD_FALSE;
+    authenc_ctx->authenc_ctrl.iv_length = dinit->nonce.length;
+    authenc_ctx->ccm_gcm_config.aad_len = dinit->aad_len;
+    authenc_ctx->ccm_gcm_config.tag_len = dinit->tag_len;
+    authenc_ctx->ccm_gcm_config.data_len = dinit->payload_len;
+    authenc_ctx->ccm_gcm_config.aad_buf.virt_addr = authenc_ctx->aad;
+    authenc_ctx->authenc_ctrl.param = (td_void *)&authenc_ctx->ccm_gcm_config;
+    authenc_ctx->current_ptlen = 0;
+    authenc_ctx->current_aadlen = 0;
+
+    switch (dinit->key.length) {
+        case KEY_128BIT_LEN:
+            authenc_ctx->authenc_ctrl.symc_key_length = CRYPTO_SYMC_KEY_128BIT;
+            break;
+        case KEY_256BIT_LEN:
+            authenc_ctx->authenc_ctrl.symc_key_length = CRYPTO_SYMC_KEY_256BIT;
+            break;
+#ifdef CFG_HI3516CV610
+        case KEY_192BIT_LEN:
+            authenc_ctx->authenc_ctrl.symc_key_length = CRYPTO_SYMC_KEY_192BIT;
+            break;
+#endif
+        default:
+            EMSG("key length dismatch!\n");
+            return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    ret = memcpy_s(authenc_ctx->authenc_ctrl.iv, CRYPTO_IV_LEN_IN_BYTES,
+                   dinit->nonce.data, dinit->nonce.length);
+    cipher_chk_return((ret != EOK), TEE_ERROR_BAD_STATE,
+                      EMSG("memcpy_s failed!\n"));
+
+    if (authenc_ctx->keyslot_created) {
+        ret = kapi_keyslot_destroy(authenc_ctx->keyslot_handle);
+        cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                          EMSG("kapi_keyslot_destroy failed\n"));
+        authenc_ctx->keyslot_created = false;
+    }
+
+    /* next operation */
+    ret = authenc_prepare_work_before_cal(authenc_ctx);
+    cipher_chk_return((ret != TEE_SUCCESS), TEE_ERROR_BAD_STATE,
+                      EMSG("authenc_prepare_work_before_cal failed!\n"));
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_authenc_update_aad(
+    struct drvcrypt_authenc_update_aad *dupdate)
+{
+    struct gp_cipher_authenc_ctx *authenc_ctx;
+    td_s32 ret = TD_FAILURE;
+
+    if (dupdate == NULL || dupdate->ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    authenc_ctx = dupdate->ctx;
+
+    if (authenc_ctx->ccm_gcm_config.aad_len <
+        authenc_ctx->current_aadlen + dupdate->aad.length) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    ret = memcpy_s(authenc_ctx->aad + authenc_ctx->current_aadlen, AAD_LEN,
+                   dupdate->aad.data, dupdate->aad.length);
+    cipher_chk_return(ret != EOK, TEE_ERROR_BAD_STATE,
+                      EMSG("memcpy_s failed!\n"));
+
+    authenc_ctx->current_aadlen += dupdate->aad.length;
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_authenc_update_payload(
+    struct drvcrypt_authenc_update_payload *d)
+{
+    struct gp_cipher_authenc_ctx *authenc_ctx;
+    uint32_t length;
+    crypto_buf_attr src_buf;
+    crypto_buf_attr dst_buf;
+    void *src_virt_addr;
+    void *dst_virt_addr;
+    td_s32 ret = TD_FAILURE;
+    td_s32 (*crypt_func)(td_handle, const crypto_buf_attr *,
+                         const crypto_buf_attr *, td_u32);
+
+    if (d == NULL || d->ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    authenc_ctx = d->ctx;
+    length = d->src.length;
+    crypt_func =
+        d->encrypt ? kapi_cipher_symc_encrypt : kapi_cipher_symc_decrypt;
+
+    if (authenc_ctx->authenc_ctrl.work_mode == CRYPTO_SYMC_WORK_MODE_CCM &&
+        (authenc_ctx->ccm_gcm_config.aad_len != authenc_ctx->current_aadlen ||
+         authenc_ctx->ccm_gcm_config.data_len <
+             length + authenc_ctx->current_ptlen)) {
+        EMSG("aad_len is wrong or data_len is too long!\n");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (!authenc_ctx->config_set) {
+        authenc_ctx->ccm_gcm_config.aad_len = authenc_ctx->current_aadlen;
+        /* set config */
+        ret = kapi_cipher_symc_set_config(authenc_ctx->authenc_handle,
+                                          &(authenc_ctx->authenc_ctrl));
+        cipher_chk_return(ret != TD_SUCCESS, TEE_ERROR_BAD_STATE,
+                          EMSG("kapi_cipher_symc_set_config failed!\n"));
+
+        authenc_ctx->config_set = true;
+    }
+
+    if (length == 0) {
+        return TEE_SUCCESS;
+    }
+
+    ret = cipher_alloc_and_map(&src_buf, &src_virt_addr, length);
+    cipher_chk_return(ret != TD_SUCCESS, TEE_ERROR_BAD_STATE,
+                      EMSG("cipher_alloc_and_map failed!\n"));
+
+    ret = cipher_alloc_and_map(&dst_buf, &dst_virt_addr, length);
+    cipher_chk_goto(ret != TD_SUCCESS, MMZ_UNMAP_AND_FREE2,
+                    EMSG("cipher_alloc_and_map failed!\n"));
+
+    ret = memcpy_s(src_virt_addr, length, d->src.data, length);
+    cipher_chk_goto(ret != EOK, MMZ_UNMAP_AND_FREE1,
+                    EMSG("memcpy_s failed!\n"));
+
+    ret = crypt_func(authenc_ctx->authenc_handle, &src_buf, &dst_buf, length);
+    cipher_chk_goto((ret != TD_SUCCESS), MMZ_UNMAP_AND_FREE1,
+                    EMSG("kapi_cipher_symc_encrypt or decrypt failed!\n"));
+
+    authenc_ctx->current_ptlen += length;
+
+    ret = kapi_cipher_symc_get_config(authenc_ctx->authenc_handle,
+                                      &(authenc_ctx->authenc_ctrl));
+    cipher_chk_goto((ret != TD_SUCCESS), MMZ_UNMAP_AND_FREE1,
+                    EMSG("kapi_cipher_symc_get_config failed!\n"));
+
+    ret = memcpy_s(d->dst.data, length, dst_virt_addr, length);
+    cipher_chk_goto(ret != EOK, MMZ_UNMAP_AND_FREE1,
+                    EMSG("memcpy_s failed!\n"));
+
+MMZ_UNMAP_AND_FREE1:
+    (void)cipher_unmap_and_free(&dst_buf, dst_virt_addr, length);
+MMZ_UNMAP_AND_FREE2:
+    (void)cipher_unmap_and_free(&src_buf, src_virt_addr, length);
+
+    return ret != TD_SUCCESS ? TEE_ERROR_BAD_STATE : TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_authenc_enc_final(
+    struct drvcrypt_authenc_final *dfinal)
+{
+    struct gp_cipher_authenc_ctx *authenc_ctx;
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    td_u32 ret = TD_FAILURE;
+    struct drvcrypt_authenc_update_payload dupdate;
+
+    if (dfinal == NULL || dfinal->ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    authenc_ctx = dfinal->ctx;
+    dupdate.encrypt = true;
+    dupdate.ctx = authenc_ctx;
+    dupdate.src = dfinal->src;
+    dupdate.dst = dfinal->dst;
+
+    /* Finalize the remaining buffer */
+    res = gp_cipher_authenc_update_payload(&dupdate);
+    cipher_chk_return(res != TEE_SUCCESS, TEE_ERROR_BAD_STATE,
+                      EMSG("gp_cipher_authenc_update_payload failed!\n"));
+
+    /* Check the tag length */
+    if (dfinal->tag.length < authenc_ctx->ccm_gcm_config.tag_len) {
+        dfinal->tag.length = authenc_ctx->ccm_gcm_config.tag_len;
+        return TEE_ERROR_SHORT_BUFFER;
+    }
+    dfinal->tag.length = authenc_ctx->ccm_gcm_config.tag_len;
+
+    if (authenc_ctx->current_ptlen != authenc_ctx->ccm_gcm_config.data_len) {
+        return TEE_ERROR_BAD_STATE;
+    }
+
+    /* get tag */
+    ret = kapi_cipher_symc_get_tag(authenc_ctx->authenc_handle,
+                                   dfinal->tag.data, dfinal->tag.length);
+    cipher_chk_return(ret != TD_SUCCESS, TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_symc_get_tag failed!\n"));
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_authenc_dec_final(
+    struct drvcrypt_authenc_final *dfinal)
+{
+    struct gp_cipher_authenc_ctx *authenc_ctx;
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    td_s32 ret = TD_FAILURE;
+    td_u8 dst_tag[TAG_MAX_LENGTH] = {0};
+    struct drvcrypt_authenc_update_payload dupdate;
+
+    if (dfinal == NULL || dfinal->ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    authenc_ctx = dfinal->ctx;
+    dupdate.encrypt = false;
+    dupdate.ctx = authenc_ctx;
+    dupdate.src = dfinal->src;
+    dupdate.dst = dfinal->dst;
+
+    if (dfinal->tag.length != authenc_ctx->ccm_gcm_config.tag_len) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    /* Finalize the remaining buffer */
+    res = gp_cipher_authenc_update_payload(&dupdate);
+    cipher_chk_return(res != TEE_SUCCESS, TEE_ERROR_BAD_STATE,
+                      EMSG("gp_cipher_authenc_update_payload failed!\n"));
+
+    if (authenc_ctx->current_ptlen != authenc_ctx->ccm_gcm_config.data_len) {
+        return TEE_ERROR_BAD_STATE;
+    }
+
+    /* get tag */
+    ret = kapi_cipher_symc_get_tag(authenc_ctx->authenc_handle, dst_tag,
+                                   dfinal->tag.length);
+    cipher_chk_return(ret != TD_SUCCESS, TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_symc_get_tag failed!\n"));
+
+    if (memcmp(dst_tag, dfinal->tag.data, dfinal->tag.length)) {
+        EMSG("The tag is not match !\n");
+        return TEE_ERROR_MAC_INVALID;
+    }
+
+    return TEE_SUCCESS;
+}
+
+static void gp_cipher_authenc_final(void *ctx)
+{
+    struct gp_cipher_authenc_ctx *authenc_ctx;
+
+    if (ctx == NULL) {
+        return;
+    }
+
+    authenc_ctx = ctx;
+    authenc_ctx->current_ptlen = 0;
+    authenc_ctx->current_aadlen = 0;
+    (void)memset_s(authenc_ctx->aad, AAD_LEN, 0, AAD_LEN);
+}
+
+static void gp_cipher_authenc_free_ctx(void *ctx)
+{
+    struct gp_cipher_authenc_ctx *authenc_ctx;
+    if (ctx == NULL) {
+        return;
+    }
+
+    authenc_ctx = ctx;
+    (void)kapi_keyslot_destroy(authenc_ctx->keyslot_handle);
+    (void)kapi_cipher_symc_destroy(authenc_ctx->authenc_handle);
+    (void)free(ctx);
+
+    (void)kapi_cipher_symc_deinit();
+}
+
+static void gp_cipher_authenc_copy_state(void *dst_ctx, void *src_ctx)
+{
+    struct gp_cipher_authenc_ctx *src = src_ctx;
+    struct gp_cipher_authenc_ctx *dst = dst_ctx;
+    td_bool status;
+    bool config_set;
+
+    if (src_ctx == NULL || dst_ctx == NULL) {
+        return;
+    }
+
+    config_set = dst->config_set;
+    status = dst->keyslot_created;
+    (void)kapi_cipher_symc_set_config(src->authenc_handle, &src->authenc_ctrl);
+    (void)memcpy_s(dst, sizeof(struct gp_cipher_authenc_ctx), src,
+                   sizeof(struct gp_cipher_authenc_ctx));
+
+    (void)authenc_prepare_work_before_cal(dst);
+    dst->config_set = config_set;
+    dst->keyslot_created = status;
+}
+
+static TEE_Result cipher_authenc_alloc_ctx(void **ctx_ret,
+                                           crypto_symc_ctrl_t symc_ctrl)
+{
+    struct gp_cipher_authenc_ctx *ctx = NULL;
+
+    ctx = calloc(1, sizeof(*ctx));
+    if (!ctx) {
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    ctx->authenc_ctrl = symc_ctrl;
+    ctx->keyslot_created = false;
+    ctx->config_set = false;
+
+    /* 1. cipher init */
+    if (kapi_cipher_symc_init() != TD_SUCCESS) {
+        free(ctx);
+        EMSG("kapi_cipher_symc_init failed!\n");
+        return TEE_ERROR_BAD_STATE;
+    }
+
+    *ctx_ret = ctx;
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_authenc_alloc_ctx(void **ctx, uint32_t algo)
+{
+    crypto_symc_ctrl_t symc_ctrl;
+
+    if (ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    symc_ctrl.symc_bit_width = CRYPTO_SYMC_BIT_WIDTH_128BIT;
+    symc_ctrl.symc_alg = CRYPTO_SYMC_ALG_AES;
+
+    switch (algo) {
+        case TEE_ALG_AES_CCM:
+            symc_ctrl.work_mode = CRYPTO_SYMC_WORK_MODE_CCM;
+            symc_ctrl.iv_change_flag = CRYPTO_SYMC_CCM_IV_CHANGE_START;
+            break;
+        case TEE_ALG_AES_GCM:
+            symc_ctrl.work_mode = CRYPTO_SYMC_WORK_MODE_GCM;
+            symc_ctrl.iv_change_flag = CRYPTO_SYMC_GCM_IV_CHANGE_START;
+            break;
+        default:
+            return TEE_ERROR_NOT_IMPLEMENTED;
+    }
+
+    
+    return cipher_authenc_alloc_ctx(ctx, symc_ctrl);
+}
+
+static struct drvcrypt_authenc gp_cipher_authenc_ops = {
+    .alloc_ctx = gp_cipher_authenc_alloc_ctx,
+    .init = gp_cipher_authenc_init,
+    .update_aad = gp_cipher_authenc_update_aad,
+    .update_payload = gp_cipher_authenc_update_payload,
+    .enc_final = gp_cipher_authenc_enc_final,
+    .dec_final = gp_cipher_authenc_dec_final,
+    .final = gp_cipher_authenc_final,
+    .free_ctx = gp_cipher_authenc_free_ctx,
+    .copy_state = gp_cipher_authenc_copy_state,
+};
+
+static TEE_Result drv_gp_cipher_authenc_init(void)
+{
+    drvcrypt_register_authenc(&gp_cipher_authenc_ops);
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(drv_gp_cipher_authenc_init);
diff --git a/bsp/gp_cipher/src/gp_cipher_cmac.c b/bsp/gp_cipher/src/gp_cipher_cmac.c
new file mode 100644
index 0000000..0869ccc
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_cmac.c
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher cmac interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <drvcrypt_mac.h>
+#include <gp_cipher.h>
+#include <initcall.h>
+#include <kernel/mutex.h>
+#include <tee_api_types.h>
+#include "kapi_hash.h"
+#include "kapi_symc.h"
+#include "ot_osal.h"
+
+/******************************************************************************
+ * Message digest functions
+ ******************************************************************************/
+
+typedef struct crypt_buf {
+    const td_u8 *data;
+    td_u32 length;
+} crypt_buf;
+
+struct gp_cipher_cmac_ctx {
+    struct crypto_mac_ctx ctx;
+    crypto_symc_mac_attr cmac_attr;
+    td_handle cmac_handle;
+    td_handle keyslot_handle;
+    td_bool keyslot_created;
+    crypt_buf key;
+};
+static const struct crypto_mac_ops gp_cipher_cmac_ops;
+
+static struct gp_cipher_cmac_ctx *to_cmac_ctx(const struct crypto_mac_ctx *ctx)
+{
+    if (ctx == NULL || ctx->ops != &gp_cipher_cmac_ops) {
+        return NULL;
+    }
+
+    return container_of(ctx, struct gp_cipher_cmac_ctx, ctx);
+}
+
+static td_s32 cmac_prepare_work_before_cal(struct gp_cipher_cmac_ctx *cmac_ctx,
+                                           const uint8_t *key, size_t len)
+{
+    td_s32 ret = TD_FAILURE;
+
+    if (!cmac_ctx->keyslot_created) {
+        ret = kapi_keyslot_create(&cmac_ctx->keyslot_handle,
+                                  KM_KEYSLOT_TYPE_MCIPHER);
+        cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                          EMSG("kapi_keyslot_create failed\n"));
+        cmac_ctx->keyslot_created = true;
+    }
+
+    ret = cipher_set_clear_key(cmac_ctx->cmac_attr.symc_alg,
+                               cmac_ctx->keyslot_handle, key, len);
+    cipher_chk_goto((ret != TD_SUCCESS), KEYSLOT_DESTROY,
+                    EMSG("cipher_set_clear_key failed\n"));
+
+    cmac_ctx->cmac_attr.keyslot_chn = (td_handle)cmac_ctx->keyslot_handle;
+
+    ret = kapi_cipher_mac_start(&cmac_ctx->cmac_handle, &cmac_ctx->cmac_attr);
+    cipher_chk_goto((ret != TD_SUCCESS), KEYSLOT_DESTROY,
+                    EMSG("kapi_cipher_mac_start failed\n"));
+
+    return TD_SUCCESS;
+
+KEYSLOT_DESTROY:
+    (void)kapi_keyslot_destroy(cmac_ctx->keyslot_handle);
+    return ret;
+}
+
+static TEE_Result gp_cipher_cmac_init(struct crypto_mac_ctx *ctx,
+                                      const uint8_t *key, size_t len)
+{
+    struct gp_cipher_cmac_ctx *cmac_ctx = NULL;
+    td_s32 ret = TD_FAILURE;
+
+    if (key == NULL || (cmac_ctx = to_cmac_ctx(ctx)) == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    switch (len) {
+        case KEY_128BIT_LEN:
+            cmac_ctx->cmac_attr.symc_key_length = CRYPTO_SYMC_KEY_128BIT;
+            break;
+        case KEY_256BIT_LEN:
+            cmac_ctx->cmac_attr.symc_key_length = CRYPTO_SYMC_KEY_256BIT;
+            break;
+#ifdef CFG_HI3516CV610
+        case KEY_192BIT_LEN:
+            cmac_ctx->cmac_attr.symc_key_length = CRYPTO_SYMC_KEY_192BIT;
+            break;
+#endif
+        default:
+            EMSG("key length dismatch!\n");
+            return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    cmac_ctx->key.data = key;
+    cmac_ctx->key.length = len;
+
+    if (cmac_ctx->keyslot_created) {
+        ret = kapi_keyslot_destroy(cmac_ctx->keyslot_handle);
+        cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                          EMSG("kapi_keyslot_destroy failed\n"));
+        cmac_ctx->keyslot_created = false;
+    }
+
+    ret = cmac_prepare_work_before_cal(cmac_ctx, key, len);
+    cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                      EMSG("cmac_prepare_work_before_cal failed!\n"));
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_cmac_update(struct crypto_mac_ctx *ctx,
+                                        const uint8_t *data, size_t len)
+{
+    struct gp_cipher_cmac_ctx *cmac_ctx = NULL;
+    crypto_buf_attr src_buf = {};
+    td_s32 ret = TD_FAILURE;
+
+    if (data == NULL || (cmac_ctx = to_cmac_ctx(ctx)) == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    src_buf.virt_addr = (td_u8 *)data;
+    ret = kapi_cipher_mac_update(cmac_ctx->cmac_handle, &src_buf, len);
+    cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_mac_update failed\n"));
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_cmac_final(struct crypto_mac_ctx *ctx,
+                                       uint8_t *digest, size_t len)
+{
+    struct gp_cipher_cmac_ctx *cmac_ctx = NULL;
+    td_u32 result_len = len;
+    td_s32 ret = TD_FAILURE;
+
+    if (digest == NULL || (cmac_ctx = to_cmac_ctx(ctx)) == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    ret = kapi_cipher_mac_finish(cmac_ctx->cmac_handle, digest, &result_len);
+    cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_mac_finish failed\n"));
+    cmac_ctx->keyslot_created = false;
+
+    return TEE_SUCCESS;
+}
+
+static void gp_cipher_cmac_free_ctx(struct crypto_mac_ctx *ctx)
+{
+    struct gp_cipher_cmac_ctx *cmac_ctx = to_cmac_ctx(ctx);
+    if (cmac_ctx == NULL) {
+        return;
+    }
+
+    (void)kapi_keyslot_destroy(cmac_ctx->keyslot_handle);
+    (void)free(cmac_ctx);
+
+    (void)kapi_cipher_symc_deinit();
+}
+
+static void gp_cipher_cmac_copy_state(struct crypto_mac_ctx *dst_ctx,
+                                      struct crypto_mac_ctx *src_ctx)
+{
+    struct gp_cipher_cmac_ctx *src = NULL;
+    struct gp_cipher_cmac_ctx *dst = NULL;
+    td_bool status;
+
+    if ((src = to_cmac_ctx(src_ctx)) == NULL ||
+        (dst = to_cmac_ctx(dst_ctx)) == NULL) {
+        return;
+    }
+
+    status = dst->keyslot_created;
+    (void)memcpy_s(dst, sizeof(struct gp_cipher_cmac_ctx), src,
+                   sizeof(struct gp_cipher_cmac_ctx));
+
+    dst->keyslot_created = status;
+    (void)cmac_prepare_work_before_cal(dst, dst->key.data, dst->key.length);
+}
+
+static const struct crypto_mac_ops gp_cipher_cmac_ops = {
+    .init = gp_cipher_cmac_init,
+    .update = gp_cipher_cmac_update,
+    .final = gp_cipher_cmac_final,
+    .free_ctx = gp_cipher_cmac_free_ctx,
+    .copy_state = gp_cipher_cmac_copy_state,
+};
+
+static TEE_Result cipher_cmac_alloc_ctx(struct crypto_mac_ctx **ctx_ret,
+                                        crypto_symc_work_mode cmac_type)
+{
+    struct gp_cipher_cmac_ctx *ctx = NULL;
+
+    ctx = calloc(1, sizeof(*ctx));
+    if (!ctx) {
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    ctx->ctx.ops = &gp_cipher_cmac_ops;
+    ctx->cmac_attr.work_mode = cmac_type;
+    ctx->cmac_attr.is_long_term = TD_FALSE;
+    ctx->cmac_attr.symc_alg = CRYPTO_SYMC_ALG_AES;
+    ctx->keyslot_created = false;
+
+    if (kapi_cipher_symc_init() != TD_SUCCESS) {
+        free(ctx);
+        EMSG("kapi_cipher_symc_init failed!\n");
+        return TEE_ERROR_BAD_STATE;
+    }
+
+    *ctx_ret = &ctx->ctx;
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_cmac_alloc_ctx(struct crypto_mac_ctx **ctx,
+                                           uint32_t algo)
+{
+    crypto_symc_work_mode work_mode;
+
+    if (ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    switch (algo) {
+        case TEE_ALG_AES_CMAC:
+            work_mode = CRYPTO_SYMC_WORK_MODE_CMAC;
+            break;
+        default:
+            return TEE_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return cipher_cmac_alloc_ctx(ctx, work_mode);
+}
+
+static TEE_Result drv_gp_cipher_cmac_init(void)
+{
+    drvcrypt_register_cmac(gp_cipher_cmac_alloc_ctx);
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(drv_gp_cipher_cmac_init);
diff --git a/bsp/gp_cipher/src/gp_cipher_common.c b/bsp/gp_cipher/src/gp_cipher_common.c
new file mode 100644
index 0000000..0f0df0e
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_common.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher common interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <drvcrypt.h>
+#include <drvcrypt_acipher.h>
+#include <gp_cipher.h>
+#include <mbedtls/bignum.h>
+#include <securec.h>
+#include <tee_api_defines_extensions.h>
+#include <tee_api_types.h>
+#include "mmz_ext.h"
+
+bool bn_alloc_max(struct bignum **s)
+{
+    *s = crypto_bignum_allocate(_CFG_CORE_LTC_BIGNUM_MAX_BITS);
+
+    return *s;
+}
+
+#ifdef GP_CIPHER_PKE_DUMP
+void dump_data(const drv_pke_data *data, const char *name)
+{
+    EMSG("name: %s-----------------\n", name);
+    DHEXDUMP(data->data, data->length);
+}
+void dump_bignum_data(const void *bignum, const char *name)
+{
+    mbedtls_mpi *buffer = bignum;
+    EMSG("name: %s-----------------\n", name);
+    DHEXDUMP(buffer->p, crypto_bignum_num_bytes(bignum));
+}
+#else
+void dump_data(const drv_pke_data *data, const char *name)
+{
+    (void)data;
+    (void)name;
+}
+void dump_bignum_data(const void *bignum, const char *name)
+{
+    (void)bignum;
+    (void)name;
+}
+#endif
+
+td_u32 get_align_size(td_u32 a_len, td_u32 b_len, td_u32 c_len)
+{
+    td_u32 a = MAX(b_len, c_len);
+    td_u32 size_max = MAX(a_len, a);
+
+    return (size_max + MIN_PKE_LEN - 1) / MIN_PKE_LEN * MIN_PKE_LEN;
+}
+
+TEE_Result padding_data(drv_pke_data *data, td_u32 size_align,
+                        struct drvcrypt_buf *buf)
+{
+    if (size_align < buf->length) {
+        return TEE_ERROR_SHORT_BUFFER;
+    }
+
+    cipher_chk_return(memcpy_s(data->data + size_align - buf->length,
+                               buf->length, buf->data, buf->length) != EOK,
+                      TEE_ERROR_BAD_STATE, EMSG("memcpy_s failed!\n"));
+
+    return TEE_SUCCESS;
+}
+
+void get_bignum_data(const void *bignum, td_u8 *buf, td_u32 buf_len)
+{
+    mbedtls_mpi *buffer = bignum;
+    td_u32 length = crypto_bignum_num_bytes(bignum);
+
+    for (td_u32 i = 0; i < length; ++i) {
+        buf[buf_len - 1 - i] = ((td_u8 *)buffer->p)[i];
+    }
+}
+
+td_s32 cipher_set_clear_key(crypto_symc_alg algo, crypto_handle keyslot_handle,
+                            const td_u8 *key, td_u32 keylen)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_handle klad_handle = 0;
+    km_klad_attr klad_attr = {.key_cfg = {.engine = algo == CRYPTO_SYMC_ALG_AES
+                                                        ? KM_CRYPTO_ALG_AES
+                                                        : KM_CRYPTO_ALG_SM4,
+                                          .decrypt_support = TD_TRUE,
+                                          .encrypt_support = TD_TRUE},
+                              .key_sec_cfg = {
+                                  .key_sec = KM_KLAD_SEC_ENABLE,
+                                  .master_only_enable = TD_TRUE,
+                                  .dest_buf_sec_support = TD_TRUE,
+                                  .dest_buf_non_sec_support = TD_FALSE,
+                                  .src_buf_sec_support = TD_TRUE,
+                                  .src_buf_non_sec_support = TD_FALSE,
+                              }};
+    km_klad_clear_key clear_key = {.key = key, .key_size = keylen};
+
+    /* 1. klad create handle */
+    ret = kapi_klad_create(&klad_handle);
+    cipher_chk_return(ret != TD_SUCCESS, TD_FAILURE,
+                      EMSG("kapi_klad_create failed!\n"));
+
+    /* 2. klad set attr for clear key */
+    cipher_chk_goto(kapi_klad_set_attr(klad_handle, &klad_attr) != TD_SUCCESS,
+                    __KLAD_DESTORY__, EMSG("kapi_klad_set_attr failed!\n"));
+
+    /* 3. attach klad handle & kslot handle */
+    ret = kapi_klad_attach(klad_handle, KM_KLAD_DEST_TYPE_MCIPHER,
+                           keyslot_handle);
+    cipher_chk_goto(ret != TD_SUCCESS, __KLAD_DESTORY__,
+                    EMSG("kapi_klad_attach failed!\n"));
+
+    /* 4. set clear key */
+    ret = kapi_klad_set_clear_key(klad_handle, &clear_key);
+    cipher_chk_goto(ret != TD_SUCCESS, __KLAD_DETACH__,
+                    EMSG("kapi_klad_attach failed!\n"));
+
+__KLAD_DETACH__:
+    kapi_klad_detach(klad_handle, KM_KLAD_DEST_TYPE_MCIPHER, keyslot_handle);
+__KLAD_DESTORY__:
+    kapi_klad_destroy(klad_handle);
+    return ret;
+}
+
+td_s32 cipher_alloc_and_map(crypto_buf_attr *buf_attr, void **virt_addr,
+                            uint32_t size)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    ret = drv_mmz_alloc(&(buf_attr->phys_addr), "SPACC Buffer", "SMMZ2", size);
+    cipher_chk_return(ret != TD_SUCCESS, TD_FAILURE,
+                      EMSG("drv_mmz_alloc failed!\n"));
+
+    *virt_addr = drv_mmz_map_nocache(buf_attr->phys_addr, size);
+    cipher_chk_goto(*virt_addr == NULL, MMZ_FREE,
+                    EMSG("drv_mmz_map_nocache failed!\n"));
+
+    return ret;
+
+MMZ_FREE:
+    drv_mmz_free(buf_attr->phys_addr);
+    buf_attr->phys_addr = 0;
+    return TD_FAILURE;
+}
+
+void cipher_unmap_and_free(crypto_buf_attr *buf_attr, const void *virt_addr,
+                           uint32_t size)
+{
+    (void)drv_mmz_unmap(virt_addr, size);
+    (void)drv_mmz_free(buf_attr->phys_addr);
+    buf_attr->phys_addr = 0;
+}
diff --git a/bsp/gp_cipher/src/gp_cipher_hash.c b/bsp/gp_cipher/src/gp_cipher_hash.c
new file mode 100644
index 0000000..00a1cd9
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_hash.c
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher hash interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <drvcrypt_hash.h>
+#include <gp_cipher.h>
+#include <initcall.h>
+#include <tee_api_types.h>
+#include "kapi_hash.h"
+
+#define MAX_HASH_LEN 64
+
+/******************************************************************************
+ * Message digest functions
+ ******************************************************************************/
+struct gp_cipher_hash_ctx {
+    struct crypto_hash_ctx ctx;
+    crypto_hash_attr hash_attr;
+    td_handle hash_handle;
+    td_bool hash_handle_created;
+};
+
+static const struct crypto_hash_ops gp_cipher_hash_ops;
+
+static struct gp_cipher_hash_ctx *to_hash_ctx(const struct crypto_hash_ctx *ctx)
+{
+    if (ctx == NULL || ctx->ops != &gp_cipher_hash_ops) {
+        return NULL;
+    }
+
+    return container_of(ctx, struct gp_cipher_hash_ctx, ctx);
+}
+
+static TEE_Result gp_cipher_hash_init(struct crypto_hash_ctx *ctx)
+{
+    struct gp_cipher_hash_ctx *hash_ctx = NULL;
+    td_s32 ret = TD_FAILURE;
+
+    if ((hash_ctx = to_hash_ctx(ctx)) == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (hash_ctx->hash_handle_created) {
+        ret = kapi_cipher_hash_destroy(hash_ctx->hash_handle);
+        cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_SECURITY,
+                          EMSG("kapi_cipher_hash_destroy failed\n"));
+        hash_ctx->hash_handle_created = false;
+    }
+
+    ret = kapi_cipher_hash_start(&hash_ctx->hash_handle, &hash_ctx->hash_attr);
+    cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_SECURITY,
+                      EMSG("kapi_cipher_hash_start failed\n"));
+    hash_ctx->hash_handle_created = true;
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_hash_update(struct crypto_hash_ctx *ctx,
+                                        const uint8_t *data, size_t len)
+{
+    struct gp_cipher_hash_ctx *hash_ctx = NULL;
+    crypto_buf_attr src_buf = {0};
+    td_s32 ret = TD_FAILURE;
+
+    if (data == NULL || (hash_ctx = to_hash_ctx(ctx)) == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    src_buf.virt_addr = data;
+    ret = kapi_cipher_hash_update(hash_ctx->hash_handle, &src_buf, len);
+    cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_hash_update failed\n"));
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_hash_final(struct crypto_hash_ctx *ctx,
+                                       uint8_t *digest, size_t len)
+{
+    struct gp_cipher_hash_ctx *hash_ctx = NULL;
+    td_u32 result_len = MAX_HASH_LEN;
+    TEE_Result res = TEE_ERROR_BAD_STATE;
+    td_s32 ret = TD_FAILURE;
+    td_u8 out[MAX_HASH_LEN] = {0};
+
+    if (digest == NULL || (hash_ctx = to_hash_ctx(ctx)) == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    ret = kapi_cipher_hash_finish(hash_ctx->hash_handle, out, &result_len);
+    cipher_chk_goto((ret != TD_SUCCESS), err_exit,
+                    EMSG("kapi_cipher_hash_finish failed\n"));
+    hash_ctx->hash_handle_created = false;
+
+    ret = memcpy_s(digest, len, out, result_len);
+    cipher_chk_goto(ret != EOK, err_exit, EMSG("memcpy_s failed!\n"));
+
+    res = TEE_SUCCESS;
+err_exit:
+    (void)memset_s(out, sizeof(out), 0, sizeof(out));
+    return res;
+}
+
+static void gp_cipher_hash_free_ctx(struct crypto_hash_ctx *ctx)
+{
+    struct gp_cipher_hash_ctx *hash_ctx = to_hash_ctx(ctx);
+    if (hash_ctx == NULL) {
+        return;
+    }
+
+    if (hash_ctx->hash_handle_created) {
+        (void)kapi_cipher_hash_destroy(hash_ctx->hash_handle);
+        hash_ctx->hash_handle = false;
+    }
+
+    (void)free(hash_ctx);
+    (void)kapi_cipher_hash_deinit();
+}
+
+static void gp_cipher_hash_copy_state(struct crypto_hash_ctx *dst_ctx,
+                                      struct crypto_hash_ctx *src_ctx)
+{
+    struct gp_cipher_hash_ctx *src = NULL;
+    struct gp_cipher_hash_ctx *dst = NULL;
+    crypto_hash_clone_ctx clone_ctx = {0};
+
+    if ((src = to_hash_ctx(src_ctx)) == NULL ||
+        (dst = to_hash_ctx(dst_ctx)) == NULL) {
+        return;
+    }
+
+    (void)kapi_cipher_hash_get(src->hash_handle, &clone_ctx);
+    (void)kapi_cipher_hash_set(dst->hash_handle, &clone_ctx);
+}
+
+static const struct crypto_hash_ops gp_cipher_hash_ops = {
+    .init = gp_cipher_hash_init,
+    .update = gp_cipher_hash_update,
+    .final = gp_cipher_hash_final,
+    .free_ctx = gp_cipher_hash_free_ctx,
+    .copy_state = gp_cipher_hash_copy_state,
+};
+
+static TEE_Result cipher_hash_alloc_ctx(struct crypto_hash_ctx **ctx_ret,
+                                        crypto_hash_type hash_type)
+{
+    struct gp_cipher_hash_ctx *ctx = NULL;
+
+    ctx = calloc(1, sizeof(*ctx));
+    if (!ctx) {
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    ctx->ctx.ops = &gp_cipher_hash_ops;
+    ctx->hash_attr.hash_type = hash_type;
+    ctx->hash_attr.is_long_term = TD_FALSE;
+    ctx->hash_handle_created = false;
+
+    if (kapi_cipher_hash_init() != TD_SUCCESS) {
+        free(ctx);
+        EMSG("kapi_cipher_hash_init failed!\n");
+        return TEE_ERROR_BAD_STATE;
+    }
+
+    *ctx_ret = &ctx->ctx;
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_hash_alloc_ctx(struct crypto_hash_ctx **ctx,
+                                           uint32_t algo)
+{
+    crypto_hash_type hash_type;
+
+    if (ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    switch (algo) {
+        case TEE_ALG_SHA256:
+            hash_type = CRYPTO_HASH_TYPE_SHA256;
+            break;
+#ifndef CFG_HI3516CV610
+        case TEE_ALG_SHA384:
+            hash_type = CRYPTO_HASH_TYPE_SHA384;
+            break;
+        case TEE_ALG_SHA512:
+            hash_type = CRYPTO_HASH_TYPE_SHA512;
+            break;
+#endif
+        case TEE_ALG_SM3:
+            hash_type = CRYPTO_HASH_TYPE_SM3;
+            break;
+        default:
+            return TEE_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return cipher_hash_alloc_ctx(ctx, hash_type);
+}
+
+static TEE_Result drv_gp_cipher_hash_init(void)
+{
+    drvcrypt_register_hash(gp_cipher_hash_alloc_ctx);
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(drv_gp_cipher_hash_init);
diff --git a/bsp/gp_cipher/src/gp_cipher_hmac.c b/bsp/gp_cipher/src/gp_cipher_hmac.c
new file mode 100644
index 0000000..343c9d9
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_hmac.c
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher mac interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <assert.h>
+#include <drvcrypt_mac.h>
+#include <gp_cipher.h>
+#include <initcall.h>
+#include <stdlib.h>
+#include <tee_api_types.h>
+#include "kapi_hash.h"
+
+/******************************************************************************
+ * Message digest functions
+ ******************************************************************************/
+struct gp_cipher_hmac_ctx {
+    struct crypto_mac_ctx ctx;
+    crypto_hash_attr hmac_attr;
+    td_handle hmac_handle;
+    td_bool hmac_handle_created;
+};
+
+static const struct crypto_mac_ops gp_cipher_hmac_ops;
+
+static struct gp_cipher_hmac_ctx *to_hmac_ctx(const struct crypto_mac_ctx *ctx)
+{
+    if (ctx == NULL || ctx->ops != &gp_cipher_hmac_ops) {
+        return NULL;
+    }
+
+    return container_of(ctx, struct gp_cipher_hmac_ctx, ctx);
+}
+
+static TEE_Result gp_cipher_hmac_init(struct crypto_mac_ctx *ctx,
+                                      const uint8_t *key, size_t len)
+{
+    struct gp_cipher_hmac_ctx *hmac_ctx = NULL;
+    td_s32 ret = TD_FAILURE;
+
+    if (((hmac_ctx = to_hmac_ctx(ctx)) == NULL) || key == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    hmac_ctx->hmac_attr.key = (td_u8 *)key;
+    hmac_ctx->hmac_attr.key_len = len;
+
+    if (hmac_ctx->hmac_handle_created) {
+        ret = kapi_cipher_hash_destroy(hmac_ctx->hmac_handle);
+        cipher_chk_return((ret != TD_SUCCESS),
+                          TEE_ERROR_BAD_STATE,
+                          EMSG("kapi_cipher_hash_destroy failed\n"));
+        hmac_ctx->hmac_handle_created = false;
+    }
+
+    ret = kapi_cipher_hash_start(&hmac_ctx->hmac_handle, &hmac_ctx->hmac_attr);
+    cipher_chk_return((ret != TD_SUCCESS),
+                      TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_hash_start failed!\n"));
+    hmac_ctx->hmac_handle_created = true;
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_hmac_update(struct crypto_mac_ctx *ctx,
+                                        const uint8_t *data, size_t len)
+{
+    struct gp_cipher_hmac_ctx *hmac_ctx = NULL;
+    crypto_buf_attr src_buf = {0};
+    td_s32 ret = TD_FAILURE;
+
+    if (data == NULL || (hmac_ctx = to_hmac_ctx(ctx)) == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    src_buf.virt_addr = (td_u8 *)data;
+    ret = kapi_cipher_hash_update(hmac_ctx->hmac_handle, &src_buf, len);
+    cipher_chk_return((ret != TD_SUCCESS),
+                      TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_hash_update failed\n"));
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_hmac_final(struct crypto_mac_ctx *ctx,
+                                       uint8_t *digest, size_t len)
+{
+    struct gp_cipher_hmac_ctx *hmac_ctx = NULL;
+    td_u32 result_len = len;
+    td_s32 ret = TD_FAILURE;
+
+    if (digest == NULL || ((hmac_ctx = to_hmac_ctx(ctx)) == NULL)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    ret = kapi_cipher_hash_finish(hmac_ctx->hmac_handle, digest, &result_len);
+    cipher_chk_return((ret != TD_SUCCESS),
+                      TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_mac_finish failed\n"));
+    hmac_ctx->hmac_handle_created = false;
+
+    return TEE_SUCCESS;
+}
+
+static void gp_cipher_hmac_free_ctx(struct crypto_mac_ctx *ctx)
+{
+    if (to_hmac_ctx(ctx) == NULL) {
+        return;
+    }
+
+    (void)free(to_hmac_ctx(ctx));
+    (void)kapi_cipher_hash_deinit();
+}
+
+static void gp_cipher_hmac_copy_state(struct crypto_mac_ctx *dst_ctx,
+                                      struct crypto_mac_ctx *src_ctx)
+{
+    struct gp_cipher_hmac_ctx *src = NULL;
+    struct gp_cipher_hmac_ctx *dst = NULL;
+    crypto_hash_clone_ctx clone_ctx = {0};
+
+    if ((src = to_hmac_ctx(src_ctx)) == NULL ||
+        (dst = to_hmac_ctx(dst_ctx)) == NULL) {
+        return;
+    }
+
+    (void)memcpy_s(dst,
+                   sizeof(struct gp_cipher_hmac_ctx),
+                   src,
+                   sizeof(struct gp_cipher_hmac_ctx));
+
+    (void)kapi_cipher_hash_start(&dst->hmac_handle, &dst->hmac_attr);
+    (void)kapi_cipher_hash_get(src->hmac_handle, &clone_ctx);
+    (void)kapi_cipher_hash_set(dst->hmac_handle, &clone_ctx);
+}
+
+static const struct crypto_mac_ops gp_cipher_hmac_ops = {
+    .init = gp_cipher_hmac_init,
+    .update = gp_cipher_hmac_update,
+    .final = gp_cipher_hmac_final,
+    .free_ctx = gp_cipher_hmac_free_ctx,
+    .copy_state = gp_cipher_hmac_copy_state,
+};
+
+static TEE_Result cipher_hmac_alloc_ctx(struct crypto_mac_ctx **ctx_ret,
+                                        crypto_hash_type hmac_type)
+{
+    struct gp_cipher_hmac_ctx *ctx = NULL;
+
+    ctx = calloc(1, sizeof(*ctx));
+    if (!ctx) {
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    ctx->ctx.ops = &gp_cipher_hmac_ops;
+    ctx->hmac_attr.hash_type = hmac_type;
+    ctx->hmac_attr.is_long_term = TD_FALSE;
+    ctx->hmac_handle_created = false;
+
+    if (kapi_cipher_hash_init() != TD_SUCCESS) {
+        free(ctx);
+        EMSG("kapi_cipher_hash_init failed!\n");
+        return TEE_ERROR_BAD_STATE;
+    }
+
+    *ctx_ret = &ctx->ctx;
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_hmac_alloc_ctx(struct crypto_mac_ctx **ctx,
+                                           uint32_t algo)
+{
+    crypto_hash_type hash_type;
+
+    if (ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    switch (algo) {
+        case TEE_ALG_HMAC_SHA256:
+            hash_type = CRYPTO_HASH_TYPE_HMAC_SHA256;
+            break;
+#ifndef CFG_HI3516CV610
+        case TEE_ALG_HMAC_SHA384:
+            hash_type = CRYPTO_HASH_TYPE_HMAC_SHA384;
+            break;
+        case TEE_ALG_HMAC_SHA512:
+            hash_type = CRYPTO_HASH_TYPE_HMAC_SHA512;
+            break;
+#endif
+        case TEE_ALG_HMAC_SM3:
+            hash_type = CRYPTO_HASH_TYPE_HMAC_SM3;
+            break;
+        default:
+            return TEE_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return cipher_hmac_alloc_ctx(ctx, hash_type);
+}
+
+static TEE_Result drv_gp_cipher_hmac_init(void)
+{
+    drvcrypt_register_hmac(gp_cipher_hmac_alloc_ctx);
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(drv_gp_cipher_hmac_init);
diff --git a/bsp/gp_cipher/src/gp_cipher_spacc.c b/bsp/gp_cipher/src/gp_cipher_spacc.c
new file mode 100644
index 0000000..f519f25
--- /dev/null
+++ b/bsp/gp_cipher/src/gp_cipher_spacc.c
@@ -0,0 +1,313 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the gp cipher hash interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <drvcrypt.h>
+#include <drvcrypt_cipher.h>
+#include <gp_cipher.h>
+#include <initcall.h>
+#include <securec.h>
+#include <tee_api_types.h>
+#include "kapi_symc.h"
+#include "mmz_ext.h"
+
+/******************************************************************************
+ * Message digest functions
+ ******************************************************************************/
+
+struct gp_cipher_spacc_ctx {
+    struct drvcrypt_buf key1;
+    struct drvcrypt_buf key2;
+    crypto_symc_attr spacc_attr;
+    crypto_symc_ctrl_t spacc_ctrl;
+    td_handle spacc_handle;
+    td_handle keyslot_handle;
+    td_bool keyslot_created;
+    td_s32 (*crypt_func)(td_handle, const crypto_buf_attr *,
+                         const crypto_buf_attr *, td_u32);
+};
+
+static struct drvcrypt_cipher gp_cipher_spacc_ops;
+
+static TEE_Result spacc_prepare_work_before_cal(
+    struct gp_cipher_spacc_ctx *spacc_ctx)
+{
+    td_s32 ret = TD_FAILURE;
+
+    /* 2. cipher create handle */
+    ret = kapi_cipher_symc_create(&spacc_ctx->spacc_handle,
+                                  &spacc_ctx->spacc_attr);
+    cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                      EMSG("kapi_cipher_symc_create failed\n"));
+
+    /* 3. create keyslot handle */
+    if (!spacc_ctx->keyslot_created) {
+        ret = kapi_keyslot_create(&spacc_ctx->keyslot_handle,
+                                  KM_KEYSLOT_TYPE_MCIPHER);
+        cipher_chk_goto((ret != TD_SUCCESS), CIPHER_DESTROY,
+                        EMSG("kapi_keyslot_create failed\n"));
+        spacc_ctx->keyslot_created = true;
+    }
+
+    /* 4. attach cipher handle & kslot handle */
+    ret = kapi_cipher_symc_attach(spacc_ctx->spacc_handle,
+                                  (td_handle)spacc_ctx->keyslot_handle);
+    cipher_chk_goto((ret != TD_SUCCESS), KEYSLOT_DESTROY,
+                    EMSG("kapi_cipher_symc_attach failed\n"));
+
+    /* 5. set clear key */
+    ret = cipher_set_clear_key(spacc_ctx->spacc_ctrl.symc_alg,
+                               spacc_ctx->keyslot_handle, spacc_ctx->key1.data,
+                               spacc_ctx->key1.length);
+    cipher_chk_goto((ret != TD_SUCCESS), KEYSLOT_DESTROY,
+                    EMSG("cipher_set_clear_key failed\n"));
+
+    /* 6. set config */
+    ret = kapi_cipher_symc_set_config(spacc_ctx->spacc_handle,
+                                      &(spacc_ctx->spacc_ctrl));
+    cipher_chk_goto(ret != TD_SUCCESS, KEYSLOT_DESTROY,
+                    EMSG("kapi_cipher_symc_set_config failed!\n"));
+
+    return TEE_SUCCESS;
+
+KEYSLOT_DESTROY:
+    (void)kapi_keyslot_destroy(spacc_ctx->keyslot_handle);
+CIPHER_DESTROY:
+    (void)kapi_cipher_symc_destroy(spacc_ctx->spacc_handle);
+    return TEE_ERROR_BAD_STATE;
+}
+
+static TEE_Result gp_cipher_spacc_init(struct drvcrypt_cipher_init *dinit)
+{
+    struct gp_cipher_spacc_ctx *spacc_ctx = NULL;
+    td_s32 ret = TD_FAILURE;
+
+    if (dinit == NULL || dinit->ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    spacc_ctx = dinit->ctx;
+    spacc_ctx->key1 = dinit->key1;
+    spacc_ctx->key2 = dinit->key2;
+    spacc_ctx->crypt_func =
+        dinit->encrypt ? kapi_cipher_symc_encrypt : kapi_cipher_symc_decrypt;
+    spacc_ctx->spacc_attr.symc_type = CRYPTO_SYMC_TYPE_NORMAL;
+    spacc_ctx->spacc_attr.is_long_term = TD_FALSE;
+    spacc_ctx->spacc_ctrl.iv_length = dinit->iv.length;
+
+    if (spacc_ctx->spacc_ctrl.symc_alg == CRYPTO_SYMC_ALG_SM4) {
+        spacc_ctx->spacc_ctrl.symc_key_length = CRYPTO_SYMC_KEY_128BIT;
+    } else {
+        switch (dinit->key1.length) {
+            case KEY_128BIT_LEN:
+                spacc_ctx->spacc_ctrl.symc_key_length = CRYPTO_SYMC_KEY_128BIT;
+                break;
+            case KEY_256BIT_LEN:
+                spacc_ctx->spacc_ctrl.symc_key_length = CRYPTO_SYMC_KEY_256BIT;
+                break;
+#ifdef CFG_HI3516CV610
+            case KEY_192BIT_LEN:
+                spacc_ctx->spacc_ctrl.symc_key_length = CRYPTO_SYMC_KEY_192BIT;
+                break;
+#endif
+            default:
+                EMSG("key length dismatch!\n");
+                return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    ret = memcpy_s(spacc_ctx->spacc_ctrl.iv, CRYPTO_IV_LEN_IN_BYTES,
+                   dinit->iv.data, dinit->iv.length);
+    cipher_chk_return((ret != EOK), TEE_ERROR_BAD_STATE,
+                      EMSG("memcpy_s failed!\n"));
+
+    if (spacc_ctx->keyslot_created) {
+        ret = kapi_keyslot_destroy(spacc_ctx->keyslot_handle);
+        cipher_chk_return((ret != TD_SUCCESS), TEE_ERROR_BAD_STATE,
+                          EMSG("kapi_keyslot_destroy failed\n"));
+        spacc_ctx->keyslot_created = false;
+    }
+
+    /* next operation */
+    ret = spacc_prepare_work_before_cal(spacc_ctx);
+    cipher_chk_return((ret != TEE_SUCCESS), TEE_ERROR_BAD_STATE,
+                      EMSG("spacc_prepare_work_before_cal failed!\n"));
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_spacc_update(struct drvcrypt_cipher_update *dupdate)
+{
+    struct gp_cipher_spacc_ctx *spacc_ctx = NULL;
+    uint32_t length;
+    crypto_buf_attr src_buf;
+    crypto_buf_attr dst_buf;
+    void *src_virt_addr;
+    void *dst_virt_addr;
+    td_s32 ret = TD_FAILURE;
+
+    if (dupdate == NULL || dupdate->ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+    spacc_ctx = dupdate->ctx;
+    length = dupdate->src.length;
+
+    ret = cipher_alloc_and_map(&src_buf, &src_virt_addr, length);
+    cipher_chk_return(ret != TD_SUCCESS, TEE_ERROR_BAD_STATE,
+                      EMSG("cipher_alloc_and_map failed!\n"));
+
+    ret = cipher_alloc_and_map(&dst_buf, &dst_virt_addr, length);
+    cipher_chk_goto(ret != TD_SUCCESS, MMZ_UNMAP_AND_FREE2,
+                    EMSG("cipher_alloc_and_map failed!\n"));
+
+    ret = memcpy_s(src_virt_addr, length, dupdate->src.data, length);
+    cipher_chk_goto(ret != EOK, MMZ_UNMAP_AND_FREE1,
+                    EMSG("memcpy_s failed!\n"));
+
+    ret = spacc_ctx->crypt_func(spacc_ctx->spacc_handle, &src_buf, &dst_buf,
+                                length);
+    cipher_chk_goto((ret != TD_SUCCESS), MMZ_UNMAP_AND_FREE1,
+                    EMSG("kapi_cipher_symc_encrypt or decrypt failed!\n"));
+
+    ret = kapi_cipher_symc_get_config(spacc_ctx->spacc_handle,
+                                      &(spacc_ctx->spacc_ctrl));
+    cipher_chk_goto((ret != TD_SUCCESS), MMZ_UNMAP_AND_FREE1,
+                    EMSG("kapi_cipher_symc_get_config failed!\n"));
+
+    ret = memcpy_s(dupdate->dst.data, length, dst_virt_addr, length);
+    cipher_chk_goto(ret != EOK, MMZ_UNMAP_AND_FREE1,
+                    EMSG("memcpy_s failed!\n"));
+
+MMZ_UNMAP_AND_FREE1:
+    (void)cipher_unmap_and_free(&dst_buf, dst_virt_addr, length);
+MMZ_UNMAP_AND_FREE2:
+    (void)cipher_unmap_and_free(&src_buf, src_virt_addr, length);
+
+    return ret != TD_SUCCESS ? TEE_ERROR_BAD_STATE : TEE_SUCCESS;
+}
+
+static void gp_cipher_spacc_final(void *ctx)
+{
+    (void)ctx;
+}
+
+static void gp_cipher_spacc_free_ctx(void *ctx)
+{
+    struct gp_cipher_spacc_ctx *spacc_ctx;
+
+    if (ctx == NULL) {
+        return;
+    }
+
+    spacc_ctx = ctx;
+    (void)kapi_keyslot_destroy(spacc_ctx->keyslot_handle);
+    (void)kapi_cipher_symc_destroy(spacc_ctx->spacc_handle);
+    (void)free(ctx);
+
+    (void)kapi_cipher_symc_deinit();
+}
+
+static void gp_cipher_spacc_copy_state(void *dst_ctx, void *src_ctx)
+{
+    struct gp_cipher_spacc_ctx *src;
+    struct gp_cipher_spacc_ctx *dst;
+    td_bool status;
+
+    if (dst_ctx == NULL || src_ctx == NULL) {
+        return;
+    }
+
+    src = src_ctx;
+    dst = dst_ctx;
+    status = dst->keyslot_created;
+    /* The reason why this place use set_config function is copy_state may be
+     * use after update function, so we need to update the status of
+     * spacc_handle to origin status, and then copy to dst->spacc_handle
+     */
+    (void)kapi_cipher_symc_set_config(src->spacc_handle, &src->spacc_ctrl);
+    (void)memcpy_s(dst, sizeof(struct gp_cipher_spacc_ctx), src,
+                   sizeof(struct gp_cipher_spacc_ctx));
+
+    dst->keyslot_created = status;
+    (void)spacc_prepare_work_before_cal(dst);
+}
+
+static TEE_Result cipher_spacc_alloc_ctx(void **ctx_ret,
+                                         crypto_symc_ctrl_t symc_ctrl)
+{
+    struct gp_cipher_spacc_ctx *ctx = NULL;
+
+    ctx = calloc(1, sizeof(*ctx));
+    if (!ctx) {
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    ctx->keyslot_created = false;
+    ctx->spacc_ctrl = symc_ctrl;
+
+    /* 1. cipher init */
+    if (kapi_cipher_symc_init() != TD_SUCCESS) {
+        free(ctx);
+        EMSG("kapi_cipher_symc_init failed!\n");
+        return TEE_ERROR_BAD_STATE;
+    }
+
+    *ctx_ret = ctx;
+    return TEE_SUCCESS;
+}
+
+static TEE_Result gp_cipher_spacc_alloc_ctx(void **ctx, uint32_t algo)
+{
+    crypto_symc_ctrl_t symc_ctrl;
+    TEE_Result res = TEE_SUCCESS;
+
+    if (ctx == NULL) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    symc_ctrl.symc_bit_width = CRYPTO_SYMC_BIT_WIDTH_128BIT;
+
+    switch (algo) {
+        case TEE_ALG_AES_CBC_NOPAD:
+        case TEE_ALG_AES_CTR:
+            symc_ctrl.symc_alg = CRYPTO_SYMC_ALG_AES;
+            symc_ctrl.work_mode = algo == TEE_ALG_AES_CBC_NOPAD
+                                      ? CRYPTO_SYMC_WORK_MODE_CBC
+                                      : CRYPTO_SYMC_WORK_MODE_CTR;
+            break;
+        case TEE_ALG_SM4_CBC_NOPAD:
+        case TEE_ALG_SM4_CTR:
+            symc_ctrl.symc_alg = CRYPTO_SYMC_ALG_SM4;
+            symc_ctrl.work_mode = algo == TEE_ALG_SM4_CBC_NOPAD
+                                      ? CRYPTO_SYMC_WORK_MODE_CBC
+                                      : CRYPTO_SYMC_WORK_MODE_CTR;
+            break;
+        default:
+            return TEE_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return cipher_spacc_alloc_ctx(ctx, symc_ctrl);
+}
+
+static struct drvcrypt_cipher gp_cipher_spacc_ops = {
+    .alloc_ctx = gp_cipher_spacc_alloc_ctx,
+    .init = gp_cipher_spacc_init,
+    .update = gp_cipher_spacc_update,
+    .final = gp_cipher_spacc_final,
+    .free_ctx = gp_cipher_spacc_free_ctx,
+    .copy_state = gp_cipher_spacc_copy_state,
+};
+
+static TEE_Result drv_gp_cipher_spacc_init(void)
+{
+    drvcrypt_register_cipher(&gp_cipher_spacc_ops);
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(drv_gp_cipher_spacc_init);
diff --git a/bsp/gp_cipher/sub.mk b/bsp/gp_cipher/sub.mk
new file mode 100644
index 0000000..186d6b2
--- /dev/null
+++ b/bsp/gp_cipher/sub.mk
@@ -0,0 +1,28 @@
+GP_CIPHER_INC := bsp/gp_cipher/include
+DRV_INC := bsp/security_subsys/security_subsys_common
+LIB_INC := bsp/security_subsys/lib/../security_subsys_common/include
+OSAL_INC := bsp/security_subsys/drivers/crypto_osal
+GP_CIPHER_OBJS += src/gp_cipher_hash.c
+GP_CIPHER_OBJS += src/gp_cipher_spacc.c
+GP_CIPHER_OBJS += src/gp_cipher_cmac.c
+GP_CIPHER_OBJS += src/gp_cipher_hmac.c
+GP_CIPHER_OBJS += src/gp_cipher_authenc.c
+GP_CIPHER_OBJS += src/gp_cipher_asymc_rsa.c
+GP_CIPHER_OBJS += src/gp_cipher_asymc_ecc.c
+GP_CIPHER_OBJS += src/gp_cipher_asymc_dh.c
+GP_CIPHER_OBJS += src/gp_cipher_common.c
+
+GP_CIPHER_CFLAGS += -I$(DRV_INC)/..
+GP_CIPHER_CFLAGS += -I$(DRV_INC)/common
+GP_CIPHER_CFLAGS += -I$(LIB_INC)/common_include
+GP_CIPHER_CFLAGS += -I$(LIB_INC)/kapi_include
+GP_CIPHER_CFLAGS += -I$(LIB_INC)/drv_include
+GP_CIPHER_CFLAGS += -I$(LIB_INC)/hal_include
+GP_CIPHER_CFLAGS += -I$(OSAL_INC)
+GP_CIPHER_CFLAGS += -I$(LIB_INC)/../drv_code
+GP_CIPHER_CFLAGS += -I$(LIB_INC)/../kapi_code
+GP_CIPHER_CFLAGS += -I$(GP_CIPHER_INC)
+GP_CIPHER_CFLAGS += -Icore/lib/libtomcrypt/src/headers
+
+cflags-$(CFG_GP_CIPHER) += $(GP_CIPHER_CFLAGS)
+srcs-$(CFG_GP_CIPHER) += $(GP_CIPHER_OBJS)
diff --git a/bsp/mmz/README.md b/bsp/mmz/README.md
new file mode 100644
index 0000000..90a3b2a
--- /dev/null
+++ b/bsp/mmz/README.md
@@ -0,0 +1,2 @@
+# optee_smmz
+
diff --git a/bsp/mmz/drivers/include/mmz_ext.h b/bsp/mmz/drivers/include/mmz_ext.h
new file mode 100644
index 0000000..bc2c50a
--- /dev/null
+++ b/bsp/mmz/drivers/include/mmz_ext.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related driver interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef MMZ_EXT_H
+#define MMZ_EXT_H
+
+#include "ot_type.h"
+
+/*
+ * brief            Alloc SMMZ2 memory.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * mmb              The name of mmb, less than 16 characters.
+ * zone             The name of zone, less than 16 characters.
+ * len              Length of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 drv_mmz_alloc(td_phys_addr_t *phys_addr, const td_char *mmb_name, const td_char *zone_name, td_size_t size);
+
+/*
+ * brief            Free SMMZ2 memory.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 drv_mmz_free(td_phys_addr_t phys_addr);
+
+/*
+ * brief            Map phys_addr to kvirt without cache.
+ *
+ * Note:            The size must be corresponding to the physical address.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           Virt_addr != NULL if successful
+ */
+td_void *drv_mmz_map_nocache(td_phys_addr_t phys_addr, td_size_t size);
+
+/*
+ * brief            Map phys_addr to kvirt with cache.
+ *
+ * Note:            The size must be corresponding to the physical address.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           Virt_addr != NULL if successful
+ */
+td_void *drv_mmz_map_cached(td_phys_addr_t phys_addr, td_size_t size);
+
+/*
+ * brief            Unmap the kvirt.
+ *
+ * Note:            The size must be corresponding to the virtual address.
+ *
+ * virt_addr        The virtual address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 drv_mmz_unmap(td_void *virt_addr, td_size_t size);
+
+/*
+ * brief            Clean and invalidate cache.
+ *
+ * Note:            The size must be corresponding to the virtual address.
+ *
+ * virt_addr        The virtual address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 drv_mmz_flush_cache(td_void *virt_addr, td_size_t size);
+
+/*
+ * brief            Invalidate cache.
+ *
+ * Note:            The size must be corresponding to the virtual address.
+ *
+ * virt_addr        The virtual address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 drv_mmz_invalid_cache(td_void *virt_addr, td_size_t size);
+
+/*
+ * brief            Check whether ta has access to this physical address.
+ *
+ * Note:            The size must be corresponding to the physical address.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 drv_mmz_check_phys_and_ta(td_phys_addr_t phys_addr, td_size_t size);
+
+/*
+ * brief            Add the user_cnt.
+ *
+ * Note:            The size must be corresponding to the physical address.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 drv_mmz_get(td_phys_addr_t phys_addr, td_size_t size);
+
+/*
+ * brief            Subtract the user_cnt.
+ *
+ * Note:            The size must be corresponding to the physical address.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 drv_mmz_put(td_phys_addr_t phys_addr, td_size_t size);
+
+#endif
diff --git a/bsp/mmz/drivers/src/include/drv_mmz_debug.h b/bsp/mmz/drivers/src/include/drv_mmz_debug.h
new file mode 100644
index 0000000..dea38c3
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/drv_mmz_debug.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the debug method
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef DRV_MMZ_DEBUG_H
+#define DRV_MMZ_DEBUG_H
+
+#include "osal_debug.h"
+
+#define MMZ_LEVEL_ERROR      0
+#define MMZ_LEVEL_WARN       1
+#define MMZ_LEVEL_INFO       2
+#define MMZ_LEVEL_DBG        3
+#define LOG_DEFAULT          MMZ_LEVEL_ERROR
+
+#define mmz_trace(level, s, params...) do { \
+    if ((level <= LOG_DEFAULT) != 0)        \
+        osal_printk("[%s]: " s "\n",       \
+        __FUNCTION__, params);    \
+} while (0)
+
+#define smmz_trace(level, lab, pline, fmt, ...)                                                 \
+    do {                                                                                        \
+        if (level <= LOG_DEFAULT) {                                                             \
+            if (pline) {                                                                        \
+                osal_printk(lab "[%s] " fmt, __FUNCTION__, ##__VA_ARGS__);            \
+            } else {                                                                            \
+                osal_printk("%s " fmt, __FUNCTION__, ##__VA_ARGS__);                               \
+            }                                                                                   \
+        }                                                                                       \
+    } while (0)
+
+#define SZ_1K 1024
+#define MMZ_MEM_INFO "nBYTES=%ldKB,   NAME=\"%s\""
+#define mmz_mem_info_input(p) (p)->size / SZ_1K, (p)->name
+
+#define MMB_MEM_INFO "map_kernel_cnt=%d, user_cnt=%d, flags=0x%08lX, size=%luKB, name =\"%s\""
+#define mmb_mem_info_input(p) refcount_val(&p->map_kernel_cnt), refcount_val(&p->user_cnt), (p)->flags, \
+                (p)->size / SZ_1K, (p)->name
+
+#define log_error(fmt, ...)     smmz_trace(MMZ_LEVEL_ERROR, "ERROR ", TD_TRUE, fmt, ##__VA_ARGS__)
+
+#if (LOG_DEFAULT >= MMZ_LEVEL_WARN)
+#define log_warn(fmt, ...)      smmz_trace(MMZ_LEVEL_WARN, "WARN ", TD_TRUE, fmt, ##__VA_ARGS__)
+#else
+#define log_warn(fmt, ...)
+#endif
+
+#if (LOG_DEFAULT >= MMZ_LEVEL_INFO)
+#define log_info(fmt, ...)      smmz_trace(MMZ_LEVEL_INFO, "INFO ", TD_TRUE, fmt, ##__VA_ARGS__)
+#define func_enter()            smmz_trace(MMZ_LEVEL_INFO, "", TD_FALSE, "function enter --->\n")
+#define func_exit()             smmz_trace(MMZ_LEVEL_INFO, "", TD_FALSE, "function exit ... ...\n\n")
+#else
+#define log_info(fmt, ...)
+#define func_enter()
+#define func_exit()
+#endif
+
+#if (LOG_DEFAULT >= MMZ_LEVEL_DBG)
+#define log_dbg(fmt, ...)       smmz_trace(MMZ_LEVEL_DBG, "DBG ", TD_TRUE, fmt, ##__VA_ARGS__)
+#else
+#define log_dbg(fmt, ...)
+#endif
+
+/* Function trace log, strictly prohibited to expand */
+#define print_func_errno(func, errno)       log_error("Call %s return [0x%08X]\n", #func, (unsigned int)(errno))
+#define print_errno(errno)                  log_error("Error Code: [0x%08X]\n", (unsigned int)(errno))
+
+#endif /* DRV_MMZ_DEBUG_H */
diff --git a/bsp/mmz/drivers/src/include/drv_mmz_ioctl.h b/bsp/mmz/drivers/src/include/drv_mmz_ioctl.h
new file mode 100644
index 0000000..ce314f2
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/drv_mmz_ioctl.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related mmz ioctl
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef DRV_MMZ_IOCTL_H
+#define DRV_MMZ_IOCTL_H
+
+#include "ot_type.h"
+#include "mpi_mmz.h"
+
+typedef void* td_virt_addr_t;
+
+/* struct of Symmetric mmz alloc */
+typedef struct {
+    td_phys_addr_t phys_addr;
+    td_virt_addr_t virt_addr;
+    const td_char *mmb_name;
+    const td_char *zone_name;
+    td_size_t size;
+} mmz_alloc_t;
+
+/* struct of Symmetric mmz free */
+typedef struct {
+    td_phys_addr_t phys_addr;
+    td_virt_addr_t virt_addr;
+} mmz_free_t;
+
+/* struct of Symmetric mmz mmap */
+typedef struct {
+    td_phys_addr_t phys_addr;
+    td_virt_addr_t virt_addr;
+    td_size_t size;
+} mmz_mmap_t;
+
+/* struct of Symmetric mmz mummap */
+typedef struct {
+    td_virt_addr_t virt_addr;
+    td_size_t size;
+} mmz_munmap_t;
+
+/* struct of Symmetric mmz mummap */
+typedef struct {
+    td_phys_addr_t phys_addr;
+    td_virt_addr_t virt_addr;
+    td_size_t size;
+} mmz_flush_cache_t;
+
+/* struct of Symmetric mmz mummap */
+typedef struct {
+    td_virt_addr_t virt_addr;
+    mem_info *m_info;
+} mmz_get_info_t;
+
+typedef enum {
+    MMZ_IOC_NR_MMZ_ALLOC,
+    MMZ_IOC_NR_MMZ_ALLOC_CACHED,
+    MMZ_IOC_NR_MMZ_FREE,
+    MMZ_IOC_NR_MMZ_MMAP,
+    MMZ_IOC_NR_MMZ_MMAP_CACHED,
+    MMZ_IOC_NR_MMZ_MUNMAP,
+    MMZ_IOC_NR_MMZ_FLUSH_CACHE,
+    MMZ_IOC_NR_MMZ_GET_INFO,
+    MMZ_IOC_NR_BUTT,
+} mmz_ioc_nr;
+
+td_u32 mmz_ioctl(td_u32 cmd, td_void *argp);
+
+#define MMZ_IOC_NRBITS 8
+#define MMZ_IOC_TYPEBITS   8
+
+#ifndef MMZ_IOC_SIZEBITS
+# define MMZ_IOC_SIZEBITS  14
+#endif
+
+#ifndef MMZ_IOC_DIRBITS
+# define MMZ_IOC_DIRBITS   2
+#endif
+
+#define MMZ_IOC_NRMASK     ((1 << MMZ_IOC_NRBITS)-1)
+#define MMZ_IOC_TYPEMASK   ((1 << MMZ_IOC_TYPEBITS)-1)
+#define MMZ_IOC_SIZEMASK   ((1 << MMZ_IOC_SIZEBITS)-1)
+#define MMZ_IOC_DIRMASK    ((1 << MMZ_IOC_DIRBITS)-1)
+
+#define MMZ_IOC_NRSHIFT    0
+#define MMZ_IOC_TYPESHIFT  (MMZ_IOC_NRSHIFT+MMZ_IOC_NRBITS)
+#define MMZ_IOC_SIZESHIFT  (MMZ_IOC_TYPESHIFT+MMZ_IOC_TYPEBITS)
+#define MMZ_IOC_DIRSHIFT   (MMZ_IOC_SIZESHIFT+MMZ_IOC_SIZEBITS)
+
+#ifndef MMZ_IOC_NONE
+# define MMZ_IOC_NONE  0U
+#endif
+
+#ifndef MMZ_IOC_WRITE
+# define MMZ_IOC_WRITE 1U
+#endif
+
+#ifndef MMZ_IOC_READ
+# define MMZ_IOC_READ  2U
+#endif
+
+#define MMZ_IOC(dir, type, nr, size) \
+    (((dir)  << MMZ_IOC_DIRSHIFT)  | \
+     ((type) << MMZ_IOC_TYPESHIFT) | \
+     ((nr)   << MMZ_IOC_NRSHIFT)   | \
+     ((size) << MMZ_IOC_SIZESHIFT))
+
+#ifdef __KERNEL__
+/* provoke compile error for invalid uses of size argument */
+extern unsigned int invalid_size_argument_for_IOC;
+#define MMZ_IOC_TYPECHECK(t) \
+    ((sizeof(t) == sizeof(t[1]) && \
+      sizeof(t) < (1 << MMZ_IOC_SIZEBITS)) ? \
+      sizeof(t) : invalid_size_argument_for_IOC)
+#else
+#define MMZ_IOC_TYPECHECK(t) (sizeof(t))
+#endif
+
+/* used to create numbers */
+#define MMZ_IO(type, nr)         MMZ_IOC(MMZ_IOC_NONE, (type), (nr), 0)
+#define MMZ_IOR(type, nr, size)  MMZ_IOC(MMZ_IOC_READ, (type), (nr), (MMZ_IOC_TYPECHECK(size)))
+#define MMZ_IOW(type, nr, size)  MMZ_IOC(MMZ_IOC_WRITE, (type), (nr), (MMZ_IOC_TYPECHECK(size)))
+#define MMZ_IOWR(type, nr, size) MMZ_IOC(MMZ_IOC_READ|MMZ_IOC_WRITE, (type), (nr), (MMZ_IOC_TYPECHECK(size)))
+#define MMZ_IOR_BAD(type, nr, size)  MMZ_IOC(MMZ_IOC_READ, (type), (nr), sizeof(size))
+#define MMZ_IOW_BAD(type, nr, size)  MMZ_IOC(MMZ_IOC_WRITE, (type), (nr), sizeof(size))
+#define MMZ_IOWR_BAD(type, nr, size) MMZ_IOC(MMZ_IOC_READ|MMZ_IOC_WRITE, (type), (nr), sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define MMZ_IOC_DIR(nr)        (((nr) >> MMZ_IOC_DIRSHIFT) & MMZ_IOC_DIRMASK)
+#define MMZ_IOC_TYPE(nr)       (((nr) >> MMZ_IOC_TYPESHIFT) & MMZ_IOC_TYPEMASK)
+#define MMZ_IOC_NR(nr)         (((nr) >> MMZ_IOC_NRSHIFT) & MMZ_IOC_NRMASK)
+#define MMZ_IOC_SIZE(nr)       (((nr) >> MMZ_IOC_SIZESHIFT) & MMZ_IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+#define MMZ_IOC_IN          (MMZ_IOC_WRITE << MMZ_IOC_DIRSHIFT)
+#define MMZ_IOC_OUT         (MMZ_IOC_READ << MMZ_IOC_DIRSHIFT)
+#define MMZ_IOC_INOUT       ((MMZ_IOC_WRITE|MMZ_IOC_READ) << MMZ_IOC_DIRSHIFT)
+#define MMZ_IOCSIZE_MASK    (MMZ_IOC_SIZEMASK << MMZ_IOC_SIZESHIFT)
+#define MMZ_IOCSIZE_SHIFT   (MMZ_IOC_SIZESHIFT)
+
+#ifndef IOC_TYPE_MMZ
+#define IOC_TYPE_MMZ       'o'
+#endif
+
+/* Ioctl definitions */
+#define CMD_MMZ_ALLOC          MMZ_IOWR(IOC_TYPE_MMZ, MMZ_IOC_NR_MMZ_ALLOC, mmz_alloc_t)
+#define CMD_MMZ_ALLOC_CACHED   MMZ_IOWR(IOC_TYPE_MMZ, MMZ_IOC_NR_MMZ_ALLOC_CACHED, mmz_alloc_t)
+#define CMD_MMZ_FREE           MMZ_IOWR(IOC_TYPE_MMZ, MMZ_IOC_NR_MMZ_FREE, mmz_free_t)
+#define CMD_MMZ_MMAP           MMZ_IOWR(IOC_TYPE_MMZ, MMZ_IOC_NR_MMZ_MMAP, mmz_mmap_t)
+#define CMD_MMZ_MMAP_CACHED    MMZ_IOWR(IOC_TYPE_MMZ, MMZ_IOC_NR_MMZ_MMAP_CACHED, mmz_mmap_t)
+#define CMD_MMZ_MUNMAP         MMZ_IOWR(IOC_TYPE_MMZ, MMZ_IOC_NR_MMZ_MUNMAP, mmz_munmap_t)
+#define CMD_MMZ_FLUSH_CACHE    MMZ_IOWR(IOC_TYPE_MMZ, MMZ_IOC_NR_MMZ_FLUSH_CACHE, mmz_flush_cache_t)
+#define CMD_MMZ_GET_INFO       MMZ_IOWR(IOC_TYPE_MMZ, MMZ_IOC_NR_MMZ_GET_INFO, mmz_get_info_t)
+#define CMD_MMZ_COUNT          MMZ_IOC_NR_BUTT
+
+#endif /* DRV_MMZ_IOCTL_H */
diff --git a/bsp/mmz/drivers/src/include/list_ext.h b/bsp/mmz/drivers/src/include/list_ext.h
new file mode 100644
index 0000000..5d706dd
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/list_ext.h
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related mmz list
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef LIST_EXT_H__
+#define LIST_EXT_H__
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+/* This defination is from stddef.h, and as a base of typeof */
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((unsigned long)&((TYPE *)0)->MEMBER)
+#endif
+
+#ifndef container_of
+/* *
+ * container_of - cast a member of a structure out to the containing structure
+ *
+ * @ptr:        the pointer to the member.
+ * @type:       the type of the container struct this is embedded in.
+ * @member:     the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({                    \
+        const typeof(((type *)0)->member)*__mptr = (ptr);    \
+        (type *)((char *)__mptr - offsetof(type, member)); })
+#endif
+
+struct list_head {
+    struct list_head *next, *prev;
+};
+
+/* *
+ * Initialize  an empty list.
+ *
+ * @param The list to initialized.
+ */
+#define LIST_HEAD_INIT(name) {                        \
+        &(name), &(name)     \
+    }
+#define MMZ_LIST_HEAD(name) \
+    struct list_head name = LIST_HEAD_INIT(name)
+
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+    list->next = list;
+    list->prev = list;
+}
+
+/*
+ * Insert a new element to the list
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+#ifndef CONFIG_DEBUG_LIST
+static inline void _list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
+{
+    next->prev = new;
+    new->next = next;
+    new->prev = prev;
+    prev->next = new;
+}
+#else
+extern void _list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
+#endif
+
+/* *
+ * list_add - add a new entry to the list from head
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static inline void list_add(struct list_head *new, struct list_head *head)
+{
+    _list_add(new, head, head->next);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void _list_del(struct list_head *prev, struct list_head *next)
+{
+    next->prev = prev;
+    prev->next = next;
+}
+
+/* *
+ * list_del - deletes entry from the list.
+ * @entry: the element to delete from the list.
+ */
+#ifndef CONFIG_DEBUG_LIST
+static inline void _list_del_entry(struct list_head *entry)
+{
+    _list_del(entry->prev, entry->next);
+}
+
+static inline void list_del(struct list_head *entry)
+{
+    _list_del(entry->prev, entry->next);
+}
+#else
+extern void _list_del_entry(struct list_head *entry);
+extern void list_del(struct list_head *entry);
+#endif
+
+/* *
+ * list_del_init - clear all entry an reinitialize a list
+ * @entry: the element to delete from the list.
+ */
+static inline void list_del_init(struct list_head *entry)
+{
+    _list_del_entry(entry);
+    INIT_LIST_HEAD(entry);
+}
+
+/* *
+ * list_is_last - check the list entry whether or not the list head
+ * @list: the entry to test
+ * @head: the head of the list
+ */
+static inline int list_is_last(const struct list_head *list, const struct list_head *head)
+{
+    return list->next == head;
+}
+
+/* *
+ * list_entry - get info about this entry
+ * @ptr:    the &struct list_head pointer.
+ * @type:    the type of the struct this is embedded in.
+ * @member:    the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member)  container_of(ptr, type, member)
+
+
+/* *
+ * list_first_entry - get the first element from a list
+ * @ptr:    the list head to take the element from.
+ * @type:    the type of the struct this is embedded in.
+ * @member:    the name of the list_struct within the struct.
+ *
+ * Note, that list is expected to be not empty.
+ */
+#define list_first_entry(ptr, type, member) \
+    list_entry((ptr)->next, type, member)
+
+
+/* *
+ * list_for_each_entry    -    traverse list
+ * @pos:    element pointer  to use as a loop cursor.
+ * @head:    the head of list.
+ * @member:    the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)                \
+    for (pos = list_entry((head)->next, typeof(*pos), member);    \
+         &(pos->member) != (head);     \
+         pos = list_entry(pos->member.next, typeof(*pos), member))
+
+#endif
+
diff --git a/bsp/mmz/drivers/src/include/mmz_common.h b/bsp/mmz/drivers/src/include/mmz_common.h
new file mode 100644
index 0000000..b369eeb
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/mmz_common.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the num and struct related mmz
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef MMZ_COMMON_H
+#define MMZ_COMMON_H
+
+#include "memory_zone.h"
+#include "ot_type.h"
+
+typedef enum {
+    MMZ_TYPE_SMMZ1,
+    MMZ_TYPE_SMMZ2,
+} mmz_types;
+
+#define NO_CACHE                0
+#define CACHED                  1
+
+#define MEM_LIMIT_SIZE          0x40000000
+#define SMMZ1_BLOCK_NAME_LEN    32
+#define MEM_MAX_NAME_LEN        16
+#define UUID_LENGTH             16
+#define SMMZ1_MAX_BOLOCK_NUMS   15
+
+#ifndef EOK
+#define EOK                     (0)
+#endif
+
+#define SMMZ1_PHYS_START 0x41830000
+#define SMMZ1_SIZE 0x3800000
+#define SMMZ2_PHYS_START 0x41030000
+#define SMMZ2_SIZE 0x400000
+
+
+/*
+ * brief            destroy mmb while destroy ta.
+ *
+ * return           no return
+ */
+td_void drv_mmz_destroy_mmb(TEE_UUID* uuid);
+
+#endif /* __MMZ_COMMON_H__ */
diff --git a/bsp/mmz/drivers/src/include/mmz_intf.h b/bsp/mmz/drivers/src/include/mmz_intf.h
new file mode 100644
index 0000000..df4cdd1
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/mmz_intf.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related internal interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef MMZ_INTF_H
+#define MMZ_INTF_H
+
+#include "mmz_mem.h"
+
+tee_mmz_t *mmz_new_zone(const td_char *name, smmz_info *tmp);
+
+td_void mmz_delete_zone(tee_mmz_t *zone);
+
+td_s32 mmz_delete_mmb(td_phys_addr_t phys_addr);
+
+td_s32 mmz_new_mmb(td_phys_addr_t *phys_addr, const td_char *mmb_name,
+                   const td_char *mmz_name, td_size_t size);
+
+td_s32 mmz_alloc_and_map_mmb(td_phys_addr_t *phys_addr, td_virt_addr_t *virt_addr,
+    const td_char *mmb, const td_char *zone, td_size_t size, td_bool cache);
+
+td_void *mmz_map_phys_to_user_virt(td_phys_addr_t phys_addr, td_size_t size, td_bool cache);
+
+td_s32 mmz_unmap_user_virt(td_virt_addr_t virt_addr, td_size_t size);
+
+td_s32 mmz_unmap_and_free_mmb(td_phys_addr_t phys_addr, td_virt_addr_t virt_addr);
+
+td_void *mmz_map_phys_to_kernel_virt(td_phys_addr_t phys_addr, td_size_t size, td_bool cache);
+
+td_s32 mmz_unmap_kernel_virt(td_virt_addr_t virt_addr, td_size_t size);
+
+td_s32 mmz_flush_mmb(td_phys_addr_t phys_addr);
+
+td_s32 mmz_flush_cache(td_virt_addr_t virt_addr, td_size_t size);
+
+td_s32 mmz_invalid_cache(td_virt_addr_t virt_addr, td_size_t size);
+
+td_s32 mmz_check_phys_user(td_phys_addr_t phys_addr, td_size_t size);
+
+td_s32 mmz_check_size_kernel(td_virt_addr_t virt_addr, td_size_t size);
+
+td_s32 mmz_check_phys_kernel(td_phys_addr_t phys_addr, td_size_t size);
+
+td_s32 mmz_check_phys_and_ta(td_phys_addr_t phys_addr, td_size_t size);
+
+td_s32 mmz_check_ta(td_phys_addr_t phys_addr);
+
+td_s32 mmz_check_name_and_size(const td_char *zone_name, td_size_t size);
+
+td_s32 mmz_check_phys_virt_match(td_phys_addr_t phys_addr, td_virt_addr_t virt_addr);
+
+td_s32 mmz_get_virt_mem_info(td_virt_addr_t virt_addr, mem_info *mem_info);
+
+td_void mmz_dump(const td_char *name);
+
+td_s32 mmz_get_cnt(td_phys_addr_t phys_addr, td_size_t size);
+
+td_s32 mmz_put_cnt(td_phys_addr_t phys_addr, td_size_t size);
+#endif
diff --git a/bsp/mmz/drivers/src/include/mmz_mem.h b/bsp/mmz/drivers/src/include/mmz_mem.h
new file mode 100644
index 0000000..76026e0
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/mmz_mem.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related underlying
+ * implementation Author: AuthorNameMagicTag Create: 2019-12-11
+ */
+
+#ifndef MMZ_MEM_H
+#define MMZ_MEM_H
+
+#include <kernel/refcount.h>
+#include <mm/mobj.h>
+#include "drv_mmz_debug.h"
+#include "drv_mmz_ioctl.h"
+#include "list_ext.h"
+#include "mmz_common.h"
+#include "ot_type.h"
+#include "tee_api_types.h"
+
+#define MAX_SIZE 0x80000000
+
+struct tee_media_memory_block {
+    td_char name[MEM_MAX_NAME_LEN + 1];
+    struct tee_media_memory_zone *zone;
+    struct list_head list;
+    td_phys_addr_t phys_addr;
+    td_size_t size;
+    td_virt_addr_t kvirt;
+    td_size_t flags;
+    td_s32 mmz_type;
+    td_bool cache;
+    struct refcount map_kernel_cnt;
+    struct refcount user_cnt;
+    TEE_UUID *uuid;
+    struct mobj *mobj;
+};
+typedef struct tee_media_memory_block tee_mmb_t;
+
+struct tee_media_memory_zone {
+    td_char name[MEM_MAX_NAME_LEN];
+    td_phys_addr_t phys_start;
+    td_size_t size;
+    td_s32 die_id;
+    struct list_head list;
+    struct list_head mmb_list;
+    td_void (*destructor)(td_void *);
+};
+typedef struct tee_media_memory_zone tee_mmz_t;
+
+/********** API_1 for inf & usr *********/
+td_void smmz_inside_mutex_lock();
+td_void smmz_inside_mutex_unlock();
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+td_void smmz_shared_mutex_lock();
+td_void smmz_shared_mutex_unlock();
+#endif
+struct list_head *get_mmz_list();
+td_s32 list_add_mmb(tee_mmb_t *mmb);
+td_void *mmb_mem_get_uuid(td_void);
+td_s32 mmb_mem_free_mmb(tee_mmb_t *_mmb);
+td_void mmb_mem_init_mute(td_void);
+tee_mmz_t *mmb_mem_create_mmz(const td_char *name, td_phys_addr_t phys_start,
+                              td_size_t size);
+td_s32 mmb_mem_destroy_mmz(tee_mmz_t *mmz);
+td_s32 mmb_mem_register_mmz(tee_mmz_t *mmz);
+td_s32 mmb_mem_unregister_mmz(tee_mmz_t *mmz);
+td_void *mmb_mem_map_phys_to_user_virt(tee_mmb_t *mmb);
+td_s32 mmb_mem_unmap_user_virt(td_virt_addr_t virt_addr, td_size_t size);
+td_void *mmb_mem_map_phys_to_kernel_virt(tee_mmb_t *mmb);
+td_s32 mmb_mem_unmap_kernel_virt(tee_mmb_t *mmb);
+tee_mmb_t *mmb_mem_getby_phys(td_phys_addr_t phys_addr);
+tee_mmb_t *mmb_mem_getby_kvirt(td_virt_addr_t virt_addr);
+td_void mmb_mem_flush_cache(td_void *addr, td_length_t size);
+td_void mmb_mem_invalid_cache(td_void *addr, td_length_t size);
+td_void mmb_mem_flush_mmb(tee_mmb_t *_mmb);
+td_void mmb_mem_dump(const td_char *name);
+td_void mmb_mem_destroy_by_uuid(TEE_UUID *uuid);
+td_s32 mmb_mem_get_zone_by_phys(td_phys_addr_t phys_addr, td_size_t size);
+td_bool mmb_is_memory_overlap(const tee_mmz_t **data, int index,
+                              smmz_info *tmp);
+td_bool mmb_is_phys_overlap(const smmz_info *smmz, td_phys_addr_t phys_addr,
+                            td_size_t size);
+td_bool mmb_is_phys_in_smmz(mmz_types type, td_phys_addr_t phys_addr,
+                            td_size_t size);
+#endif
diff --git a/bsp/mmz/drivers/src/include/mmz_smmz_inside.h b/bsp/mmz/drivers/src/include/mmz_smmz_inside.h
new file mode 100644
index 0000000..d293b17
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/mmz_smmz_inside.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related underlying
+ * implementation about SMMZ_INSIDE
+ * Author: AuthorNameMagicTag Create: 2019-12-11
+ */
+
+#ifndef MMZ_SMMZ_INSIDE_H
+#define MMZ_SMMZ_INSIDE_H
+
+#include "mmz_mem.h"
+
+/********** API_1 for inf & usr *********/
+
+/*
+ * brief            Print SMMZ2 memory information.
+ *
+ * return           no return
+ */
+td_void drv_mmz_dump_smmz2(td_void);
+
+tee_mmb_t *mmb_mem_alloc_smmz2(const td_char *name, td_size_t size,
+                               const td_char *mmz_name);
+#endif  // MMZ_SMMZ_INSIDE_H
diff --git a/bsp/mmz/drivers/src/include/mmz_smmz_shared.h b/bsp/mmz/drivers/src/include/mmz_smmz_shared.h
new file mode 100644
index 0000000..94374c9
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/mmz_smmz_shared.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related underlying
+ * implementation about SMMZ_SHARED
+ * Author: AuthorNameMagicTag Create: 2019-12-11
+ */
+
+#ifndef MMZ_SMMZ_SHARED_H
+#define MMZ_SMMZ_SHARED_H
+
+#include "mmz_mem.h"
+
+struct smmz1_info {
+    td_char name[SMMZ1_BLOCK_NAME_LEN];
+    td_phys_addr_t phys_addr;
+    td_size_t size;
+    td_s32 uuid_num;
+    LIST_ENTRY(smmz1_info) link;
+    TEE_UUID uuids[0];
+};
+
+struct smmz1_blocks {
+    td_s32 block_num;
+    struct smmz1_info_list_head *smmz1_info;
+};
+
+TEE_Result register_smmz1_block(const struct smmz1_info *);
+LIST_HEAD(smmz1_info_list_head, smmz1_info);
+
+/********** API_1 for inf & usr *********/
+
+/*
+ * brief            get smmz1 blocks infomation.
+ *
+ * return           Pointer to SMMZ1 blocks.
+ */
+struct smmz1_blocks *drv_mmz_get_smmz1_blocks(td_void);
+
+/*
+ * brief            Print SMMZ1 memory information.
+ *
+ * return           no return
+ */
+td_void drv_mmz_dump_smmz1(td_void);
+
+struct smmz1_blocks *mmb_mem_get_smmz1_blocks(td_void);
+
+tee_mmb_t *mmb_mem_alloc_smmz1(td_phys_addr_t phys_addr, td_size_t size,
+                               td_bool cache);
+
+td_s32 mmz_check_ta_smmz1(td_phys_addr_t phys_addr, td_size_t size,
+                          TEE_UUID *uuid);
+
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+
+td_s32 mmz_check_smmz1(td_phys_addr_t phys_addr, td_size_t size);
+#else
+static inline td_s32 mmz_check_smmz1(td_phys_addr_t phys_addr, td_size_t size)
+{
+    (void)&phys_addr;
+    (void)&size;
+    return TD_FAILURE;
+}
+#endif  // CFG_SMMZ_SHARED_SUPPORT
+        //
+#endif  // MMZ_SMMZ_SHARED_H
diff --git a/bsp/mmz/drivers/src/include/mmz_usr.h b/bsp/mmz/drivers/src/include/mmz_usr.h
new file mode 100644
index 0000000..4dcc207
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/mmz_usr.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related user interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef MMZ_USER_H
+#define MMZ_USER_H
+
+#include "mpi_mmz.h"
+
+td_s32 usr_mmz_alloc_map_nocache(td_phys_addr_t *phys_addr, td_void **virt_addr, const td_char *mmb_name,
+                                 const td_char *zone_name, td_size_t size);
+
+td_s32 usr_mmz_alloc_map_cached(td_phys_addr_t *phys_addr, td_void **virt_addr, const td_char *mmb_name,
+                                const td_char *zone_name, td_size_t size);
+
+td_s32 usr_mmz_unmap_and_free(td_phys_addr_t phys_addr, td_void *virt_addr);
+
+td_void *usr_mmz_mmap_nocache(td_phys_addr_t phys_addr, td_size_t size);
+
+td_void *usr_mmz_mmap_cached(td_phys_addr_t phys_addr, td_size_t size);
+
+td_s32 usr_mmz_munmap(td_void *virt_addr, td_size_t size);
+
+td_s32 usr_mmz_flush_cache(td_phys_addr_t phys_addr, td_void *virt_addr, td_size_t size);
+
+td_s32 usr_mmz_get_mem_info(td_void *virt_addr, mem_info *mem_info);
+#endif
diff --git a/bsp/mmz/drivers/src/include/ot_type.h b/bsp/mmz/drivers/src/include/ot_type.h
new file mode 100644
index 0000000..0a5ee38
--- /dev/null
+++ b/bsp/mmz/drivers/src/include/ot_type.h
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ *
+ */
+
+#ifndef __OT_TYPE_H__
+#define __OT_TYPE_H__
+
+#ifdef __KERNEL__
+
+#include <string.h>
+#else
+
+#include <stdint.h>
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#ifndef NULL
+    #define NULL                0L
+#endif
+
+#define TD_NULL                 0L
+#define TD_SUCCESS              0
+#define TD_FAILURE              (-1)
+
+typedef unsigned char           td_uchar;
+typedef unsigned char           td_u8;
+typedef unsigned short          td_u16;
+typedef unsigned int            td_u32;
+typedef unsigned long           td_ulong;
+
+typedef char                    td_char;
+typedef signed char             td_s8;
+typedef short                   td_s16;
+typedef int                     td_s32;
+typedef long                    td_slong;
+
+typedef float                   td_float;
+typedef double                  td_double;
+
+typedef void                    td_void;
+
+#ifndef _M_IX86
+    typedef unsigned long long  td_u64;
+    typedef long long           td_s64;
+#else
+    typedef unsigned __int64    td_u64;
+    typedef __int64             td_s64;
+#endif
+
+// typedef unsigned long           uintptr_t;
+typedef unsigned long           td_size_t;
+typedef unsigned long           td_length_t;
+typedef unsigned long int       td_phys_addr_t;
+typedef td_u32                  td_handle;
+typedef unsigned long           td_uintptr_t;
+typedef unsigned int            td_fr32;
+
+typedef enum {
+    TD_FALSE = 0,
+    TD_TRUE  = 1,
+} td_bool;
+
+#ifndef __KERNEL__
+
+#define OT_PRINT      printf
+
+#else
+
+#define OT_PRINT      IMSG
+
+#endif /* end of __KERNEL__ */
+
+#define EOK    0
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __OT_TYPE_H__ */
+
diff --git a/bsp/mmz/drivers/src/smmz_common/build.mak b/bsp/mmz/drivers/src/smmz_common/build.mak
new file mode 100644
index 0000000..96452cc
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_common/build.mak
@@ -0,0 +1,10 @@
+MMZ_DRV_OBJS += smmz_common/drv_mmz_init.c
+MMZ_DRV_OBJS += smmz_common/mmz_dispatch.c
+MMZ_DRV_OBJS += smmz_common/mmz_ext.c
+MMZ_DRV_OBJS += smmz_common/mmz_intf.c
+MMZ_DRV_OBJS += smmz_common/mmz_mem.c
+MMZ_DRV_OBJS += smmz_common/mmz_usr.c
+
+MMZ_DRV_CFLAGS += -I$(MMZ_DRV_DIR)/src/include
+MMZ_DRV_CFLAGS += -I$(MMZ_DRV_DIR)/include
+MMZ_DRV_CFLAGS += -I$(MMZ_API_DIR)/include
diff --git a/bsp/mmz/drivers/src/smmz_common/drv_mmz_init.c b/bsp/mmz/drivers/src/smmz_common/drv_mmz_init.c
new file mode 100644
index 0000000..0b5ff52
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_common/drv_mmz_init.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: SEC_MMZ init SMMZ zone, mute and mobj.
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <initcall.h>
+#include <tee/tee_svc_security_subsys.h>
+#include "entry_fast.h"
+#include "mmz_common.h"
+#include "mmz_ext.h"
+#include "mmz_intf.h"
+#include "mmz_smmz_inside.h"
+#include "mmz_smmz_shared.h"
+#include "mobj_mmz.h"
+#include "osal_addr.h"
+
+TEE_Result syscall_mmz_ioctl(void *param, size_t param_len)
+{
+    TEE_MMZ_Data *data = (TEE_MMZ_Data *)param;
+
+    if (sizeof(*data) != param_len) {
+        log_error("check param_len failed!\n");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    return mmz_ioctl(data->cmd, data->param);
+}
+
+static void mmz_delete_zone_group(tee_mmz_t **data, int index)
+{
+    for (int i = 0; i < index; ++i) {
+        mmz_delete_zone(data[i]);
+    }
+}
+
+static int init_mmz(mmz_types flag, smmz_info *smmz, tee_mmz_t **data,
+                    int *index)
+{
+    tee_mmz_t *smmz_zone = NULL;
+    smmz_info *tmp = NULL;
+    const char *name = flag == MMZ_TYPE_SMMZ1 ? "SMMZ1" : "SMMZ2";
+
+    LIST_FOR_SMMZ(tmp, smmz)
+    {
+        smmz_zone = mmz_new_zone(name, tmp);
+        if (smmz_zone == NULL) {
+            log_error("%s is NULL!", name);
+            goto err_exit;
+        }
+
+        if (mmb_is_memory_overlap((const tee_mmz_t **)data, *index, tmp) ==
+            TD_TRUE) {
+            log_error("memory overlap!");
+            goto err_exit;
+        }
+
+        data[(*index)++] = smmz_zone;
+    }
+
+    return TD_SUCCESS;
+
+err_exit:
+    mmz_delete_zone_group(data, *index);
+    return TD_FAILURE;
+}
+
+static TEE_Result drv_sec_mmz_init(td_void)
+{
+    int block_num = 0;
+    int index = 0;
+    tee_mmz_t **data = NULL;
+    td_s32 ret = TD_FAILURE;
+
+    block_num += g_smmz1_info != NULL ? g_smmz1_info->block_num : 0;
+    block_num += g_smmz2_info != NULL ? g_smmz2_info->block_num : 0;
+    data = (tee_mmz_t **)malloc(sizeof(tee_mmz_t *) * block_num);
+    if (data == NULL) {
+        log_error("malloc failed!\n");
+        return TD_FAILURE;
+    }
+
+    if (mobj_mapped_sec_mmz_init() != TD_SUCCESS) {
+        log_error("mobj init failed!");
+        goto err_exit;
+    }
+    /* init mmz */
+    /* SMMZ1 indicates the security memory pre-allocated to the REE side */
+    if (init_mmz(MMZ_TYPE_SMMZ1, g_smmz1_info, data, &index) != TD_SUCCESS) {
+        goto err_exit;
+    }
+
+    /* SMMZ2 indicates the security memory pre-allocated to the TEE side */
+    if (init_mmz(MMZ_TYPE_SMMZ2, g_smmz2_info, data, &index) != TD_SUCCESS) {
+        goto err_exit;
+    }
+
+    mmb_mem_init_mute();
+
+#ifdef CFG_OPTEE_DEBUG
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+    register_debug_func(DUMP_SMMZ1, drv_mmz_dump_smmz1);
+#endif
+    register_debug_func(DUMP_SMMZ2, drv_mmz_dump_smmz2);
+#endif
+    ret = TD_SUCCESS;
+err_exit:
+    free(data);
+    data = NULL;
+    return ret;
+}
+service_init_late(drv_sec_mmz_init);
diff --git a/bsp/mmz/drivers/src/smmz_common/mmz_dispatch.c b/bsp/mmz/drivers/src/smmz_common/mmz_dispatch.c
new file mode 100644
index 0000000..c7ecdaa
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_common/mmz_dispatch.c
@@ -0,0 +1,239 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: MMZ ioctl for user interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include "stdlib.h"
+#include "vm.h"
+#include "user_mode_ctx.h"
+#include "osal_addr.h"
+#include "drv_mmz_debug.h"
+#include "drv_mmz_ioctl.h"
+#include "mmz_common.h"
+#include "mmz_ext.h"
+#include "mmz_usr.h"
+
+typedef td_s32 (*ot_drv_func)(td_void *param);
+
+typedef struct {
+    const td_char *name;
+    ot_drv_func func;
+    td_u32 cmd;
+} mmz_dispatch_func;
+
+static td_s32 dispatch_mmz_alloc(td_void *argp)
+{
+    td_s32 ret;
+    mmz_alloc_t *alloc = argp;
+    td_phys_addr_t phys_addr = 0;
+    td_void *virt_addr = NULL;
+
+    ret = usr_mmz_alloc_map_nocache(&phys_addr, &virt_addr, alloc->mmb_name, alloc->zone_name, alloc->size);
+    if (ret != TD_SUCCESS) {
+        print_func_errno(usr_mmz_alloc_map_nocache, ret);
+        return ret;
+    }
+
+    alloc->phys_addr = phys_addr;
+    alloc->virt_addr = virt_addr;
+    return TD_SUCCESS;
+}
+
+static td_s32 dispatch_mmz_alloc_cached(td_void *argp)
+{
+    td_s32 ret;
+    mmz_alloc_t *alloc = argp;
+    td_phys_addr_t phys_addr = 0;
+    td_void *virt_addr = NULL;
+
+    ret = usr_mmz_alloc_map_cached(&phys_addr, &virt_addr, alloc->mmb_name, alloc->zone_name, alloc->size);
+    if (ret != TD_SUCCESS) {
+        print_func_errno(usr_mmz_alloc_map_cached, ret);
+        return ret;
+    }
+
+    alloc->phys_addr = phys_addr;
+    alloc->virt_addr = virt_addr;
+    return TD_SUCCESS;
+}
+
+static td_s32 dispatch_mmz_free(td_void *argp)
+{
+    td_s32 ret;
+    mmz_free_t *free = argp;
+
+    ret = usr_mmz_unmap_and_free(free->phys_addr, free->virt_addr);
+    if (ret != TD_SUCCESS) {
+        print_func_errno(usr_mmz_unmap_and_free, ret);
+        return ret;
+    }
+	
+    return TD_SUCCESS;
+}
+
+static td_s32 dispatch_mmz_mmap(td_void *argp)
+{
+    td_void *virt_addr;
+    mmz_mmap_t *mmap = argp;
+
+    virt_addr = usr_mmz_mmap_nocache(mmap->phys_addr, mmap->size);
+    if (virt_addr == NULL) {
+        print_func_errno(usr_mmz_mmap_nocache, 0);
+        return TD_FAILURE;
+    }
+    
+    mmap->virt_addr = virt_addr;
+    return TD_SUCCESS;
+}
+
+static td_s32 dispatch_mmz_mmap_cached(td_void *argp)
+{
+    td_void *virt_addr;
+    mmz_mmap_t *mmap = argp;
+
+    virt_addr = usr_mmz_mmap_cached(mmap->phys_addr, mmap->size);
+    if (virt_addr == NULL) {
+        print_func_errno(usr_mmz_mmap_cached, 0);
+        return TD_FAILURE;
+    }
+
+    mmap->virt_addr = virt_addr;
+    return TD_SUCCESS;
+}
+
+static td_s32 dispatch_mmz_munmap(td_void *argp)
+{
+    td_s32 ret;
+    mmz_munmap_t *munmap = argp;
+
+    ret = usr_mmz_munmap(munmap->virt_addr, munmap->size);
+    if (ret != TD_SUCCESS) {
+        print_func_errno(usr_mmz_munmap, ret);
+        return ret;
+    }
+	
+    return TD_SUCCESS;
+}
+
+static td_s32 dispatch_mmz_flush_cache(td_void *argp)
+{
+    td_s32 ret;
+    mmz_flush_cache_t *flush = argp;
+
+    ret = usr_mmz_flush_cache(flush->phys_addr, flush->virt_addr, flush->size);
+    if (ret != TD_SUCCESS) {
+        print_func_errno(usr_mmz_flush_cache, ret);
+        return ret;
+    }
+
+    return TD_SUCCESS;
+}
+
+static td_s32 dispatch_mmz_get_info(td_void *argp)
+{
+    td_s32 ret;
+    mmz_get_info_t *get_info = argp;
+    mem_info *m_info = NULL;
+
+    if (get_info->m_info == NULL) {
+        print_func_errno(usr_mmz_get_mem_info, 0);
+        return TD_FAILURE;
+    }
+
+    m_info = malloc(sizeof(mem_info));
+    if (m_info == NULL) {
+        print_func_errno(mmz_ioctl, 0);
+        goto exit;
+    }
+
+    ret = usr_mmz_get_mem_info(get_info->virt_addr, m_info);
+    if (ret != TD_SUCCESS) {
+        print_func_errno(usr_mmz_get_mem_info, ret);
+        goto exit;
+    }
+
+    ret = osal_copy_to_user(get_info->m_info, m_info, sizeof(mem_info));
+    if (ret != TD_SUCCESS) {
+        print_func_errno(mmz_ioctl, ret);
+        goto exit;
+    }
+
+    free(m_info);
+    m_info = NULL;
+
+    return TD_SUCCESS;
+
+exit:
+    if (m_info != NULL) {
+        free(m_info);
+        m_info = NULL;
+    }
+
+    return TD_FAILURE;
+}
+
+/* ****************************** API Code **************************** */
+static mmz_dispatch_func g_dispatch_func[CMD_MMZ_COUNT] = {
+    {"MmzAlloc",       dispatch_mmz_alloc,        CMD_MMZ_ALLOC},
+    {"MmzAllocCached", dispatch_mmz_alloc_cached, CMD_MMZ_ALLOC_CACHED},
+    {"MmzFree",        dispatch_mmz_free,         CMD_MMZ_FREE},
+    {"MmzMmap",        dispatch_mmz_mmap,         CMD_MMZ_MMAP},
+    {"MmzMmapCached",  dispatch_mmz_mmap_cached,  CMD_MMZ_MMAP_CACHED},
+    {"MmzMunmap",      dispatch_mmz_munmap,       CMD_MMZ_MUNMAP},
+    {"MmzFlushCache",  dispatch_mmz_flush_cache,  CMD_MMZ_FLUSH_CACHE},
+    {"MmzGetInfo",     dispatch_mmz_get_info,     CMD_MMZ_GET_INFO},
+};
+
+td_u32 mmz_ioctl(td_u32 cmd, td_void *argp)
+{
+    td_u32 nr;
+    td_s32 ret;
+    td_char *kbuf = NULL;
+    td_u32 user_size = MMZ_IOC_SIZE(cmd);
+
+    nr = MMZ_IOC_NR(cmd);
+    if (argp == NULL || nr >= CMD_MMZ_COUNT || g_dispatch_func[nr].cmd != cmd) {
+        print_func_errno(mmz_ioctl, 0);
+        return TD_FAILURE;
+    }
+
+    kbuf = (char *)osal_vmalloc(user_size);
+    if (kbuf == NULL) {
+        print_func_errno(mmz_ioctl, 0);
+        goto exit;
+    }
+
+    ret = osal_copy_from_user(kbuf, (char *)(uintptr_t)argp, user_size);
+    if (ret != TD_SUCCESS) {
+        print_func_errno(mmz_ioctl, ret);
+        goto exit;
+    }
+
+    ret = g_dispatch_func[nr].func(kbuf);
+    if (ret != TD_SUCCESS) {
+        goto exit;
+    }
+    
+    ret = osal_copy_to_user(argp, kbuf, MMZ_IOC_SIZE(cmd));
+    if (ret != TD_SUCCESS) {
+        print_func_errno(mmz_ioctl, ret);
+        goto exit;
+    }
+
+    osal_vfree(kbuf);
+
+    func_exit();
+    return TD_SUCCESS;
+
+exit:
+    if (kbuf != NULL) {
+        osal_vfree(kbuf);
+        kbuf = NULL;
+    }
+
+    func_exit();
+    return TD_FAILURE;
+}
+
diff --git a/bsp/mmz/drivers/src/smmz_common/mmz_ext.c b/bsp/mmz/drivers/src/smmz_common/mmz_ext.c
new file mode 100644
index 0000000..42ad5c3
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_common/mmz_ext.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: MMZ driver interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include "mmz_ext.h"
+#include "mmz_intf.h"
+#include "mmz_mem.h"
+
+td_s32 drv_mmz_alloc(td_phys_addr_t *phys_addr, const td_char *mmb_name,
+                     const td_char *zone_name, td_size_t size)
+{
+    if (mmb_name == NULL || zone_name == NULL || phys_addr == NULL) {
+        return TD_FAILURE;
+    }
+
+    if (mmz_check_name_and_size(zone_name, size) != TD_SUCCESS) {
+        return TD_FAILURE;
+    }
+
+    return mmz_new_mmb(phys_addr, mmb_name, zone_name, size);
+}
+
+td_s32 drv_mmz_free(td_phys_addr_t phys_addr)
+{
+    if (mmb_is_phys_in_smmz(MMZ_TYPE_SMMZ2, phys_addr, 0) != TD_TRUE) {
+        log_error("phys_addr is not match!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_delete_mmb(phys_addr);
+}
+
+td_void *drv_mmz_map_nocache(td_phys_addr_t phys_addr, td_size_t size)
+{
+    if (mmz_check_phys_kernel(phys_addr, size) != TD_SUCCESS) {
+        log_error("check phys failed!\n");
+        return NULL;
+    }
+
+    return mmz_map_phys_to_kernel_virt(phys_addr, size, NO_CACHE);
+}
+
+td_void *drv_mmz_map_cached(td_phys_addr_t phys_addr, td_size_t size)
+{
+    if (mmz_check_phys_kernel(phys_addr, size) != TD_SUCCESS) {
+        log_error("check phys failed!\n");
+        return NULL;
+    }
+
+    return mmz_map_phys_to_kernel_virt(phys_addr, size, CACHED);
+}
+
+td_s32 drv_mmz_unmap(td_virt_addr_t virt_addr, td_size_t size)
+{
+    if (mmz_check_size_kernel(virt_addr, size) != TD_SUCCESS) {
+        log_error("check size failed!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_unmap_kernel_virt(virt_addr, size);
+}
+
+td_s32 drv_mmz_flush_cache(td_virt_addr_t virt_addr, td_size_t size)
+{
+    if (mmz_check_size_kernel(virt_addr, size) != TD_SUCCESS) {
+        log_error("check size failed!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_flush_cache(virt_addr, size);
+}
+
+td_s32 drv_mmz_invalid_cache(td_virt_addr_t virt_addr, td_size_t size)
+{
+    if (mmz_check_size_kernel(virt_addr, size) != TD_SUCCESS) {
+        log_error("check size failed!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_invalid_cache(virt_addr, size);
+}
+
+td_s32 drv_mmz_check_phys_and_ta(td_phys_addr_t phys_addr, td_size_t size)
+{
+    if (mmb_is_phys_in_smmz(MMZ_TYPE_SMMZ1, phys_addr, size) != TD_TRUE &&
+        mmb_is_phys_in_smmz(MMZ_TYPE_SMMZ2, phys_addr, size) != TD_TRUE) {
+        log_error("phys_addr is not match!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_check_phys_and_ta(phys_addr, size);
+}
+
+td_s32 drv_mmz_get(td_phys_addr_t phys_addr, td_size_t size)
+{
+    if (mmz_check_phys_kernel(phys_addr, size) != TD_SUCCESS) {
+        log_error("check phys failed!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_get_cnt(phys_addr, size);
+}
+
+td_s32 drv_mmz_put(td_phys_addr_t phys_addr, td_size_t size)
+{
+    if (mmz_check_phys_kernel(phys_addr, size) != TD_SUCCESS) {
+        log_error("check phys failed!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_put_cnt(phys_addr, size);
+}
diff --git a/bsp/mmz/drivers/src/smmz_common/mmz_intf.c b/bsp/mmz/drivers/src/smmz_common/mmz_intf.c
new file mode 100644
index 0000000..5079ac7
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_common/mmz_intf.c
@@ -0,0 +1,651 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: MMZ internal interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include "mmz_intf.h"
+#include "mmz_smmz_inside.h"
+#include "mmz_smmz_shared.h"
+#include "osal_addr.h"
+#include "osal_debug.h"
+#include "securec.h"
+
+#define MAX_ZONE_NUM 64
+
+td_phys_addr_t g_zone_start[MAX_ZONE_NUM] = {0};
+td_size_t g_zone_size[MAX_ZONE_NUM] = {0};
+
+static td_s32 g_zone_num = 0;
+
+tee_mmz_t *mmz_new_zone(const td_char *name, smmz_info *tmp)
+{
+    tee_mmz_t *mmz = NULL;
+    td_phys_addr_t phys_start = tmp == NULL ? 0 : tmp->addr;
+    td_size_t size = tmp == NULL ? 0 : tmp->size;
+
+    if (phys_start == 0 || size == 0 || phys_start >= (phys_start + size)) {
+        osal_printk("phys or size is not match");
+        return NULL;
+    }
+
+    if (g_zone_num >= MAX_ZONE_NUM) {
+        log_error("More than Max zone numbersi, forbid!\n");
+        return NULL;
+    }
+
+    for (td_s32 j = 0; j < g_zone_num; j++) {
+        if (((phys_start >= g_zone_start[j]) &&
+             (phys_start < (g_zone_start[j] + g_zone_size[j]))) ||
+            (((phys_start + size) > g_zone_start[j]) &&
+             ((phys_start + size) <= (g_zone_start[j] + g_zone_size[j])))) {
+            log_error("The zone area should not intersect!\n");
+            return NULL;
+        }
+    }
+
+    mmz = mmb_mem_create_mmz(name, phys_start, size);
+    if (mmz == NULL) {
+        log_error("Create mem zone failed!\n");
+        return NULL;
+    }
+
+    mmz->die_id = tmp->die_id;
+    if (mmb_mem_register_mmz(mmz) != 0) {
+        log_error("register failed mmz name :%s\n", mmz->name);
+        mmb_mem_destroy_mmz(mmz);
+        return NULL;
+    }
+
+    g_zone_start[g_zone_num] = phys_start;
+    g_zone_size[g_zone_num] = size;
+    g_zone_num++;
+
+    return mmz;
+}
+
+td_void mmz_delete_zone(tee_mmz_t *zone)
+{
+    mmb_mem_unregister_mmz(zone);
+    mmb_mem_destroy_mmz(zone);
+}
+
+td_s32 mmz_delete_mmb(td_phys_addr_t phys_addr)
+{
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    mmb_mem_free_mmb(mmb);
+    mmb = NULL;
+
+    return TD_SUCCESS;
+}
+
+int mmz_new_mmb(td_phys_addr_t *phys_addr, const td_char *mmb_name,
+                const td_char *mmz_name, td_size_t size)
+{
+    td_char mmzname[MEM_MAX_NAME_LEN + 1];
+    td_char mmbname[MEM_MAX_NAME_LEN + 1];
+    td_size_t len;
+    tee_mmb_t *mmb = NULL;
+
+    if (strlen(mmb_name) > MEM_MAX_NAME_LEN) {
+        log_error("name length more than 16\n");
+        return TD_FAILURE;
+    }
+
+    memset_s(mmzname, MEM_MAX_NAME_LEN + 1, 0x0, MEM_MAX_NAME_LEN + 1);
+    memset_s(mmbname, MEM_MAX_NAME_LEN + 1, 0x0, MEM_MAX_NAME_LEN + 1);
+
+    len = strlen(mmz_name) + 1;
+    if (memcpy_s(mmzname, MEM_MAX_NAME_LEN + 1, mmz_name,
+                 (len > MEM_MAX_NAME_LEN) ? MEM_MAX_NAME_LEN : len) != EOK) {
+        log_error("memcpy mmzname failed, mmz_name:%s\n", mmz_name);
+        return TD_FAILURE;
+    }
+
+    len = strlen(mmb_name) + 1;
+    if (memcpy_s(mmbname, MEM_MAX_NAME_LEN + 1, mmb_name,
+                 (len > MEM_MAX_NAME_LEN) ? MEM_MAX_NAME_LEN : len) != EOK) {
+        log_error("memcpy mmbname failed, mmb_name:%s\n", mmb_name);
+        return TD_FAILURE;
+    }
+    mmzname[MEM_MAX_NAME_LEN] = '\0';
+    mmbname[MEM_MAX_NAME_LEN] = '\0';
+
+    mmb = mmb_mem_alloc_smmz2(mmbname, size, mmzname);
+    if (mmb == NULL) {
+        log_error(" Fail to new mmb %s(0x%lX Bytes) from zone %s\n",
+                  mmbname ? mmbname : "null", size,
+                  mmzname ? mmzname : "null");
+        return TD_FAILURE;
+    }
+
+    *phys_addr = mmb->phys_addr;
+
+    return TD_SUCCESS;
+}
+
+static td_void *map_phys_to_user(td_phys_addr_t phys_addr, td_size_t size,
+                                 td_bool cache)
+{
+    tee_mmb_t *mmb = NULL;
+    td_virt_addr_t virt_addr = NULL;
+    uintptr_t v_addr = 0;
+    (void)&size;
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        log_error("mmb can't find!\n");
+        return NULL;
+    }
+
+    mmb->cache = cache;
+
+    virt_addr = mmb_mem_map_phys_to_user_virt(mmb);
+    if (virt_addr == NULL) {
+        log_error("mmb map_user failed, mmb_name:%s", mmb->name);
+        return NULL;
+    }
+
+    v_addr = (uintptr_t)(virt_addr) + (phys_addr - mmb->phys_addr);
+
+    return (td_virt_addr_t)v_addr;
+}
+
+td_s32 mmz_alloc_and_map_mmb(td_phys_addr_t *phys_addr,
+                             td_virt_addr_t *virt_addr, const td_char *mmb,
+                             const td_char *zone, td_size_t size, td_bool cache)
+{
+    td_s32 ret;
+    tee_mmb_t *new_mmb = NULL;
+
+    ret = mmz_new_mmb(phys_addr, mmb, zone, size);
+    if (ret != TD_SUCCESS) {
+        log_error("mmb alloc failed, mmb->name:%s\n", mmb);
+        return TD_FAILURE;
+    }
+
+    new_mmb = mmb_mem_getby_phys(*phys_addr);
+    if (new_mmb == NULL) {
+        log_error("mmb can't find\n");
+        *phys_addr = 0;
+
+        return TD_FAILURE;
+    }
+    refcount_inc(&new_mmb->user_cnt);
+
+    *virt_addr = map_phys_to_user(*phys_addr, size, cache);
+    if (*virt_addr == NULL) {
+        log_error("mmb map_user failed, mmb->name:%s\n", new_mmb->name);
+
+        ret = mmb_mem_free_mmb(new_mmb);
+        if (ret != TD_SUCCESS) {
+            log_error("mmb free failed, mmb->name:%s\n", new_mmb->name);
+        }
+        new_mmb = NULL;
+
+        *phys_addr = 0;
+
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_void *mmz_map_phys_to_user_virt(td_phys_addr_t phys_addr, td_size_t size,
+                                   td_bool cache)
+{
+    td_s32 mmz_type;
+    td_virt_addr_t virt_addr = NULL;
+    tee_mmb_t *mmb = NULL;
+    td_bool smmz1_alloced = false;
+
+    mmz_type = mmb_mem_get_zone_by_phys(phys_addr, size);
+    if (mmz_type != MMZ_TYPE_SMMZ1 && mmz_type != MMZ_TYPE_SMMZ2) {
+        log_error("mmap TYPE is not SMMZ\n");
+        return NULL;
+    }
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+    if (mmz_type == MMZ_TYPE_SMMZ1 && mmb == NULL) {
+        mmb = mmb_mem_alloc_smmz1(phys_addr, size, cache);
+        log_error("smmz1 mmb alloc %s\n", mmb == NULL ? "failed" : "success");
+        smmz1_alloced = true;
+    }
+#endif
+
+    if (mmb != NULL && mmb->cache == cache) {
+        if (!smmz1_alloced) {
+            refcount_inc(&mmb->user_cnt);
+        }
+    } else {
+        if (mmb == NULL) {
+            log_error("smmz mmb not find\n");
+        } else {
+            log_error("CACHE_TYPE is not match, cache:%d, mmb_cache:%d, "
+                      "mmb->name:%s\n",
+                      cache, mmb->cache, mmb->name);
+        }
+        return NULL;
+    }
+
+    virt_addr = map_phys_to_user(phys_addr, size, cache);
+    if (virt_addr == NULL) {
+        log_error("map_user failed, mmb->name:%s\n", mmb->name);
+        mmb_mem_free_mmb(mmb);
+    }
+
+    return virt_addr;
+}
+
+td_s32 mmz_unmap_user_virt(td_virt_addr_t virt_addr, td_size_t size)
+{
+    td_s32 ret;
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_phys(osal_virt_to_phys(virt_addr));
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    if (size == 0 || size > mmb->size) {
+        log_error("size is not match, size:0x%lx, mmb_size:0x%lx\n", size,
+                  mmb->size);
+        return TD_FAILURE;
+    }
+
+    if (refcount_val(&mmb->user_cnt) == 0) {
+        log_warn("munmap too many times, mmb_name:%s\n", mmb->name);
+        return TD_SUCCESS;
+    }
+
+    ret = mmb_mem_unmap_user_virt(virt_addr, size);
+    if (ret != TD_SUCCESS) {
+        log_error("munmap_mmz failed, mmb_name:%s\n", mmb->name);
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_unmap_and_free_mmb(td_phys_addr_t phys_addr,
+                              td_virt_addr_t virt_addr)
+{
+    td_s32 ret;
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    ret = mmb_mem_unmap_user_virt(virt_addr, mmb->size);
+    if (ret == TD_FAILURE) {
+        log_error("munmap_mmz failed, mmb_name:%s\n", mmb->name);
+        return TD_FAILURE;
+    }
+
+    mmb_mem_free_mmb(mmb);
+    mmb = NULL;
+
+    return TD_SUCCESS;
+}
+
+td_void *mmz_map_phys_to_kernel_virt(td_phys_addr_t phys_addr, td_size_t size,
+                                     td_bool cache)
+{
+    td_s32 mmz_type;
+    tee_mmb_t *mmb = NULL;
+    uintptr_t virt_addr = 0;
+
+    mmz_type = mmb_mem_get_zone_by_phys(phys_addr, size);
+    if (mmz_type != MMZ_TYPE_SMMZ1 && mmz_type != MMZ_TYPE_SMMZ2) {
+        log_error("TYPE is not SMMZ\n");
+        return NULL;
+    }
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        if (mmz_type == MMZ_TYPE_SMMZ2) {
+            log_error("mmb not find\n");
+            return NULL;
+        }
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+        else {
+            mmb = mmb_mem_alloc_smmz1(phys_addr, size, cache);
+            if (mmb == NULL) {
+                log_error("mmb alloc failed\n");
+                return NULL;
+            }
+        }
+#endif
+    }
+
+    if (size == 0 || size > mmb->size ||
+        phys_addr + size > mmb->phys_addr + mmb->size) {
+        log_error("size is not match, size:0x%lx, mmb_size:0x%lx\n", size,
+                  mmb->size);
+        return NULL;
+    }
+
+    if (mmb->kvirt != NULL) {
+        if (mmb->cache == cache) {
+            refcount_inc(&mmb->map_kernel_cnt);
+        } else {
+            log_error("CACHE_TYPE is not match, cache:%d, mmb_cache:%d, "
+                      "mmb->name:%s\n",
+                      cache, mmb->cache, mmb->name);
+            return NULL;
+        }
+    } else {
+        mmb->cache = cache;
+        mmb->kvirt = mmb_mem_map_phys_to_kernel_virt(mmb);
+    }
+
+    virt_addr = (uintptr_t)mmb->kvirt + phys_addr - mmb->phys_addr;
+    return (td_virt_addr_t)virt_addr;
+}
+
+td_s32 mmz_unmap_kernel_virt(td_virt_addr_t virt_addr, td_size_t size)
+{
+    td_s32 ret;
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_kvirt(virt_addr);
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    if (size == 0 || size > mmb->size) {
+        log_error("size is not match, size:0x%lx, mmb_size:0x%lx\n", size,
+                  mmb->size);
+        return TD_FAILURE;
+    }
+
+    if (refcount_val(&mmb->map_kernel_cnt) == 0) {
+        log_warn("kunmap too many times, mmb_name:%s\n", mmb->name);
+        return TD_SUCCESS;
+    }
+
+    ret = mmb_mem_unmap_kernel_virt(mmb);
+    if (ret != TD_SUCCESS) {
+        log_error("kunmap_mmz failed, mmb_name:%s\n", mmb->name);
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_flush_mmb(td_phys_addr_t phys_addr)
+{
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    mmb_mem_flush_mmb(mmb);
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_flush_cache(td_virt_addr_t virt_addr, td_size_t size)
+{
+    mmb_mem_flush_cache(virt_addr, size);
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_invalid_cache(td_virt_addr_t virt_addr, td_size_t size)
+{
+    mmb_mem_invalid_cache(virt_addr, size);
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_check_phys_and_ta(td_phys_addr_t phys_addr, td_size_t size)
+{
+    tee_mmb_t *mmb = NULL;
+    td_s32 ret;
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    if (size == 0 || size > mmb->size ||
+        phys_addr + size > mmb->phys_addr + mmb->size) {
+        log_error("size is not match, size:0x%lx, mmb_size:0x%lx, "
+                  "phys_addr:%#lx, mmb->phys_addr:%#lx\n",
+                  size, mmb->size, phys_addr, mmb->phys_addr);
+        return TD_FAILURE;
+    }
+
+    ret = mmz_check_ta(phys_addr);
+    if (ret != TD_SUCCESS) {
+        log_error("check ta failed\n");
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_check_ta(td_phys_addr_t phys_addr)
+{
+    td_s32 mmz_type;
+    tee_mmb_t *mmb = NULL;
+    TEE_UUID *mmb_uuid = NULL;
+
+    mmz_type = mmb_mem_get_zone_by_phys(phys_addr, 1);
+    if (mmz_type != MMZ_TYPE_SMMZ1 && mmz_type != MMZ_TYPE_SMMZ2) {
+        log_error("TYPE is not SMMZ\n");
+        return TD_FAILURE;
+    }
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    /* The kernel has access to TA */
+    mmb_uuid = mmb_mem_get_uuid();
+    if (mmb_uuid == NULL) {
+        return TD_SUCCESS;
+    }
+
+    if (memcmp(mmb->uuid, mmb_uuid, sizeof(TEE_UUID)) != 0) {
+        log_error("uuid is not match, mmb_name:%s\n", mmb->name);
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_check_name_and_size(const td_char *zone_name, td_size_t size)
+{
+    if (strncmp(zone_name, "SMMZ2", MEM_MAX_NAME_LEN) != 0) {
+        log_error("zone_name is not match! size is 0x%lx\n", size);
+        return TD_FAILURE;
+    }
+
+    if (size == 0 || CHECK_WRONG_SIZE(size, g_smmz2_info)) {
+        log_error("size is not match! size is 0x%lx\n", size);
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_check_phys_virt_match(td_phys_addr_t phys_addr,
+                                 td_virt_addr_t virt_addr)
+{
+    if (virt_addr == NULL) {
+        log_error("NULL point error\n");
+        return TD_FAILURE;
+    }
+
+    if (phys_addr != osal_virt_to_phys(virt_addr)) {
+        log_error("addr is not match\n");
+        return TD_FAILURE;
+    }
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_check_phys_user(td_phys_addr_t phys_addr, td_size_t size)
+{
+    td_s32 ret;
+
+    if (mmb_is_phys_in_smmz(MMZ_TYPE_SMMZ1, phys_addr, size)) {
+        if (size == 0 || CHECK_WRONG_SIZE(size, g_smmz1_info)) {
+            log_error("size is not match! size is 0x%lx\n", size);
+            return TD_FAILURE;
+        }
+
+        ret = mmz_check_smmz1(phys_addr, size);
+        if (ret != TD_SUCCESS) {
+            log_error("SMMZ1 phys is not match!\n");
+            return TD_FAILURE;
+        }
+    } else if (mmb_is_phys_in_smmz(MMZ_TYPE_SMMZ2, phys_addr, size)) {
+        ret = mmz_check_phys_and_ta(phys_addr, size);
+        if (ret != TD_SUCCESS) {
+            log_error("SMMZ2 phys is not match!\n");
+            return TD_FAILURE;
+        }
+    } else {
+        log_error("phys_addr is not match!\n");
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+static int check_in_smmz(mmz_types type, td_phys_addr_t addr, td_size_t size)
+{
+    smmz_info *smmz = type == MMZ_TYPE_SMMZ1 ? g_smmz1_info : g_smmz2_info;
+
+    if (mmb_is_phys_in_smmz(type, addr, size)) {
+        if (size == 0 || CHECK_WRONG_SIZE(size, smmz)) {
+            log_error("size is not match! size is 0x%lx\n", size);
+            return TD_FAILURE;
+        }
+
+        if (mmb_is_phys_overlap(smmz, addr, size) == TD_TRUE) {
+            log_error("phys overlap!\n");
+            return TD_FAILURE;
+        }
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_check_phys_kernel(td_phys_addr_t phys_addr, td_size_t size)
+{
+    if (check_in_smmz(MMZ_TYPE_SMMZ1, phys_addr, size) != TD_SUCCESS &&
+        check_in_smmz(MMZ_TYPE_SMMZ2, phys_addr, size) != TD_SUCCESS) {
+        log_error("get phys_addr is not match!\n");
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_check_size_kernel(td_virt_addr_t virt_addr, td_size_t size)
+{
+    if (size == 0 || (CHECK_WRONG_SIZE(size, g_smmz1_info) &&
+                      CHECK_WRONG_SIZE(size, g_smmz2_info))) {
+        log_error("size is not match! size is 0x%lx\n", size);
+        return TD_FAILURE;
+    }
+
+    if (virt_addr == NULL) {
+        log_error("NULL point error\n");
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_get_virt_mem_info(td_virt_addr_t virt_addr, mem_info *m_info)
+{
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_phys(osal_virt_to_phys(virt_addr));
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    m_info->cache = mmb->cache;
+    m_info->size = mmb->size;
+    return TD_SUCCESS;
+}
+
+td_void mmz_dump(const td_char *name)
+{
+    mmb_mem_dump(name);
+}
+
+td_s32 mmz_get_cnt(td_phys_addr_t phys_addr, td_size_t size)
+{
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    if (size == 0 || size > mmb->size ||
+        phys_addr + size > mmb->phys_addr + mmb->size) {
+        log_error("get size is not match, size:0x%lx, mmb_size:0x%lx\n", size,
+                  mmb->size);
+        return TD_FAILURE;
+    }
+
+    refcount_inc(&mmb->user_cnt);
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmz_put_cnt(td_phys_addr_t phys_addr, td_size_t size)
+{
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_phys(phys_addr);
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    if (size == 0 || size > mmb->size ||
+        phys_addr + size > mmb->phys_addr + mmb->size) {
+        log_error("put size is not match, size:0x%lx, mmb_size:0x%lx\n", size,
+                  mmb->size);
+        return TD_FAILURE;
+    }
+
+    if (refcount_val(&mmb->user_cnt) == 0) {
+        log_warn("The mmb_user_cnt is zero\n");
+    } else if (refcount_val(&mmb->user_cnt) == 1) {
+        mmb_mem_free_mmb(mmb);
+        mmb = NULL;
+    } else {
+        refcount_dec(&mmb->user_cnt);
+    }
+    return TD_SUCCESS;
+}
diff --git a/bsp/mmz/drivers/src/smmz_common/mmz_mem.c b/bsp/mmz/drivers/src/smmz_common/mmz_mem.c
new file mode 100644
index 0000000..7040e2b
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_common/mmz_mem.c
@@ -0,0 +1,739 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: MMZ underlying implementation
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include "mmz_mem.h"
+#include <tee/cache.h>
+#include "mobj_mmz.h"
+#include "osal_addr.h"
+#include "osal_cache.h"
+#include "osal_debug.h"
+#include "osal_mutex.h"
+#include "securec.h"
+#include "user_mode_ctx.h"
+#include "user_ta.h"
+#include "vm.h"
+
+/* flags */
+#define TEE_MMB_MAP2KERN        (1 << 0)
+#define TEE_MMB_MAP2KERN_CACHED (1 << 1)
+#define TEE_MMB_MAP2USER        (1 << 2)
+#define TEE_MMB_MAP2USER_CACHED (1 << 3)
+#define TEE_MMB_RELEASED        (1 << 4)
+
+#ifndef PAGE_SIZE
+#define PAGE_SIZE (1 << 12)
+#endif
+#define MMZ_GRAIN PAGE_SIZE
+
+static osal_mutex g_mmz_list_mutex;
+static osal_mutex g_smmz2_list_mutex;
+static osal_mutex g_mmb_mutex;
+
+MMZ_LIST_HEAD(mmz_list);
+
+td_void smmz_inside_mutex_lock()
+{
+    osal_mutex_lock(&g_smmz2_list_mutex);
+}
+
+td_void smmz_inside_mutex_unlock()
+{
+    osal_mutex_unlock(&g_smmz2_list_mutex);
+}
+
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+static osal_mutex g_smmz1_list_mutex;
+
+td_void smmz_shared_mutex_lock()
+{
+    osal_mutex_lock(&g_smmz1_list_mutex);
+}
+
+td_void smmz_shared_mutex_unlock()
+{
+    osal_mutex_unlock(&g_smmz1_list_mutex);
+}
+#endif
+
+struct list_head *get_mmz_list()
+{
+    return &mmz_list;
+}
+
+td_s32 list_add_mmb(tee_mmb_t *mmb)
+{
+    tee_mmb_t *p = NULL;
+
+    /* add mmb sorted */
+    list_for_each_entry(p, &mmb->zone->mmb_list, list)
+    {
+        if (mmb->phys_addr < p->phys_addr) {
+            break;
+        }
+
+        if (mmb->phys_addr == p->phys_addr) {
+            log_error("media-mem %s allocator bad in %s!\n", mmb->name,
+                      mmb->zone->name);
+        }
+    }
+
+    list_add(&mmb->list, p->list.prev);
+
+    mmz_trace(MMZ_LEVEL_INFO, MMB_MEM_INFO, mmb_mem_info_input(mmb));
+
+    return TD_SUCCESS;
+}
+
+static td_s32 mmz_check(tee_mmz_t *zone)
+{
+    tee_mmz_t *p = NULL;
+    td_phys_addr_t start;
+    td_phys_addr_t end;
+    td_phys_addr_t new_start = zone->phys_start;
+    td_phys_addr_t new_end = zone->phys_start + zone->size;
+
+    if (zone->size == 0) {
+        log_error("size of %s is zero!\n", zone->name);
+        return TD_FAILURE;
+    }
+
+    list_for_each_entry(p, &mmz_list, list)
+    {
+        start = p->phys_start;
+        end = p->phys_start + p->size;
+
+        if (new_start >= end) {
+            continue;
+        } else if ((new_start < start) && (new_end <= start)) {
+            continue;
+        }
+
+        log_error("Conflict MMZ:\n");
+        osal_printk("MMZ new:   " MMZ_MEM_INFO "\n", mmz_mem_info_input(zone));
+        osal_printk("MMZ exist: " MMZ_MEM_INFO "\n", mmz_mem_info_input(p));
+        osal_printk("Add new MMZ failed!\n");
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_void *mmb_mem_get_uuid(td_void)
+{
+    struct ts_ctx *ctx = thread_get_tsd()->ctx;
+    if (ctx == NULL) {
+        return NULL;
+    }
+
+    return &ctx->uuid;
+}
+
+static td_void mmz_free(td_void *memblock)
+{
+    osal_vfree(memblock);
+}
+
+td_bool mmb_is_memory_overlap(const tee_mmz_t **data, int index, smmz_info *tmp)
+{
+    td_phys_addr_t addr = 0;
+    td_size_t size = 0;
+
+    if (data == NULL || tmp == NULL) {
+        log_error("parameter invalid!\n");
+        return TD_TRUE;
+    }
+
+    if (tmp->addr % PAGE_SIZE != 0 || tmp->size % PAGE_SIZE != 0) {
+        log_error("addr of %s is not align to PAGE_SIZE, which is %#lx~%#lx",
+                  tmp->name, tmp->addr, tmp->addr + tmp->size);
+        return TD_TRUE;
+    }
+
+    if (tmp->size == 0) {
+        log_error("size of %s is 0\n", tmp->name);
+        return TD_TRUE;
+    }
+
+    for (int i = 0; i < index; ++i) {
+        size = data[i]->size;
+        addr = data[i]->phys_start;
+        /* If the address is less than the current block start address or the
+           sum of the address and size are greater than the current block end
+           address, it will cross */
+        if (tmp->addr + tmp->size > addr && tmp->addr < addr + size) {
+            log_error("memory %s overlap memory %#lx~%#lx\n", tmp->name, addr,
+                      addr + size);
+            return TD_TRUE;
+        }
+    }
+
+    return TD_FALSE;
+}
+
+td_bool mmb_is_phys_overlap(const smmz_info *smmz, td_phys_addr_t phys_addr,
+                            td_size_t size)
+{
+    struct smmz_info *tmp = NULL;
+
+    if (smmz == NULL) {
+        log_error("parameter invalid!\n");
+        return TD_TRUE;
+    }
+
+    if (size >= MAX_SIZE) {
+        log_error("size is invalid!\n");
+        return TD_TRUE;
+    }
+
+    LIST_FOR_SMMZ(tmp, smmz)
+    {
+        /* Check whether the current physical address crosses the boundary of
+         * two different blocks */
+        if ((phys_addr < tmp->addr && phys_addr + size > tmp->addr) ||
+            (phys_addr < tmp->addr + tmp->size &&
+             phys_addr + size > tmp->addr + tmp->size)) {
+            log_error("memory %s overlap\n", tmp->name);
+            return TD_TRUE;
+        }
+    }
+
+    return TD_FALSE;
+}
+
+td_s32 mmb_mem_free_mmb(tee_mmb_t *mmb)
+{
+    mmz_trace(MMZ_LEVEL_INFO, MMB_MEM_INFO, mmb_mem_info_input(mmb));
+
+    if (refcount_val(&mmb->user_cnt) == 0) {
+        log_error("The mmb_user_cnt is zero\n");
+    } else if (!refcount_dec(&mmb->user_cnt)) {
+        log_warn("mmb_mem_free_mmb faild, mmb->user_cnt:%d",
+                 refcount_val(&mmb->user_cnt));
+        return TD_SUCCESS;
+    }
+
+    if (mmb->mmz_type == MMZ_TYPE_SMMZ2) {
+        smmz_inside_mutex_lock();
+        list_del(&mmb->list);
+        smmz_inside_mutex_unlock();
+    }
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+    else {
+        smmz_shared_mutex_lock();
+        list_del(&mmb->list);
+        smmz_shared_mutex_unlock();
+    }
+#endif
+
+    if ((mmb->flags & TEE_MMB_RELEASED) != 0) {
+        log_warn("mmb<%s> is released before, but still used!\n", mmb->name);
+    }
+
+    if ((mmb->flags & TEE_MMB_MAP2KERN) != 0) {
+        log_warn("mmb<%s> not kunmap with map_kernel_cnt %d!\n", mmb->name,
+                 refcount_val(&mmb->map_kernel_cnt));
+        mmb_mem_unmap_kernel_virt(mmb);
+    }
+
+    if ((mmb->flags & TEE_MMB_MAP2USER) != 0) {
+        log_error("mmb<%s> with user_cnt %d error\n", mmb->name,
+                  refcount_val(&mmb->user_cnt));
+        return TD_FAILURE;
+    }
+
+    osal_mutex_lock(&g_mmb_mutex);
+    mmb->flags |= TEE_MMB_RELEASED;
+    mmb_mem_flush_mmb(mmb);
+    osal_vfree(mmb);
+    osal_mutex_unlock(&g_mmb_mutex);
+
+    return TD_SUCCESS;
+}
+
+td_void mmb_mem_init_mute(td_void)
+{
+    osal_mutex_init(&g_mmz_list_mutex);
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+    osal_mutex_init(&g_smmz1_list_mutex);
+#endif
+    osal_mutex_init(&g_smmz2_list_mutex);
+    osal_mutex_init(&g_mmb_mutex);
+}
+
+static td_s32 g_init_cnt = 0;
+tee_mmz_t *mmb_mem_create_mmz(const td_char *name, td_phys_addr_t phys_start,
+                              td_size_t size)
+{
+    tee_mmz_t *p = NULL;
+    tee_mmz_t *q = NULL;
+
+    if (name == NULL) {
+        log_error("'name' can not be zero!\n");
+        return NULL;
+    }
+
+    p = osal_vmalloc(sizeof(tee_mmz_t));
+    if (p == NULL) {
+        log_error("malloc failed! mmz_name:%s\n", name);
+        return NULL;
+    }
+
+    memset_s(p, sizeof(tee_mmz_t), 0, sizeof(tee_mmz_t));
+
+    if (strcpy_s(p->name, MEM_MAX_NAME_LEN, name) != EOK) {
+        osal_vfree(p);
+        log_error("copy name failed\n");
+        return NULL;
+    }
+    p->phys_start = phys_start;
+    p->size = size;
+    p->destructor = mmz_free;
+
+    INIT_LIST_HEAD(&p->list);
+    INIT_LIST_HEAD(&p->mmb_list);
+
+    mmz_trace(MMZ_LEVEL_INFO, MMZ_MEM_INFO, mmz_mem_info_input(p));
+
+    g_init_cnt++;
+
+    return p;
+}
+
+td_s32 mmb_mem_destroy_mmz(tee_mmz_t *mmz)
+{
+    tee_mmz_t *zone = mmz;
+
+    if (mmz == NULL) {
+        return TD_FAILURE;
+    }
+
+    mmz_trace(MMZ_LEVEL_INFO, MMZ_MEM_INFO, mmz_mem_info_input(zone));
+
+    if (zone->destructor != NULL) {
+        zone->destructor(zone);
+        if (g_init_cnt != 0) {
+            g_init_cnt--;
+        }
+    } else {
+        log_error("%s: missed destructor!\n", mmz->name);
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmb_mem_register_mmz(tee_mmz_t *mmz)
+{
+    td_s32 ret;
+    tee_mmz_t *zone = mmz;
+
+    if (mmz == NULL) {
+        log_error("NULL zone!\n");
+        return TD_FAILURE;
+    }
+
+    mmz_trace(MMZ_LEVEL_INFO, MMZ_MEM_INFO, mmz_mem_info_input(zone));
+
+    ret = mmz_check(zone);
+    if (ret != TD_SUCCESS) {
+        log_error("illegal mmz!!!\n");
+        return TD_FAILURE;
+    }
+
+    INIT_LIST_HEAD(&zone->mmb_list);
+
+    list_add(&zone->list, &mmz_list);
+
+    return TD_SUCCESS;
+}
+
+td_s32 mmb_mem_unregister_mmz(tee_mmz_t *mmz)
+{
+    td_s32 losts = 0;
+    tee_mmb_t *p = NULL;
+    tee_mmz_t *zone = mmz;
+
+    if (mmz == NULL) {
+        log_error("NULL zone!\n");
+        return TD_FAILURE;
+    }
+
+    mmz_trace(MMZ_LEVEL_INFO, MMZ_MEM_INFO, mmz_mem_info_input(zone));
+
+    list_for_each_entry(p, &zone->mmb_list, list)
+    {
+        losts++;
+    }
+
+    if (losts != 0) {
+        log_error("%d mmbs not free, mmz<%s> can not be deregistered! \n",
+                  losts, zone->name);
+        return TD_FAILURE;
+    }
+
+    list_del(&zone->list);
+
+    return TD_SUCCESS;
+}
+
+td_void *mmb_mem_map_phys_to_user_virt(tee_mmb_t *mmb)
+{
+    struct mobj *mobj = NULL;
+    struct user_mode_ctx *uctx = NULL;
+    td_size_t offs = 0;
+    uintptr_t virt_addr = 0;
+    td_size_t size = mmb->size;
+    td_s32 res;
+
+    mobj = mobj_reg_sec_mmz_alloc(mmb->phys_addr, mmb->size, mmb->cache);
+    if (mobj == NULL) {
+        log_error("creat mobj failed, mmb_name:%s\n", mmb->name);
+        goto exit;
+    }
+
+    uctx = to_user_mode_ctx(thread_get_tsd()->ctx);
+    if (uctx == NULL) {
+        log_error("get uctx failed, mmb_name:%s\n", mmb->name);
+        goto exit;
+    }
+
+    mmz_trace(MMZ_LEVEL_INFO, MMB_MEM_INFO, mmb_mem_info_input(mmb));
+
+    res = vm_map(uctx, &virt_addr, size, TEE_MATTR_URW, VM_FLAG_PERMANENT, mobj,
+                 offs);
+    if (res != TD_SUCCESS) {
+        log_error("vm_map failed, mmb_name:%s\n", mmb->name);
+        goto exit;
+    }
+
+    osal_mutex_lock(&g_mmb_mutex);
+    mmb->flags |= TEE_MMB_MAP2USER;
+    if (mmb->cache) {
+        mmb->flags |= TEE_MMB_MAP2USER_CACHED;
+    } else {
+        mmb->flags &= ~TEE_MMB_MAP2USER_CACHED;
+    }
+    osal_mutex_unlock(&g_mmb_mutex);
+
+    mobj_put(mobj);
+
+    return (td_virt_addr_t)virt_addr;
+
+exit:
+    refcount_dec(&mmb->user_cnt);
+    if (mobj != NULL) {
+        mobj_put(mobj);
+    }
+    return NULL;
+}
+
+td_s32 mmb_mem_unmap_user_virt(td_virt_addr_t virt_addr, td_size_t size)
+{
+    struct user_mode_ctx *uctx = NULL;
+    td_s32 ret;
+
+    tee_mmb_t *mmb = NULL;
+
+    mmb = mmb_mem_getby_phys(osal_virt_to_phys(virt_addr));
+    if (mmb == NULL) {
+        log_error("mmb not find\n");
+        return TD_FAILURE;
+    }
+
+    if (refcount_val(&mmb->user_cnt) == 0) {
+        log_warn("The mmb_user_cnt is zero, mmb_name:%s\n", mmb->name);
+        return TD_FAILURE;
+    }
+
+    uctx = to_user_mode_ctx(thread_get_tsd()->ctx);
+    if (uctx == NULL) {
+        log_error("get uctx failed, mmb_name:%s\n", mmb->name);
+        return TD_FAILURE;
+    }
+
+    mmz_trace(MMZ_LEVEL_INFO, MMB_MEM_INFO, mmb_mem_info_input(mmb));
+
+    ret = vm_unmap(uctx, (uintptr_t)virt_addr, size);
+    if (ret != TD_SUCCESS) {
+        log_error("vm_unmap failed, mmb_name:%s\n", mmb->name);
+        return TD_FAILURE;
+    }
+
+    osal_mutex_lock(&g_mmb_mutex);
+    mmb->flags &= ~TEE_MMB_MAP2USER;
+    mmb->flags &= ~TEE_MMB_MAP2USER_CACHED;
+    osal_mutex_unlock(&g_mmb_mutex);
+
+    if (refcount_val(&mmb->user_cnt) == 1) {
+        mmb_mem_free_mmb(mmb);
+        mmb = NULL;
+    } else {
+        refcount_dec(&mmb->user_cnt);
+    }
+
+    return TD_SUCCESS;
+}
+
+td_void *mmb_mem_map_phys_to_kernel_virt(tee_mmb_t *mmb)
+{
+    td_s32 ret;
+
+    mmb->mobj = mobj_reg_sec_mmz_alloc(mmb->phys_addr, mmb->size, mmb->cache);
+    if (mmb->mobj == NULL) {
+        log_error("creat mobj failed, mmb_name:%s\n", mmb->name);
+        return NULL;
+    }
+
+    ret = mobj_reg_sec_mmz_kmap(mmb->mobj);
+    if (ret != TD_SUCCESS) {
+        log_error("kmap failed, mmb_name:%s\n", mmb->name);
+        goto exit;
+    }
+
+    mmz_trace(MMZ_LEVEL_INFO, MMB_MEM_INFO, mmb_mem_info_input(mmb));
+
+    osal_mutex_lock(&g_mmb_mutex);
+    mmb->flags |= TEE_MMB_MAP2KERN;
+    if (mmb->cache) {
+        mmb->flags |= TEE_MMB_MAP2KERN_CACHED;
+    } else {
+        mmb->flags &= ~TEE_MMB_MAP2KERN_CACHED;
+    }
+
+    mmb->kvirt = mobj_get_va(mmb->mobj, 0, mmb->size);
+    osal_mutex_unlock(&g_mmb_mutex);
+
+    refcount_set(&mmb->map_kernel_cnt, 1);
+
+    return mmb->kvirt;
+
+exit:
+    if (mmb->mobj != NULL) {
+        mobj_put(mmb->mobj);
+    }
+
+    return NULL;
+}
+
+td_s32 mmb_mem_unmap_kernel_virt(tee_mmb_t *mmb)
+{
+    td_s32 ret;
+
+    if (refcount_val(&mmb->map_kernel_cnt) == 0) {
+        log_warn("The mmb map_kernel_cnt is zero, mmb_name:%s\n", mmb->name);
+    } else {
+        refcount_dec(&mmb->map_kernel_cnt);
+    }
+
+    if (refcount_val(&mmb->map_kernel_cnt) > 0) {
+        log_warn("The mmb map_kernel_cnt is %d, mmb_name:%s\n",
+                 refcount_val(&mmb->map_kernel_cnt), mmb->name);
+        return TD_SUCCESS;
+    }
+
+    mmz_trace(MMZ_LEVEL_INFO, MMB_MEM_INFO, mmb_mem_info_input(mmb));
+
+    ret = mobj_reg_sec_mmz_kunmap(mmb->mobj);
+    if (ret != TD_SUCCESS) {
+        log_error("kunmap failed, mmb_name:%s\n", mmb->name);
+        return TD_FAILURE;
+    }
+
+    mobj_put(mmb->mobj);
+
+    osal_mutex_lock(&g_mmb_mutex);
+    mmb->kvirt = NULL;
+    mmb->flags &= ~TEE_MMB_MAP2KERN;
+    mmb->flags &= ~TEE_MMB_MAP2KERN_CACHED;
+    osal_mutex_unlock(&g_mmb_mutex);
+
+    if (mmb_mem_get_zone_by_phys(mmb->phys_addr, mmb->size) == MMZ_TYPE_SMMZ1 &&
+        refcount_val(&mmb->user_cnt) == 1) {
+        mmb_mem_free_mmb(mmb);
+        mmb = NULL;
+    }
+
+    return TD_SUCCESS;
+}
+
+static tee_mmb_t *mach_mmb_by_phys(td_phys_addr_t phys_addr)
+{
+    tee_mmz_t *__mach_mmb_zone__ = NULL;
+    list_for_each_entry(__mach_mmb_zone__, &mmz_list, list)
+    {
+        tee_mmb_t *__mach_mmb__ = NULL;
+        list_for_each_entry(__mach_mmb__, &__mach_mmb_zone__->mmb_list, list)
+        {
+            if (((uintptr_t)__mach_mmb__->phys_addr <=
+                 (uintptr_t)(phys_addr)) &&
+                (((uintptr_t)__mach_mmb__->phys_addr + __mach_mmb__->size) >
+                 (uintptr_t)(phys_addr))) {
+                return __mach_mmb__;
+            }
+        }
+    }
+    return NULL;
+}
+
+static tee_mmb_t *mach_mmb_by_virt(const td_virt_addr_t virt_addr)
+{
+    tee_mmz_t *__mach_mmb_zone__ = NULL;
+    list_for_each_entry(__mach_mmb_zone__, &mmz_list, list)
+    {
+        tee_mmb_t *__mach_mmb__ = NULL;
+        list_for_each_entry(__mach_mmb__, &__mach_mmb_zone__->mmb_list, list)
+        {
+            if (((uintptr_t)__mach_mmb__->kvirt <= (uintptr_t)(virt_addr)) &&
+                (((uintptr_t)__mach_mmb__->kvirt + __mach_mmb__->size) >
+                 (uintptr_t)(virt_addr))) {
+                return __mach_mmb__;
+            }
+        }
+    }
+    return NULL;
+}
+
+tee_mmb_t *mmb_mem_getby_phys(td_phys_addr_t phys_addr)
+{
+    tee_mmb_t *p = NULL;
+
+    p = mach_mmb_by_phys(phys_addr);
+
+    return p;
+}
+
+tee_mmb_t *mmb_mem_getby_kvirt(const td_virt_addr_t virt_addr)
+{
+    tee_mmb_t *p = NULL;
+
+    if (virt_addr == NULL) {
+        log_error("virt is NULL\n");
+        return NULL;
+    }
+
+    p = mach_mmb_by_virt(virt_addr);
+
+    return p;
+}
+
+td_void mmb_mem_flush_cache(td_void *addr, td_length_t size)
+{
+    osal_dcache_region_wb(addr, 0, size);
+}
+
+td_void mmb_mem_invalid_cache(td_void *addr, td_length_t size)
+{
+    osal_dcache_region_inv(addr, size);
+}
+
+td_void mmb_mem_flush_mmb(tee_mmb_t *mmb)
+{
+    if (mmb != NULL && (mmb->flags & TEE_MMB_MAP2KERN_CACHED) != 0 &&
+        mmb->kvirt != 0) {
+        mmb_mem_flush_cache((void *)mmb->kvirt, mmb->size);
+    }
+}
+
+td_void mmb_mem_dump(const td_char *name)
+{
+    tee_mmz_t *p = NULL;
+    tee_mmb_t *q = NULL;
+    td_s32 mmb_no;
+
+    list_for_each_entry(p, &mmz_list, list)
+    {
+        if (strcmp(p->name, name) != 0) {
+            continue;
+        }
+        osal_printk("----------------------------------------------------------"
+                    "------------------------------\n");
+        osal_printk("Name=%s  Size=0x%lx  \n",
+                    (p->name != NULL) ? p->name : "null", p->size);
+        osal_printk("----------------------------------------------------------"
+                    "------------------------------\n");
+
+        mmb_no = 0;
+        list_for_each_entry(q, &p->mmb_list, list)
+        {
+            if (mmb_no == 0) {
+                osal_printk("No.  Name             Size       Flags      Cache "
+                            "     User_cnt\n");
+            }
+            osal_printk("%-4d %-16s 0x%08lx 0x%08lx 0x%08d 0x%08x\n", mmb_no,
+                        q->name, q->size, q->flags, q->cache,
+                        refcount_val(&q->user_cnt));
+            mmb_no++;
+        }
+    }
+    osal_printk("--------------------------------------------------------------"
+                "--------------------------\n");
+}
+
+td_void mmb_mem_destroy_by_uuid(TEE_UUID *uuid)
+{
+    tee_mmz_t *p = NULL;
+    tee_mmb_t *q = NULL;
+
+    if (uuid == NULL) {
+        log_error("uuid is NULL\n");
+        return;
+    }
+
+    list_for_each_entry(p, &mmz_list, list)
+    {
+        list_for_each_entry(q, &p->mmb_list, list)
+        {
+            /* If the UUID of the current mmb is equal to the UUID of the
+               current TA, and the current memory is not mapped in kernel state,
+               it will be released */
+            if (q->uuid != NULL &&
+                memcmp(q->uuid, uuid, sizeof(TEE_UUID)) == 0 &&
+                refcount_val(&q->map_kernel_cnt) == 0) {
+                mmb_mem_free_mmb(q);
+                /* If the reference count of the current memory is still greater
+                   than or equal to 1 after the release, execute the release
+                   operation again */
+                if (refcount_val(&q->user_cnt) >= 1) {
+                    mmb_mem_free_mmb(q);
+                }
+            }
+        }
+    }
+}
+
+td_bool mmb_is_phys_in_smmz(mmz_types type, td_phys_addr_t phys_addr,
+                            td_size_t size)
+{
+    smmz_info *smmz = type == MMZ_TYPE_SMMZ1 ? g_smmz1_info : g_smmz2_info;
+
+    if (size >= MAX_SIZE) {
+        log_error("size is invalid!\n");
+        return TD_FALSE;
+    }
+
+    if (CHECK_WRONG_SIZE(size, smmz) ||
+        CHECK_WRONG_ADDR(phys_addr, size, smmz)) {
+        return TD_FALSE;
+    } else {
+        return TD_TRUE;
+    }
+}
+
+td_s32 mmb_mem_get_zone_by_phys(td_phys_addr_t phys_addr, td_size_t size)
+{
+    for (mmz_types type = MMZ_TYPE_SMMZ1; type <= MMZ_TYPE_SMMZ2; ++type) {
+        if (mmb_is_phys_in_smmz(type, phys_addr, size)) {
+            return type;
+        }
+    }
+
+    return TD_FAILURE;
+}
+
+td_void drv_mmz_destroy_mmb(TEE_UUID *uuid)
+{
+    mmb_mem_destroy_by_uuid(uuid);
+}
diff --git a/bsp/mmz/drivers/src/smmz_common/mmz_usr.c b/bsp/mmz/drivers/src/smmz_common/mmz_usr.c
new file mode 100644
index 0000000..b68634e
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_common/mmz_usr.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: MMZ Intermediate interface for user
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include "mmz_usr.h"
+#include "mmz_intf.h"
+#include "osal_addr.h"
+#include "memtag.h"
+#include "mm/vm.h"
+#include "kernel/user_mode_ctx.h"
+
+static TEE_Result check_buffer(const td_void *buffer, td_size_t size)
+{
+	td_u32 flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER;
+    struct ts_session *s = ts_get_current_session();
+
+	buffer = memtag_strip_tag_const(buffer);
+	return vm_check_access_rights(to_user_mode_ctx(s->ctx), flags,
+				      (vaddr_t)buffer, size);
+}
+
+td_s32 usr_mmz_alloc_map_nocache(td_phys_addr_t *phys_addr,
+                                 td_virt_addr_t *virt_addr,
+                                 const td_char *mmb_name,
+                                 const td_char *zone_name, td_size_t size)
+{
+    if (mmb_name == NULL || zone_name == NULL) {
+        return TD_FAILURE;
+    }
+
+    if (mmz_check_name_and_size(zone_name, size) != TD_SUCCESS) {
+        return TD_FAILURE;
+    }
+
+    if (virt_addr == NULL || phys_addr == NULL) {
+        log_error("NULL point error\n");
+        return TD_FAILURE;
+    }
+
+    if (check_buffer(zone_name, strlen(zone_name) + 1) != TEE_SUCCESS) {
+        log_error("zone_name buffer access error!\n");
+        return TD_FAILURE;
+    }
+
+    if (check_buffer(mmb_name, strlen(mmb_name) + 1) != TEE_SUCCESS) {
+        log_error("mmb_name buffer access error!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_alloc_and_map_mmb(
+        phys_addr, virt_addr, mmb_name, zone_name, size, NO_CACHE);
+}
+
+td_s32 usr_mmz_alloc_map_cached(td_phys_addr_t *phys_addr,
+                                td_virt_addr_t *virt_addr,
+                                const td_char *mmb_name,
+                                const td_char *zone_name, td_size_t size)
+{
+    if (mmb_name == NULL || zone_name == NULL) {
+        return TD_FAILURE;
+    }
+
+    if (mmz_check_name_and_size(zone_name, size) != TD_SUCCESS) {
+        return TD_FAILURE;
+    }
+
+    if (virt_addr == NULL || phys_addr == NULL) {
+        log_error("NULL point error\n");
+        return TD_FAILURE;
+    }
+
+    if (check_buffer(zone_name, strlen(zone_name) + 1) != TEE_SUCCESS) {
+        log_error("zone_name buffer access error!\n");
+        return TD_FAILURE;
+    }
+
+    if (check_buffer(mmb_name, strlen(mmb_name) + 1) != TEE_SUCCESS) {
+        log_error("mmb_name buffer access error!\n");
+        return TD_FAILURE;
+    }
+
+    return mmz_alloc_and_map_mmb(
+        phys_addr, virt_addr, mmb_name, zone_name, size, CACHED);
+}
+
+td_s32 usr_mmz_unmap_and_free(td_phys_addr_t phys_addr,
+                              td_virt_addr_t virt_addr)
+{
+    if (mmb_is_phys_in_smmz(MMZ_TYPE_SMMZ2, phys_addr, 0) != TD_TRUE) {
+        log_error("phys_addr is not match!\n");
+        return TD_FAILURE;
+    }
+
+    if (virt_addr == NULL) {
+        log_error("NULL point error\n");
+        return TD_FAILURE;
+    }
+
+    if (mmz_check_phys_virt_match(phys_addr, virt_addr) != TD_SUCCESS) {
+        return TD_FAILURE;
+    }
+
+    if (mmz_check_ta(phys_addr) != TD_SUCCESS) {
+        return TD_FAILURE;
+    }
+
+    return mmz_unmap_and_free_mmb(phys_addr, virt_addr);
+}
+
+td_void *usr_mmz_mmap_nocache(td_phys_addr_t phys_addr, td_size_t size)
+{
+    if (mmz_check_phys_user(phys_addr, size) != TD_SUCCESS) {
+        log_error("check phys and size failed");
+        return NULL;
+    }
+
+    return mmz_map_phys_to_user_virt(phys_addr, size, NO_CACHE);
+}
+
+td_void *usr_mmz_mmap_cached(td_phys_addr_t phys_addr, td_size_t size)
+{
+    if (mmz_check_phys_user(phys_addr, size) != TD_SUCCESS) {
+        log_error("check phys and size failed");
+        return NULL;
+    }
+
+    return mmz_map_phys_to_user_virt(phys_addr, size, CACHED);
+}
+
+td_s32 usr_mmz_munmap(td_virt_addr_t virt_addr, td_size_t size)
+{
+    if (virt_addr == NULL) {
+        log_error("NULL point error\n");
+        return TD_FAILURE;
+    }
+
+    if (mmz_check_phys_user(osal_virt_to_phys(virt_addr), size) != TD_SUCCESS) {
+        log_error("check phys and size failed");
+        return TD_FAILURE;
+    }
+
+    return mmz_unmap_user_virt(virt_addr, size);
+}
+
+td_s32 usr_mmz_flush_cache(td_phys_addr_t phys_addr, td_virt_addr_t virt_addr,
+                           td_size_t size)
+{
+    if (mmz_check_phys_virt_match(phys_addr, virt_addr) != TD_SUCCESS) {
+        return TD_FAILURE;
+    }
+
+    if (mmz_check_phys_user(phys_addr, size) != TD_SUCCESS) {
+        log_error("check phys and size failed");
+        return TD_FAILURE;
+    }
+
+    return mmz_flush_cache(virt_addr, size);
+}
+
+td_s32 usr_mmz_get_mem_info(td_virt_addr_t virt_addr, mem_info *m_info)
+{
+    if (virt_addr == NULL || m_info == NULL) {
+        log_error("NULL point error\n");
+        return TD_FAILURE;
+    }
+
+    if (mmz_check_ta(osal_virt_to_phys(virt_addr)) != TD_SUCCESS) {
+        return TD_FAILURE;
+    }
+
+    return mmz_get_virt_mem_info(virt_addr, m_info);
+}
diff --git a/bsp/mmz/drivers/src/smmz_inside/build.mak b/bsp/mmz/drivers/src/smmz_inside/build.mak
new file mode 100644
index 0000000..7d9722b
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_inside/build.mak
@@ -0,0 +1 @@
+MMZ_SMMZ_INSIDE_OBJS += smmz_inside/mmz_smmz_inside.c
diff --git a/bsp/mmz/drivers/src/smmz_inside/mmz_smmz_inside.c b/bsp/mmz/drivers/src/smmz_inside/mmz_smmz_inside.c
new file mode 100644
index 0000000..a7d850c
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_inside/mmz_smmz_inside.c
@@ -0,0 +1,242 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: MMZ underlying implementation of SMMZ_INSIDE
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include "mmz_smmz_inside.h"
+#include "mmz_intf.h"
+#include "mmz_mem.h"
+#include "osal_addr.h"
+#include "osal_mutex.h"
+#include "securec.h"
+
+#ifndef PAGE_SIZE
+#define PAGE_SIZE (1 << 12)
+#endif
+#define MMZ_GRAIN PAGE_SIZE
+
+#define mmz_align2(x, g)      ((((x) + (g)-1) / (g)) * (g))
+#define mmz_grain_align(x)    mmz_align2(x, MMZ_GRAIN)
+#define mmz_length2grain(len) (mmz_grain_align(len) / MMZ_GRAIN)
+
+/* Memory optimal allocation algorithm.
+ * 1.Calculates the memory gap between each mmb application memory by mmb_list.
+ * Mmb_list is sorted by physical address.
+ * 2.Match the minimum memory gap that is not less than the size of the
+ * requested memory. The size of the requested memory will be aligned with the
+ * page table size of 4k. 3.Return the address of the gap.
+ */
+static td_phys_addr_t _find_fixed_region(td_phys_addr_t *region_len,
+                                         tee_mmz_t *mmz, td_size_t size)
+{
+    td_phys_addr_t start;
+    td_length_t len;
+    td_phys_addr_t fixed_start = 0;
+    td_length_t blank_len;
+    td_size_t tmp;
+    td_ulong fixed_len = (td_ulong)-1;
+    tee_mmb_t *p = NULL;
+
+    /* Align physical addresses first */
+    start = mmz_align2(mmz->phys_start, MMZ_GRAIN);
+    len = mmz_grain_align(size);
+    tmp = (td_size_t)len;
+
+    list_for_each_entry(p, &mmz->mmb_list, list)
+    {
+        tee_mmb_t *next = NULL;
+        mmz_trace(MMZ_LEVEL_DBG, "p->phys_addr=0x%08lX p->size = %luKB \t",
+                  p->phys_addr, p->size / SZ_1K);
+        next = list_entry(p->list.next, typeof(*p), list);
+        mmz_trace(MMZ_LEVEL_DBG, ",next = 0x%08lX\n\n", next->phys_addr);
+
+        /* If p is the first memory block */
+        if (list_first_entry(&mmz->mmb_list, typeof(*p), list) == p) {
+            blank_len = p->phys_addr - start;
+            if ((blank_len < fixed_len) && (blank_len >= len)) {
+                fixed_len = blank_len;
+                fixed_start = start;
+                mmz_trace(MMZ_LEVEL_DBG,
+                          "%d: fixed_region: start=0x%08lX, len=%luKB\n",
+                          __LINE__, fixed_start, fixed_len / SZ_1K);
+            }
+        }
+
+        start = mmz_align2((p->phys_addr + p->size),
+                           MMZ_GRAIN);  // start align to usr's align
+        if ((start < mmz->phys_start) ||
+            (start > (mmz->phys_start + mmz->size))) {
+            return TD_SUCCESS;
+        }
+
+        /* If memory is requested after the last memory block */
+        if (list_is_last(&p->list, &mmz->mmb_list) != 0) {
+            blank_len = mmz->phys_start + mmz->size - start;
+            if ((blank_len < fixed_len) && (blank_len >= len)) {
+                fixed_len = blank_len;
+                fixed_start = start;
+                mmz_trace(MMZ_LEVEL_DBG,
+                          "%d: fixed_region: start=0x%08lX, len=%luKB\n",
+                          __LINE__, fixed_start, fixed_len / SZ_1K);
+                break;
+            } else {
+                if (fixed_len != (td_ulong)-1)
+                    goto out;
+                fixed_start = 0;
+                mmz_trace(MMZ_LEVEL_DBG,
+                          "%d: fixed_region: start=0x%08lX, len=%luKB\n",
+                          __LINE__, fixed_start, fixed_len / SZ_1K);
+                goto out;
+            }
+        }
+
+        /* If the gap between two blocks is too small */
+        if ((start + len) > next->phys_addr) {
+            mmz_trace(MMZ_LEVEL_DBG, "start=0x%08lX ,len=%lu,next=0x%08lX\n",
+                      start, len, next->phys_addr);
+            continue;
+        }
+
+        blank_len = next->phys_addr - start;
+        if ((blank_len < fixed_len) && (blank_len >= len)) {
+            fixed_len = blank_len;
+            fixed_start = start;
+            mmz_trace(MMZ_LEVEL_DBG,
+                      "%d: fixed_region: start=0x%08lX, len=%luKB\n", __LINE__,
+                      fixed_start, fixed_len / SZ_1K);
+        }
+    }
+
+    tmp = tmp + (td_size_t)start;
+    /* When the physical address and size are within the range of mmz, the
+       initial address of mmz meets the requirements and the current area meets
+       the requirements */
+    if ((mmz_grain_align(start + len) <= (mmz->phys_start + mmz->size)) &&
+        (start >= mmz->phys_start) && (start < (mmz->phys_start + mmz->size)) &&
+        (tmp > (td_size_t)start) &&
+        (tmp <= (td_size_t)(mmz->phys_start + mmz->size))) {
+        fixed_len = len;
+        fixed_start = start;
+        mmz_trace(MMZ_LEVEL_DBG, "%d: fixed_region: start=0x%08lX, len=%luKB\n",
+                  __LINE__, fixed_start, fixed_len / SZ_1K);
+    } else {
+        fixed_start = 0;
+        mmz_trace(MMZ_LEVEL_DBG, "%d: fixed_region: start=0x%08lX, len=%luKB\n",
+                  __LINE__, fixed_start, len / SZ_1K);
+    }
+
+out:
+    *region_len = len;
+
+    return fixed_start;
+}
+
+/* This function is performed only twice. For the first time, the fixed_mmz
+ * is searched in the smmz area under the current die. If the fixed_mmz
+ * cannot be found in the current die, it searches for the fixed_mmz
+ * in the smmz area of other dies.
+ */
+static td_bool find_optimal_mmz(const td_char *mmz_name, td_length_t align_size,
+                                tee_mmz_t **fixed_mmz,
+                                td_phys_addr_t *fixed_start,
+                                td_bool alloc_in_cur_die)
+{
+    tee_mmz_t *mmz = NULL;
+    int cur_die_id = 0;
+    td_phys_addr_t start = 0;
+    td_length_t fixed_len = (td_length_t)-1;
+    td_length_t region_len = 0;
+    struct list_head *mmz_list = get_mmz_list();
+
+
+    list_for_each_entry(mmz, mmz_list, list)
+    {
+        if (strncmp(mmz_name, mmz->name, MEM_MAX_NAME_LEN) != EOK ||
+            (alloc_in_cur_die && cur_die_id != mmz->die_id) ||
+            (!alloc_in_cur_die && cur_die_id == mmz->die_id)) {
+            continue;
+        }
+
+        mmz_trace(MMZ_LEVEL_DBG, MMZ_MEM_INFO, mmz_mem_info_input(mmz));
+        start = _find_fixed_region(&region_len, mmz, align_size);
+        if ((fixed_len > region_len) && (start != 0)) {
+            fixed_len = region_len;
+            *fixed_start = start;
+            *fixed_mmz = mmz;
+        }
+    }
+
+    return *fixed_mmz == NULL ? false : true;
+}
+
+tee_mmb_t *mmb_mem_alloc_smmz2(const td_char *name, td_size_t size,
+                               const td_char *mmz_name)
+{
+    tee_mmb_t *mmb = NULL;
+    td_size_t align_size;
+    td_phys_addr_t fixed_start = 0;
+    tee_mmz_t *fixed_mmz = NULL;
+    td_bool ret = false;
+
+    align_size = mmz_grain_align(size);
+    if ((align_size == 0) || (align_size > MEM_LIMIT_SIZE)) {
+        log_error("invalid alloc size! size:%lx\n", size);
+        return NULL;
+    }
+
+    if (find_optimal_mmz(mmz_name, align_size, &fixed_mmz, &fixed_start,
+                         true) == false) {
+        ret = find_optimal_mmz(mmz_name, align_size, &fixed_mmz, &fixed_start,
+                               false);
+        if (ret != true) {
+            log_error("malloc failed! fixed_mmz == NULL\n");
+            return NULL;
+        }
+    }
+
+    mmb = osal_vmalloc(sizeof(tee_mmb_t));
+    if (mmb == NULL) {
+        log_error("malloc failed\n");
+        return NULL;
+    }
+    memset_s(mmb, sizeof(tee_mmb_t), 0, sizeof(tee_mmb_t));
+
+    if (strlen(name) != 0) {
+        if (strcpy_s(mmb->name, MEM_MAX_NAME_LEN + 1, name) != EOK) {
+            log_error("copy mmb name failed\n");
+            goto exit;
+        }
+    } else {
+        if (strcpy_s(mmb->name, MEM_MAX_NAME_LEN + 1, "--") != EOK) {
+            log_error("copy mmb name failed\n");
+            goto exit;
+        }
+    }
+    mmb->zone = fixed_mmz;
+    mmb->phys_addr = fixed_start;
+    mmb->size = size;
+    mmb->mmz_type = MMZ_TYPE_SMMZ2;
+    refcount_set(&mmb->user_cnt, 1);
+
+    mmb->uuid = mmb_mem_get_uuid();
+
+    smmz_inside_mutex_lock();
+    list_add_mmb(mmb);
+    smmz_inside_mutex_unlock();
+
+    return mmb;
+
+exit:
+    if (mmb != NULL) {
+        osal_vfree(mmb);
+        mmb = NULL;
+    }
+    return NULL;
+}
+
+td_void drv_mmz_dump_smmz2(td_void)
+{
+    mmz_dump("SMMZ2");
+}
diff --git a/bsp/mmz/drivers/src/smmz_shared/build.mak b/bsp/mmz/drivers/src/smmz_shared/build.mak
new file mode 100644
index 0000000..15be153
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_shared/build.mak
@@ -0,0 +1 @@
+MMZ_SMMZ_SHARED_OBJS += smmz_shared/mmz_smmz_shared.c
diff --git a/bsp/mmz/drivers/src/smmz_shared/mmz_smmz_shared.c b/bsp/mmz/drivers/src/smmz_shared/mmz_smmz_shared.c
new file mode 100644
index 0000000..1371f6c
--- /dev/null
+++ b/bsp/mmz/drivers/src/smmz_shared/mmz_smmz_shared.c
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: MMZ underlying implementation of SMMZ_SHARED
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include "mmz_smmz_shared.h"
+#include "mmz_mem.h"
+#include "mmz_intf.h"
+#include "osal_addr.h"
+#include "osal_mutex.h"
+#include "securec.h"
+
+TEE_Result register_smmz1_block(const struct smmz1_info *info)
+{
+    struct smmz1_info *info_on_list = NULL;
+    struct smmz1_blocks *blocks = mmb_mem_get_smmz1_blocks();
+    ssize_t info_size;
+
+    if (info == NULL) {
+        panic("register smmz error!!!");
+        return TEE_ERROR_OVERFLOW;
+    }
+
+    info_size = sizeof(*info_on_list) + sizeof(TEE_UUID) * info->uuid_num;
+
+    info_on_list = nex_calloc(1, info_size);
+    if (info_on_list == NULL) {
+        DMSG("register smmz error!!!");
+        goto error_out;
+    }
+
+    if (memcpy_s(info_on_list, info_size, info, info_size)) {
+        DMSG("register smmz error!!!");
+        goto error_out;
+    }
+
+    LIST_INSERT_HEAD(blocks->smmz1_info, info_on_list, link);
+    blocks->block_num++;
+    return TEE_SUCCESS;
+
+error_out:
+    if (info_on_list != NULL) {
+        nex_free(info_on_list);
+    }
+    return TEE_ERROR_OVERFLOW;
+}
+
+static struct smmz1_info_list_head g_smmz1_info_list __nex_data =
+    LIST_HEAD_INITIALIZER(smmz1_info_list_head);
+static struct smmz1_blocks g_smmz1_block = {0, &g_smmz1_info_list};
+
+struct smmz1_blocks *mmb_mem_get_smmz1_blocks(td_void)
+{
+    return &g_smmz1_block;
+}
+
+td_s32 mmz_check_smmz1(td_phys_addr_t phys_addr, td_size_t size)
+{
+    const struct smmz1_blocks *blocks = mmb_mem_get_smmz1_blocks();
+    const struct smmz1_info *psmmz1_info = NULL;
+    td_s32 ret;
+
+    ret = mmb_is_phys_overlap(g_smmz1_info, phys_addr, size);
+    if (ret == TD_TRUE) {
+        log_error("phys overlap!\n");
+        return TD_FAILURE;
+    }
+
+    LIST_FOREACH(psmmz1_info, blocks->smmz1_info, link)
+    {
+        if (phys_addr >= psmmz1_info->phys_addr &&
+            phys_addr + size <= psmmz1_info->phys_addr + psmmz1_info->size) {
+            for (int i = 0; i < psmmz1_info->uuid_num; i++) {
+                if (memcmp(&psmmz1_info->uuids[i], mmb_mem_get_uuid(),
+                           sizeof(TEE_UUID)) == 0) {
+                    return TD_SUCCESS;
+                }
+            }
+        }
+    }
+
+    return TD_FAILURE;
+}
+
+td_s32 mmz_check_ta_smmz1(td_phys_addr_t phys_addr, td_size_t size,
+                          TEE_UUID *uuid)
+{
+    const struct smmz1_blocks *blocks = mmb_mem_get_smmz1_blocks();
+    const struct smmz1_info *psmmz1_info = NULL;
+    td_s32 ret;
+
+    ret = mmb_is_phys_overlap(g_smmz1_info, phys_addr, size);
+    if (ret == TD_TRUE) {
+        log_error("phys overlap!\n");
+        return TD_FAILURE;
+    }
+
+    LIST_FOREACH(psmmz1_info, blocks->smmz1_info, link)
+    {
+        if (phys_addr >= psmmz1_info->phys_addr &&
+            phys_addr + size <= psmmz1_info->phys_addr + psmmz1_info->size) {
+            for (td_s32 uuid_num = 0; uuid_num < psmmz1_info->uuid_num;
+                 uuid_num++) {
+                if (memcmp(uuid, &psmmz1_info->uuids[uuid_num],
+                           sizeof(TEE_UUID)) == 0) {
+                    return TD_SUCCESS;
+                }
+            }
+        }
+    }
+
+    log_error("uuid is not match");
+    return TD_FAILURE;
+}
+
+tee_mmb_t *mmb_mem_alloc_smmz1(td_phys_addr_t phys_addr, td_size_t size,
+                               td_bool cache)
+{
+    tee_mmz_t *mmz = NULL;
+    tee_mmb_t *mmb = NULL;
+    struct list_head *mmz_list = get_mmz_list();
+
+
+    mmb = osal_vmalloc(sizeof(tee_mmb_t));
+    if (mmb == NULL) {
+        log_error("malloc failed\n");
+        return NULL;
+    }
+    memset_s(mmb, sizeof(tee_mmb_t), 0, sizeof(tee_mmb_t));
+
+    list_for_each_entry(mmz, mmz_list, list)
+    {
+        if (strcmp(mmz->name, "SMMZ1") == 0) {
+            mmb->zone = mmz;
+        }
+    }
+
+    mmb->phys_addr = phys_addr;
+    mmb->size = size;
+    mmb->cache = cache;
+    mmb->mmz_type = MMZ_TYPE_SMMZ1;
+    refcount_set(&mmb->user_cnt, 1);
+
+    mmb->uuid = mmb_mem_get_uuid();
+
+    if (mmb->uuid == NULL) {
+        if (strcpy_s(mmb->name, MEM_MAX_NAME_LEN + 1, "smmz1_mmb") != EOK) {
+            log_error("copy mmb name failed\n");
+            goto exit;
+        }
+    } else if (snprintf_s(mmb->name, MEM_MAX_NAME_LEN + 1, MEM_MAX_NAME_LEN,
+                          "mmb_%x", mmb->uuid->timeLow) < 0) {
+        log_error("copy uuid failed, mmb_name:%s\n", mmb->name);
+        goto exit;
+    }
+
+    smmz_shared_mutex_lock();
+    list_add_mmb(mmb);
+    smmz_shared_mutex_unlock();
+
+    return mmb;
+exit:
+    if (mmb != NULL) {
+        osal_vfree(mmb);
+        mmb = NULL;
+    }
+
+    return NULL;
+}
+
+td_void drv_mmz_dump_smmz1(td_void)
+{
+    mmz_dump("SMMZ1");
+}
+
+struct smmz1_blocks *drv_mmz_get_smmz1_blocks(td_void)
+{
+    return mmb_mem_get_smmz1_blocks();
+}
diff --git a/bsp/mmz/drivers/src/sub.mk b/bsp/mmz/drivers/src/sub.mk
new file mode 100644
index 0000000..1a67505
--- /dev/null
+++ b/bsp/mmz/drivers/src/sub.mk
@@ -0,0 +1,29 @@
+MMZ_API_DIR := bsp/mmz/lib
+MMZ_DRV_DIR := bsp/mmz/drivers
+
+MMZ_CFLAGS += -I$(MMZ_DRV_DIR)/src/include
+MMZ_CFLAGS += -I$(MMZ_DRV_DIR)/include
+MMZ_CFLAGS += -I$(MMZ_API_DIR)/include
+MMZ_CFLAGS += -I core/arch/arm/include/mm
+MMZ_CFLAGS += -I core/include
+MMZ_CFLAGS += -I core/include/kernel
+MMZ_CFLAGS += -I core/include/tee
+MMZ_CFLAGS += -I core/include/mm
+MMZ_CFLAGS += -I core/arch/arm/include/kernel
+MMZ_CFLAGS += -I core/arch/arm/include/tee
+MMZ_CFLAGS += -I bsp/osal/include
+MMZ_CFLAGS += -I bsp/tzasc/include
+
+include $(MMZ_DRV_DIR)/src/smmz_common/build.mak
+include $(MMZ_DRV_DIR)/src/smmz_inside/build.mak
+include $(MMZ_DRV_DIR)/src/smmz_shared/build.mak
+
+-include $(MMZ_DRV_DIR)/src/drv_test/build.mak
+
+cflags-y += $(MMZ_CFLAGS)
+
+ccflags-y += $(cflags-y)
+
+srcs-y += $(MMZ_DRV_OBJS)
+srcs-y += $(MMZ_SMMZ_INSIDE_OBJS)
+srcs-$(CFG_SMMZ_SHARED_SUPPORT) += $(MMZ_SMMZ_SHARED_OBJS)
diff --git a/bsp/mmz/drivers/sub.mk b/bsp/mmz/drivers/sub.mk
new file mode 100644
index 0000000..d825ad4
--- /dev/null
+++ b/bsp/mmz/drivers/sub.mk
@@ -0,0 +1,4 @@
+global-incdirs-y += src/include
+global-incdirs-y += include
+
+subdirs-y += src
diff --git a/bsp/mmz/lib/include/mpi_mmz.h b/bsp/mmz/lib/include/mpi_mmz.h
new file mode 100644
index 0000000..7c298e6
--- /dev/null
+++ b/bsp/mmz/lib/include/mpi_mmz.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related mpi interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef MPI_MMZ_H
+#define MPI_MMZ_H
+
+#include "ot_type.h"
+
+struct memory_infomation {
+    td_size_t size;
+    td_s32 cache;
+};
+typedef struct memory_infomation mem_info;
+typedef struct memory_infomation ot_sys_virt_mem_info;
+
+/*
+ * brief            Alloc SMMZ2 memory and map to uvirt.
+ *
+ * output:
+ * phys_addr        The physical address of the alloced memory.
+ * virt_addr        The virtual address of the alloced memory.
+ * input:
+ * mmb              The name of mmb, less than 16 characters.
+ * zone             The name of zone, less than 16 characters.
+ * len              Length of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 mpi_sys_mmz_alloc(td_phys_addr_t *phys_addr, td_void **virt_addr,
+    const td_char *mmb, const td_char *zone, td_u32 len);
+
+/*
+ * brief            Alloc SMMZ2 memory and map to uvirt.
+ *
+ * output:
+ * phys_addr        The physical address of the alloced memory.
+ * virt_addr        The virtual address of the alloced memory.
+ * input:
+ * mmb              The name of mmb, less than 16 characters.
+ * zone             the name of zone, less than 16 characters.
+ * len              Length of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 mpi_sys_mmz_alloc_cached(td_phys_addr_t *phys_addr, td_void **virt_addr,
+    const td_char *mmb, const td_char *zone, td_u32 len);
+
+/*
+ * brief            Free SMMZ2 memory and unmap the uvirt.
+ *
+ * Note:            Physical and virtual addresses must correspond to each other.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * virt_addr        The virtual address of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 mpi_sys_mmz_free(td_phys_addr_t phys_addr, td_void *virt_addr);
+
+/*
+ * brief            Map phys_addr to uvirt without cache.
+ *
+ * Note:            The size must be corresponding to the physical address.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           Virt_addr != NULL if successful
+ */
+td_void *mpi_sys_mmap(td_phys_addr_t phys_addr, td_u32 size);
+
+/*
+ * brief            Map phys_addr to uvirt with cache.
+ *
+ * Note:            The size must be corresponding to the physical address.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           Virt_addr != NULL if successful
+ */
+td_void *mpi_sys_mmap_cached(td_phys_addr_t phys_addr, td_u32 size);
+
+/*
+ * brief            Unmap the uvirt.
+ *
+ * Note:            The size must be corresponding to the virtual address.
+ *
+ * virt_addr        The virtual address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 mpi_sys_munmap(td_void *virt_addr, td_u32 size);
+
+/*
+ * brief            Clean and invalidate cache.
+ *
+ * Note:            The size must be corresponding to the virtual address.
+ *
+ * phys_addr        The physical address of the alloced memory.
+ * virt_addr        The virtual address of the alloced memory.
+ * size             Size of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 mpi_sys_flush_cache(td_phys_addr_t phys_addr, td_void *virt_addr, td_u32 size);
+
+/*
+ * brief            Get mem info by virtual address.
+ *
+ * virt_addr        The virtual address of the alloced memory.
+ * mem_info         The mem_info of the alloced memory.
+ *
+ * return           0 if successful
+ */
+td_s32 mpi_sys_get_virt_mem_info(td_void *virt_addr, ot_sys_virt_mem_info *mem_info);
+
+#endif /* MPI_MMZ_H */
diff --git a/bsp/mmz/lib/src/api/build.mak b/bsp/mmz/lib/src/api/build.mak
new file mode 100644
index 0000000..58b24d1
--- /dev/null
+++ b/bsp/mmz/lib/src/api/build.mak
@@ -0,0 +1,6 @@
+MMZ_API_OBJS += api/mpi_mmz.c
+
+MMZ_API_CFLAGS += -I$(MMZ_API_DIR)/include
+MMZ_API_CFLAGS += -I$(MMZ_DRV_DIR)/src/include
+MMZ_API_CFLAGS += -I$(MMZ_DRV_DIR)/include
+MMZ_API_CFLAGS += -I$(MMZ_DRV_DIR)/../osal/include
diff --git a/bsp/mmz/lib/src/api/mpi_mmz.c b/bsp/mmz/lib/src/api/mpi_mmz.c
new file mode 100644
index 0000000..2e0d599
--- /dev/null
+++ b/bsp/mmz/lib/src/api/mpi_mmz.c
@@ -0,0 +1,255 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: MMZ user interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <utee_syscalls.h>
+#include "securec.h"
+#include "drv_mmz_ioctl.h"
+#include "mpi_mmz.h"
+
+td_s32 mpi_sys_mmz_alloc(td_phys_addr_t *phys_addr, td_void **virt_addr,
+    const td_char *mmb, const td_char *zone, td_u32 len)
+{
+    td_s32 ret;
+    mmz_alloc_t alloc;
+    TEE_MMZ_Data data = {};
+    td_char func[] = "syscall_mmz_ioctl";
+
+    if (phys_addr == NULL || virt_addr == NULL) {
+        OT_PRINT("NULL point ERROR");
+    }
+
+    if (memset_s(&alloc, sizeof(alloc), 0, sizeof(alloc)) != EOK) {
+        OT_PRINT("memset ERROR!");
+        return TD_FAILURE;
+    }
+
+    alloc.phys_addr = *phys_addr;
+    alloc.virt_addr = *virt_addr;
+    alloc.mmb_name = mmb;
+    alloc.zone_name = zone;
+    alloc.size = len;
+
+    data.cmd = CMD_MMZ_ALLOC;
+    data.param = &alloc;
+
+    ret = _utee_pick_function(UTEE_PICK_FUNCTION, func, &data, sizeof(data));
+    if (ret != TD_SUCCESS) {
+        OT_PRINT("mpi_sys_mmz_alloc ERROR!");
+        return ret;
+    }
+
+    *phys_addr = alloc.phys_addr;
+    *virt_addr = alloc.virt_addr;
+    return TD_SUCCESS;
+}
+
+td_s32 mpi_sys_mmz_alloc_cached(td_phys_addr_t *phys_addr, td_void **virt_addr,
+    const td_char *mmb, const td_char *zone, td_u32 len)
+{
+    td_s32 ret;
+    mmz_alloc_t alloc;
+    TEE_MMZ_Data data = {};
+    td_char func[] = "syscall_mmz_ioctl";
+
+    if (phys_addr == NULL || virt_addr == NULL) {
+        OT_PRINT("NULL point ERROR");
+    }
+
+    if (memset_s(&alloc, sizeof(alloc), 0, sizeof(alloc)) != EOK) {
+        OT_PRINT("memset ERROR!");
+        return TD_FAILURE;
+    }
+
+    alloc.virt_addr = *virt_addr;
+    alloc.phys_addr = *phys_addr;
+    alloc.mmb_name = mmb;
+    alloc.zone_name = zone;
+    alloc.size = len;
+
+    data.cmd = CMD_MMZ_ALLOC_CACHED;
+    data.param = &alloc;
+
+    ret = _utee_pick_function(UTEE_PICK_FUNCTION, func, &data, sizeof(data));
+    if (ret != TD_SUCCESS) {
+        OT_PRINT("mpi_sys_mmz_alloc_cached ERROR!");
+        return ret;
+    }
+
+    *phys_addr = alloc.phys_addr;
+    *virt_addr = alloc.virt_addr;
+    return TD_SUCCESS;
+}
+
+td_s32 mpi_sys_mmz_free(td_phys_addr_t phys_addr, td_void *virt_addr)
+{
+    td_s32 ret;
+    mmz_free_t free;
+    TEE_MMZ_Data data = {};
+    td_char func[] = "syscall_mmz_ioctl";
+
+    if (memset_s(&free, sizeof(free), 0, sizeof(free)) != EOK) {
+        OT_PRINT("memset ERROR!");
+        return TD_FAILURE;
+    }
+
+    free.phys_addr = phys_addr;
+    free.virt_addr = virt_addr;
+
+    data.cmd = CMD_MMZ_FREE;
+    data.param = &free;
+
+    ret = _utee_pick_function(UTEE_PICK_FUNCTION, func, &data, sizeof(data));
+    if (ret != TD_SUCCESS) {
+        OT_PRINT("mpi_sys_mmz_free ERROR!");
+        return ret;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_void *mpi_sys_mmap(td_phys_addr_t phys_addr, td_u32 size)
+{
+    td_s32 ret;
+    mmz_mmap_t mmap;
+    td_void *virt_addr = NULL;
+    TEE_MMZ_Data data = {};
+    td_char func[] = "syscall_mmz_ioctl";
+
+    if (memset_s(&mmap, sizeof(mmap), 0, sizeof(mmap)) != EOK) {
+        OT_PRINT("memset ERROR!");
+        return NULL;
+    }
+
+    mmap.phys_addr = phys_addr;
+    mmap.size = size;
+    mmap.virt_addr = virt_addr;
+
+    data.cmd = CMD_MMZ_MMAP;
+    data.param = &mmap;
+
+    ret = _utee_pick_function(UTEE_PICK_FUNCTION, func, &data, sizeof(data));
+    if (ret != TD_SUCCESS) {
+        OT_PRINT("mpi_sys_mmap ERROR!");
+        return NULL;
+    }
+
+    virt_addr = mmap.virt_addr;
+    return virt_addr;
+}
+
+td_void *mpi_sys_mmap_cached(td_phys_addr_t phys_addr, td_u32 size)
+{
+    td_s32 ret;
+    mmz_mmap_t mmap;
+    td_void *virt_addr = NULL;
+    TEE_MMZ_Data data = {};
+    td_char func[] = "syscall_mmz_ioctl";
+
+    if (memset_s(&mmap, sizeof(mmap), 0, sizeof(mmap)) != EOK) {
+        OT_PRINT("memset ERROR!");
+        return NULL;
+    }
+
+    mmap.phys_addr = phys_addr;
+    mmap.size = size;
+    mmap.virt_addr = virt_addr;
+
+    data.cmd = CMD_MMZ_MMAP_CACHED;
+    data.param = &mmap;
+
+    ret = _utee_pick_function(UTEE_PICK_FUNCTION, func, &data, sizeof(data));
+    if (ret != TD_SUCCESS) {
+        OT_PRINT("mpi_sys_mmap_cached ERROR!");
+        return NULL;
+    }
+
+    virt_addr = mmap.virt_addr;
+    return virt_addr;
+}
+
+td_s32 mpi_sys_munmap(td_void *virt_addr, td_u32 size)
+{
+    td_s32 ret;
+    mmz_munmap_t munmap;
+    TEE_MMZ_Data data = {};
+    td_char func[] = "syscall_mmz_ioctl";
+
+    if (memset_s(&munmap, sizeof(munmap), 0, sizeof(munmap)) != EOK) {
+        OT_PRINT("memset ERROR!");
+        return TD_FAILURE;
+    }
+
+    munmap.virt_addr = virt_addr;
+    munmap.size = size;
+
+    data.cmd = CMD_MMZ_MUNMAP;
+    data.param = &munmap;
+
+    ret = _utee_pick_function(UTEE_PICK_FUNCTION, func, &data, sizeof(data));
+    if (ret != TD_SUCCESS) {
+        OT_PRINT("mpi_sys_munmap ERROR!");
+        return ret;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mpi_sys_flush_cache(td_phys_addr_t phys_addr, td_void *virt_addr, td_u32 size)
+{
+    td_s32 ret;
+    mmz_flush_cache_t flush;
+    TEE_MMZ_Data data = {};
+    td_char func[] = "syscall_mmz_ioctl";
+
+    if (memset_s(&flush, sizeof(flush), 0, sizeof(flush)) != EOK) {
+        OT_PRINT("memset ERROR!");
+        return TD_FAILURE;
+    }
+
+    flush.virt_addr = virt_addr;
+    flush.phys_addr = phys_addr;
+    flush.size = size;
+
+    data.cmd = CMD_MMZ_FLUSH_CACHE;
+    data.param = &flush;
+
+    ret = _utee_pick_function(UTEE_PICK_FUNCTION, func, &data, sizeof(data));
+    if (ret != TD_SUCCESS) {
+        OT_PRINT("mpi_sys_flush_cache ERROR!");
+        return ret;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 mpi_sys_get_virt_mem_info(td_void *virt_addr, ot_sys_virt_mem_info *m_info)
+{
+    td_s32 ret;
+    mmz_get_info_t get_info;
+    TEE_MMZ_Data data = {};
+    td_char func[] = "syscall_mmz_ioctl";
+
+    if (memset_s(&get_info, sizeof(get_info), 0, sizeof(get_info)) != EOK) {
+        OT_PRINT("memset ERROR!");
+        return TD_FAILURE;
+    }
+
+    get_info.virt_addr = virt_addr;
+    get_info.m_info = m_info;
+
+    data.cmd = CMD_MMZ_GET_INFO;
+    data.param = &get_info;
+
+    ret = _utee_pick_function(UTEE_PICK_FUNCTION, func, &data, sizeof(data));
+    if (ret != TD_SUCCESS) {
+        OT_PRINT("mpi_sys_get_virt_mem_info ERROR!");
+        return ret;
+    }
+
+    return TD_SUCCESS;
+}
+
diff --git a/bsp/mmz/lib/src/sub.mk b/bsp/mmz/lib/src/sub.mk
new file mode 100644
index 0000000..d7beb42
--- /dev/null
+++ b/bsp/mmz/lib/src/sub.mk
@@ -0,0 +1,16 @@
+MMZ_API_DIR := bsp/mmz/lib
+MMZ_DRV_DIR := bsp/mmz/drivers
+
+MMZ_CFLAGS += -I$(MMZ_API_DIR)/src/api
+MMZ_CFLAGS += -I$(MMZ_API_DIR)/include
+MMZ_CFLAGS += -I$(MMZ_DRV_DIR)/src/include
+MMZ_CFLAGS += -I$(MMZ_DRV_DIR)/include
+MMZ_CFLAGS += -Ibsp/osal/include
+
+# Add objs
+include $(MMZ_API_DIR)/src/api/build.mak
+
+cflags-y += $(MMZ_CFLAGS)
+
+srcs-y += $(MMZ_API_OBJS)
+
diff --git a/bsp/mmz/lib/sub.mk b/bsp/mmz/lib/sub.mk
new file mode 100644
index 0000000..25712c4
--- /dev/null
+++ b/bsp/mmz/lib/sub.mk
@@ -0,0 +1,2 @@
+global-incdirs-y += include
+subdirs-y += src
diff --git a/bsp/npu/README.md b/bsp/npu/README.md
new file mode 100644
index 0000000..9ce99af
--- /dev/null
+++ b/bsp/npu/README.md
@@ -0,0 +1,2 @@
+# optee_npu
+
diff --git a/bsp/npu/drivers/include/inside_secboot.h b/bsp/npu/drivers/include/inside_secboot.h
new file mode 100644
index 0000000..64e0fd8
--- /dev/null
+++ b/bsp/npu/drivers/include/inside_secboot.h
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2014, STMicroelectronics International N.V.
+ */
+#ifndef INIT_SECBOOT_H
+#define INIT_SECBOOT_H
+
+#include <mm/core_memprot.h>
+
+#define SVP_NPU0_REGS_ADDR        0x14000000
+#define SVP_NPU0_REGS_SIZE        0x10000
+
+__asm__(".section .data\n" \
+".global incbin_secboot_start\n" \
+".balign 16\n" \
+"incbin_secboot_start:\n" \
+".incbin \"../secure_boot.om\"\n" \
+\
+".global incbin_secboot_end\n" \
+".balign 1\n" \
+"incbin_secboot_end:\n" \
+".byte 0\n" \
+".fill 0xa00,1,0\n" \
+);
+extern const __attribute__((aligned(16))) void* incbin_secboot_start;
+extern const void* incbin_secboot_end;
+
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    sec_boot_en           : 1; /* [0] */
+        unsigned int    sec_boot_jump_end     : 1; /* [1] */
+        unsigned int    sec_boot_dbg_out_en   : 1; /* [2] */
+        unsigned int    sec_boot_end_layer_mode : 1; /* [3] */
+        unsigned int    reserved_0            : 28; /* [31..4] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_sec_boot_ctrl;
+
+/* Define the union u_hwts_glb_config_s */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int hwts_aicore0_mode     : 1; /* [0] */
+        unsigned int hwts_aicpu0_int_mode  : 1; /* [1] */
+        unsigned int hwts_aicore0_srst_crush_en : 1; /* [2] */
+        unsigned int hwts_cpu_sec_mode     : 1; /* [3] */
+        unsigned int reserved_0            : 28; /* [31..4] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int u32;
+} u_hwts_glb_config_s;
+
+typedef struct {
+	u_sec_boot_ctrl	 sec_boot_ctrl; /* 0x40 */
+	unsigned int		sec_boot_code_base_addr_l; /* 0x44 */
+	unsigned int		sec_boot_code_base_addr_h; /* 0x48 */
+	unsigned int		sec_boot_code_base_length; /* 0x4c */
+	unsigned int		sec_boot_code_addr; /* 0x50 */
+	unsigned int		sec_boot_code_length; /* 0x54 */
+	unsigned int		sec_boot_start_pc; /* 0x58 */
+} svp_npu_sec_boot_hal;
+
+register_phys_mem(MEM_AREA_IO_SEC, SVP_NPU0_REGS_ADDR, SVP_NPU0_REGS_SIZE);
+#endif
\ No newline at end of file
diff --git a/bsp/npu/drivers/src/inside_secboot.c b/bsp/npu/drivers/src/inside_secboot.c
new file mode 100644
index 0000000..e73bcc4
--- /dev/null
+++ b/bsp/npu/drivers/src/inside_secboot.c
@@ -0,0 +1,180 @@
+#include "inside_secboot.h"
+#include <memory_zone.h>
+#include <tee/tee_svc_security_subsys.h>
+#include <mmz_ext.h>
+#include <mmz_common.h>
+#include <utee_types.h>
+#include <tee_api_types.h>
+#include <kernel/thread.h>
+#include <kernel/user_access.h>
+#include <mm/core_memprot.h>
+#include <osal_addr.h>
+#include "securec.h"
+
+#define SVP_NPU_MAX_CLASS_NUM 0x10
+#define SVP_NPU_MAX_MODEL_NUM 0x20
+#define SVP_NPU_RULE_NUM_PER_ONE_MODEL 0x10
+#define SVP_NPU_SECBOOT_OFFSET 0x40
+#define SVP_NPU_ADDR_MAX 0xFFFFFFFF
+#define SVP_NPU_REGS_SECBOOT 0x14000040
+#define SVP_NPU_REGS_HWTS 0x14008004
+#define SVP_NPU_WHOLE_TABLE_SIZE 0x9c0
+#define SVP_NPU_CLASS_OFFSET 0xc
+
+typedef struct {
+	uint64_t table_addr;
+	uint32_t table_size;
+} npu_params;
+typedef struct {
+	uint32_t base_addr_start;
+	uint32_t base_addr_end;
+	uint32_t class : 4;
+	uint32_t rsv   : 28;
+} svp_npu_class_table;
+
+typedef struct {
+	uint32_t table_addr_start;
+	uint32_t table_addr_end;
+	uint64_t rsv;
+	uint64_t ct_table_addr;
+	uint32_t ct_table_size;
+	uint32_t ct_table_num;
+	uint64_t smrt_table_addr;
+	uint32_t smrt_table_size;
+	uint32_t smrt_table_num;
+	uint64_t rt_table_addr;
+	uint32_t rt_table_size;
+	uint32_t rt_table_num;
+} svp_npu_task_table;
+
+static TEE_Result npu_init_sec_boot_info(td_void)
+{
+	td_u64 inc_bin_addr = (td_u64)virt_to_phys(&incbin_secboot_start);
+	td_u32 inc_bin_size = (td_u64)&incbin_secboot_end - (td_u64)&incbin_secboot_start;
+	u_hwts_glb_config_s hwts_glb_config_s = {
+		.bits.hwts_aicpu0_int_mode = 1
+	};
+	svp_npu_sec_boot_hal *sec_boot_hal = (svp_npu_sec_boot_hal *)phys_to_virt(SVP_NPU_REGS_SECBOOT,
+		MEM_AREA_IO_SEC, 0x4000);
+	td_u32 *sec_hwts_config = (td_u32 *)phys_to_virt(SVP_NPU_REGS_HWTS, MEM_AREA_IO_SEC, 0x4000);
+	svp_npu_task_table *table = (svp_npu_task_table *)&incbin_secboot_start;
+
+	if (sec_boot_hal == TD_NULL) {
+		EMSG("Error! map reg %#x failed!\n", SVP_NPU_REGS_SECBOOT);
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+	if (sec_hwts_config == TD_NULL) {
+		EMSG("Error! map reg %#x failed!\n", SVP_NPU_REGS_HWTS);
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+	sec_boot_hal->sec_boot_ctrl.bits.sec_boot_jump_end = 0;
+	sec_boot_hal->sec_boot_ctrl.bits.sec_boot_dbg_out_en = 0;
+	sec_boot_hal->sec_boot_ctrl.bits.sec_boot_end_layer_mode = 0;
+	sec_boot_hal->sec_boot_ctrl.bits.sec_boot_en = 1;
+	sec_boot_hal->sec_boot_code_base_addr_l = inc_bin_addr;
+	sec_boot_hal->sec_boot_code_base_addr_h = 0;
+	sec_boot_hal->sec_boot_code_base_length = inc_bin_size + SVP_NPU_WHOLE_TABLE_SIZE;
+	sec_boot_hal->sec_boot_code_addr = SVP_NPU_SECBOOT_OFFSET;
+	sec_boot_hal->sec_boot_code_length = inc_bin_size - SVP_NPU_SECBOOT_OFFSET;
+	sec_boot_hal->sec_boot_start_pc = 0;
+	*sec_hwts_config = hwts_glb_config_s.u32;
+	table->ct_table_addr = (td_u64)virt_to_phys(&incbin_secboot_end);
+	table->ct_table_size = SVP_NPU_MAX_CLASS_NUM * (td_u32)sizeof(svp_npu_class_table);
+	table->ct_table_num = SVP_NPU_MAX_CLASS_NUM;
+	table->smrt_table_addr = table->ct_table_addr + table->ct_table_size;
+	table->smrt_table_size = SVP_NPU_MAX_MODEL_NUM * (td_u32)sizeof(td_u64);
+	table->smrt_table_num = SVP_NPU_MAX_MODEL_NUM;
+	table->rt_table_addr = table->smrt_table_addr + table->smrt_table_size;
+	table->rt_table_size = SVP_NPU_MAX_MODEL_NUM * SVP_NPU_RULE_NUM_PER_ONE_MODEL * (td_u32)sizeof(td_u32);
+	table->rt_table_num = SVP_NPU_MAX_MODEL_NUM * SVP_NPU_RULE_NUM_PER_ONE_MODEL;
+	table->table_addr_start = table->ct_table_addr >> SVP_NPU_CLASS_OFFSET;
+	table->table_addr_end = (table->ct_table_addr + SVP_NPU_WHOLE_TABLE_SIZE) >> SVP_NPU_CLASS_OFFSET + 1;
+	return TEE_SUCCESS;
+}
+
+static TEE_Result npu_init_class_table(td_void)
+{
+	uint32_t i = 0;
+	svp_npu_class_table *data = (svp_npu_class_table *)&incbin_secboot_end;
+	const struct class_table_list_head *class_list = get_npu_class_list();
+	struct class_table_entry *node = TD_NULL;
+	if (class_list == TD_NULL) {
+		EMSG("Error! Get class table failed!\n");
+		return TEE_ERROR_ITEM_NOT_FOUND;
+	}
+	LIST_FOREACH(node, class_list, link)
+	{
+		data[i].class = node->num;
+		data[i].rsv = 0;
+		data[i].base_addr_start = node->addr >> SVP_NPU_CLASS_OFFSET;
+		data[i].base_addr_end = (node->addr + node->size) >> SVP_NPU_CLASS_OFFSET;
+		i++;
+	}
+	data[i].class = 0;
+	data[i].rsv = 0;
+	data[i].base_addr_start = 0;
+	data[i].base_addr_end = SVP_NPU_ADDR_MAX;
+	return TEE_SUCCESS;
+}
+
+static TEE_Result npu_set_sec_table_info(td_u8 *data)
+{
+	td_u32 ret;
+	td_u32 class_table_size = SVP_NPU_MAX_CLASS_NUM * (td_u32)sizeof(svp_npu_class_table);
+	ret = memcpy_s(data, class_table_size, &incbin_secboot_end, class_table_size);
+	if (ret != EOK) {
+		EMSG("Error! copy class info failed\n");
+		return TEE_ERROR_GENERIC;
+	}
+	ret = memcpy_s(&incbin_secboot_end, SVP_NPU_WHOLE_TABLE_SIZE, data, SVP_NPU_WHOLE_TABLE_SIZE);
+	if (ret != EOK) {
+		EMSG("Error! set secboot info failed\n");
+		return TEE_ERROR_GENERIC;
+	}
+	return TEE_SUCCESS;
+}
+
+TEE_Result syscall_npu_ioctl(void *param, size_t param_len)
+{
+	npu_params params = *(npu_params *)param;
+	td_u64 table_addr;
+	td_u32 table_size;
+	td_u8 *data = TD_NULL;
+	TEE_Result ret = TD_FAILURE;
+	td_u32 exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
+	if (sizeof(params) != param_len) {
+		EMSG("check param_len failed!\n");
+		goto fail;
+	}
+
+	table_addr = params.table_addr;
+	table_size = params.table_size;
+	if (table_addr < SMMZ2_PHYS_START || table_addr > SMMZ2_PHYS_START + SMMZ2_SIZE - table_size ||
+		table_size != SVP_NPU_WHOLE_TABLE_SIZE) {
+		EMSG("Error! table addr or table size invalid!\n");
+		goto fail;
+	}
+	ret = npu_init_sec_boot_info();
+	if (ret != TEE_SUCCESS) {
+		EMSG("Error! init secboot info failed!\n");
+		goto fail;
+	}
+	ret = npu_init_class_table();
+	if (ret != TEE_SUCCESS) {
+		EMSG("Error! init class table failed!\n");
+		goto fail;
+	}
+	data = drv_mmz_map_nocache(table_addr, table_size);
+	if (data == TD_NULL) {
+		EMSG("Error! get secboot table addr failed!\n");
+		goto fail;
+	}
+	ret = npu_set_sec_table_info(data);
+	if (ret != TEE_SUCCESS) {
+		EMSG("Error! set secboot table info failed!\n");
+	}
+	(td_void)drv_mmz_unmap(data, table_size);
+fail:
+	thread_unmask_exceptions(exceptions);
+	return ret;
+}
diff --git a/bsp/npu/drivers/src/sub.mk b/bsp/npu/drivers/src/sub.mk
new file mode 100644
index 0000000..452c97e
--- /dev/null
+++ b/bsp/npu/drivers/src/sub.mk
@@ -0,0 +1,3 @@
+srcs-y += inside_secboot.c
+
+incdirs-y += ../include
\ No newline at end of file
diff --git a/bsp/npu/drivers/sub.mk b/bsp/npu/drivers/sub.mk
new file mode 100644
index 0000000..129621e
--- /dev/null
+++ b/bsp/npu/drivers/sub.mk
@@ -0,0 +1 @@
+subdirs-y += src
diff --git a/bsp/npu/lib/include/mpi_npu.h b/bsp/npu/lib/include/mpi_npu.h
new file mode 100644
index 0000000..c5cdf94
--- /dev/null
+++ b/bsp/npu/lib/include/mpi_npu.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal address
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef MPI_NPU_H
+#define MPI_NPU_H
+
+#include "ot_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+td_s32 mpi_sys_npu_init(td_u64 table_addr, td_u32 table_size);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* MPI_NPU_H */
diff --git a/bsp/npu/lib/include/ot_debug.h b/bsp/npu/lib/include/ot_debug.h
new file mode 100644
index 0000000..0e33e47
--- /dev/null
+++ b/bsp/npu/lib/include/ot_debug.h
@@ -0,0 +1,40 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2019, HiSilicon Technologies Co., Ltd.
+ */
+
+#ifndef __OT_DEBUG_H__
+#define __OT_DEBUG_H__
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#include <stdarg.h>
+#else
+#include <trace.h>
+#endif
+
+#include "ot_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#ifndef __KERNEL__
+
+#define OT_PRINT      printf
+
+#else
+
+#define OT_PRINT      IMSG
+
+#endif /* end of __KERNEL__ */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __OT_DEBUG_H__ */
diff --git a/bsp/npu/lib/include/ot_type.h b/bsp/npu/lib/include/ot_type.h
new file mode 100644
index 0000000..7e90d85
--- /dev/null
+++ b/bsp/npu/lib/include/ot_type.h
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ *
+ */
+
+#ifndef __OT_TYPE_H__
+#define __OT_TYPE_H__
+
+#ifdef __KERNEL__
+
+#include <string.h>
+#else
+
+#include <stdint.h>
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#ifndef NULL
+    #define NULL                0L
+#endif
+
+#define TD_NULL                 0L
+#define TD_SUCCESS              0
+#define TD_FAILURE              (-1)
+
+typedef unsigned char           td_uchar;
+typedef unsigned char           td_u8;
+typedef unsigned short          td_u16;
+typedef unsigned int            td_u32;
+typedef unsigned long           td_ulong;
+
+typedef char                    td_char;
+typedef signed char             td_s8;
+typedef short                   td_s16;
+typedef int                     td_s32;
+typedef long                    td_slong;
+
+typedef float                   td_float;
+typedef double                  td_double;
+
+typedef void                    td_void;
+
+#ifndef _M_IX86
+    typedef unsigned long long  td_u64;
+    typedef long long           td_s64;
+#else
+    typedef unsigned __int64    td_u64;
+    typedef __int64             td_s64;
+#endif
+
+typedef unsigned long           uintptr_t;
+
+typedef unsigned long           td_size_t;
+typedef unsigned long           td_length_t;
+typedef unsigned long int       td_phys_addr_t;
+typedef td_u32                  td_handle;
+typedef uintptr_t               td_uintptr_t;
+typedef unsigned int            td_fr32;
+
+typedef enum {
+    TD_FALSE = 0,
+    TD_TRUE  = 1,
+} td_bool;
+
+#ifndef __KERNEL__
+
+#define OT_PRINT      printf
+
+#else
+
+#define OT_PRINT      IMSG
+
+#endif /* end of __KERNEL__ */
+
+#define EOK    0
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __OT_TYPE_H__ */
+
diff --git a/bsp/npu/lib/src/mpi_npu.c b/bsp/npu/lib/src/mpi_npu.c
new file mode 100644
index 0000000..c1f383b
--- /dev/null
+++ b/bsp/npu/lib/src/mpi_npu.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal address
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <utee_syscalls.h>
+#include "mpi_npu.h"
+
+typedef struct {
+	td_u64 table_addr;
+	td_u32 table_size;
+} npu_params;
+td_s32 mpi_sys_npu_init(td_u64 table_addr, td_u32 table_size)
+{
+	npu_params data = {
+		.table_addr = table_addr,
+		.table_size = table_size
+	};
+	td_s32 ret = _utee_pick_function(UTEE_PICK_FUNCTION, "syscall_npu_ioctl", &data, sizeof(data));
+	if (ret != TD_SUCCESS) {
+		EMSG("Call syscall_npu_ioctl return [0x%08X]\n", ret);
+		return ret;
+	}
+
+	return TD_SUCCESS;
+}
\ No newline at end of file
diff --git a/bsp/npu/lib/src/sub.mk b/bsp/npu/lib/src/sub.mk
new file mode 100644
index 0000000..6414598
--- /dev/null
+++ b/bsp/npu/lib/src/sub.mk
@@ -0,0 +1,13 @@
+NPU_API_DIR := bsp/npu/lib
+
+NPU_CFLAGS += -I$(NPU_API_DIR)/src
+NPU_CFLAGS += -I$(NPU_API_DIR)/include
+
+NPU_API_OBJS += mpi_npu.c
+
+NPU_API_CFLAGS += -I$(MMZ_API_DIR)/include
+
+cflags-y += $(NPU_CFLAGS)
+
+srcs-y += $(NPU_API_OBJS)
+
diff --git a/bsp/npu/lib/sub.mk b/bsp/npu/lib/sub.mk
new file mode 100644
index 0000000..25712c4
--- /dev/null
+++ b/bsp/npu/lib/sub.mk
@@ -0,0 +1,2 @@
+global-incdirs-y += include
+subdirs-y += src
diff --git a/bsp/osal/README.md b/bsp/osal/README.md
new file mode 100644
index 0000000..35a65b7
--- /dev/null
+++ b/bsp/osal/README.md
@@ -0,0 +1,2 @@
+# optee_osal
+
diff --git a/bsp/osal/include/osal_addr.h b/bsp/osal/include/osal_addr.h
new file mode 100755
index 0000000..ae13ddb
--- /dev/null
+++ b/bsp/osal/include/osal_addr.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal address
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_ADDR_H__
+#define __OSAL_ADDR_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define OSAL_GFP_ZERO (0x1)
+#define OSAL_GFP_ATOMIC (0x1 << 1)
+#define OSAL_GFP_DMA (0x1 << 2)
+#define OSAL_GFP_KERNEL (0x1 << 3)
+#define OSAL_VERIFY_READ 0
+#define OSAL_VERIFY_WRITE 1
+/* The size make sure the example pass */
+#define OSAL_MEMPOOL_SIZE (1024 * 26)
+#define osal_readl(x) (*((volatile unsigned int *)(x)))
+#define osal_writel(v, x) (*((volatile unsigned int *)(x)) = (v))
+
+
+/**
+ * @ingroup osal_addr
+ * @brief Alloc dynamic memory.
+ *
+ * @par Description:
+ * This API is used to alloc a memory block of which the size is specified.
+ *
+ * @param size [in] How many bytes of memory are required.
+ * @param osal_gfp_flag [in] The type of memory to alloc.
+ * In OP-TEE, it must include one of the following access modes: OSAL_GFP_ATOMIC, OSAL_GFP_KERNEL.
+ */
+void *osal_kmalloc(unsigned long size, unsigned int osal_gfp_flag);
+
+/**
+ * @ingroup osal_addr
+ * @brief Free dynamic memory.
+ *
+ * @par Description:
+ * This API is used to free specified dynamic memory that has been allocd and update module mem used.
+ *
+ * @param addr [in] Starting address of the memory block to be freed.
+ */
+void osal_kfree(void *addr);
+
+/**
+ * @ingroup osal_addr
+ * @brief alloc virtually contiguous memory.
+ *
+ * @par Description:
+ * This API is used to alloc memory space with consecutive virtual addresses.
+ *
+ * @param size [in] How many bytes of memory are required.
+ *
+ * @return Returns the pointer to the virtual memory.
+ */
+void *osal_vmalloc(unsigned long size);
+
+/**
+ * @ingroup osal_addr
+ * @brief release memory allocd by vmalloc().
+ *
+ * @par Description:
+ * This API is used to release memory allocd by osal_vmalloc().
+ *
+ * @param addr [in] Starting address of the memory block to be freed.
+ */
+void osal_vfree(void *addr);
+
+/**
+ * @ingroup osal_addr
+ * @brief Initialize dynamic memory.
+ *
+ * @par Description:
+ * This API is used to initialize the dynamic memory of a doubly linked list.
+ *
+ * @attention
+ * The size parameter value should match the following two conditions:\n
+ * 1) Be less than or equal to the Memory pool size;\n
+ * 2) Be greater than the size of min_pool_size of each system.\n
+ * The parameter input must be 4 or 8 byte-aligned.
+ * The init area [pool, pool + size] should not conflict with other pools.
+ *
+ * @param pool [out] Starting address of memory.
+ * @param size [in] Memory size.
+ *
+ * @return OSAL_SUCCESS/OSAL_FAILURE
+ */
+int osal_pool_mem_init(void *pool, unsigned int size);
+
+/**
+ * @ingroup osal_addr
+ * @brief alloc dynamic memory.
+ *
+ * @par Description:
+ * This API is used to alloc a memory block of which the size is specified and update module mem used.
+ *
+ * @attention
+ * The input pool parameter must be initialized via func osal_pool_mem_init.
+ * The size of the input parameter size can not be greater than the memory pool size that specified at the second
+ * input parameter of osal_pool_mem_init.
+ * The size of the input parameter size must be four byte-aligned.
+ *
+ * @param pool [in] Pointer to the memory pool that contains the memory block to be allocd.
+ * @param size [in] Size of the memory block to be allocd (unit: byte).
+ *
+ * @retval NULL The memory fails to be allocd.
+ * @retval VOID* The memory is successfully allocd, and the API returns the pointer to the allocd memory block.
+ */
+void *osal_pool_mem_alloc(void *pool, unsigned long size);
+
+/**
+ * @ingroup osal_addr
+ * @brief Free dynamic memory.
+ *
+ * @par Description:
+ * This API is used to free specified dynamic memory that has been allocd.
+ *
+ * @attention
+ * The input pool parameter must be initialized via func osal_pool_mem_init.
+ * The input addr parameter must be allocd by osal_pool_mem_alloc or osal_pool_mem_alloc_align.
+ *
+ * @param  pool  [in] Pointer to the memory pool that contains the dynamic memory block to be freed.
+ * @param  addr  [in] Starting address of the memory block to be freed.
+ */
+void osal_pool_mem_free(void *pool, const void *addr);
+
+typedef enum {
+    OSAL_BLOCKMEM_VALID = 0,
+    OSAL_BLOCKMEM_INVALID_PHYADDR = 1,
+    OSAL_BLOCKMEM_INVALID_SIZE = 2,
+    OSAL_BLOCKMEM_MAX,
+} osal_blockmem_status;
+
+/**
+ * @ingroup osal_addr
+ * @brief Map bus memory into CPU space.
+ *
+ * @par Description:
+ * This API is used to map the device whose memory type is device memory and does not use the cache.
+ *
+ * In OP-TEE, before this API is used, must register the memory in the macro by
+ * using the following functions: register_phys_mem_pgdir(MEM_AREA_IO_SEC, phys_addr, size)
+ */
+
+void *osal_ioremap(unsigned long phys_addr, unsigned long size);
+
+/**
+ * @ingroup osal_addr
+ * @brief Map bus memory into CPU space.
+ *
+ * @par Description:
+ * Map bus memory into CPU space.The functions of osal_ioremap_nocache are the same as those of osal_ioremap.
+ * and reserved symbols for backward compatibility with drivers that use the osal_ioremap_nocache interface.
+ *
+ * @param phys_addr [in] bus address of the memory
+ * @param size [in] size of the resource to map
+ *
+ * @attention Must be freed with iounmap.
+ */
+void *osal_ioremap_nocache(unsigned long phys_addr, unsigned long size);
+
+/**
+ * @ingroup osal_addr
+ * @brief Map bus memory into CPU space.
+ *
+ * @par Description:
+ * This API is used to map the device whose memory type is normal memory and use the cache.
+ * This speeds up memory access and improves system performance.
+ */
+void *osal_ioremap_cached(unsigned long phys_addr, unsigned long size);
+
+/**
+ * @ingroup osal_addr
+ * @brief Free a IO remapping.
+ *
+ * @param addr [in] virtual address from ioremap_*.
+ *
+ * @attention Caller must ensure there is only one unmapping for the same pointer.
+ */
+void osal_iounmap(void *addr, unsigned long size);
+
+/**
+ * @ingroup osal_addr
+ * @brief Change physical addresses to virtual addresses.
+ */
+void *osal_phys_to_virt(unsigned long addr);
+
+/**
+ * @ingroup osal_addr
+ * @brief Change virtual addresses to physical addresses.
+ */
+unsigned long osal_virt_to_phys(const void *virt_addr);
+
+/**
+ * @ingroup osal_addr
+ * @brief copy_from_user.
+ *
+ * @param to   [out] The kernel address to which the data is copied.
+ * @param from [in] The user space address of the data to be copied.
+ * @param n    [in] Length of data to be copied (unit: bytes).
+ *
+ * @return 0 is returned on success; otherwise, the number of bytes that are not copied is returned.
+ */
+unsigned long osal_copy_from_user(void *to, const void *from, unsigned long n);
+
+/**
+ * @ingroup osal_addr
+ * @brief copy_to_user.
+ *
+ * @param to   [out] The user space address to which the data is copied.
+ * @param from [in] The kernel address of the data to be copied.
+ * @param n    [in] Length of data to be copied (unit: bytes).
+ *
+ * @return 0 is returned on success; otherwise, the number of bytes that are not copied is returned.
+ */
+unsigned long osal_copy_to_user(void *to, const void *from, unsigned long n);
+
+/**
+ * @ingroup osal_addr
+ * @brief Check whether the user space memory block is available.
+ *
+ * @param type [in] Access type. 0:read, 1:write.
+ * @param addr [in] A pointer variable to user space that points to the beginning of a memory block to be checked.
+ * @param size [in] Size of the memory block to be checked.
+ *
+ * @retval true   user space memory block is available.
+ * @retval false  user space memory block is unavailable.
+ */
+int osal_access_ok(int type, const void *addr, unsigned long size);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_ADDR_H__ */
diff --git a/bsp/osal/include/osal_atomic.h b/bsp/osal/include/osal_atomic.h
new file mode 100644
index 0000000..de4ee9f
--- /dev/null
+++ b/bsp/osal/include/osal_atomic.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal atomic
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_ATOMIC_H__
+#define __OSAL_ATOMIC_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+typedef struct {
+    volatile int counter;
+} osal_atomic;
+
+/**
+ * @ingroup osal_atomic
+ * @brief read atomic variable
+ *
+ * @par Description:
+ * This API is used to implement the atomic read and return the value read from the input parameter @atomic.
+ */
+int osal_atomic_read(osal_atomic *atomic);
+
+/**
+ * @ingroup osal_atomic
+ * @brief set atomic variable
+ *
+ * @par Description:
+ * This API is used to implement the atomic setting operation.
+ */
+void osal_atomic_set(osal_atomic *atomic, int i);
+
+/**
+ * @ingroup osal_atomic
+ * @brief increment atomic variable and return
+ *
+ * @par Description:
+ * This API is used to implement the atomic self-addition and return the self-addition result.
+ */
+int osal_atomic_inc_return(osal_atomic *atomic);
+
+/**
+ * @ingroup osal_atomic
+ * @brief decrement atomic variable and return
+ *
+ * @par Description:
+ * This API is used to implement the atomic self-decrement and return the self-decrement result.
+ */
+int osal_atomic_dec_return(osal_atomic *atomic);
+
+/**
+ * @ingroup osal_atomic
+ * @brief increment atomic variable
+ *
+ * @par Description:
+ * This API is used to implement the atomic self-addition.
+ */
+void osal_atomic_inc(osal_atomic *atomic);
+
+/**
+ * @ingroup osal_atomic
+ * @brief decrement atomic variable
+ *
+ * @par Description:
+ * This API is used to implement the atomic self-decrement.
+ */
+void osal_atomic_dec(osal_atomic *atomic);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_ATOMIC_H__ */
diff --git a/bsp/osal/include/osal_barrier.h b/bsp/osal/include/osal_barrier.h
new file mode 100755
index 0000000..3c8dd04
--- /dev/null
+++ b/bsp/osal/include/osal_barrier.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function related osal barrier
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_BARRIER_H__
+#define __OSAL_BARRIER_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/**
+ * @ingroup osal_barrier
+ * @brief Instruction Synchronization Barrier.
+ *
+ * @par Description:
+ * Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following
+ * the ISB are fetched from cache or memory, after the instruction has been completed. It ensures that the effects
+ * of context altering operations, such as changing the ASID, or completed TLB maintenance operations,
+ * or branch predictor maintenance operations, as well as all changes to the CP15 registers,
+ * executed before the ISB instruction are visible to the instructions fetched after the ISB.
+ * In addition, the ISB instruction ensures that any branches that appear in program order after it
+ * are always written into the branch prediction logic with the context that is visible after the ISB instruction.
+ * This is required to ensure correct execution of the instruction stream.
+ */
+void osal_isb(void);
+
+/**
+ * @ingroup osal_barrier
+ * @brief Data Synchronization Barrier.
+ *
+ * @par Description:
+ * Data Synchronization Barrier acts as a special kind of memory barrier. No instruction in program order after
+ * this instruction executes until this instruction completes. This instruction completes when:
+ *  All explicit memory accesses before this instruction complete.
+ *  All Cache, Branch predictor and TLB maintenance operations before this instruction complete.
+ */
+void osal_dsb(void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_BARRIER_H__ */
diff --git a/bsp/osal/include/osal_cache.h b/bsp/osal/include/osal_cache.h
new file mode 100755
index 0000000..afbd289
--- /dev/null
+++ b/bsp/osal/include/osal_cache.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function related osal cache
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef OSAL_CAHCE_H
+#define OSAL_CAHCE_H
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/**
+ * @ingroup osal_cache
+ * @brief flush DCache.
+ *
+ * @par Description:
+ * This API is used to flush DCache.
+ *
+ * @attention
+ * Make sure that phys_addr is valid when mmu does not exist, and user set its addr in kvirt.
+ *
+ * @param  phys_addr    [in] The start address need flush.
+ * @param  size         [in] The size of flush memory.
+ */
+void osal_dcache_region_wb(void *kvirt, unsigned long phys_addr, unsigned long size);
+
+/**
+ * @ingroup osal_cache
+ * @brief invalid DCache.
+ *
+ * @par Description:
+ * This API is used to invalid DCache.
+ *
+ * @param  addr         [in] The start address need invalid.
+ * @param  size         [in] The size of invalid memory.
+ */
+void osal_dcache_region_inv(void *addr, unsigned long size);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_CAHCE_H__ */
diff --git a/bsp/osal/include/osal_debug.h b/bsp/osal/include/osal_debug.h
new file mode 100644
index 0000000..2cb1885
--- /dev/null
+++ b/bsp/osal/include/osal_debug.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function related osal debug
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_DEBUG_H__
+#define __OSAL_DEBUG_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#ifdef OSAL_DEBUG
+#define OSAL_BUG() \
+    do             \
+    {              \
+    } while (1)
+#else
+#define OSAL_BUG()
+#endif
+
+#define OSAL_ASSERT(expr)                       \
+    do                                          \
+    {                                           \
+        if (!(expr))                            \
+        {                                       \
+            osal_printk("\nASSERT failed at:\n" \
+                        "  >Condition: %s\n",   \
+                        #expr);                 \
+            OSAL_BUG();                         \
+        }                                       \
+    } while (0)
+
+#define OSAL_BUG_ON(expr)                                                  \
+    do                                                                     \
+    {                                                                      \
+        if (expr)                                                          \
+        {                                                                  \
+            osal_printk("BUG: failure at %d/%s()!\n", __LINE__, __func__); \
+            OSAL_BUG();                                                    \
+        }                                                                  \
+    } while (0)
+
+/**
+ * @ingroup osal_debug
+ * @brief Log printing function.
+ */
+void osal_printk(const char *fmt, ...);
+
+/**
+ * @ingroup osal_debug
+ * @brief Kernel panic function.
+ *
+ * @par Description:
+ * Stack function that prints kernel panics.
+ * After this function is called and stack information is printed, the system will fail to respond.
+ */
+void osal_panic(const char *fmt, const char *fun, int line, const char *cond) __attribute__((noreturn));
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_DEBUG_H__ */
diff --git a/bsp/osal/include/osal_device.h b/bsp/osal/include/osal_device.h
new file mode 100644
index 0000000..9d9d001
--- /dev/null
+++ b/bsp/osal/include/osal_device.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal device
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_DEVICE_H__
+#define __OSAL_DEVICE_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define OSAL_DEV_NAME_LEN 32
+
+typedef struct osal_poll_ {
+    void *poll_table;
+    void *data;
+} osal_poll;
+
+typedef struct osal_ioctl_cmd_ {
+    unsigned int cmd;
+    int (*handler)(unsigned int cmd, void *arg, void *private_data);
+} osal_ioctl_cmd;
+
+typedef struct osal_vm_ {
+    void *vm;
+} osal_vm;
+
+typedef struct osal_fileops_ {
+    int (*open)(void *private_data);
+    int (*read)(char *buf, int size, long *offset, void *private_data);
+    int (*write)(const char *buf, int size, long *offset, void *private_data);
+    long (*llseek)(long offset, int whence, void *private_data);
+    int (*release)(void *private_data);
+    unsigned int (*poll)(osal_poll *osal_poll, void *private_data);
+    int (*mmap)(osal_vm *vm, unsigned long start, unsigned long end, unsigned long vm_pgoff, void *private_data);
+    int (*fasync)(int fd, void *filp, int mode);
+    osal_ioctl_cmd *cmd_list;
+    unsigned int cmd_cnt;
+} osal_fileops;
+
+typedef struct osal_pmops_ {
+    int (*pm_suspend)(void *private_data);
+    int (*pm_resume_early)(void *private_data);
+    int (*pm_resume)(void *private_data);
+    int (*pm_lowpower_enter)(void *private_data);
+    int (*pm_lowpower_exit)(void *private_data);
+    int (*pm_poweroff)(void *private_data);
+    void *private_data;
+} osal_pmops;
+
+typedef struct osal_dev_ {
+    char name[OSAL_DEV_NAME_LEN];
+    int minor;
+    unsigned int parent_minor;
+    osal_fileops *fops;
+    osal_pmops *pmops;
+    void *dev;
+} osal_dev;
+
+osal_dev *osal_dev_create(const char *name);
+
+int osal_dev_destroy(osal_dev *dev);
+
+int osal_dev_register(osal_dev *dev);
+
+void osal_dev_unregister(osal_dev *dev);
+
+int osal_remap_pfn_range(osal_vm *vm, unsigned long addr, unsigned long pfn, unsigned long size);
+
+void osal_pgprot_noncached(osal_vm *vm);
+
+void osal_pgprot_cached(osal_vm *vm);
+
+int osal_opendev(const char *path, int flag, ...);
+
+int osal_closedev(int fd);
+
+int osal_readdev(int fd, void *buf, unsigned long count);
+
+int osal_writedev(int fd, const void *buf, unsigned long count);
+
+int osal_ioctldev(int fd, unsigned int cmd, ...);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_DEVICE_H__ */
diff --git a/bsp/osal/include/osal_interrupt.h b/bsp/osal/include/osal_interrupt.h
new file mode 100755
index 0000000..c5484a4
--- /dev/null
+++ b/bsp/osal/include/osal_interrupt.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal interrupt
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_INTERRUPT_H__
+#define __OSAL_INTERRUPT_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define OSAL_CPU_ALL 0
+#define OSAL_CPU_0 (1 << 1)
+#define OSAL_CPU_1 (1 << 2)
+#define OSAL_CPU_2 (1 << 3)
+#define OSAL_CPU_3 (1 << 4)
+
+enum osal_irqreturn {
+    OSAL_IRQ_NONE = (0 << 0),
+    OSAL_IRQ_HANDLED = (1 << 0),
+    OSAL_IRQ_WAKE_THREAD = (1 << 1),
+};
+
+typedef int (*osal_irq_handler)(int, void *);
+
+/**
+ * @ingroup osal_interrupt
+ * @brief alloc an interrupt line.
+ *
+ * @param irq [in] Interrupt line to alloc.
+ * @param irq_handler [in] Function to be called when the IRQ occurs. Primary handler for threaded interrupts.
+ * If NULL and thread_fn != NULL the default primary handler is installed.
+ * @param thread_handler [in] Function called from the irq handler thread. If NULL, no irq thread is created.
+ * @param name [in] An ascii name for the claiming device.
+ * @param dev [in] A cookie passed back to the handler function.
+ *
+ * @return OSAL_SUCCESS/OSAL_FAILURE
+ */
+int osal_irq_request(unsigned int irq, osal_irq_handler irq_handler, \
+    osal_irq_handler thread_handler, const char *name, void *dev);
+
+/**
+ * @ingroup osal_interrupt
+ * @brief free an interrupt allocd with request_irq.
+ *
+ * @param irq [in] Interrupt line to free.
+ * @param dev [in] Device identity to free, maybe unused.
+ *
+ * @attention This function must not be called from interrupt context.
+ */
+void osal_irq_free(unsigned int irq, void *dev);
+
+/**
+ * @ingroup osal_interrupt
+ * @brief enable handling of an irq.
+ *
+ * @par Description:
+ * Undoes the effect of one call to disable_irq().
+ * If this matches the last disable, processing of interrupts on this IRQ line is re-enabled.
+ *
+ * @param irq [in] Interrupt to enable.
+ */
+void osal_irq_enable(unsigned int irq);
+
+/**
+ * @ingroup osal_interrupt
+ * @brief disable an irq and wait for completion.
+ *
+ * @par Description:
+ * Disable the selected interrupt line.
+ *
+ * @param irq [in] Interrupt to disable.
+ */
+void osal_irq_disable(unsigned int irq);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_INTERRUPT_H__ */
diff --git a/bsp/osal/include/osal_math.h b/bsp/osal/include/osal_math.h
new file mode 100755
index 0000000..7ea843a
--- /dev/null
+++ b/bsp/osal/include/osal_math.h
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function related osal math
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_MATH_H__
+#define __OSAL_MATH_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/**
+ * @ingroup osal_math
+ * @brief Unsigned 64bit divide with 32bit divisor.
+ *
+ * @par Description:
+ * Unsigned 64bit divide with 32bit divisor.
+ *
+ * @param dividend [in] unsigned 64bit dividend.
+ * @param divisor [in] unsigned 32bit divisor.
+ *
+ * @return Returns dividend / divisor.
+ *
+ * @attention Caller should ensure divisor not be zero
+ */
+unsigned long long osal_div_u64(unsigned long long dividend, unsigned int divisor);
+
+/**
+ * @ingroup osal_math
+ * @brief Signed 64bit divide with 32bit divisor.
+ *
+ * @par Description:
+ * Signed 64bit divide with 32bit divisor.
+ *
+ * @param dividend [in] signed 64bit dividend.
+ * @param divisor [in] signed 32bit divisor.
+ *
+ * @return Returns dividend / divisor.
+ *
+ * @attention Caller should ensure divisor not be zero
+ */
+long long osal_div_s64(long long dividend, int divisor);
+
+/**
+ * @ingroup osal_math
+ * @brief Unsigned 64bit divide with Unsigned 64bit divisor.
+ *
+ * @par Description:
+ * Unsigned 64bit divide with Unsigned 64bit divisor.
+ *
+ * @param dividend [in] unsigned 64bit dividend.
+ * @param divisor [in] unsigned 64bit divisor.
+ *
+ * @return Returns dividend / divisor.
+ *
+ * @attention Caller should ensure divisor not be zero
+ */
+unsigned long long osal_div64_u64(unsigned long long dividend, unsigned long long divisor);
+
+/**
+ * @ingroup osal_math
+ * @brief Signed 64bit divide with 64bit divisor.
+ *
+ * @par Description:
+ * Signed 64bit divide with 64bit divisor.
+ *
+ * @param dividend [in] signed 64bit dividend.
+ * @param divisor [in] signed 64bit divisor.
+ *
+ * @return Returns dividend / divisor.
+ *
+ * @attention Caller should ensure divisor not be zero
+ */
+long long osal_div64_s64(long long dividend, long long divisor);
+
+/**
+ * @ingroup osal_math
+ * @brief Unsigned 64bit divide with 32bit divisor with remainder.
+ *
+ * @par Description:
+ * Unsigned 64bit divide with 32bit divisor with remainder.
+ *
+ * @param dividend [in] unsigned 64bit dividend.
+ * @param divisor [in] unsigned 32bit divisor.
+ *
+ * @return Returns the remainder of dividend / divisor.
+ *
+ * @attention Caller should ensure divisor not be zero
+ */
+unsigned long long osal_div_u64_rem(unsigned long long dividend, unsigned int divisor);
+
+/**
+ * @ingroup osal_math
+ * @brief Signed 64bit divide with 32bit divisor with remainder.
+ *
+ * @par Description:
+ * Signed 64bit divide with 32bit divisor with remainder.
+ *
+ * @param dividend [in] signed 64bit dividend.
+ * @param divisor [in] signed 32bit divisor.
+ *
+ * @return Returns the remainder of dividend / divisor.
+ *
+ * @attention Caller should ensure divisor not be zero
+ */
+long long osal_div_s64_rem(long long dividend, int divisor);
+
+/**
+ * @ingroup osal_math
+ * @brief Unsigned 64bit divide with unsigned 64bit divisor with remainder.
+ *
+ * @par Description:
+ * Unsigned 64bit divide with unsigned 64bit divisor with remainder.
+ *
+ * @param dividend [in] unsigned 64bit dividend.
+ * @param divisor [in] unsigned 64bit divisor.
+ *
+ * @return Returns the remainder of dividend / divisor.
+ *
+ * @attention Caller should ensure divisor not be zero
+ */
+unsigned long long osal_div64_u64_rem(unsigned long long dividend, unsigned long long divisor);
+
+/**
+ * @ingroup osal_math
+ * @brief Random number generator.
+ *
+ * @par Description:
+ * Random number generator.
+ *
+ * @return Returns random number.
+ */
+unsigned int osal_get_random_int(void);
+
+#define osal_max(x, y)                     \
+    (                                      \
+        {                                  \
+            __typeof__(x) _max1 = (x);     \
+            __typeof__(y) _max2 = (y);     \
+            (void)(&_max1 == &_max2);      \
+            _max1 > _max2 ? _max1 : _max2; \
+        })
+
+#define osal_min(x, y)                     \
+    (                                      \
+        {                                  \
+            __typeof__(x) _min1 = (x);     \
+            __typeof__(y) _min2 = (y);     \
+            (void)(&_min1 == &_min2);      \
+            _min1 < _min2 ? _min1 : _min2; \
+        })
+
+#define osal_abs(x)                               \
+    (                                             \
+        {                                         \
+            long ret;                             \
+            if (sizeof(x) == sizeof(long))        \
+            {                                     \
+                long __x = (x);                   \
+                ret = (__x < 0) ? (-__x) : (__x); \
+            }                                     \
+            else                                  \
+            {                                     \
+                int __x = (x);                    \
+                ret = (__x < 0) ? (-__x) : (__x); \
+            }                                     \
+            ret;                                  \
+        })
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_MATH_H__ */
diff --git a/bsp/osal/include/osal_mutex.h b/bsp/osal/include/osal_mutex.h
new file mode 100755
index 0000000..a6b0abf
--- /dev/null
+++ b/bsp/osal/include/osal_mutex.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal mutex
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_MUTEX_H__
+#define __OSAL_MUTEX_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define OSAL_MUTEX_WAIT_FOREVER (-1)
+
+typedef struct {
+    void *mutex;
+} osal_mutex;
+
+/**
+ * @ingroup osal_mutex
+ * @brief Initialize the mutex.
+ *
+ * @par Description:
+ * This API is used to initialize the mutex.
+ *
+ * @param mutex [in] the mutex to be initialized.
+ *
+ * @return OSAL_FAILURE/OSAL_SUCCESS
+ */
+int osal_mutex_init(osal_mutex *mutex);
+
+/**
+ * @ingroup osal_mutex
+ * @brief Acquire the mutex.
+ *
+ * @par Description:
+ * Acquire the mutex. Lock the mutex exclusively for this task.
+ * If the mutex is not available right now, it will sleep until it can get it.
+ *
+ * @param mutex [in] the mutex to be initialized.
+ *
+ * @return OSAL_FAILURE/OSAL_SUCCESS
+ *
+ * @note
+ * The mutex must later on be released by the same task that acquired it. Recursive locking is not allowed.
+ * The task may not exit without first unlocking the mutex.
+ * Also, kernel memory where the mutex resides must not be freed with the mutex still locked.
+ * The mutex must first be initialized (or statically defined) before it can be locked.
+ * memset()-ing the mutex to 0 is not allowed.
+ */
+int osal_mutex_lock(osal_mutex *mutex);
+
+/**
+ * @ingroup osal_mutex
+ * @brief Try to acquire the mutex.
+ *
+ * @par Description:
+ * try to acquire the mutex, without waiting.
+ *
+ * @param mutex [in] The mutex to be acquired.
+ *
+ * @return TRUE/FALSE
+ */
+int osal_mutex_trylock(osal_mutex *mutex);
+
+/**
+ * @ingroup osal_mutex
+ * @brief Release the mutex.
+ *
+ * @par Description:
+ * Release the mutex. Unlock a mutex that has been locked by this task previously.
+ * This function must not be used in interrupt context. Unlocking of a not locked mutex is not allowed.
+ *
+ * @param mutex [in] the mutex to be released.
+ */
+void osal_mutex_unlock(osal_mutex *mutex);
+
+/**
+ * @ingroup osal_mutex
+ * @brief Destroy the mutex.
+ *
+ * @par Description:
+ * This API is used to destroy the mutex.
+ *
+ * @param mutex [in] The mutex to be destroyed.
+ *
+ * @attention
+ * must be called when kmod exit, otherwise will lead to memory leak; osal_mutex_destroy will free memory,
+ * caller should clear pointer to be NULL after called.
+ */
+void osal_mutex_destroy(osal_mutex *mutex);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_MUTEX_H__ */
diff --git a/bsp/osal/include/osal_proc.h b/bsp/osal/include/osal_proc.h
new file mode 100644
index 0000000..5e08354
--- /dev/null
+++ b/bsp/osal/include/osal_proc.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal proc
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_PROC_H__
+#define __OSAL_PROC_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define OSAL_PROC_NAME_LENGTH 32
+#define PROC_CMD_SINGEL_LENGTH_MAX 32
+
+struct osal_list_head {
+    struct osal_list_head *next, *prev;
+};
+
+typedef struct osal_proc_cmd_ {
+    char name[OSAL_PROC_NAME_LENGTH];
+    int (*handler)(unsigned int argc, char (*argv)[PROC_CMD_SINGEL_LENGTH_MAX], void *private_data);
+} osal_proc_cmd;
+
+typedef struct osal_proc_dir_entry {
+    char name[OSAL_PROC_NAME_LENGTH];
+    unsigned int cmd_cnt;
+    osal_proc_cmd *cmd_list;
+    void *proc_dir_entry;
+    int (*open)(struct osal_proc_dir_entry *entry);
+    int (*read)(struct osal_proc_dir_entry *entry);
+    int (*write)(struct osal_proc_dir_entry *entry, const char *buf, int count, long long *);
+    void *private_data;
+    void *seqfile;
+    struct osal_list_head node;
+} osal_proc_entry;
+
+void osal_proc_init(const char *name);
+
+void osal_proc_exit(const char *name);
+
+void osal_remove_proc_entry(const char *name, osal_proc_entry *parent);
+
+osal_proc_entry *osal_create_proc_entry(const char *name, osal_proc_entry *parent);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_PROC_H__ */
diff --git a/bsp/osal/include/osal_semaphore.h b/bsp/osal/include/osal_semaphore.h
new file mode 100644
index 0000000..833952e
--- /dev/null
+++ b/bsp/osal/include/osal_semaphore.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal semaphore
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_SEMAPHORE_H__
+#define __OSAL_SEMAPHORE_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+typedef struct {
+    void *sem;
+} osal_semaphore;
+
+int osal_sem_init(osal_semaphore *sem, int val);
+
+int osal_sem_down(osal_semaphore *sem);
+
+int osal_sem_down_timeout(osal_semaphore *sem, unsigned int timeout);
+
+int osal_sem_down_interruptible(osal_semaphore *sem);
+
+int osal_sem_trydown(osal_semaphore *sem);
+
+void osal_sem_up(osal_semaphore *sem);
+
+void osal_sem_destroy(osal_semaphore *sem);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_SEMAPHORE_H__ */
diff --git a/bsp/osal/include/osal_spinlock.h b/bsp/osal/include/osal_spinlock.h
new file mode 100755
index 0000000..78b748a
--- /dev/null
+++ b/bsp/osal/include/osal_spinlock.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related osal spinlock
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_SPINLOCK_H__
+#define __OSAL_SPINLOCK_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+typedef struct {
+    void *lock;
+} osal_spinlock;
+
+/**
+ * @ingroup osal_spinlock
+ * @brief Initialize a spin lock.
+ *
+ * @par Description:
+ * This API is used to initialization of spin_lock.
+ *
+ * @param lock [out] the lock to be initialized.
+ *
+ * @attention
+ * must be free with osal_spin_lock_destroy, other wise will lead to memory leak;
+ *
+ * @return OSAL_SUCCESS/OSAL_FAILURE
+ */
+int osal_spin_lock_init(osal_spinlock *lock);
+
+/**
+ * @ingroup osal_spinlock
+ * @brief Lock the spinlock.
+ *
+ * @par Description:
+ * This API is used to lock the spinlock. If the spinlock has been obtained by another thread,
+ * the thread will wait cyclically until it can lock the spinlock successfully.
+ *
+ * @attention
+ * The spinlock must be initialized before it is used. It should be initialized by osal_spin_lock_init.
+ * A spinlock can not be locked for multiple times in a task. Otherwise, a deadlock occurs.
+ * If the spinlock will be used in both task and interrupt, using osal_spin_lock_irqsave instead of this API.
+ *
+ * In the OP-TEE kernel, before locking the spinlock,
+ * must call this API: thread_mask_exceptions(THREAD_EXCP_ALL).
+ *
+ * @param lock [in] The lock to be acquired, Initialized by osal_spin_lock_init.
+ */
+void osal_spin_lock(osal_spinlock *lock);
+
+/**
+ * @ingroup osal_spinlock
+ * @brief Try to acquire the spin_lock.
+ *
+ * @par Description:
+ * try to acquire the spin_lock.
+ *
+ * @param lock [in] the lock to be acquired.
+ *
+ * In the OP-TEE kernel, before locking the spinlock,
+ * must call this API: thread_mask_exceptions(THREAD_EXCP_ALL).
+ *
+ * @return Returns true if the lock can be obtained immediately, otherwise returns false immediately.
+ */
+int osal_spin_trylock(osal_spinlock *lock);
+
+/**
+ * @ingroup osal_spinlock
+ * @brief release the spin_lock.
+ *
+ * @par Description:
+ * release the spin_lock.
+ *
+ * In the OP-TEE kernel, after unlocking the spinlock,
+ * must call this API: thread_unmask_exceptions.
+ *
+ * @param lock [in] the lock to be released.
+ */
+void osal_spin_unlock(osal_spinlock *lock);
+
+/**
+ * @ingroup osal_spinlock
+ * @brief Try to acquire the spin_lock.
+ *
+ * @par Description:
+ * Saves the current IRQ status of the CPU, try to acquire the spin_lock, and disables the interrupts of the CPU.
+ *
+ * @param lock [in] the lock to be acquired.
+ */
+void osal_spin_lock_irqsave(osal_spinlock *lock, unsigned long *flags);
+
+/**
+ * @ingroup osal_spinlock
+ * @brief release the spin_lock.
+ *
+ * @par Description:
+ * Releases the specified spin_lock and restores the interrupt status of the CPU, and enables the interrupts of the CPU.
+ *
+ * @param lock [in] the lock to be released.
+ */
+void osal_spin_unlock_irqrestore(osal_spinlock *lock, unsigned long *flags);
+
+/**
+ * @ingroup osal_spinlock
+ * @brief Destroy the spin_lock.
+ *
+ * @par Description:
+ * Destroy the spin_lock.
+ *
+ * @param lock [in] The lock to be destroyed.
+ *
+ * @attention
+ * must be called when kmod exit, other wise will lead to memory leak;
+ * this API will free memory, lock must be from osal_spin_lock_init returns
+ */
+void osal_spin_lock_destroy(osal_spinlock *lock);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_SPINLOCK_H__ */
diff --git a/bsp/osal/include/osal_task.h b/bsp/osal/include/osal_task.h
new file mode 100755
index 0000000..76f6fe8
--- /dev/null
+++ b/bsp/osal/include/osal_task.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function related osal task
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_TASK_H__
+#define __OSAL_TASK_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#if defined(__LITEOS__)
+#define OSAL_TASK_PRIORITY_ABOVE_HIGH   2
+#define OSAL_TASK_PRIORITY_HIGH         3
+#define OSAL_TASK_PRIORITY_BELOW_HIGH   4
+#define OSAL_TASK_PRIORITY_ABOVE_MIDDLE 5
+#define OSAL_TASK_PRIORITY_MIDDLE       6
+#define OSAL_TASK_PRIORITY_BELOW_MIDDLE 7
+#define OSAL_TASK_PRIORITY_ABOVE_LOW    8
+#define OSAL_TASK_PRIORITY_LOW          10
+#define OSAL_TASK_PRIORITY_BELOW_LOW    11
+
+#elif defined(__KERNEL__)
+#define OSAL_TASK_PRIORITY_ABOVE_HIGH   99
+#define OSAL_TASK_PRIORITY_HIGH         90
+#define OSAL_TASK_PRIORITY_BELOW_HIGH   80
+#define OSAL_TASK_PRIORITY_ABOVE_MIDDLE 70
+#define OSAL_TASK_PRIORITY_MIDDLE       60
+#define OSAL_TASK_PRIORITY_BELOW_MIDDLE 50
+#define OSAL_TASK_PRIORITY_ABOVE_LOW    40
+#define OSAL_TASK_PRIORITY_LOW          30
+#define OSAL_TASK_PRIORITY_BELOW_LOW    20
+
+#elif defined(__FREERTOS__)
+#define OSAL_TASK_PRIORITY_ABOVE_HIGH   11
+#define OSAL_TASK_PRIORITY_HIGH         10
+#define OSAL_TASK_PRIORITY_BELOW_HIGH   8
+#define OSAL_TASK_PRIORITY_ABOVE_MIDDLE 7
+#define OSAL_TASK_PRIORITY_MIDDLE       6
+#define OSAL_TASK_PRIORITY_BELOW_MIDDLE 5
+#define OSAL_TASK_PRIORITY_ABOVE_LOW    4
+#define OSAL_TASK_PRIORITY_LOW          3
+#define OSAL_TASK_PRIORITY_BELOW_LOW    2
+
+#else
+#define OSAL_TASK_PRIORITY_ABOVE_HIGH   2
+#define OSAL_TASK_PRIORITY_HIGH         3
+#define OSAL_TASK_PRIORITY_BELOW_HIGH   4
+#define OSAL_TASK_PRIORITY_ABOVE_MIDDLE 5
+#define OSAL_TASK_PRIORITY_MIDDLE       6
+#define OSAL_TASK_PRIORITY_BELOW_MIDDLE 7
+#define OSAL_TASK_PRIORITY_ABOVE_LOW    8
+#define OSAL_TASK_PRIORITY_LOW          10
+#define OSAL_TASK_PRIORITY_BELOW_LOW    11
+#endif
+
+typedef struct {
+    void *task;
+} osal_task;
+
+typedef int (*osal_kthread_handler)(void *data);
+
+/**
+ * @ingroup osal_task
+ *
+ * @brief Obtains the tid of the current thread.
+ *
+ * @par Description:
+ * Obtains the tid of the current thread.
+ *
+ * @return  tid of the current thread.
+ */
+long osal_get_current_tid(void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_TASK_H__ */
diff --git a/bsp/osal/include/osal_timer.h b/bsp/osal/include/osal_timer.h
new file mode 100755
index 0000000..82b53ee
--- /dev/null
+++ b/bsp/osal/include/osal_timer.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function related osal timer
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_TIMER_H__
+#define __OSAL_TIMER_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+typedef struct {
+    void *timer;
+    void (*handler)(unsigned long);
+    unsigned long data;    // data for handler
+    unsigned int interval; // timer timing duration, unit: ms.
+} osal_timer;
+
+typedef struct {
+    long tv_sec;
+    long tv_usec;
+} osal_timeval;
+
+/**
+ * @ingroup osal_timer
+ * @brief sleep safely even with waitqueue interruptions.
+ *
+ * @par Description:
+ * sleep safely even with waitqueue interruptions.
+ *
+ * @param msecs [in] Time in milliseconds to sleep for.
+ */
+void osal_msleep_uninterruptible(unsigned int msecs);
+
+/**
+ * @ingroup osal_timer
+ * @brief spinning-delay in microsecond (us).
+ *
+ * @par Description:
+ * This API is used to delay in microsecond.
+ *
+ * @param usecs [in] Time in microseconds to wait for.
+ */
+void osal_udelay(unsigned int usecs);
+
+/**
+ * @ingroup osal_timer
+ * @brief spinning-delay in millisecond (ms).
+ *
+ * @par Description:
+ * This API is used to delay in millisecond.
+ *
+ * @param msecs [in] Time in milliseconds to wait for.
+ */
+void osal_mdelay(unsigned int msecs);
+
+/**
+ * @ingroup osal_timer
+ * @brief Obtaining the Current System Kernel Time.
+ *
+ * @par Description:
+ * Obtaining the Current System Kernel Time.
+ *
+ * @param tv [out] Obtained Current System Kernel Time.
+ */
+void osal_gettimeofday(osal_timeval *tv);
+
+/* Return values for the timer callback function */
+typedef enum {
+    OSAL_HRTIMER_NORESTART, /* < The timer will not be restarted. */
+    OSAL_HRTIMER_RESTART    /* < The timer must be restarted. */
+} osal_hrtimer_restart;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_TIMER_H__ */
diff --git a/bsp/osal/include/osal_wait.h b/bsp/osal/include/osal_wait.h
new file mode 100644
index 0000000..53e3f65
--- /dev/null
+++ b/bsp/osal/include/osal_wait.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function related osal wait
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OSAL_WAIT_H__
+#define __OSAL_WAIT_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define OSAL_WAIT_FOREVER 0xFFFFFFFF
+#define OSAL_WAIT_CONDITION_TRUE 1
+
+typedef struct {
+    void *wait;
+} osal_wait;
+
+/* return value is a bool type */
+typedef int (*osal_wait_condition_func)(const void *param);
+
+/**
+ * @ingroup osal_wait
+ * @brief Initialize a waiting queue.
+ *
+ * @par Description:
+ * This API is used to Initialize a waiting queue.
+ *
+ * @param wait [out] The wait queue to be initialized.
+ */
+int osal_wait_init(osal_wait *wait);
+
+ /**
+ * @ingroup osal_wait
+ * @brief sleep until a condition gets true
+ *
+ * @par Description:
+ * sleep until a condition gets true.
+ * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the @func returned true.
+ * Return value of the @func is checked each time the waitqueue @wait is woken up.
+ *
+ * @attention
+ * wake_up() has to be called after changing any variable that could change the result of the wait condition.
+ *
+ * @return OSAL_SUCCESS/OSAL_FAILURE
+ */
+int osal_wait_uninterruptible(osal_wait *wait, osal_wait_condition_func func, const void *param);
+
+/**
+ * @ingroup osal_wait
+ * @brief sleep until a condition gets true or a timeout elapses.
+ *
+ * @par Description:
+ * sleep until a condition gets true or a timeout elapses.
+ * The process is put to sleep (TASK_INTERRUPTIBLE) until the @func returned true or a signal is received.
+ * Return value of the @func is checked each time the waitqueue @wait is woken up.
+ *
+ * @param wait [in] the waitqueue to wait on.
+ * @param func [in] a C expression for the event to wait for.
+ * @param  ms  [in] timeout, in ms.
+ */
+int osal_wait_timeout_uninterruptible(osal_wait *wait, osal_wait_condition_func func, const void *param, \
+    unsigned long ms);
+
+/**
+ * @ingroup osal_wait
+ * @brief wake up threads blocked on a waitqueue.
+ *
+ * @par Description:
+ * Wake-up wait queue.
+ *
+ * @param wait [in] The wait to be wake up.
+ */
+void osal_wait_wakeup(osal_wait *wait); // same as wake_up_all
+
+/**
+ * @ingroup osal_wait
+ * @brief to destroy the wait.
+ *
+ * @par Description:
+ * This API is used to destroy the wait.
+ *
+ * @param wait [in] The wait to be destroyed.
+ *
+ * @attention this api may free memory, wait should be from osal_wait_init.
+ */
+void osal_wait_destroy(osal_wait *wait);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OSAL_WAIT_H__ */
+
diff --git a/bsp/osal/include/ot_osal.h b/bsp/osal/include/ot_osal.h
new file mode 100644
index 0000000..828d9a3
--- /dev/null
+++ b/bsp/osal/include/ot_osal.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Include all osal function and some struct related osal function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#ifndef __OT_OSAL_H__
+#define __OT_OSAL_H__
+
+#include "osal_debug.h"
+#include "osal_atomic.h"
+#include "osal_math.h"
+#include "osal_interrupt.h"
+#include "osal_mutex.h"
+#include "osal_spinlock.h"
+#include "osal_addr.h"
+#include "osal_barrier.h"
+#include "osal_task.h"
+#include "osal_timer.h"
+#include "osal_wait.h"
+#include "osal_cache.h"
+#include "osal_device.h"
+#include "osal_proc.h"
+#include "osal_semaphore.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define OT_OSAL_VERSION  "1.0"
+#define OSAL_ERROR       (-1)
+#define OSAL_SUCCESS       0
+#define CFG_WITH_USER_TA   1
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif /* __OT_OSAL_H__ */
diff --git a/bsp/osal/src/osal_addr.c b/bsp/osal/src/osal_addr.c
new file mode 100644
index 0000000..8267b8b
--- /dev/null
+++ b/bsp/osal/src/osal_addr.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal address function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <stdio.h>
+#include <malloc.h>
+#include <mempool.h>
+#include <kernel/user_access.h>
+#include <mm/vm.h>
+#include <kernel/user_mode_ctx.h>
+#include <types_ext.h>
+#include <mm/core_memprot.h>
+
+#define LEN 1
+
+void *osal_kmalloc(unsigned long size, unsigned int osal_gfp_flag)
+{
+    if (size == 0 || (osal_gfp_flag != OSAL_GFP_KERNEL && osal_gfp_flag != OSAL_GFP_ATOMIC)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return NULL;
+    }
+
+    return malloc(size);
+}
+
+void osal_kfree(void *addr)
+{
+    if (addr == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    free(addr);
+}
+
+void *osal_vmalloc(unsigned long size)
+{
+    if (size != 0) { // size can not be 0.
+        return malloc(size);
+    }
+
+    return NULL;
+}
+
+void osal_vfree(void *addr)
+{
+    if (addr == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    free(addr);
+}
+
+static struct mempool *get_osal_memory_pool(unsigned int size)
+{
+    static uint8_t data[OSAL_MEMPOOL_SIZE] __aligned(MEMPOOL_ALIGN);
+    (void)&size; /* Unused parameter */
+
+    return mempool_alloc_pool(data, sizeof(data), NULL);
+}
+
+
+int osal_pool_mem_init(void *pool, unsigned int size)
+{
+    struct mempool *ptr = get_osal_memory_pool(size);
+    if (ptr == NULL) {
+        osal_printk("%s failed!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    *(struct mempool **)pool = ptr;
+
+    return OSAL_SUCCESS;
+}
+
+void *osal_pool_mem_alloc(void *pool, unsigned long size)
+{
+    if (pool == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return NULL;
+    }
+
+    return mempool_alloc(pool, size);
+}
+
+void osal_pool_mem_free(void *pool, const void *addr)
+{
+    if (pool == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    mempool_free(pool, (void *)addr);
+}
+
+/* You must use this interface to register the memory in the macro before  */
+/* using the following functions: register_phys_mem_pgdir(MEM_AREA_IO_SEC, phys_addr, size) */
+void *osal_ioremap(unsigned long phys_addr, unsigned long size)
+{
+    return phys_to_virt(phys_addr, MEM_AREA_IO_SEC, size);
+}
+
+/* You must use this interface to register the memory in the macro before  */
+/* using the following functions: register_phys_mem_pgdir(MEM_AREA_IO_SEC, phys_addr, size) */
+void *osal_ioremap_nocache(unsigned long phys_addr, unsigned long size)
+{
+    return phys_to_virt(phys_addr, MEM_AREA_IO_SEC, size);
+}
+
+void *osal_ioremap_cached(unsigned long phys_addr, unsigned long size)
+{
+    return (void *)core_mmu_get_va(phys_addr, MEM_AREA_IO_SEC, size);
+}
+
+void osal_iounmap(void *addr, unsigned long size)
+{
+    (void)addr; /* Unused parameter */
+    (void)&size; /* Unused parameter */
+
+    if (addr == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+    }
+
+    return;
+}
+
+void *osal_phys_to_virt(unsigned long addr)
+{
+    return phys_to_virt(addr, MEM_AREA_IO_SEC, LEN);
+}
+
+unsigned long osal_virt_to_phys(const void *virt_addr)
+{
+    if (virt_addr == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    return virt_to_phys((void *)virt_addr);
+}
+
+unsigned long osal_copy_from_user(void *to, const void *from, unsigned long n)
+{
+    unsigned long ret = TEE_SUCCESS;
+
+    if (to == NULL || from == NULL) {
+        osal_printk("%s parameter failed!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    ret = copy_from_user(to, from, n);
+    if (ret != TEE_SUCCESS) {
+        osal_printk("%s failed!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    return OSAL_SUCCESS;
+}
+
+unsigned long osal_copy_to_user(void *to, const void *from, unsigned long n)
+{
+    unsigned long ret = TEE_SUCCESS;
+
+    if (to == NULL || from == NULL) {
+        osal_printk("%s parameter failed!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    ret = copy_to_user(to, from, n);
+    if (ret != TEE_SUCCESS) {
+        osal_printk("%s failed!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    return OSAL_SUCCESS;
+}
+
+int osal_access_ok(int type, const void *addr, unsigned long size)
+{
+    struct ts_session *s = NULL;
+
+    if (addr == NULL) {
+        osal_printk("%s parameter failed!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    s = ts_get_current_session();
+    if (vm_check_access_rights(to_user_mode_ctx(s->ctx), \
+        (type + 1) | TEE_MEMORY_ACCESS_ANY_OWNER, \
+        (uaddr_t)addr, size) == TEE_SUCCESS) {
+        return true;
+    }
+    return false;
+}
diff --git a/bsp/osal/src/osal_atomic.c b/bsp/osal/src/osal_atomic.c
new file mode 100644
index 0000000..f896e20
--- /dev/null
+++ b/bsp/osal/src/osal_atomic.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal atomic function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <atomic.h>
+
+int osal_atomic_read(osal_atomic *atomic)
+{
+    osal_atomic *p = NULL;
+
+    if (atomic == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p = (osal_atomic *)atomic;
+    return atomic_load_int((int *)&(p->counter));
+}
+
+void osal_atomic_set(osal_atomic *atomic, int i)
+{
+    osal_atomic *p = NULL;
+
+    if (atomic == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (osal_atomic *)atomic;
+    atomic_store_int((int *)&(p->counter), i);
+}
+
+int osal_atomic_inc_return(osal_atomic *atomic)
+{
+    osal_atomic *p = NULL;
+
+    if (atomic == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p = (osal_atomic *)atomic;
+    return (int)atomic_inc32((volatile uint32_t *)&(p->counter));
+}
+
+int osal_atomic_dec_return(osal_atomic *atomic)
+{
+    osal_atomic *p = NULL;
+
+    if (atomic == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p = (osal_atomic *)atomic;
+    return (int)atomic_dec32((volatile uint32_t *)&(p->counter));
+}
+
+void osal_atomic_inc(osal_atomic *atomic)
+{
+    osal_atomic *p = NULL;
+
+    if (atomic == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (osal_atomic *)atomic;
+    atomic_inc32((volatile uint32_t *)&(p->counter));
+}
+
+void osal_atomic_dec(osal_atomic *atomic)
+{
+    osal_atomic *p = NULL;
+
+    if (atomic == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (osal_atomic *)atomic;
+    atomic_dec32((volatile uint32_t *)&(p->counter));
+}
diff --git a/bsp/osal/src/osal_barrier.c b/bsp/osal/src/osal_barrier.c
new file mode 100644
index 0000000..07932ef
--- /dev/null
+++ b/bsp/osal/src/osal_barrier.c
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal barrier function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <arm64.h>
+
+void osal_isb(void)
+{
+    isb();
+}
+
+void osal_dsb(void)
+{
+    dsb();
+}
diff --git a/bsp/osal/src/osal_cache.c b/bsp/osal/src/osal_cache.c
new file mode 100644
index 0000000..f0bb21e
--- /dev/null
+++ b/bsp/osal/src/osal_cache.c
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal cache function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <kernel/cache_helpers.h>
+#include <tee/cache.h>
+
+void osal_dcache_region_wb(void *kvirt, unsigned long phys_addr, unsigned long size)
+{
+    (void)&phys_addr; /* Unused parameters */
+
+    if (kvirt == NULL) {
+        osal_printk("%s parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    cache_operation(TEE_CACHEFLUSH, kvirt, size);
+}
+
+void osal_dcache_region_inv(void *addr, unsigned long size)
+{
+    if (addr == NULL) {
+        osal_printk("%s parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    dcache_inv_range(addr, size);
+    cache_operation(TEE_CACHEINVALIDATE, addr, size);
+}
diff --git a/bsp/osal/src/osal_debug.c b/bsp/osal/src/osal_debug.c
new file mode 100644
index 0000000..e8cefc1
--- /dev/null
+++ b/bsp/osal/src/osal_debug.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal debug function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <printk.h>
+#include <trace.h>
+#include <kernel/panic.h>
+#include "securec.h"
+
+void osal_printk(const char *fmt, ...)
+{
+    char to_format[MAX_PRINT_SIZE];
+    va_list ap;
+    int s;
+
+    if (fmt == NULL) {
+        DMSG("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    if (trace_get_level() < TRACE_PRINTF_LEVEL) {
+        return;
+    }
+
+    va_start(ap, fmt);
+    s = vsnprintf_s(to_format, sizeof(to_format), MAX_PRINT_SIZE - 1, fmt, ap);
+    va_end(ap);
+
+    if (s < 0) {
+        return;
+    }
+
+    trace_ext_puts(to_format);
+    return;
+}
+
+void osal_panic(const char *fmt, const char *fun, int line, const char *cond)
+{
+    __do_panic(cond, line, fun, fmt);
+}
diff --git a/bsp/osal/src/osal_device.c b/bsp/osal/src/osal_device.c
new file mode 100644
index 0000000..e54b901
--- /dev/null
+++ b/bsp/osal/src/osal_device.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal device function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <stdio.h>
+
+osal_dev *osal_dev_create(const char *name)
+{
+    (void)name; /* Unused parameters */
+
+    return NULL;
+}
+
+int osal_dev_destroy(osal_dev *dev)
+{
+    (void)dev; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_dev_register(osal_dev *dev)
+{
+    (void)dev; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+void osal_dev_unregister(osal_dev *dev)
+{
+    (void)dev; /* Unused parameters */
+
+    return;
+}
+
+int osal_remap_pfn_range(osal_vm *vm, unsigned long addr, unsigned long pfn, unsigned long size)
+{
+    (void)vm; /* Unused parameters */
+    (void)&addr; /* Unused parameters */
+    (void)&pfn; /* Unused parameters */
+    (void)&size; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+void osal_pgprot_noncached(osal_vm *vm)
+{
+    (void)vm; /* Unused parameters */
+
+    return;
+}
+
+void osal_pgprot_cached(osal_vm *vm)
+{
+    (void)vm; /* Unused parameters */
+
+    return;
+}
+
+int osal_opendev(const char *path, int flag, ...)
+{
+    (void)path; /* Unused parameters */
+    (void)&flag; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_closedev(int fd)
+{
+    (void)&fd; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_readdev(int fd, void *buf, unsigned long count)
+{
+    (void)&fd; /* Unused parameters */
+    (void)buf; /* Unused parameters */
+    (void)&count; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_writedev(int fd, const void *buf, unsigned long count)
+{
+    (void)&fd; /* Unused parameters */
+    (void)buf; /* Unused parameters */
+    (void)&count; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_ioctldev(int fd, unsigned int cmd, ...)
+{
+    (void)&fd; /* Unused parameters */
+    (void)&cmd; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
diff --git a/bsp/osal/src/osal_interrupt.c b/bsp/osal/src/osal_interrupt.c
new file mode 100644
index 0000000..06e22d5
--- /dev/null
+++ b/bsp/osal/src/osal_interrupt.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal interrupt function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <malloc.h>
+#include <kernel/interrupt.h>
+
+static SLIST_HEAD(, itr_handler) handlers __nex_data =  SLIST_HEAD_INITIALIZER(handlers);
+
+typedef struct {
+    unsigned int irq;
+    void *dev;
+    char *name;
+    struct itr_handler *itr;
+} itr_data;
+
+typedef struct {
+    itr_data data;
+    osal_irq_handler irq_handler;
+    osal_irq_handler thread_fn;
+} osal_itr_data;
+
+void osal_irq_enable(unsigned int irq)
+{
+    itr_enable(irq);
+}
+
+void osal_irq_disable(unsigned int irq)
+{
+    itr_disable(irq);
+}
+
+static enum osal_irqreturn irq_process_fn(struct itr_handler *h)
+{
+    itr_data *data = h->data;
+    osal_itr_data *hd = container_of(data, osal_itr_data, data);
+
+    if (hd->irq_handler) {
+        hd->irq_handler(data->irq, data->dev);
+
+        if (hd->thread_fn) {
+            hd->thread_fn(data->irq, data->dev);
+        }
+    }
+
+    return OSAL_IRQ_HANDLED;
+}
+
+static enum osal_irqreturn irq_default_primary_handler(unsigned int irq, void *dev)
+{
+    (void)&irq; /* Unused parameter */
+    (void)dev; /* Unused parameter */
+
+    return OSAL_IRQ_WAKE_THREAD;
+}
+
+int osal_irq_request(unsigned int irq, osal_irq_handler irq_handler, \
+    osal_irq_handler thread_handler, const char *name, void *dev)
+{
+    struct itr_handler *osal_itr = NULL;
+    osal_itr_data *hd = NULL;
+
+    if (irq_handler == NULL) {
+        if (thread_handler == NULL) {
+            osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+            return OSAL_ERROR;
+        }
+        irq_handler = (osal_irq_handler)irq_default_primary_handler;
+    }
+
+    hd = calloc(1, sizeof(*hd));
+    if (hd == NULL) {
+        osal_printk("%s calloc failed!", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    hd->data.irq = irq;
+    hd->data.dev = dev;
+    hd->data.name = (char *)name;
+    osal_itr = itr_alloc_add(irq, (itr_handler_t)irq_process_fn, ITRF_SHARED, &hd->data);
+    if (!osal_itr) {
+        free(hd);
+        hd = NULL;
+        return OSAL_ERROR;
+    }
+
+    SLIST_INSERT_HEAD(&handlers, osal_itr, link);
+    hd->irq_handler = irq_handler;
+    hd->thread_fn = thread_handler;
+    hd->data.itr = osal_itr;
+    return OSAL_SUCCESS;
+}
+
+void osal_irq_free(unsigned int irq, void *dev)
+{
+    struct itr_handler *h = NULL;
+    struct itr_handler *h_tmp = NULL;
+    itr_data *data = NULL;
+    osal_itr_data *hd = NULL;
+    (void)dev; /* Unused parameter */
+
+    SLIST_FOREACH_SAFE(h, &handlers, link, h_tmp) {
+        if (h->it == irq) {
+            data = h->data;
+            hd = container_of(data, osal_itr_data, data);
+            SLIST_REMOVE(&handlers, h, itr_handler, link);
+            itr_free(h);
+            free(hd);
+            hd = NULL;
+        }
+    }
+}
diff --git a/bsp/osal/src/osal_math.c b/bsp/osal/src/osal_math.c
new file mode 100644
index 0000000..26f0526
--- /dev/null
+++ b/bsp/osal/src/osal_math.c
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal math function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <rng_support.h>
+
+/* the result of u64/u32. */
+unsigned long long osal_div_u64(unsigned long long dividend, unsigned int divisor)
+{
+    unsigned long long res = 0;
+    if (!divisor) {
+        osal_printk("divisor should not be zero!\n");
+        return OSAL_ERROR;
+    }
+
+    res = dividend / divisor;
+    return res;
+}
+
+/* the result of s64/s32. */
+long long osal_div_s64(long long dividend, int divisor)
+{
+    long long res = 0;
+
+    if (!divisor) {
+        osal_printk("divisor should not be zero!\n");
+        return OSAL_ERROR;
+    }
+
+    res = dividend / divisor;
+    return res;
+}
+
+/* the result of u64/u64. */
+unsigned long long osal_div64_u64(unsigned long long dividend, unsigned long long divisor)
+{
+    unsigned long long res = 0;
+    if (!divisor) {
+        osal_printk("divisor should not be zero!\n");
+        return OSAL_ERROR;
+    }
+
+    res = dividend / divisor;
+    return res;
+}
+
+/* the result of s64/s64. */
+long long osal_div64_s64(long long dividend, long long divisor)
+{
+    long long res = 0;
+
+    if (!divisor) {
+        osal_printk("divisor should not be zero!\n");
+        return OSAL_ERROR;
+    }
+
+    res = dividend / divisor;
+    return res;
+}
+
+/* the remainder of u64/u32. */
+unsigned long long osal_div_u64_rem(unsigned long long dividend, unsigned int divisor)
+{
+    unsigned long long remainder = 0;
+    if (!divisor) {
+        osal_printk("divisor should not be zero!\n");
+        return OSAL_ERROR;
+    }
+
+    remainder = dividend % divisor;
+    return remainder;
+}
+
+/* the remainder of u64/u64. */
+unsigned long long osal_div64_u64_rem(unsigned long long dividend, unsigned long long divisor)
+{
+    unsigned long long remainder = 0;
+
+    if (!divisor) {
+        osal_printk("divisor should not be zero!\n");
+        return OSAL_ERROR;
+    }
+
+    remainder = dividend % divisor;
+    return remainder;
+}
+
+/* the remainder of s64/s32. */
+long long osal_div_s64_rem(long long dividend, int divisor)
+{
+    long long remainder = 0;
+
+    if (!divisor) {
+        osal_printk("divisor should not be zero!\n");
+        return OSAL_ERROR;
+    }
+
+    remainder = dividend % divisor;
+    return remainder;
+}
+
+unsigned int osal_get_random_int(void)
+{
+    unsigned int ret = TEE_SUCCESS;
+    unsigned int random_num = 0;
+
+    ret = hw_get_random_bytes(&random_num, sizeof(random_num));
+    if (ret != TEE_SUCCESS) {
+        osal_printk("hw_get_random_bytes failed!\n");
+    }
+
+    return random_num;
+}
diff --git a/bsp/osal/src/osal_mutex.c b/bsp/osal/src/osal_mutex.c
new file mode 100644
index 0000000..ceed746
--- /dev/null
+++ b/bsp/osal/src/osal_mutex.c
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal mutex function
+ * Author: AuthorNameMagicTag
+ * Create: 2019OSAL_ERROR2OSAL_ERROR1
+*/
+
+#include <ot_osal.h>
+#include <kernel/mutex.h>
+#include <malloc.h>
+
+int osal_mutex_init(osal_mutex *mutex)
+{
+    struct mutex *p = NULL;
+
+    if (mutex == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p = malloc(sizeof(struct mutex));
+    if (p == NULL) {
+        osal_printk("%s - kmalloc error!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    mutex_init(p);
+    mutex->mutex = p;
+    return OSAL_SUCCESS;
+}
+
+int osal_mutex_lock(osal_mutex *mutex)
+{
+    struct mutex *p = NULL;
+
+    if ((mutex == NULL) || (mutex->mutex == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p = (struct mutex *)(mutex->mutex);
+    mutex_lock(p);
+    return OSAL_SUCCESS;
+}
+
+int osal_mutex_trylock(osal_mutex *mutex)
+{
+    struct mutex *p = NULL;
+
+    if ((mutex == NULL) || (mutex->mutex == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p = (struct mutex *)(mutex->mutex);
+    return mutex_trylock(p);
+}
+
+void osal_mutex_unlock(osal_mutex *mutex)
+{
+    struct mutex *p = NULL;
+
+    if ((mutex == NULL) || (mutex->mutex == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (struct mutex *)(mutex->mutex);
+    mutex_unlock(p);
+}
+
+void osal_mutex_destroy(osal_mutex *mutex)
+{
+    struct mutex *p = NULL;
+
+    if ((mutex == NULL) || (mutex->mutex == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (struct mutex *)(mutex->mutex);
+    mutex_destroy(p);
+    free(p);
+    p = NULL;
+    mutex->mutex = NULL;
+}
diff --git a/bsp/osal/src/osal_proc.c b/bsp/osal/src/osal_proc.c
new file mode 100644
index 0000000..7ebe97d
--- /dev/null
+++ b/bsp/osal/src/osal_proc.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal proc function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <stdio.h>
+
+void osal_proc_init(const char *name)
+{
+    (void)name; /* Unused parameters */
+
+    return;
+}
+
+void osal_proc_exit(const char *name)
+{
+    (void)name; /* Unused parameters */
+
+    return;
+}
+
+void osal_remove_proc_entry(const char *name, osal_proc_entry *parent)
+{
+    (void)name; /* Unused parameters */
+    (void)parent; /* Unused parameters */
+
+    return;
+}
+
+osal_proc_entry *osal_create_proc_entry(const char *name, osal_proc_entry *parent)
+{
+    (void)name; /* Unused parameters */
+    (void)parent; /* Unused parameters */
+
+    return NULL;
+}
diff --git a/bsp/osal/src/osal_semaphore.c b/bsp/osal/src/osal_semaphore.c
new file mode 100644
index 0000000..3adf213
--- /dev/null
+++ b/bsp/osal/src/osal_semaphore.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal semaphore function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <stdio.h>
+
+int osal_sem_init(osal_semaphore *sem, int val)
+{
+    (void)sem; /* Unused parameters */
+    (void)&val; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_sem_down(osal_semaphore *sem)
+{
+    (void)sem; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_sem_down_timeout(osal_semaphore *sem, unsigned int timeout)
+{
+    (void)sem; /* Unused parameters */
+    (void)&timeout; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_sem_down_interruptible(osal_semaphore *sem)
+{
+    (void)sem; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+int osal_sem_trydown(osal_semaphore *sem)
+{
+    (void)sem; /* Unused parameters */
+
+    return OSAL_SUCCESS;
+}
+
+void osal_sem_up(osal_semaphore *sem)
+{
+    (void)sem; /* Unused parameters */
+
+    return;
+}
+
+void osal_sem_destroy(osal_semaphore *sem)
+{
+    (void)sem; /* Unused parameters */
+
+    return;
+}
diff --git a/bsp/osal/src/osal_spinlock.c b/bsp/osal/src/osal_spinlock.c
new file mode 100644
index 0000000..1f30c65
--- /dev/null
+++ b/bsp/osal/src/osal_spinlock.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal spinlock function
+ * Author: AuthorNameMagicTag
+ * Create: 2019OSAL_ERROR2OSAL_ERROR1
+*/
+
+#include <kernel/spinlock.h>
+#include <ot_osal.h>
+#include <malloc.h>
+
+typedef struct {
+    unsigned int spinlock;
+} spinlock_t;
+
+int osal_spin_lock_init(osal_spinlock *lock)
+{
+    spinlock_t *p = NULL;
+
+    if (lock == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p = (spinlock_t *)malloc(sizeof(spinlock_t));
+    if (p == NULL) {
+        osal_printk("%s - malloc error!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p->spinlock = SPINLOCK_UNLOCK;
+    lock->lock = (void *)p;
+    return OSAL_SUCCESS;
+}
+
+void osal_spin_lock(osal_spinlock *lock)
+{
+    spinlock_t *p = NULL;
+
+    if ((lock == NULL) || (lock->lock == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (spinlock_t *)(lock->lock);
+    cpu_spin_lock(&p->spinlock);
+}
+
+int osal_spin_trylock(osal_spinlock *lock)
+{
+    spinlock_t *p = NULL;
+
+    if ((lock == NULL) || (lock->lock == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    p = (spinlock_t *)(lock->lock);
+    return cpu_spin_trylock(&p->spinlock);
+}
+
+void osal_spin_unlock(osal_spinlock *lock)
+{
+    spinlock_t *p = NULL;
+
+    if ((lock == NULL) || (lock->lock == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (spinlock_t *)(lock->lock);
+    cpu_spin_unlock(&p->spinlock);
+}
+
+void osal_spin_lock_irqsave(osal_spinlock *lock, unsigned long *flags)
+{
+    spinlock_t *p = NULL;
+
+    if ((lock == NULL) || (lock->lock == NULL) || (flags == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+    p = (spinlock_t *)(lock->lock);
+
+    *flags = cpu_spin_lock_xsave(&p->spinlock);
+}
+
+void osal_spin_unlock_irqrestore(osal_spinlock *lock, unsigned long *flags)
+{
+    spinlock_t *p = NULL;
+    unsigned int f;
+
+    if ((lock == NULL) || (lock->lock == NULL) || (flags == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (spinlock_t *)(lock->lock);
+    f = *flags;
+    cpu_spin_unlock_xrestore(&p->spinlock, f);
+}
+
+void osal_spin_lock_destroy(osal_spinlock *lock)
+{
+    spinlock_t *p = NULL;
+
+    if ((lock == NULL) || (lock->lock == NULL)) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return;
+    }
+
+    p = (spinlock_t *)(lock->lock);
+    free(p);
+    lock->lock = NULL;
+}
diff --git a/bsp/osal/src/osal_task.c b/bsp/osal/src/osal_task.c
new file mode 100644
index 0000000..d8d15be
--- /dev/null
+++ b/bsp/osal/src/osal_task.c
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal task function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <kernel/thread.h>
+
+long osal_get_current_tid(void)
+{
+    return thread_get_id();
+}
diff --git a/bsp/osal/src/osal_timer.c b/bsp/osal/src/osal_timer.c
new file mode 100644
index 0000000..47ad187
--- /dev/null
+++ b/bsp/osal/src/osal_timer.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal timer function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <kernel/tee_time.h>
+#include <kernel/delay.h>
+
+#define MS_TO_USEC 1000
+
+void osal_gettimeofday(osal_timeval *tv)
+{
+    TEE_Time time;
+    TEE_Result ret = TEE_SUCCESS;
+
+    if (tv == NULL) {
+        osal_printk("parameter invalid!\n");
+        return;
+    }
+
+    ret = tee_time_get_ree_time(&time);
+    if (ret != TEE_SUCCESS) {
+        osal_printk("%s failed!\n", __FUNCTION__);
+        return;
+    }
+
+    tv->tv_sec = time.seconds;
+    tv->tv_usec = time.millis * MS_TO_USEC;
+}
+
+void osal_msleep_uninterruptible(unsigned int msecs)
+{
+    tee_time_wait(msecs);
+}
+
+void osal_udelay(unsigned int usecs)
+{
+    udelay(usecs);
+}
+
+void osal_mdelay(unsigned int msecs)
+{
+    mdelay(msecs);
+}
diff --git a/bsp/osal/src/osal_wait.c b/bsp/osal/src/osal_wait.c
new file mode 100644
index 0000000..a438a52
--- /dev/null
+++ b/bsp/osal/src/osal_wait.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the osal wait function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <ot_osal.h>
+#include <stdio.h>
+#include <kernel/wait_queue.h>
+#include <kernel/spinlock.h>
+#include <tee_api_defines.h>
+#include <optee_rpc_cmd.h>
+
+int osal_wait_init(osal_wait *wait)
+{
+    if (wait == NULL || wait->wait != NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+    wait->wait = (struct wait_queue *)malloc(sizeof(struct wait_queue));
+    if (wait->wait == NULL) {
+        osal_printk("%s - malloc failed!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+    wq_init(wait->wait);
+
+    return OSAL_SUCCESS;
+}
+
+int osal_wait_uninterruptible(osal_wait *wait, osal_wait_condition_func func, const void *param)
+{
+    struct wait_queue_elem wqe;
+    int flag;
+    bool wait_read = true;
+
+    if (wait == NULL || wait->wait == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    if (func == NULL) {
+        return OSAL_SUCCESS;
+    }
+
+    flag = func(param);
+
+    while (!flag) {
+        wq_wait_init(wait->wait, &wqe, wait_read);
+        wq_wait_final(wait->wait, &wqe, NULL, "osal_wait_uninterruptible", __LINE__);
+        flag = func(param);
+    }
+
+    return OSAL_SUCCESS;
+}
+
+int osal_wait_timeout_uninterruptible(osal_wait *wait, osal_wait_condition_func func, const void *param, \
+    unsigned long ms)
+{
+    struct wait_queue_elem wqe;
+    unsigned flag;
+    bool wait_read = true;
+    unsigned long time_left = ms;
+
+    if (wait == NULL || wait->wait == NULL) {
+        osal_printk("%s - parameter invalid!\n", __FUNCTION__);
+        return OSAL_ERROR;
+    }
+
+    if (func == NULL || ms == 0) {
+        return OSAL_SUCCESS;
+    }
+
+    flag = func(param);
+
+    while (!flag && time_left != 0) {
+        wq_wait_init(wait->wait, &wqe, wait_read);
+        time_left = wq_wait_final_timeout(wait->wait, &wqe, NULL, time_left, \
+                                          "osal_wait_timeout_uninterruptible", __LINE__);
+        flag = func(param);
+    }
+
+    return OSAL_SUCCESS;
+}
+
+void osal_wait_wakeup(osal_wait *wait) // same as wake_up_all
+{
+    struct wait_queue *wq = NULL;
+
+    if (wait == NULL || wait->wait == NULL) {
+        osal_printk("wait is NULL!\n");
+        return;
+    }
+
+    wq = (struct wait_queue *)wait->wait;
+    wq_wake_next(wq, NULL, NULL, 0);
+}
+
+void osal_wait_destroy(osal_wait *wait)
+{
+    if (wait == NULL || wait->wait == NULL) {
+        osal_printk("wait is NULL!\n");
+        return;
+    }
+
+    free(wait->wait);
+    wait->wait = NULL;
+}
diff --git a/bsp/osal/src/sub.mk b/bsp/osal/src/sub.mk
new file mode 100644
index 0000000..245c3bb
--- /dev/null
+++ b/bsp/osal/src/sub.mk
@@ -0,0 +1,17 @@
+srcs-y += osal_debug.c
+srcs-y += osal_mutex.c
+srcs-y += osal_addr.c
+srcs-y += osal_timer.c
+srcs-y += osal_cache.c
+ifeq ($(filter y, $(CFG_HI3516CV610) $(CFG_HIXMATRIX)), )
+srcs-y += osal_atomic.c
+srcs-y += osal_interrupt.c
+srcs-y += osal_math.c
+srcs-y += osal_spinlock.c
+srcs-y += osal_wait.c
+srcs-y += osal_task.c
+srcs-y += osal_barrier.c
+srcs-y += osal_device.c
+srcs-y += osal_proc.c
+srcs-y += osal_semaphore.c
+endif
\ No newline at end of file
diff --git a/bsp/osal/sub.mk b/bsp/osal/sub.mk
new file mode 100644
index 0000000..fec9ac5
--- /dev/null
+++ b/bsp/osal/sub.mk
@@ -0,0 +1,4 @@
+
+global-incdirs-y += include
+
+subdirs-y += src
diff --git a/bsp/security_subsys/.gitignore b/bsp/security_subsys/.gitignore
new file mode 100644
index 0000000..0a38a1c
--- /dev/null
+++ b/bsp/security_subsys/.gitignore
@@ -0,0 +1 @@
+security_subsys_common/
diff --git a/bsp/security_subsys/README.md b/bsp/security_subsys/README.md
new file mode 100644
index 0000000..50fd282
--- /dev/null
+++ b/bsp/security_subsys/README.md
@@ -0,0 +1,2 @@
+# optee_security_subsys
+
diff --git a/bsp/security_subsys/crypto_features.h b/bsp/security_subsys/crypto_features.h
new file mode 100755
index 0000000..7dc806e
--- /dev/null
+++ b/bsp/security_subsys/crypto_features.h
@@ -0,0 +1,273 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2008-2020. All rights reserved.
+ * Description   : Automatically generated C config: don't edit
+ * Author        : Hisilicon multimedia software
+ * Create        : 2008/06/06
+ */
+#ifndef CRYPTO_FEATURES_H
+#define CRYPTO_FEATURES_H
+
+
+/*
+ * TRNG Configuration
+ */
+#define CONFIG_TRNG_SUPPORT 1
+
+/*
+ * Symc Configuration
+ */
+#define CONFIG_SYMC_SUPPORT 1
+#define CONFIG_SYMC_CCM_SUPPORT 1
+#define CONFIG_SYMC_GCM_SUPPORT 1
+#define CONFIG_SYMC_CMAC_SUPPORT 1
+#define CONFIG_SYMC_CBC_MAC_SUPPORT 1
+#define CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT 1
+#define CONFIG_SYMC_PROC_SUPPORT 1
+#define CONFIG_SYMC_IRQ_SUPPORT 1
+#define CONFIG_SYMC_128_SUPPORT 1
+#define CONFIG_SYMC_256_SUPPORT 1
+// #define CONFIG_SYMC_MODE_ECB_SUPPORT 1
+#define CONFIG_SYMC_MODE_CTR_SUPPORT 1
+#define CONFIG_SYMC_MODE_OFB_SUPPORT 1
+#define CONFIG_SYMC_MODE_CFB_SUPPORT 1
+#define CONFIG_SYMC_MODE_CCM_SUPPORT 1
+#define CONFIG_SYMC_MODE_GCM_SUPPORT 1
+#define CONFIG_SYMC_MODE_CBC_MAC_SUPPORT 1
+#define CONFIG_SYMC_MODE_CMAC_SUPPORT 1
+#define CONFIG_SYMC_ALG_SM4_SUPPORT 1
+#define CONFIG_SYMC_BIT_WIDTH_64_SUPPORT 1
+#define CONFIG_SYMC_BIT_WIDTH_8_SUPPORT 1
+#define CONFIG_SYMC_SM4_MAC_SUPPORT 1
+
+/*
+ * Hash Configuration
+ */
+#define CONFIG_HASH_SUPPORT 1
+#define CONFIG_HASH_PBKDF2_SUPPORT 1
+
+#define CONFIG_HASH_CLONE_SUPPORT 1
+#define CONFIG_HASH_HMAC_KEYSLOT_SUPPORT 1
+#define CONFIG_HASH_SOFT_HMAC_SUPPORT 1
+#define CONFIG_HASH_SHA256_SUPPORT 1
+#define CONFIG_HASH_SM3_SUPPORT 1
+
+/*
+ * FAPC Configuration
+ */
+
+/*
+ * KM Configuration
+ */
+#define CONFIG_KM_SUPPORT 1
+#define CONFIG_KM_CLEAR_KEY_SUPPORT 1
+#define CONFIG_KM_KEY_LEN_192_SUPPORT 1
+#define CONFIG_KM_KEY_LEN_256_SUPPORT 1
+#define CONFIG_KM_KDF_SM3_SUPPORT 1
+
+/*
+ * KM RootKey support
+ */
+#define CONFIG_KM_ERK_TEE_SUPPORT 1
+#define CONFIG_KM_ERK_REE_SUPPORT 1
+#define CONFIG_KM_ERK1_REE_SUPPORT 1
+#define CONFIG_KM_ERK2_REE_SUPPORT 1
+
+/*
+ * OTP Configuration
+ */
+#define CONFIG_OTP_SUPPORT 1
+#define CONFIG_OTP_READ_BYTE_SUPPORT 1
+#define CONFIG_OTP_WRITE_BYTE_SUPPORT 1
+#define CONFIG_OTP_GET_DIE_ID_SUPPORT 1
+#define CONFIG_OTP_MEMORY_MAX_ADDR 0x1ff
+
+/*
+ * PKE Configuration
+ */
+#define CONFIG_PKE_SUPPORT 1
+
+/*
+ * PKE Cal Configuration
+ */
+#define CONFIG_PKE_CAL_SUPPORT 1
+#define CONFIG_DRV_PKE_CAL_SUPPORT 1
+#define CONFIG_PKE_EXP_MOD_SUPPORT 1
+#define CONFIG_PKE_MOD_SUPPORT 1
+
+/*
+ * PKE RSA Configuration
+ */
+#define CONFIG_PKE_RSA_SUPPORT 1
+#define CONFIG_PKE_RSA_SIGN_SUPPORT 1
+#define CONFIG_PKE_RSA_VERIFY_SUPPORT 1
+#define CONFIG_PKE_RSA_PUB_ENC_SUPPORT 1
+#define CONFIG_PKE_RSA_PRIV_DEC_SUPPORT 1
+// #define CONFIG_PKE_RSA_V15_SUPPORT 1
+#define CONFIG_PKE_RSA_V21_SUPPORT 1
+#define CONFIG_PKE_RSA_3072_SUPPORT 1
+#define CONFIG_PKE_RSA_4096_SUPPORT 1
+#define CONFIG_PKE_RSA_SHA256_SUPPORT 1
+
+/*
+ * PKE ECC Configuration
+ */
+#define CONFIG_PKE_ECC_SUPPORT 1
+
+/*
+ * ECC Curve Type Configuration
+ */
+#define CONFIG_PKE_SUPPORT_ECC_BP256R 1
+#define CONFIG_PKE_SUPPORT_ECC_BP384R 1
+#define CONFIG_PKE_SUPPORT_ECC_BP512R 1
+#define CONFIG_PKE_SUPPORT_SM2 1
+// #define CONFIG_PKE_SUPPORT_ECC_FIPS_P256R 1
+// #define CONFIG_PKE_SUPPORT_ECC_FIPS_P384R 1
+// #define CONFIG_PKE_SUPPORT_ECC_FIPS_P521R 1
+#define CONFIG_PKE_ECC_CHECK_DOT_ON_CURVE_SUPPORT 1
+#define CONFIG_PKE_ECC_ECDSA_SIGN_SUPPORT 1
+#define CONFIG_PKE_ECC_ECDSA_VERIFY_SUPPORT 1
+#define CONFIG_PKE_ECC_SM2_DSA_HASH_SUPPORT 1
+#define CONFIG_PKE_ECC_SM2_SIGN_SUPPORT 1
+#define CONFIG_PKE_ECC_SM2_VERIFY_SUPPORT 1
+#define CONFIG_PKE_ECC_ECDH_SUPPORT 1
+#define CONFIG_PKE_ECC_GEN_KEY_SUPPORT 1
+#define CONFIG_PKE_ECC_SM2_PUB_ENC_SUPPORT 1
+#define CONFIG_PKE_ECC_SM2_PRIV_DEC_SUPPORT 1
+#define CONFIG_PKE_TRNG_SUPPORT 1
+#define CONFIG_PKE_CAL_HASH_SUPPORT 1
+
+/*
+ * UAPI Layer Configuration
+ */
+#define CONFIG_UAPI_SUPPORT 1
+#define CONFIG_UAPI_HASH_SUPPORT 1
+#define CONFIG_UAPI_KDF_SUPPORT 1
+#define CONFIG_UAPI_KM_SUPPORT 1
+#define CONFIG_UAPI_OTP_SUPPORT 1
+#define CONFIG_UAPI_PKE_SUPPORT 1
+#define CONFIG_UAPI_SYMC_SUPPORT 1
+#define CONFIG_UAPI_TRNG_SUPPORT 1
+
+/*
+ * DISPATCH Layer Configuration
+ */
+#define CONFIG_DISPATCH_SUPPORT 1
+
+/*
+ * KAPI Layer Configuration
+ */
+#define CONFIG_KAPI_SUPPORT 1
+#define CONFIG_KAPI_SYMC_SUPPORT 1
+#define CONFIG_SYMC_KAPI_DMA_BUF_LEN 4096
+#define CONFIG_KAPI_PKE_SUPPORT 1
+#define CONFIG_KAPI_HASH_SUPPORT 1
+#define CONFIG_HASH_KAPI_DMA_BUF_LEN 4096
+#define CONFIG_KAPI_TRNG_SUPPORT 1
+#define CONFIG_MAX_PROCESS_NUM 2
+#define CONFIG_DRV_AAD_SIZE 1024
+#define CONFIG_KAPI_KM_SUPPORT 1
+#define CONFIG_KAPI_OTP_SUPPORT 1
+
+/*
+ * DRV Layer Configuration
+ */
+#define CONFIG_DRV_SYMC_SUPPORT 1
+#define CONFIG_DRV_PKE_SUPPORT 1
+#define CONFIG_DRV_HASH_SUPPORT 1
+#define CONFIG_DRV_TRNG_SUPPORT 1
+#define CONFIG_DRV_KM_SUPPORT 1
+#define CONFIG_DRV_OTP_SUPPORT 1
+
+/*
+ * HAL Layer Configuration
+ */
+#define CONFIG_HAL_TRNG_V4_SUPPORT 1
+#define CONFIG_HAL_SPACC_V4_SUPPORT 1
+#define CONFIG_HAL_PKE_V5_SUPPORT 1
+#define CONFIG_PKE_ROM_LIB_START_ADDR 0xC00000
+#define CONFIG_HAL_KM_V4_SUPPORT 1
+
+/*
+ * Parameters Configuration
+ */
+#define CONFIG_MMU_SUPPORT 1
+#define CONFIG_SYMC_HARD_CHN_CNT 3
+#define CONFIG_SYMC_HARD_CHANNEL_MASK 0xFFFF
+#define CONFIG_HASH_HARD_CHN_CNT 3
+#define CONFIG_HASH_HARD_CHN_MASK 0xFFFF
+
+/*
+ * Timeout Parameters Configuration
+ */
+#define CONFIG_HASH_CLEAR_CHN_TIMEOUT 10000
+#define CONFIG_HASH_CALC_TIMEOUT 1000000
+#define CONFIG_PKE_TIMEOUT_IN_US 10000
+#define CONFIG_TRNG_TIMEOUT_IN_US 10000
+#define CONFIG_SYMC_WAIT_TIMEOUT_IN_US 1000000
+#define CONFIG_SYMC_CLEAR_TIMEOUT_IN_US 10000
+#define CONFIG_RKP_WAIT_TIMEOUT_IN_US 10000
+#define CONFIG_KLAD_COM_ROUTE_TIMEOUT_IN_US 10000
+#define CONFIG_OT_TYPE_SUPPORT 1
+
+#if defined(CONFIG_HI3516CV610)
+#define CONFIG_SYMC_192_SUPPORT 1
+#define CONFIG_SYMC_BIT_WIDTH_1_SUPPORT 1
+#define CONFIG_HASH_PBKDF2_SOFT_SUPPORT 1
+#define CONFIG_SYMC_SM4_CFB_OFB_SUPPORT 1
+#define CONFIG_KM_EFFECTIVE_KEY_SUPPORT 1
+#define CONFIG_KM_KEYSLOT_SOFT_SUPPORT 1
+#define CRYPTO_IOT_V200 1
+#define CONFIG_HASH_VIRT_CHN_NUM 8
+#define CONFIG_SYMC_VIRT_CHN_NUM 8
+#define CONFIG_SPACC_NONALIGNED_ADDR_SUPPORT    1
+#define CONFIG_SPACC_ADDR_ALIGN_LEN 1
+#endif
+
+#if defined(CONFIG_HI3519DV500)
+#define CONFIG_HASH_SHA384_SUPPORT 1
+#define CONFIG_HASH_SHA512_SUPPORT 1
+#define CONFIG_HASH_PBKDF2_HARD_SUPPORT 1
+#define CONFIG_KM_SESSION_KEY_SUPPORT 1
+#define CONFIG_KM_CONTENT_KEY_SUPPORT 1
+#define CONFIG_KM_ABRK1_SUPPORT 1
+#define CONFIG_KM_ABRK2_SUPPORT 1
+#define CONFIG_KM_ODRK1_SUPPORT 1
+#define CONFIG_KM_DRK1_SUPPORT 1
+#define CONFIG_KM_RDRK0_SUPPORT 1
+#define CONFIG_KM_RDRK1_SUPPORT 1
+#define CONFIG_KM_MDRK0_SUPPORT 1
+#define CONFIG_KM_MDRK1_SUPPORT 1
+#define CONFIG_KM_MDRK2_SUPPORT 1
+#define CONFIG_KM_MDRK3_SUPPORT 1
+#define CONFIG_KM_SBRK2_SUPPORT 1
+#define CONFIG_KM_KEYSLOT_HARD_SUPPORT 1
+#define CONFIG_PKE_SUPPORT_ECC_CURVE_25519 1
+#define CONFIG_PKE_SUPPORT_ECC_ED25519 1
+#define CONFIG_PKE_ECC_EDDSA_SIGN_SUPPORT 1
+#define CONFIG_PKE_ECC_EDDSA_VERIFY_SUPPORT 1
+#define CONFIG_KM_SM4_SUPPORT 1
+#define CONFIG_HASH_VIRT_CHN_NUM 32
+#define CONFIG_SYMC_VIRT_CHN_NUM 8
+#define CONFIG_SPACC_ADDR_ALIGN_LEN 4
+#endif
+
+/*
+ * Romable API Configuration
+ */
+
+/*
+ * Test Configuration
+ */
+#define CONFIG_UT_SUPPORT 1
+
+/*
+ * Application Configuration
+ */
+
+/*
+ * Log Configuration
+ */
+#define CONFIG_CRYPTO_LOG_INFO_DISABLE 1
+#define CONFIG_CRYPTO_LOG_PTR_CHK_INFO_DISABLE 1
+
+#endif /* CRYPTO_FEATURES_H */
diff --git a/bsp/security_subsys/crypto_platform.h b/bsp/security_subsys/crypto_platform.h
new file mode 100644
index 0000000..0df7cdb
--- /dev/null
+++ b/bsp/security_subsys/crypto_platform.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef CRYPTO_PLATFORM_H
+#define CRYPTO_PLATFORM_H
+
+/* Register Base Addr. */
+#define SEC_SUBSYS_BASE_ADDR    0x10100000
+
+#define SPACC_REG_BASE_ADDR     (SEC_SUBSYS_BASE_ADDR + 0xF0000)
+#define SPACC_REG_SIZE          (0x10000)
+
+#define TRNG_REG_BASE_ADDR      (SEC_SUBSYS_BASE_ADDR + 0xEE000)
+#define TRNG_REG_SIZE           (0x1000)
+
+#define PKE_REG_BASE_ADDR       (SEC_SUBSYS_BASE_ADDR + 0xEC000)
+#define PKE_REG_SIZE            (0x2000)
+
+#define CA_MISC_REG_BASE_ADDR   (SEC_SUBSYS_BASE_ADDR + 0xE8000)
+#define CA_MISC_REG_SIZE        (0x1000)
+
+#define KM_REG_BASE_ADDR        (SEC_SUBSYS_BASE_ADDR + 0xEA000)
+#define KM_REG_SIZE             (0x2000)
+
+#define OTPC_BASE_ADDR          (SEC_SUBSYS_BASE_ADDR + 0xE0000)
+#define OTPC_ADDR_SIZE          (0x2000)
+
+#define CRYPTO_DRV_AAD_SIZE             (4 * 1024)
+#define CRYPTO_HASH_DRV_BUFFER_SIZE     (128 * 1024)
+
+/* Define the time out us */
+#define PKE_TIME_OUT_US               10000000
+#define PKE_MAX_TIMES                 3000
+
+/* PKE related defines */
+/* define PKE rom lib related register micro. */
+#ifdef DEBUG_IN_RAM
+#define PKE_ROM_LIB_START_ADDR              ((uintptr_t)g_instr_rom)  /* the instr start address */
+#else
+#define PKE_ROM_LIB_START_ADDR              (0xc00000)  /* the instr start address */
+#endif
+#define PKE_ROM_LIB_INVALID_ADDR            0xFFFFFFFF
+#define ROM_LIB_INSTR_NUM                   646         /* define the instr number, that put in the ROM. */
+
+/* whether to enable the DFA function */
+#define CRYPTO_DRV_DFA_ENABLE
+
+#define CRYPTO_STATIC static
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/drivers/cipher/crypto_drv_init.c b/bsp/security_subsys/drivers/cipher/crypto_drv_init.c
new file mode 100644
index 0000000..f5f1461
--- /dev/null
+++ b/bsp/security_subsys/drivers/cipher/crypto_drv_init.c
@@ -0,0 +1,262 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. Ltd. 2019-2019. All rights reserved.
+ * Description: drivers of drv_osal_init
+ * Author: AuthorNameMagicTag
+ * Create: 2019-06-18
+ */
+#include <initcall.h>
+#include <tee/tee_svc_security_subsys.h>
+
+#include "crypto_drv_common.h"
+#include "crypto_pke_common.h"
+#include "crypto_ioctl_cmd.h"
+#include "crypto_dispatch.h"
+#include "kapi_inner.h"
+#include "mmz_ext.h"
+
+#if defined(CRYPTO_UT_TEST_ENABLE)
+#include "hal_test.h"
+#include "drv_test.h"
+#include "kapi_test.h"
+#endif
+
+#if defined(CRYPTO_DTS_TEST_ENABLE)
+#include "dts_test.h"
+#endif
+
+#define CRYPTO_MOD_CIPHER_NAME  "cipher"
+#define CRYPTO_DEV_CIPHER_NAME  "soc_cipher"
+
+#define unused(x)             (void)(x)
+
+#define CRYPTO_MEM_POOL_NUM             100
+static crypto_mutex g_mem_pool_lock;
+
+typedef struct {
+    td_void *mem_handle;
+    td_void *virt_addr;
+    td_phys_addr_t phys_addr;
+    td_u32 size;
+    td_bool is_used;
+} crypto_mem_pool;
+
+static crypto_mem_pool g_coherent_mem_pool[CRYPTO_MEM_POOL_NUM] = {0};
+
+td_void *crypto_malloc_coherent(td_u32 size, const td_char *name)
+{
+    td_u32 i;
+    td_s32 ret;
+    td_void *virt_addr = TD_NULL;
+    td_phys_addr_t phys_addr = 0;
+    crypto_mem_pool *mem_pool = TD_NULL;
+
+    crypto_mutex_lock(&g_mem_pool_lock);
+    for (i = 0; i < CRYPTO_MEM_POOL_NUM; i++) {
+        if (g_coherent_mem_pool[i].is_used == TD_FALSE) {
+            mem_pool = &g_coherent_mem_pool[i];
+            break;
+        }
+    }
+    if (mem_pool == TD_NULL) {
+        crypto_log_err("Memory Pool is Full!\n");
+        crypto_mutex_unlock(&g_mem_pool_lock);
+        return TD_NULL;
+    }
+
+    ret = drv_mmz_alloc(&phys_addr, "cipher", "SMMZ2", size);
+    if (ret != 0) {
+        crypto_log_err("drv_mmz_alloc failed\n");
+        crypto_mutex_unlock(&g_mem_pool_lock);
+        return TD_NULL;
+    }
+
+    virt_addr = drv_mmz_map_nocache(phys_addr, size);
+    crypto_chk_goto(virt_addr == TD_NULL, error_mmz_free, "drv_mmz_map_nocache failed\n");
+
+    mem_pool->virt_addr = virt_addr;
+    mem_pool->phys_addr = phys_addr;
+    mem_pool->size = size;
+    mem_pool->is_used = TD_TRUE;
+    (td_void)memset_s(virt_addr, size, 0x00, size);
+
+    crypto_mutex_unlock(&g_mem_pool_lock);
+    return mem_pool->virt_addr;
+error_mmz_free:
+    drv_mmz_free(phys_addr);
+    crypto_mutex_unlock(&g_mem_pool_lock);
+    return TD_NULL;
+}
+
+td_void *crypto_malloc_mmz(td_u32 size, const td_char *name)
+{
+    return crypto_malloc_coherent(size, name);
+}
+
+td_void crypto_free_coherent(const td_void *ptr)
+{
+    td_u32 i;
+    crypto_mem_pool *mem_pool = TD_NULL;
+
+    crypto_mutex_lock(&g_mem_pool_lock);
+    for (i = 0; i < CRYPTO_MEM_POOL_NUM; i++) {
+        if (g_coherent_mem_pool[i].virt_addr == ptr && g_coherent_mem_pool[i].is_used == TD_TRUE) {
+            mem_pool = &g_coherent_mem_pool[i];
+            break;
+        }
+    }
+    if (mem_pool == TD_NULL) {
+        crypto_log_err("Invalid Ptr!\n");
+        crypto_mutex_unlock(&g_mem_pool_lock);
+        return;
+    }
+    drv_mmz_unmap(mem_pool->virt_addr, mem_pool->size);
+    drv_mmz_free(mem_pool->phys_addr);
+    (td_void)memset_s(mem_pool, sizeof(crypto_mem_pool), 0, sizeof(crypto_mem_pool));
+    crypto_mutex_unlock(&g_mem_pool_lock);
+}
+
+td_u64 crypto_get_phys_addr(const td_void *ptr)
+{
+    td_u32 i;
+    crypto_mem_pool *mem_pool = TD_NULL;
+
+    for (i = 0; i < CRYPTO_MEM_POOL_NUM; i++) {
+        mem_pool = &g_coherent_mem_pool[i];
+        if (mem_pool->is_used == TD_FALSE) {
+            continue;
+        }
+        if ((td_u8 *)ptr >= (td_u8 *)mem_pool->virt_addr && (td_u8 *)ptr < (td_u8 *)mem_pool->virt_addr +
+            mem_pool->size) {
+            return mem_pool->phys_addr + (unsigned long)((td_u8 *)ptr - (td_u8 *)mem_pool->virt_addr);
+        }
+    }
+    return 0;
+}
+
+static td_s32 crypto_drv_mod_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+
+#if defined(CRYPTO_UT_TEST_ENABLE)
+    hal_test_trng_entry();
+    hal_test_symc_entry();
+    hal_test_hash_entry();
+    drv_test_trng_entry();
+    drv_test_symc_entry();
+    drv_test_hash_entry();
+    drv_test_pke_entry();
+#endif
+
+    ret = crypto_mutex_init(&g_mem_pool_lock);
+    crypto_chk_return(ret != TD_SUCCESS, TD_FAILURE, "crypto_mutex_init failed\n");
+
+    /* KAPI Init. */
+    ret = kapi_cipher_hash_env_init();
+    crypto_chk_goto(ret != TD_SUCCESS, error_unlock_mem_pool,
+        "kapi_cipher_hash_env_init failed, ret is 0x%x.\n", ret);
+
+    ret = kapi_cipher_trng_env_init();
+    crypto_chk_goto(ret != TD_SUCCESS, error_kapi_hash_env_deinit,
+        "kapi_cipher_trng_env_init failed, ret is 0x%x.\n", ret);
+
+    ret = kapi_cipher_symc_env_init();
+    crypto_chk_goto(ret != TD_SUCCESS, error_kapi_trng_env_deinit,
+        "kapi_cipher_symc_env_init failed, ret is 0x%x.\n", ret);
+
+    ret = kapi_cipher_pke_env_init();
+    crypto_chk_goto(ret != TD_SUCCESS, error_kapi_symc_env_deinit,
+        "kapi_cipher_pke_env_init failed, ret is 0x%x.\n", ret);
+
+    crypto_curve_param_init();
+
+#if defined(CRYPTO_UT_TEST_ENABLE)
+    kapi_test_trng_entry();
+    kapi_test_symc_entry();
+    drv_test_pke_entry();
+#endif
+
+#if defined(CRYPTO_DTS_TEST_ENABLE)
+    dts_test_kapi_entry();
+#endif
+
+    crypto_print("load Secure Cipher success.\n");
+    return ret;
+
+error_kapi_symc_env_deinit:
+    kapi_cipher_symc_env_deinit();
+error_kapi_trng_env_deinit:
+    kapi_cipher_trng_env_deinit();
+error_kapi_hash_env_deinit:
+    kapi_cipher_hash_env_deinit();
+error_unlock_mem_pool:
+    crypto_mutex_destroy(&g_mem_pool_lock);
+    return ret;
+}
+
+static td_s32 crypto_ioctl(td_u32 cmd, td_void *argp)
+{
+    td_u32 nr;
+    td_s32 ret;
+    crypto_ioctl_cmd *ioctl_cmd = TD_NULL;
+    td_u32 cmd_cnt = 0;
+
+    crypto_chk_return(argp == TD_NULL, TD_FAILURE, "argp is NULL!\n");
+
+    ioctl_cmd = crypto_get_ioctl_cmd_list();
+    crypto_chk_return(ioctl_cmd == TD_NULL, TD_FAILURE, "crypto_get_ioctl_cmd_list failed\n");
+
+    cmd_cnt = crypto_get_ioctl_cmd_cnt();
+
+    nr = CRYPTO_IOC_NR(cmd);
+    crypto_chk_return(nr >= cmd_cnt, TD_FAILURE, "Invalid NR!\n");
+
+    ret = ioctl_cmd[nr].handler(cmd, argp, TD_NULL);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "ioctl_cmd failed, cmd is 0x%x\n", cmd);
+
+    return ret;
+}
+
+#define CRYPTO_IOCTL_ARG_MAX_SIZE 0x100
+static int crypto_drv_ioctl(void *param, size_t param_len)
+{
+    td_u8 local[CRYPTO_IOCTL_ARG_MAX_SIZE] = {0};
+    td_u32 size = 0;
+    td_s32 ret = TD_FAILURE;
+    TEE_SECURITY_SUBSYS_Data data = *(TEE_SECURITY_SUBSYS_Data *)param;
+
+    crypto_chk_return(sizeof(data) != param_len, TD_FAILURE, "check param_len failed!\n");
+
+    size = CRYPTO_IOC_SIZE(data.cmd);
+    if (size >= CRYPTO_IOCTL_ARG_MAX_SIZE) {
+        return TD_FAILURE;
+    }
+
+    if (size != 0) {
+        ret = crypto_copy_from_user(local, sizeof(local), data.param, size);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_copy_from_user failed\n");
+    }
+
+    ret = crypto_ioctl(data.cmd, local);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "crypto_ioctl failed\n");
+
+    if (CRYPTO_IOC_DIR(data.cmd) & CRYPTO_IOC_R) {
+        ret = crypto_copy_to_user(data.param, size, local, size);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "crypto_copy_to_user failed\n");
+    }
+
+exit_clean:
+    (td_void)memset_s(local, sizeof(local), 0, sizeof(local));
+    return ret;
+}
+
+TEE_Result syscall_cipher_ioctl(void *param, size_t param_len)
+{
+    return crypto_drv_ioctl(param, param_len);
+}
+
+static TEE_Result ot_unified_cipher_init(void)
+{
+    return (TEE_Result)crypto_drv_mod_init();
+}
+
+service_init_late(ot_unified_cipher_init);
diff --git a/bsp/security_subsys/drivers/crypto_osal/crypto_osal_lib.c b/bsp/security_subsys/drivers/crypto_osal/crypto_osal_lib.c
new file mode 100644
index 0000000..730104d
--- /dev/null
+++ b/bsp/security_subsys/drivers/crypto_osal/crypto_osal_lib.c
@@ -0,0 +1,168 @@
+#include <kernel/user_access.h>
+
+#include "crypto_platform.h"
+#include "crypto_common_macro.h"
+#include "crypto_drv_common.h"
+#include "mmz_ext.h"
+
+#define PKE_CLOCK_BIT 3
+#define PKE_RESET_BIT 2
+
+register_phys_mem(MEM_AREA_IO_SEC, OTPC_BASE_ADDR, OTPC_ADDR_SIZE);
+register_phys_mem(MEM_AREA_IO_SEC, CA_MISC_REG_BASE_ADDR, CA_MISC_REG_SIZE);
+register_phys_mem(MEM_AREA_IO_SEC, KM_REG_BASE_ADDR, KM_REG_SIZE);
+register_phys_mem(MEM_AREA_IO_SEC, PKE_REG_BASE_ADDR, PKE_REG_SIZE);
+register_phys_mem(MEM_AREA_IO_SEC, TRNG_REG_BASE_ADDR, TRNG_REG_SIZE);
+register_phys_mem(MEM_AREA_IO_SEC, SPACC_REG_BASE_ADDR, SPACC_REG_SIZE);
+
+unsigned long crypto_osal_get_phys_addr(const crypto_buf_attr *buf)
+{
+    return buf->phys_addr;
+}
+
+td_bool crypto_data_buf_check(const crypto_buf_attr *buf_attr, td_u32 length)
+{
+    td_s32 ret = TD_FAILURE;
+    if (buf_attr == TD_NULL) {
+        return TD_FALSE;
+    }
+
+    ret = drv_mmz_check_phys_and_ta(buf_attr->phys_addr, length);
+    if (ret == TD_SUCCESS) {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+/* Crypto Owner Operation. */
+td_s32 crypto_get_owner(crypto_owner *owner)
+{
+    struct ts_ctx *ctx = thread_get_tsd()->ctx;
+    if (ctx == TD_NULL) {
+        return CRYPTO_FAILURE;
+    }
+    if (owner == TD_NULL) {
+        return CRYPTO_FAILURE;
+    }
+    if (memcpy_s(owner, sizeof(crypto_owner), &ctx->uuid, sizeof(crypto_owner)) != EOK) {
+        return CRYPTO_FAILURE;
+    }
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 crypto_virt_xor_phys_copy_to_phys(td_u64 dst_phys_addr, const td_u8 *a_virt_addr,
+    td_u64 b_phys_addr, td_u32 length)
+{
+    td_s32 ret;
+    td_u32 i;
+    td_u8 *b_virt_addr = TD_NULL;
+    td_u8 *dst_virt_addr = TD_NULL;
+
+    b_virt_addr = drv_mmz_map_nocache(b_phys_addr, length);
+    crypto_chk_goto_with_ret(ret, b_virt_addr == TD_NULL, exit, TD_FAILURE, "drv_mmz_map_nocache failed\n");
+
+    dst_virt_addr = drv_mmz_map_nocache(dst_phys_addr, length);
+    crypto_chk_goto_with_ret(ret, dst_virt_addr == TD_NULL, exit, TD_FAILURE, "drv_mmz_map_nocache failed\n");
+
+    for (i = 0; i < length; i++) {
+        dst_virt_addr[i] = a_virt_addr[i] ^ b_virt_addr[i];
+    }
+
+    ret = TD_SUCCESS;
+exit:
+    if (b_virt_addr != TD_NULL) {
+        drv_mmz_unmap(b_virt_addr, length);
+    }
+    if (dst_virt_addr != TD_NULL) {
+        drv_mmz_unmap(dst_virt_addr, length);
+    }
+    return ret;
+}
+
+td_s32 crypto_virt_copy_to_phys(td_phys_addr_t dst_phys_addr, const td_u8 *src_virt_addr, td_u32 length)
+{
+    td_s32 ret;
+    td_u8 *dst_virt_addr = TD_NULL;
+ 
+    dst_virt_addr = drv_mmz_map_nocache(dst_phys_addr, length);
+    crypto_chk_goto_with_ret(ret, dst_virt_addr == TD_NULL, exit, TD_FAILURE, "cmpi_remap_nocache failed\n");
+ 
+    ret = memcpy_s(dst_virt_addr, length, src_virt_addr, length);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit, TD_FAILURE, "memcpy_s failed\n");
+ 
+    ret = TD_SUCCESS;
+exit:
+    if (dst_virt_addr != TD_NULL) {
+        drv_mmz_unmap(dst_virt_addr, length);
+    }
+    return ret;
+}
+ 
+ 
+td_s32 crypto_phys_copy_to_virt(td_u8 *dst_virt_addr, td_phys_addr_t src_phys_addr, td_u32 length)
+{
+    td_s32 ret;
+    td_u8 *src_virt_addr = TD_NULL;
+ 
+    src_virt_addr = drv_mmz_map_nocache(src_phys_addr, length);
+    crypto_chk_goto_with_ret(ret, src_virt_addr == TD_NULL, exit, TD_FAILURE, "cmpi_remap_nocache failed\n");
+ 
+    ret = memcpy_s(dst_virt_addr, length, src_virt_addr, length);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit, TD_FAILURE, "memcpy_s failed\n");
+ 
+    ret = TD_SUCCESS;
+exit:
+    if (src_virt_addr != TD_NULL) {
+        drv_mmz_unmap(src_virt_addr, length);
+    }
+    return ret;
+}
+
+td_s32 crypto_copy_from_user(td_void *to, unsigned long to_len, const td_void *from, unsigned long from_len)
+{
+    if (from_len == 0) {
+        return TD_SUCCESS;
+    }
+
+    if (to == TD_NULL) {
+        crypto_log_err("to is NULL\n");
+        return TD_FAILURE;
+    }
+    if (from == TD_NULL) {
+        crypto_log_err("from is NULL\n");
+        return TD_FAILURE;
+    }
+    if (to_len < from_len) {
+        crypto_log_err("to_len is Less Than from_len!\n");
+        return TD_FAILURE;
+    }
+
+    return osal_copy_from_user(to, from, from_len);
+}
+
+td_s32 crypto_copy_to_user(td_void  *to, unsigned long to_len, const td_void *from, unsigned long from_len)
+{
+    if (from_len == 0) {
+        return TD_SUCCESS;
+    }
+    if (to == TD_NULL) {
+        crypto_log_err("to is NULL\n");
+        return TD_FAILURE;
+    }
+    if (from == TD_NULL) {
+        crypto_log_err("from is NULL\n");
+        return TD_FAILURE;
+    }
+    if (to_len < from_len) {
+        crypto_log_err("to_len is Less Than from_len!\n");
+        return TD_FAILURE;
+    }
+
+    return osal_copy_to_user(to, from, from_len);
+}
+
+td_s32 crypto_copy_from_phys_addr(td_u8 *dst, td_u32 dst_len, td_u64 src_phys_addr, td_u32 src_len)
+{
+    crypto_unused(dst_len);
+    return crypto_phys_copy_to_virt(dst, src_phys_addr, src_len);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/drivers/crypto_osal/crypto_osal_lib.h b/bsp/security_subsys/drivers/crypto_osal/crypto_osal_lib.h
new file mode 100644
index 0000000..425a62a
--- /dev/null
+++ b/bsp/security_subsys/drivers/crypto_osal/crypto_osal_lib.h
@@ -0,0 +1,135 @@
+#ifndef CRYPTO_OSAL_LIB_H
+#define CRYPTO_OSAL_LIB_H
+
+#include <io.h>
+#include <mm/core_memprot.h>
+#include <malloc.h>
+#include <kernel/mutex.h>
+#include <kernel/delay.h>
+
+#include "securec.h"
+#include "crypto_common_struct.h"
+#include "crypto_common_macro.h"
+#include "ot_osal.h"
+
+#include "crypto_security.h"
+#include "crypto_platform.h"
+#include "crypto_type.h"
+
+/* Timer. */
+#define crypto_msleep           osal_msleep
+#define crypto_udelay           osal_udelay
+
+/* map. */
+#define crypto_ioremap_nocache  osal_ioremap_nocache
+#define crypto_iounmap          osal_iounmap
+
+#define crypto_cache_all(...)
+#define crypto_cache_flush(...)
+
+/* Mutex. */
+#define crypto_mutex            osal_mutex
+#define crypto_mutex_init       osal_mutex_init
+#define crypto_mutex_destroy    osal_mutex_destroy
+#define crypto_mutex_lock       osal_mutex_lock
+#define crypto_mutex_unlock     osal_mutex_unlock
+
+/* Log. */
+#define crypto_print            osal_printk
+
+/* Malloc. */
+#define crypto_malloc(x)        (((x) > 0) ? osal_kmalloc((x), OSAL_GFP_KERNEL) : TD_NULL)
+#define crypto_free(x)          {if (((x) != TD_NULL)) osal_kfree(x);}
+
+/* ioctl_cmd. */
+#define crypto_ioctl_cmd        osal_ioctl_cmd
+
+#define crypto_getpid()             0
+#define crypto_gettid()             0
+
+/* memory. */
+td_void *crypto_malloc_coherent(td_u32 size, const td_char *name);
+
+td_void *crypto_malloc_mmz(td_u32 size, const td_char *name);
+
+td_void crypto_free_coherent(const td_void *ptr);
+
+td_u64 crypto_get_phys_addr(const td_void *ptr);
+
+#define crypto_symc_support(...)            TD_TRUE
+#define crypto_rsa_support(...)             TD_TRUE
+#define crypto_sm3_support(...)             TD_TRUE
+#define crypto_sm4_support(...)             TD_TRUE
+
+td_bool crypto_data_buf_check(const crypto_buf_attr *buf_attr, td_u32 length);
+
+#define crypto_get_cpu_type(...)            CRYPTO_CPU_TYPE_SCPU
+
+/* Register Read&Write. */
+static inline td_u32 crypto_tee_reg_read(td_u32 addr, td_u32 offset)
+{
+    td_u8 *virt = TD_NULL;
+    virt = osal_phys_to_virt(addr);
+    return crypto_reg_read(virt + offset);
+}
+
+static inline td_u32 crypto_tee_reg_write(td_u32 addr, td_u32 offset, td_u32 value)
+{
+    td_u8 *virt = TD_NULL;
+    virt = osal_phys_to_virt(addr);
+    return crypto_reg_write(virt + offset, value);
+}
+
+#define spacc_reg_read(offset)          crypto_tee_reg_read(SPACC_REG_BASE_ADDR, offset)
+#define spacc_reg_write(offset, value)  crypto_tee_reg_write(SPACC_REG_BASE_ADDR, offset, value)
+
+#define trng_reg_read(offset)           crypto_tee_reg_read(TRNG_REG_BASE_ADDR, offset)
+#define trng_reg_write(offset, value)   crypto_tee_reg_write(TRNG_REG_BASE_ADDR, offset, value)
+
+#define pke_reg_read(offset)            crypto_tee_reg_read(PKE_REG_BASE_ADDR, offset)
+#define pke_reg_write(offset, value)    crypto_tee_reg_write(PKE_REG_BASE_ADDR, offset, value)
+
+#define km_reg_read(offset)             crypto_tee_reg_read(KM_REG_BASE_ADDR, offset)
+#define km_reg_write(offset, value)     crypto_tee_reg_write(KM_REG_BASE_ADDR, offset, value)
+
+#define otpc_reg_read(offset)              crypto_tee_reg_read(OTPC_BASE_ADDR, offset)
+#define otpc_reg_write(offset, value)      crypto_tee_reg_write(OTPC_BASE_ADDR, offset, value)
+
+#define ca_misc_reg_read(offset)           crypto_tee_reg_read(CA_MISC_REG_BASE_ADDR, offset)
+#define ca_misc_reg_write(offset, value)   crypto_tee_reg_write(CA_MISC_REG_BASE_ADDR, offset, value)
+
+#define CRYPTO_EXPORT_SYMBOL(...)
+
+/* Memory Management. */
+typedef enum {
+    CRYPTO_OSAL_MMZ_TYPE,
+    CRYPTO_OSAL_NSSMMU_TYPE,
+    CRYPTO_OSAL_ERROR_TYPE,
+} crypto_osal_mem_type;
+
+unsigned long crypto_osal_get_phys_addr(const crypto_buf_attr *buf);
+#define crypto_osal_put_phys_addr(...)
+#define crypto_osal_mem_handle_get(fd, module_id)   TD_SUCCESS
+#define crypto_osal_mem_handle_put(...)
+
+#define CRYPTO_ERROR_ENV                            ERROR_ENV_OPTEE
+
+typedef void crypto_wait_t;
+
+/* Crypto Owner Operation. */
+#define crypto_owner                        TEE_UUID
+#define crypto_owner_dump(owner) do {       \
+    crypto_log_dbg("Owner's UUID is: %x-%x-%x-%02x%02x-%02x%02x%02x%02x%02x%02x\n", \
+        (owner).timeLow, (owner).timeMid, (owner).timeHiAndVersion,       \
+        (owner).clockSeqAndNode[0], (owner).clockSeqAndNode[1],         \
+        (owner).clockSeqAndNode[2], (owner).clockSeqAndNode[3],         \
+        (owner).clockSeqAndNode[4], (owner).clockSeqAndNode[5],         \
+        (owner).clockSeqAndNode[6], (owner).clockSeqAndNode[7]);        \
+} while (0)
+
+td_s32 crypto_get_owner(crypto_owner *owner);
+
+td_s32 crypto_copy_from_user(td_void *to, unsigned long to_len, const td_void *from, unsigned long from_len);
+td_s32 crypto_copy_to_user(td_void  *to, unsigned long to_len, const td_void *from, unsigned long from_len);
+
+#endif
diff --git a/bsp/security_subsys/drivers/km/crypto_km_init.c b/bsp/security_subsys/drivers/km/crypto_km_init.c
new file mode 100644
index 0000000..9ba1811
--- /dev/null
+++ b/bsp/security_subsys/drivers/km/crypto_km_init.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2017-2020. All rights reserved.
+ * Description   : drivers for linux drv osal init of cipher.
+ * Author        : Hisilicon multimedia software group
+ * Create        : 2017-10-20
+ */
+#include <initcall.h>
+#include <securec.h>
+#include <tee/tee_svc_security_subsys.h>
+
+#include "kapi_km.h"
+#include "dispatch_km.h"
+#include "crypto_common_macro.h"
+#include "crypto_drv_common.h"
+
+static td_s32 km_ioctl(td_u32 cmd, td_void *argp)
+{
+    td_u32 nr;
+    td_s32 ret;
+    crypto_ioctl_cmd *km_func_list = TD_NULL;
+    crypto_param_require(argp != TD_NULL);
+
+    nr = CRYPTO_IOC_NR(cmd);
+    km_func_list = get_km_func_list();
+    crypto_chk_return(km_func_list == TD_NULL, TD_FAILURE, "get_km_func_list failed\n");
+
+    crypto_chk_return(nr >= CMD_KM_MAX_NUM, TD_FAILURE, "Invalid CMD 0x%x\n", cmd);
+    crypto_chk_return(km_func_list[nr].handler == TD_NULL, TD_FAILURE, "NR 0x%x not Found!\n", nr);
+    crypto_chk_return(cmd != km_func_list[nr].cmd, TD_FAILURE, "Invalid CMD 0x%x, nr is 0x%x\n", cmd, nr);
+
+    ret = km_func_list[nr].handler(cmd, argp, TD_NULL);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "ioctl cmd is 0x%x, nr is 0x%x failed, ret is 0x%x\n", cmd, nr, ret);
+
+    return TD_SUCCESS;
+}
+
+#define CRYPTO_IOCTL_ARG_MAX_SIZE 0x100
+TEE_Result syscall_km_ioctl(void *param, size_t param_len)
+{
+    td_u8 local[CRYPTO_IOCTL_ARG_MAX_SIZE] = {0};
+    td_u32 size = 0;
+    td_s32 ret;
+    TEE_SECURITY_SUBSYS_Data data = *(TEE_SECURITY_SUBSYS_Data *)param;
+
+    crypto_chk_return(sizeof(data) != param_len, TD_FAILURE, "check param_len failed!\n");
+
+    size = CRYPTO_IOC_SIZE(data.cmd);
+    if (size >= CRYPTO_IOCTL_ARG_MAX_SIZE) {
+        return TD_FAILURE;
+    }
+
+    if (size != 0) {
+        ret = crypto_copy_from_user(local, sizeof(local), data.param, size);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_copy_from_user failed\n");
+    }
+
+    ret = km_ioctl(data.cmd, local);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "crypto_ioctl failed\n");
+
+    if (CRYPTO_IOC_DIR(data.cmd) & CRYPTO_IOC_R) {
+        ret = crypto_copy_to_user(data.param, size, local, size);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "crypto_copy_to_user failed\n");
+    }
+
+exit_clean:
+    (td_void)memset_s(local, sizeof(local), 0, sizeof(local));
+    return ret;
+}
+
+static td_s32 crypto_km_init(td_void)
+{
+    td_s32 ret;
+
+    ret = kapi_km_env_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_km_init failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+
+static TEE_Result ot_km_probe(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    ret = crypto_km_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_otp_init failed, ret is 0x%x\n", ret);
+
+    crypto_print("load ot_km.ko success!\n");
+
+    return ret;
+}
+
+service_init_late(ot_km_probe);
diff --git a/bsp/security_subsys/drivers/otp/crypto_otp_init.c b/bsp/security_subsys/drivers/otp/crypto_otp_init.c
new file mode 100644
index 0000000..c3b15e9
--- /dev/null
+++ b/bsp/security_subsys/drivers/otp/crypto_otp_init.c
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) Hisilicon Technologies Co., Ltd. 2017-2020. All rights reserved.
+ * Description   : drivers for linux drv osal init of cipher.
+ * Author        : Hisilicon multimedia software group
+ * Create        : 2017-10-20
+ */
+#include <initcall.h>
+#include <securec.h>
+#include <tee/tee_svc_security_subsys.h>
+
+#include "kapi_otp.h"
+#include "dispatch_otp.h"
+#include "crypto_common_macro.h"
+
+static td_s32 otp_ioctl(td_u32 cmd, td_void *argp)
+{
+    td_u32 nr;
+    td_s32 ret;
+    crypto_ioctl_cmd *otp_func_list = TD_NULL;
+    crypto_param_require(argp != TD_NULL);
+
+    nr = CRYPTO_IOC_NR(cmd);
+    otp_func_list = get_otp_func_list();
+    crypto_chk_return(otp_func_list == TD_NULL, TD_FAILURE, "get_otp_func_list failed\n");
+
+    crypto_chk_return(nr >= CMD_OTP_MAX_NUM, TD_FAILURE, "Invalid CMD 0x%x\n", cmd);
+    crypto_chk_return(otp_func_list[nr].handler == TD_NULL, TD_FAILURE, "NR 0x%x not Found!\n", nr);
+    crypto_chk_return(cmd != otp_func_list[nr].cmd, TD_FAILURE, "Invalid CMD 0x%x, nr is 0x%x\n", cmd, nr);
+
+    ret = otp_func_list[nr].handler(cmd, argp, TD_NULL);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "ioctl cmd is 0x%x, nr is 0x%x failed, ret is 0x%x\n", cmd, nr, ret);
+
+    return TD_SUCCESS;
+}
+
+#define CRYPTO_IOCTL_ARG_MAX_SIZE 0x100
+TEE_Result syscall_otp_ioctl(void *param, size_t param_len)
+{
+    td_u8 local[CRYPTO_IOCTL_ARG_MAX_SIZE] = {0};
+    td_u32 size = 0;
+    td_s32 ret;
+    TEE_SECURITY_SUBSYS_Data data = *(TEE_SECURITY_SUBSYS_Data *)param;;
+
+    crypto_chk_return(sizeof(data) != param_len, TD_FAILURE, "check param_len failed!\n");
+
+    size = CRYPTO_IOC_SIZE(data.cmd);
+    if (size >= CRYPTO_IOCTL_ARG_MAX_SIZE) {
+        return TD_FAILURE;
+    }
+
+    if (size != 0) {
+        ret = crypto_copy_from_user(local, sizeof(local), data.param, size);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_copy_from_user failed\n");
+    }
+
+    ret = otp_ioctl(data.cmd, local);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "crypto_ioctl failed\n");
+
+    if (CRYPTO_IOC_DIR(data.cmd) & CRYPTO_IOC_R) {
+        ret = crypto_copy_to_user(data.param, size, local, size);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "crypto_copy_to_user failed\n");
+    }
+
+exit_clean:
+    (td_void)memset_s(local, sizeof(local), 0, sizeof(local));
+    return ret;
+}
+
+static td_s32 crypto_otp_init(td_void)
+{
+    td_s32 ret;
+
+    ret = kapi_otp_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_otp_init failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+
+static TEE_Result ot_otp_probe(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    ret = crypto_otp_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_otp_init failed, ret is 0x%x\n", ret);
+
+    crypto_print("load ot_otp.ko success!\n");
+
+    return ret;
+}
+
+service_init_late(ot_otp_probe);
diff --git a/bsp/security_subsys/drivers/storage/drivers/drv_random.c b/bsp/security_subsys/drivers/storage/drivers/drv_random.c
new file mode 100644
index 0000000..3d62c82
--- /dev/null
+++ b/bsp/security_subsys/drivers/storage/drivers/drv_random.c
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the TRNG interface
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <trace.h>
+#include "drv_trng.h"
+#include "crypto/crypto.h"
+
+TEE_Result crypto_rng_read(void *buf, size_t len)
+{
+	td_s32 ret = TEE_SUCCESS;
+
+	ret = drv_cipher_trng_get_multi_random(len, buf);
+	if (ret != TEE_SUCCESS) {
+		EMSG("ot_drv_cipher_get_multi_random_num failed\n");
+		return TEE_ERROR_BAD_STATE;
+	}
+
+	return ret;
+}
diff --git a/bsp/security_subsys/drivers/storage/drivers/huk.c b/bsp/security_subsys/drivers/storage/drivers/huk.c
new file mode 100644
index 0000000..8a3ef1e
--- /dev/null
+++ b/bsp/security_subsys/drivers/storage/drivers/huk.c
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the interface to get chip id.
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+
+#include <stdio.h>
+#include <trace.h>
+#include <securec.h>
+
+#include <kernel/tee_common_otp.h>
+#include "drv_otp.h"
+
+#define OTP_DIE_ID_LEN              16
+
+int tee_otp_get_die_id(uint8_t *buffer, size_t len)
+{
+	int ret = TEE_SUCCESS;
+	uint8_t out[OTP_DIE_ID_LEN] = {0};
+
+	ret = drv_otp_get_die_id(out, OTP_DIE_ID_LEN);
+	if (ret != TEE_SUCCESS) {
+		EMSG("drv_otp_get_die_id failed, ret = 0x%x\r\n", ret);
+		goto err_exit;
+	}
+
+	if (memcpy_s(buffer, len, out, len) != EOK) {
+		EMSG("memcpy_s failed!\n");
+		ret = TEE_ERROR_SECURITY;
+	}
+
+err_exit:
+	(void)memset_s(out, sizeof(out), 0, sizeof(out));
+	return ret;
+}
diff --git a/bsp/security_subsys/drivers/storage/huk_subkey2.c b/bsp/security_subsys/drivers/storage/huk_subkey2.c
new file mode 100644
index 0000000..54893ff
--- /dev/null
+++ b/bsp/security_subsys/drivers/storage/huk_subkey2.c
@@ -0,0 +1,338 @@
+/* Copyright (C) 2020 Huawei Technologies Co., Ltd */
+
+#include <kernel/huk_subkey.h>
+#include <kernel/tee_common_otp.h>
+#include <securec.h>
+#include <string_ext.h>
+#include <tee/tee_fs_key_manager.h>
+#include <trace.h>
+#include "crypto_km_struct.h"
+#include "kapi_hash.h"
+#include "kapi_km.h"
+
+#ifndef cipher_chk_goto
+#define cipher_chk_goto(val, label, ...) \
+    do {                                 \
+        if ((val)) {                     \
+            __VA_ARGS__;                 \
+            goto label;                  \
+        }                                \
+    } while (0)
+#endif
+
+#ifndef cipher_chk_return
+#define cipher_chk_return(val, ret, ...) \
+    do {                                 \
+        if ((val)) {                     \
+            __VA_ARGS__;                 \
+            return (ret);                \
+        }                                \
+    } while (0)
+#endif
+
+static TEE_Result do_hw_hmac_update(td_handle hhash, const td_u8 *buffer,
+                                    td_u32 buffer_length)
+{
+    td_s32 ret = TEE_SUCCESS;
+    crypto_buf_attr src_buf = {.virt_addr = buffer,
+                               .buf_sec = CRYPTO_BUF_SECURE};
+
+    ret = kapi_cipher_hash_update(hhash, &src_buf, buffer_length);
+    if (ret != TEE_SUCCESS) {
+        return TEE_ERROR_SECURITY;
+    }
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result mac_usage(td_handle hhash, uint32_t usage)
+{
+    return do_hw_hmac_update(hhash, (const void *)&usage, sizeof(usage));
+}
+
+#ifdef CFG_CORE_HUK_SUBKEY_COMPAT
+/*
+ * This does special treatment for RPMB and SSK key derivations to give
+ * the same result as when huk_subkey_derive() wasn't used.
+ */
+static TEE_Result huk_compat(td_handle hhash, enum huk_subkey_usage usage)
+{
+    TEE_Result res = TEE_SUCCESS;
+    uint8_t chip_id[TEE_FS_KM_CHIP_ID_LENGTH] = {0};
+    static uint8_t ssk_str[] = "ONLY_FOR_tee_fs_ssk";
+
+    switch (usage) {
+        case HUK_SUBKEY_RPMB:
+            return TEE_SUCCESS;
+        case HUK_SUBKEY_SSK:
+            (void)tee_otp_get_die_id(chip_id, sizeof(chip_id));
+            res = do_hw_hmac_update(hhash, chip_id, sizeof(chip_id));
+            if (res)
+                return res;
+            return do_hw_hmac_update(hhash, ssk_str, sizeof(ssk_str));
+        default:
+            return mac_usage(hhash, usage);
+    }
+}
+#endif /* CFG_CORE_HUK_SUBKEY_COMPAT */
+
+#ifndef CFG_HI3516CV610
+typedef struct {
+    crypto_klad_alg_sel session_alg;
+    td_u8 *session_key;
+    td_u32 session_len;
+    crypto_klad_alg_sel content_alg;
+    td_u8 *content_key;
+    td_u32 content_len;
+    td_u32 rootkey_type;
+} cipher_data_t;
+
+/* The session key and content key are the input of the content key
+ * derived from klad. You do not need to change the session key and content key.
+ */
+static td_u8 session_128_bit_key_arr[] = {0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
+                                          0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
+                                          0x1c, 0x1d, 0x1e, 0x1f};
+static td_u8 content_128_bit_key_arr[] = {0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
+                                          0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
+                                          0x2c, 0x2d, 0x2e, 0x2f};
+
+static cipher_data_t g_aes_data[] = {{
+    .session_alg = CRYPTO_KLAD_ALG_SEL_AES,
+    .session_key = session_128_bit_key_arr,
+    .session_len = sizeof(session_128_bit_key_arr),
+    .content_alg = CRYPTO_KLAD_ALG_SEL_AES,
+    .content_key = content_128_bit_key_arr,
+    .content_len = sizeof(content_128_bit_key_arr),
+    .rootkey_type = KM_KLAD_KEY_TYPE_RDRK0,
+}};
+
+static td_s32 drv_cipher_set_root_key(td_handle keyslot_handle,
+                                      const cipher_data_t *data)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_handle klad_handle = 0;
+    crypto_klad_attr klad_attr = {0};
+    crypto_klad_session_key key0 = {0};
+    crypto_klad_content_key key1 = {0};
+
+    ret = kapi_klad_create(&klad_handle);
+    cipher_chk_return((ret != TD_SUCCESS), ret,
+                      EMSG("kapi_klad_create failed\n"));
+
+    (td_void) memset_s(&klad_attr, sizeof(crypto_klad_attr), 0,
+                       sizeof(crypto_klad_attr));
+    (td_void) memset_s(&key0, sizeof(crypto_klad_session_key), 0,
+                       sizeof(crypto_klad_session_key));
+    (td_void) memset_s(&key1, sizeof(crypto_klad_content_key), 0,
+                       sizeof(crypto_klad_content_key));
+
+    klad_attr.klad_cfg.rootkey_type =
+        (crypto_kdf_hard_key_type)data->rootkey_type;
+    klad_attr.key_cfg.engine = CRYPTO_KLAD_ENGINE_SHA2_HMAC;
+    klad_attr.key_cfg.decrypt_support = TD_TRUE;
+    klad_attr.key_cfg.encrypt_support = TD_TRUE;
+    klad_attr.key_sec_cfg.key_sec = TD_TRUE;
+    klad_attr.key_sec_cfg.master_only_enable = TD_TRUE;
+    klad_attr.key_sec_cfg.dest_buf_sec_support = TD_TRUE;
+    klad_attr.key_sec_cfg.dest_buf_non_sec_support = TD_FALSE;
+    klad_attr.key_sec_cfg.src_buf_sec_support = TD_TRUE;
+    klad_attr.key_sec_cfg.src_buf_non_sec_support = TD_FALSE;
+
+    ret = kapi_klad_set_attr(klad_handle, &klad_attr);
+    cipher_chk_goto((ret != TD_SUCCESS), KLAD_DESTROY,
+                    EMSG("kapi_klad_set_attr failed\n"));
+
+    ret = kapi_klad_attach(klad_handle, CRYPTO_KLAD_DEST_HMAC, keyslot_handle);
+    cipher_chk_goto((ret != TD_SUCCESS), KLAD_DESTROY,
+                    EMSG("kapi_klad_attach failed\n"));
+
+    key0.level = CRYPTO_KLAD_LEVEL_SEL_FIRST;
+    key0.alg = data->session_alg;
+    key0.key_length = data->session_len;
+    ret = memcpy_s(key0.key, sizeof(key0.key), data->session_key,
+                   data->session_len);
+    cipher_chk_goto((ret != TD_SUCCESS), EXIT_CLEAN,
+                    EMSG("memcpy_s failed\n"));
+
+    ret = kapi_klad_set_session_key(klad_handle, &key0);
+    cipher_chk_goto((ret != TD_SUCCESS), EXIT_CLEAN,
+                    EMSG("kapi_klad_set_session_key failed\n"));
+
+    key1.alg = data->content_alg;
+    key1.key_length = data->content_len;
+    key1.key_parity = TD_TRUE;
+    ret = memcpy_s(key1.key, sizeof(key1.key), data->content_key,
+                   data->content_len);
+    cipher_chk_goto((ret != TD_SUCCESS), EXIT_CLEAN,
+                    EMSG("memcpy_s failed\n"));
+
+    ret = kapi_klad_set_content_key(klad_handle, &key1);
+    cipher_chk_goto((ret != TD_SUCCESS), EXIT_CLEAN,
+                    EMSG("kapi_klad_set_content_key failed\n"));
+
+EXIT_CLEAN:
+    (td_void) memset_s(&klad_attr, sizeof(crypto_klad_attr), 0,
+                       sizeof(crypto_klad_attr));
+    (td_void) memset_s(&key0, sizeof(crypto_klad_session_key), 0,
+                       sizeof(crypto_klad_session_key));
+    (td_void) memset_s(&key1, sizeof(crypto_klad_content_key), 0,
+                       sizeof(crypto_klad_content_key));
+    kapi_klad_detach(klad_handle, CRYPTO_KLAD_DEST_HMAC, keyslot_handle);
+KLAD_DESTROY:
+    kapi_klad_destroy(klad_handle);
+
+    return ret;
+}
+#else
+#define SALT_LEN 7
+typedef struct {
+    td_bool key_parity;
+    td_bool oneway;
+    crypto_kdf_hard_alg kdf_hard_alg;
+    crypto_kdf_hard_key_type rootkey_type;
+    crypto_klad_key_size key_size; /* symc */
+} cipher_data_t;
+
+static cipher_data_t g_aes_data[] = {{
+    .key_parity = false,
+    .rootkey_type = CRYPTO_KDF_HARD_KEY_TYPE_ERK_TEE,
+    .key_size = CRYPTO_KLAD_KEY_SIZE_128BIT,
+    .kdf_hard_alg = CRYPTO_KDF_HARD_ALG_SHA256,
+    .oneway = true,
+}};
+
+static td_s32 drv_cipher_set_root_key(td_handle keyslot_handle,
+                                      const cipher_data_t *data)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_handle klad_handle = 0;
+    crypto_klad_attr klad_attr = {0};
+    td_u32 salt[SALT_LEN] = {0x01020401, 0x07010103, 0x0b0a0908, 0x0f0e0d0c,
+                             0x13121110, 0x17161514, 0x1b1a1918};
+    crypto_klad_effective_key effective_key = {
+        .salt = (td_u8 *)salt,
+        .salt_length = sizeof(salt),
+        .key_size = data->key_size,
+        .key_parity = data->key_parity,
+        .kdf_hard_alg = data->kdf_hard_alg,
+        .oneway = data->oneway,
+    };
+
+    ret = kapi_klad_create(&klad_handle);
+    cipher_chk_return((ret != TD_SUCCESS), ret,
+                      EMSG("kapi_klad_create failed\n"));
+
+    (td_void) memset_s(&klad_attr, sizeof(crypto_klad_attr), 0,
+                       sizeof(crypto_klad_attr));
+
+    klad_attr.klad_cfg.rootkey_type =
+        (crypto_kdf_hard_key_type)data->rootkey_type;
+    klad_attr.key_cfg.engine = CRYPTO_KLAD_ENGINE_SHA2_HMAC;
+    klad_attr.key_cfg.decrypt_support = TD_TRUE;
+    klad_attr.key_cfg.encrypt_support = TD_TRUE;
+    klad_attr.key_sec_cfg.key_sec = TD_TRUE;
+    klad_attr.key_sec_cfg.master_only_enable = TD_TRUE;
+    klad_attr.key_sec_cfg.dest_buf_sec_support = TD_TRUE;
+    klad_attr.key_sec_cfg.dest_buf_non_sec_support = TD_FALSE;
+    klad_attr.key_sec_cfg.src_buf_sec_support = TD_TRUE;
+    klad_attr.key_sec_cfg.src_buf_non_sec_support = TD_FALSE;
+
+    ret = kapi_klad_set_attr(klad_handle, &klad_attr);
+    cipher_chk_goto((ret != TD_SUCCESS), KLAD_DESTROY,
+                    EMSG("kapi_klad_set_attr failed\n"));
+
+    ret = kapi_klad_attach(klad_handle, CRYPTO_KLAD_DEST_HMAC, keyslot_handle);
+    cipher_chk_goto((ret != TD_SUCCESS), KLAD_DESTROY,
+                    EMSG("kapi_klad_attach failed\n"));
+
+    ret = kapi_klad_set_effective_key(klad_handle, &effective_key);
+    cipher_chk_goto((ret != TD_SUCCESS), EXIT_CLEAN,
+                    EMSG("kapi_klad_set_effective_key failed\n"));
+
+EXIT_CLEAN:
+    (td_void) memset_s(&klad_attr, sizeof(crypto_klad_attr), 0,
+                       sizeof(crypto_klad_attr));
+    kapi_klad_detach(klad_handle, CRYPTO_KLAD_DEST_HMAC, keyslot_handle);
+KLAD_DESTROY:
+    (td_void) memset_s(&effective_key, sizeof(crypto_klad_effective_key), 0,
+                       sizeof(crypto_klad_effective_key));
+    kapi_klad_destroy(klad_handle);
+
+    return ret;
+}
+
+#endif
+
+TEE_Result huk_subkey_derive(enum huk_subkey_usage usage,
+                             const void *const_data, size_t const_data_len,
+                             uint8_t *subkey, size_t subkey_len)
+{
+    TEE_Result res = TEE_SUCCESS;
+    td_u32 ret = TEE_SUCCESS;
+    td_handle hhash = 0;
+    td_handle hkeyslot = 0;
+    crypto_hash_attr hash_attr;
+    td_u32 final_len =
+        subkey_len > HUK_SUBKEY_MAX_LEN ? subkey_len : HUK_SUBKEY_MAX_LEN;
+    cipher_data_t *data = &g_aes_data[0];
+
+    if (subkey_len > HUK_SUBKEY_MAX_LEN) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (!const_data && const_data_len) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    /* create keyslot */
+    ret = kapi_keyslot_create(&hkeyslot, CRYPTO_KEYSLOT_TYPE_HMAC);
+    cipher_chk_return((ret != TEE_SUCCESS), TEE_ERROR_SECURITY,
+                      EMSG("kapi_keyslot_create failed\n"));
+
+    ret = drv_cipher_set_root_key(hkeyslot, data);
+    cipher_chk_goto((ret != TEE_SUCCESS), KSLOT_DESTROY,
+                    EMSG("drv_cipher_set_root_key failed\n"));
+
+    hash_attr.hash_type = CRYPTO_HASH_TYPE_HMAC_SHA256;
+    hash_attr.is_keyslot = TD_TRUE;
+    hash_attr.drv_keyslot_handle = hkeyslot;
+    ret = kapi_cipher_hash_start(&hhash, &hash_attr);
+    cipher_chk_goto((ret != TEE_SUCCESS), HASH_DESTROY,
+                    EMSG("kapi_cipher_hash_start failed\n"));
+
+#ifdef CFG_CORE_HUK_SUBKEY_COMPAT
+    res = huk_compat(hhash, usage);
+#else
+    res = mac_usage(hhash, usage);
+#endif
+    cipher_chk_goto((res != TEE_SUCCESS), HASH_DESTROY,
+                    EMSG("do_hw_hmac_update usage failed\n"));
+
+    if (const_data != TD_NULL) {
+        res = do_hw_hmac_update(hhash, const_data, const_data_len);
+        cipher_chk_goto((res != TEE_SUCCESS), HASH_DESTROY,
+                        EMSG("do_hw_hmac_update const_data failed\n"));
+    }
+
+    ret = kapi_cipher_hash_finish(hhash, subkey, &final_len);
+    cipher_chk_goto((ret != TEE_SUCCESS), HASH_DESTROY,
+                    EMSG("kapi_cipher_hash_finish failed\n"));
+    subkey_len = (size_t)final_len;
+
+HASH_DESTROY:
+    if (ret != TEE_SUCCESS || res != TEE_SUCCESS) {
+        (void)kapi_cipher_hash_destroy(hhash);
+    }
+KSLOT_DESTROY:
+    (void)kapi_keyslot_destroy(hkeyslot);
+    if (ret != TEE_SUCCESS) {
+        res = TEE_ERROR_SECURITY;
+    }
+
+    if (res) {
+        memzero_explicit(subkey, subkey_len);
+    }
+
+    return res;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/drivers/storage/sub.mk b/bsp/security_subsys/drivers/storage/sub.mk
new file mode 100644
index 0000000..52d77de
--- /dev/null
+++ b/bsp/security_subsys/drivers/storage/sub.mk
@@ -0,0 +1,10 @@
+STORAGE_DRV_DIR := bsp/security_subsys/drivers/storage
+CIPHER_LIB_INC := bsp/security_subsys/lib
+STORAGE_CFLAGS += -I$(STORAGE_DRV_DIR)/drivers/
+STORAGE_DRV_OBJS += drivers/drv_random.c
+STORAGE_DRV_OBJS += drivers/huk.c
+
+STORAGE_CFLAGS += -I$(CIPHER_LIB_INC)/../security_subsys_common/include/common_include
+STORAGE_CFLAGS += -I$(CIPHER_LIB_INC)/../security_subsys_common/include/drv_include
+cflags-$(CFG_HUK_CIPHER) += $(STORAGE_CFLAGS)
+srcs-$(CFG_HUK_CIPHER) += $(STORAGE_DRV_OBJS)
diff --git a/bsp/security_subsys/drivers/sub.mk b/bsp/security_subsys/drivers/sub.mk
new file mode 100644
index 0000000..7952042
--- /dev/null
+++ b/bsp/security_subsys/drivers/sub.mk
@@ -0,0 +1,191 @@
+SECURITY_SUBSYS_DIR := bsp/security_subsys/drivers
+SECURITY_SUBSYS_LIB_DIR := bsp/security_subsys/lib
+
+ifdef CFG_HI3516CV610
+    cflags-y  += -DCONFIG_HI3516CV610
+	CONFIG_HI3516CV610 = y
+else
+    cflags-y  += -DCONFIG_HI3519DV500
+	CONFIG_HI3519DV500 = y
+endif
+
+cflags-y	+= -DSOC_ID_CIPHER=0x6c
+
+# Driver-Init
+srcs-y	+= cipher/crypto_drv_init.c
+srcs-y	+= km/crypto_km_init.c
+srcs-y	+= otp/crypto_otp_init.c
+
+# Driver-Common
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/curve_param/brainpool_256r1.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/curve_param/brainpool_384r1.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/curve_param/brainpool_512r1.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/curve_param/nist_p256r.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/curve_param/nist_p384r.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/curve_param/nist_p521r.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/curve_param/sm2.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/crypto_drv_common.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/crypto_pke_common.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/crypto_hash_common.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common/ecc_curve_param.c
+
+# Driver-KAPI
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_hash_simple.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_init.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_km.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_otp.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_pke.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_pke_cal.c
+# srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_symc_simple.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_symc.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_symc_mac.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_symc_long_term.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_symc_short_term.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code/kapi_trng.c
+
+# Driver-DRV
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/hash/drv_hash_clone.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/hash/drv_hash_inner.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/hash/drv_hash_simple.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/hash/drv_hash_soft_hmac_simple.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/hash/drv_pbkdf2_soft.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/hash/drv_pbkdf2_hard.c
+
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/km/drv_keyslot.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/km/drv_klad_clear_key.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/km/drv_klad_effective_key.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/km/drv_klad_session_key.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/km/drv_klad_content_key.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/km/drv_klad.c
+
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/otp/drv_otp.c
+
+ifdef CONFIG_HI3519DV500
+srcs-y    += ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/v4/drv_pke_ecc_curve.c
+srcs-y    += ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/v4/drv_pke_ecc.c
+srcs-y    += ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/v4/drv_pke.c
+srcs-y    += ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/v4/drv_pke_rsa.c
+endif
+
+ifdef CONFIG_HI3516CV610
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_check_dot_on_curve.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_ecdh.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_gen_key.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_sign.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_verify.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_dsa_hash.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_priv_dec.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_pub_enc.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_sign.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_verify.c
+
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_priv_dec.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_pub_enc.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_sign.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_v15.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_v21.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_verify.c
+
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/drv_pke_api.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/drv_pke_exp_mod.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/drv_pke_inner.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/drv_pke_mod.c
+endif
+
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/symc/drv_symc_ccm.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/symc/drv_symc_ctr_non_align.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/symc/drv_symc_gcm.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/symc/drv_symc_get_config.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/symc/drv_symc_mac.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/symc/drv_symc.c
+
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/trng/drv_trng.c
+
+# Driver-HAL
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/km_v4/hal_keyslot_soft.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/km_v4/hal_keyslot_hard.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/km_v4/hal_klad_clear_key.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/km_v4/hal_klad.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/km_v4/hal_rkp.c
+
+ifdef CONFIG_HI3516CV610
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/calc_hash.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_check_dot_on_curve.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_common.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_compute_s.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_compute_u1_and_u2.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_compute_x.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_inner.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_inv_mod.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_mul_naf_inner.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/ecc_point_mul.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/get_multi_random.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/pke_alg_inner.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/rsa_exp_mod.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/rsa_mod.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/rsa_inner.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/sm2_add_mod.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg/sm2_compute_s.c
+endif
+
+ifdef CONFIG_HI3519DV500
+srcs-y    += ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_v4/hal_pke.c
+endif
+ifdef CONFIG_HI3516CV610
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_v5/ecc_data_ram_addr.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_v5/hal_pke.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_v5/rom_lib.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_v5/rsa_data_ram_addr.c
+endif
+
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/spacc_v4/hal_hash.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/spacc_v4/hal_symc_cbc_mac.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/spacc_v4/hal_symc_cmac.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/spacc_v4/hal_symc_ccm.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/spacc_v4/hal_symc_gcm.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/spacc_v4/hal_symc.c
+
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/trng_v4/hal_trng.c
+
+# Driver-Dispatch
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/dispatch_code/crypto_dispatch.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/dispatch_code/dispatch_km.c
+srcs-y	+= ../../../$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/dispatch_code/dispatch_otp.c
+
+# Osal Lib
+srcs-y	+= crypto_osal/crypto_osal_lib.c
+
+
+cflags-y += -Ibsp/mmz/drivers/include
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/ext_inc
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/include/common_include
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/include/ioctl_include
+cflags-y += -I$(SECURITY_SUBSYS_DIR)/crypto_osal
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/symc
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/dispatch_code
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/kapi_code
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/include/kapi_include
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/include/drv_include
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/include/hal_include
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/common
+
+ifdef CONFIG_HI3519DV500
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/v4
+endif
+ifdef CONFIG_HI3516CV610
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/drv_code/pke/ecc
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_alg
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/hal_code/pke_v5
+endif
+
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/..
+
+cflags-y += -include $(SECURITY_SUBSYS_LIB_DIR)/../crypto_features.h
+
+cflags-y += -DCONFIG_CRYPTO_LOG_INFO_DISABLE
+
+subdirs-y += storage
+
+
diff --git a/bsp/security_subsys/lib/crypto_osal/crypto_osal_user_lib.h b/bsp/security_subsys/lib/crypto_osal/crypto_osal_user_lib.h
new file mode 100644
index 0000000..87fbf1a
--- /dev/null
+++ b/bsp/security_subsys/lib/crypto_osal/crypto_osal_user_lib.h
@@ -0,0 +1,65 @@
+#ifndef CRYPTO_OSAL_LIB_H
+#define CRYPTO_OSAL_LIB_H
+
+#include <utee_syscalls.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "crypto_common_macro.h"
+
+#define crypto_print                printf
+#define crypto_log_err              printf
+
+#define unused(x)                 (void)(x)
+
+#define crypto_malloc(x)          (((x) > 0) ? malloc((x)) : TD_NULL)
+#define crypto_free(x)            {if (((x) != TD_NULL)) free((x));}
+
+#define crypto_open(...)                            1
+inline static td_s32 crypto_close(td_u32 fd)
+{
+    (void)fd;
+    return 0;
+}
+
+typedef td_u32                                      crypto_mutex_t;
+#define crypto_pthread_mutex_lock(lock)             crypto_unused(lock)
+#define crypto_pthread_mutex_unlock(lock)           crypto_unused(lock)
+#define CRYPTO_PTHREAD_MUTEX_INITIALIZER            0
+
+#define O_RDWR                                      0
+
+#define CRYPTO_ERROR_ENV                            ERROR_ENV_OPTEE
+
+static inline td_s32 crypto_ioctl(td_s32 fd, td_u32 cmd, void *argp)
+{
+    TEE_SECURITY_SUBSYS_Data tee_cipher_data = {};
+    td_char func[] = "syscall_cipher_ioctl";
+    unused(fd);
+    tee_cipher_data.cmd = cmd;
+    tee_cipher_data.param = argp;
+    return (td_s32)_utee_pick_function(UTEE_PICK_FUNCTION, func, &tee_cipher_data, sizeof(tee_cipher_data));
+}
+
+static inline td_s32 crypto_km_ioctl(td_s32 fd, td_u32 cmd, void *argp)
+{
+    TEE_SECURITY_SUBSYS_Data tee_km_data = {};
+    td_char func[] = "syscall_km_ioctl";
+    unused(fd);
+    tee_km_data.cmd = cmd;
+    tee_km_data.param = argp;
+    return (td_s32)_utee_pick_function(UTEE_PICK_FUNCTION, func, &tee_km_data, sizeof(tee_km_data));
+}
+
+static inline td_s32 crypto_otp_ioctl(td_s32 fd, td_u32 cmd, void *argp)
+{
+    TEE_SECURITY_SUBSYS_Data tee_otp_data = {};
+    td_char func[] = "syscall_otp_ioctl";
+    unused(fd);
+    tee_otp_data.cmd = cmd;
+    tee_otp_data.param = argp;
+    return (td_s32)_utee_pick_function(UTEE_PICK_FUNCTION, func, &tee_otp_data, sizeof(tee_otp_data));
+}
+
+#endif
diff --git a/bsp/security_subsys/lib/ext_inc/ot_type.h b/bsp/security_subsys/lib/ext_inc/ot_type.h
new file mode 100644
index 0000000..a22bba8
--- /dev/null
+++ b/bsp/security_subsys/lib/ext_inc/ot_type.h
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2019, HiSilicon Technologies Co., Ltd.
+ */
+
+#ifndef __OT_TYPE_H__
+#define __OT_TYPE_H__
+
+#ifdef __KERNEL__
+
+#include <string.h>
+#include <stdint.h>
+#else
+
+#include <stdint.h>
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#ifndef NULL
+    #define NULL                0L
+#endif
+
+#define TD_NULL                 0L
+#define TD_SUCCESS              0
+#define TD_FAILURE              (-1)
+
+typedef unsigned char           td_uchar;
+typedef unsigned char           td_u8;
+typedef unsigned short          td_u16;
+typedef unsigned int            td_u32;
+typedef unsigned long           td_ulong;
+
+typedef unsigned char           u8;
+typedef unsigned int            u32;
+
+typedef char                    td_char;
+typedef signed char             td_s8;
+typedef short                   td_s16;
+typedef int                     td_s32;
+typedef long                    td_slong;
+
+typedef float                   td_float;
+typedef double                  td_double;
+
+typedef void                    td_void;
+
+#ifndef _M_IX86
+    typedef unsigned long long  td_u64;
+    typedef long long           td_s64;
+#else
+    typedef unsigned __int64    td_u64;
+    typedef __int64             td_s64;
+#endif
+
+typedef unsigned long           td_size_t;
+typedef unsigned long           td_length_t;
+typedef unsigned long int       td_phys_addr_t;
+typedef td_u32                  td_handle;
+typedef uintptr_t               td_uintptr_t;
+typedef unsigned int            td_fr32;
+
+typedef enum {
+    TD_FALSE = 0,
+    TD_TRUE  = 1,
+} td_bool;
+
+#define EOK    0
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __OT_TYPE_H__ */
+
diff --git a/bsp/security_subsys/lib/sub.mk b/bsp/security_subsys/lib/sub.mk
new file mode 100755
index 0000000..47d8ef8
--- /dev/null
+++ b/bsp/security_subsys/lib/sub.mk
@@ -0,0 +1,40 @@
+SECURITY_SUBSYS_LIB_DIR := bsp/security_subsys/lib
+
+ifdef CFG_HI3519DV500
+    cflags-y  += -DCONFIG_HI3519DV500
+else
+    cflags-y  += -DCONFIG_HI3516CV610
+endif
+#cflags-y	+= -DCRYPTO_CTR_NON_ALIGN_SUPPORT
+cflags-y	+= -DSOC_ID_CIPHER=0x6c
+
+# UAPI
+srcs-y	+= ../security_subsys_common/uapi_code/uapi_hash.c
+srcs-y	+= ../security_subsys_common/uapi_code/uapi_kdf.c
+srcs-y	+= ../security_subsys_common/uapi_code/uapi_pke.c
+srcs-y	+= ../security_subsys_common/uapi_code/uapi_symc.c
+srcs-y	+= ../security_subsys_common/uapi_code/uapi_trng.c
+srcs-y	+= ../security_subsys_common/uapi_code/uapi_common.c
+srcs-y	+= ../security_subsys_common/uapi_code/uapi_km.c
+srcs-y	+= ../security_subsys_common/uapi_code/uapi_otp.c
+
+# MPI
+srcs-y	+= ../security_subsys_common/ot_mpi/ot_mpi_hash.c
+srcs-y	+= ../security_subsys_common/ot_mpi/ot_mpi_kdf.c
+srcs-y	+= ../security_subsys_common/ot_mpi/ot_mpi_pke.c
+srcs-y	+= ../security_subsys_common/ot_mpi/ot_mpi_symc.c
+srcs-y	+= ../security_subsys_common/ot_mpi/ot_mpi_trng.c
+srcs-y	+= ../security_subsys_common/ot_mpi/ot_mpi_km.c
+srcs-y	+= ../security_subsys_common/ot_mpi/ot_mpi_otp.c
+
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/ext_inc
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/crypto_osal
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../drivers/crypto_osal
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/include/common_include
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/include/ioctl_include
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/include/uapi_include
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/ot_mpi_api
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/../security_subsys_common/ot_mpi/optee
+cflags-y += -I$(SECURITY_SUBSYS_LIB_DIR)/..
+
+cflags-y += -include $(SECURITY_SUBSYS_LIB_DIR)/../crypto_features.h
diff --git a/bsp/security_subsys/security_subsys_common/common/crypto_drv_common.c b/bsp/security_subsys/security_subsys_common/common/crypto_drv_common.c
new file mode 100644
index 0000000..efccf51
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/crypto_drv_common.c
@@ -0,0 +1,90 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver common utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#include "crypto_drv_common.h"
+
+/* crypto dump functions. */
+#define MAX_DUMP_LENGHT     (512)
+#define BYTES_IN_ONE_LINE   (16)
+#ifndef KERN_CONT
+#define KERN_CONT
+#endif
+
+#if defined(CONFIG_DATA_DUMP_ENABLE)
+void crypto_dump_data(const char *name, const td_u8 *data, td_u32 data_len)
+{
+    td_u32 i;
+    td_u32 dump_length = data_len;
+    crypto_unused(name);
+    crypto_unused(data);
+    if (data == TD_NULL) {
+        crypto_log_err("data is NULL\n");
+        return;
+    }
+
+    crypto_print("%s(addr is 0x%lx, size is %d Bytes):\r\n", name, (uintptr_t)data, data_len);
+    if (dump_length > MAX_DUMP_LENGHT) {
+        dump_length = MAX_DUMP_LENGHT;
+    }
+    for (i = 0; i < dump_length; i++) {
+        crypto_print(KERN_CONT"%02x ", data[i]);
+        if ((i + 1) % BYTES_IN_ONE_LINE == 0) {
+            crypto_print("\r\n");
+        }
+    }
+    if (dump_length % BYTES_IN_ONE_LINE != 0) {
+        crypto_print("\r\n");
+    }
+}
+
+void crypto_dump_phys_addr(const char *name, const td_u64 phys_addr, td_u32 data_len)
+{
+    td_u8 *buffer = crypto_ioremap_nocache(phys_addr, data_len);
+    if (buffer == TD_NULL) {
+        crypto_log_err("crypto_ioremap_nocache failed, buffer is NULL\n");
+        return;
+    }
+    crypto_dump_data(name, buffer, data_len);
+    crypto_iounmap(buffer, data_len);
+    crypto_unused(phys_addr);
+}
+
+void crypto_reg_item_dump(const td_char *name, const reg_item_t *reg_item_table, td_u32 item_size,
+    reg_read_func read_func)
+{
+    td_u32 i;
+    crypto_unused(name);
+    crypto_unused(reg_item_table);
+    crypto_unused(read_func);
+
+    crypto_print("========== %s reg table:==========\n", name);
+    for (i = 0; i < item_size; i++) {
+        crypto_print("%s is 0x%x\n", reg_item_table[i].name, read_func(reg_item_table[i].offset));
+    }
+}
+#endif
+
+td_u32 crypto_get_value_by_index(const crypto_table_item *table, td_u32 table_size,
+    td_u32 index, td_u32 *value)
+{
+    const crypto_table_item *item = TD_NULL;
+    td_u32 i;
+
+    crypto_chk_return(table == TD_NULL, TD_FAILURE, "table is NULL\n");
+    crypto_chk_return(value == TD_NULL, TD_FAILURE, "value is NULL\n");
+
+    for (i = 0; i < table_size; i++) {
+        item = &table[i];
+        if (item->index == index) {
+            *value = item->value;
+            return TD_SUCCESS;
+        }
+    }
+    crypto_log_err("Invalid Index!\n");
+    return TD_FAILURE;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/crypto_drv_common.h b/bsp/security_subsys/security_subsys_common/common/crypto_drv_common.h
new file mode 100644
index 0000000..bb3b0a1
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/crypto_drv_common.h
@@ -0,0 +1,88 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver common utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef CRYPTO_DRV_COMMON_H
+#define CRYPTO_DRV_COMMON_H
+
+#include "crypto_type.h"
+#include "crypto_osal_lib.h"
+#include "crypto_log.h"
+#include "crypto_common_macro.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+typedef struct {
+    const td_char *name;
+    td_u32 offset;
+} reg_item_t;
+
+typedef td_u32 (*reg_read_func)(td_u32 offset);
+
+void crypto_reg_item_dump(const td_char *name, const reg_item_t *reg_item_table, td_u32 item_size,
+    reg_read_func read_func);
+
+typedef enum {
+    TIMER_ID_0  = 0,
+    TIMER_ID_1,
+    TIMER_ID_2,
+    TIMER_ID_3,
+    TIMER_ID_4,
+    TIMER_ID_5,
+    TIMER_ID_6,
+    TIMER_ID_7,
+    TIMER_ID_8,
+    TIMER_ID_9,
+} crypto_timer_id;
+#if defined(CONFIG_CRYPTO_PERF_STATISTICS)
+td_void crypto_timer_start(td_u32 timer_id, const td_char *name);
+
+td_u64 crypto_timer_end(td_u32 timer_id, const td_char *item_name);
+
+td_void crypto_timer_print(td_u32 timer_id);
+
+td_void crypto_timer_print_all(td_void);
+#else
+#define crypto_timer_start(...)
+#define crypto_timer_end(...)
+#define crypto_timer_print(...)
+#define crypto_timer_print_all(...)
+#endif
+
+typedef struct {
+    td_u32 index;
+    td_u32 value;
+} crypto_table_item;
+
+td_u32 crypto_get_value_by_index(const crypto_table_item *table, td_u32 table_size,
+    td_u32 index, td_u32 *value);
+td_u32 crypto_get_index_by_value(const crypto_table_item *table, td_u32 table_size,
+    td_u32 value, td_u32 *index);
+
+unsigned int crypto_align(unsigned int original_length, unsigned int aligned_length);
+
+void crypto_dump_data(const char *name, const td_u8 *data, td_u32 data_len);
+
+void crypto_dump_phys_addr(const char *name, const td_u64 phys_addr, td_u32 data_len);
+
+td_s32 crypto_virt_xor_phys_copy_to_phys(td_u64 dst_phys_addr, const td_u8 *a_virt_addr,
+    td_u64 b_phys_addr, td_u32 length);
+
+td_s32 crypto_copy_from_phys_addr(td_u8 *dst, td_u32 dst_len, td_u64 src_phys_addr, td_u32 src_len);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/crypto_hash_common.c b/bsp/security_subsys/security_subsys_common/common/crypto_hash_common.c
new file mode 100644
index 0000000..8effde9
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/crypto_hash_common.c
@@ -0,0 +1,195 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver hash utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2024-01-22, Create file. \n
+ */
+#include "crypto_hash_common.h"
+
+static crypto_mutex g_hash_mutex;
+
+#if defined(CONFIG_HASH_SHA1_SUPPORT)
+// SHA-1, the initial hash value
+const td_u8 g_sha1_ival[20] = {
+    0x67, 0x45, 0x23, 0x01,
+    0xEF, 0xCD, 0xAB, 0x89,
+    0x98, 0xBA, 0xDC, 0xFE,
+    0x10, 0x32, 0x54, 0x76,
+    0xC3, 0xD2, 0xE1, 0xF0
+};
+#endif
+
+#if defined(CONFIG_HASH_SHA224_SUPPORT)
+// SHA-224, the initial hash value
+static const td_u8 g_sha224_ival[32] = {
+    0xC1, 0x05, 0x9E, 0xD8,
+    0x36, 0x7C, 0xD5, 0x07,
+    0x30, 0x70, 0xDD, 0x17,
+    0xF7, 0x0E, 0x59, 0x39,
+    0xFF, 0xC0, 0x0B, 0x31,
+    0x68, 0x58, 0x15, 0x11,
+    0x64, 0xF9, 0x8F, 0xA7,
+    0xBE, 0xFA, 0x4F, 0xA4
+};
+#endif
+
+#if defined(CONFIG_HASH_SHA256_SUPPORT)
+// SHA-256, the initial hash value
+static const td_u8 g_sha256_ival[32] = {
+    0x6A, 0x09, 0xE6, 0x67,
+    0xBB, 0x67, 0xAE, 0x85,
+    0x3C, 0x6E, 0xF3, 0x72,
+    0xA5, 0x4F, 0xF5, 0x3A,
+    0x51, 0x0E, 0x52, 0x7F,
+    0x9B, 0x05, 0x68, 0x8C,
+    0x1F, 0x83, 0xD9, 0xAB,
+    0x5B, 0xE0, 0xCD, 0x19
+};
+#endif
+
+#if defined(CONFIG_HASH_SHA384_SUPPORT)
+// SHA-384, the initial hash value
+static const td_u8 g_sha384_ival[64] = {
+    0xCB, 0xBB, 0x9D, 0x5D, 0xC1, 0x05, 0x9E, 0xD8,
+    0x62, 0x9A, 0x29, 0x2A, 0x36, 0x7C, 0xD5, 0x07,
+    0x91, 0x59, 0x01, 0x5A, 0x30, 0x70, 0xDD, 0x17,
+    0x15, 0x2F, 0xEC, 0xD8, 0xF7, 0x0E, 0x59, 0x39,
+    0x67, 0x33, 0x26, 0x67, 0xFF, 0xC0, 0x0B, 0x31,
+    0x8E, 0xB4, 0x4A, 0x87, 0x68, 0x58, 0x15, 0x11,
+    0xDB, 0x0C, 0x2E, 0x0D, 0x64, 0xF9, 0x8F, 0xA7,
+    0x47, 0xB5, 0x48, 0x1D, 0xBE, 0xFA, 0x4F, 0xA4
+};
+#endif
+
+#if defined(CONFIG_HASH_SHA512_SUPPORT)
+// SHA-512, the initial hash value
+static const td_u8 g_sha512_ival[64] = {
+    0x6A, 0x09, 0xE6, 0x67, 0xF3, 0xBC, 0xC9, 0x08,
+    0xBB, 0x67, 0xAE, 0x85, 0x84, 0xCA, 0xA7, 0x3B,
+    0x3C, 0x6E, 0xF3, 0x72, 0xFE, 0x94, 0xF8, 0x2B,
+    0xA5, 0x4F, 0xF5, 0x3A, 0x5F, 0x1D, 0x36, 0xF1,
+    0x51, 0x0E, 0x52, 0x7F, 0xAD, 0xE6, 0x82, 0xD1,
+    0x9B, 0x05, 0x68, 0x8C, 0x2B, 0x3E, 0x6C, 0x1F,
+    0x1F, 0x83, 0xD9, 0xAB, 0xFB, 0x41, 0xBD, 0x6B,
+    0x5B, 0xE0, 0xCD, 0x19, 0x13, 0x7E, 0x21, 0x79
+};
+#endif
+
+#if defined(CONFIG_HASH_SM3_SUPPORT)
+// SM3, the initial hash value
+static const td_u8 g_sm3_ival[32] = {
+    0x73, 0x80, 0x16, 0x6F,
+    0x49, 0x14, 0xB2, 0xB9,
+    0x17, 0x24, 0x42, 0xD7,
+    0xDA, 0x8A, 0x06, 0x00,
+    0xA9, 0x6F, 0x30, 0xBC,
+    0x16, 0x31, 0x38, 0xAA,
+    0xE3, 0x8D, 0xEE, 0x4D,
+    0xB0, 0xFB, 0x0E, 0x4E
+};
+#endif
+
+typedef struct {
+    crypto_hash_type hash_type;
+    const td_u8 *state_val;
+    td_u32 state_length;
+} inner_drv_hash_state_iv_table_t;
+
+static inner_drv_hash_state_iv_table_t g_state_iv_table[] = {
+#if defined(CONFIG_HASH_SHA1_SUPPORT)
+    {
+        .hash_type = CRYPTO_HASH_TYPE_SHA1,
+        .state_val = g_sha1_ival,
+        .state_length = sizeof(g_sha1_ival)
+    },
+#endif
+#if defined(CONFIG_HASH_SHA224_SUPPORT)
+    {
+        .hash_type = CRYPTO_HASH_TYPE_SHA224,
+        .state_val = g_sha224_ival,
+        .state_length = sizeof(g_sha224_ival)
+    },
+#endif
+#if defined(CONFIG_HASH_SHA256_SUPPORT)
+    {
+        .hash_type = CRYPTO_HASH_TYPE_SHA256,
+        .state_val = g_sha256_ival,
+        .state_length = sizeof(g_sha256_ival)
+    },
+#endif
+#if defined(CONFIG_HASH_SHA384_SUPPORT)
+    {
+        .hash_type = CRYPTO_HASH_TYPE_SHA384,
+        .state_val = g_sha384_ival,
+        .state_length = sizeof(g_sha384_ival)
+    },
+#endif
+#if defined(CONFIG_HASH_SHA512_SUPPORT)
+    {
+        .hash_type = CRYPTO_HASH_TYPE_SHA512,
+        .state_val = g_sha512_ival,
+        .state_length = sizeof(g_sha512_ival)
+    },
+#endif
+#if defined(CONFIG_HASH_SM3_SUPPORT)
+    {
+        .hash_type = CRYPTO_HASH_TYPE_SM3,
+        .state_val = g_sm3_ival,
+        .state_length = sizeof(g_sm3_ival)
+    },
+#endif
+};
+
+td_s32 drv_hash_get_state_iv(crypto_hash_type hash_type, td_u32 *iv_size, td_u32 *state_iv, td_u32 state_iv_len)
+{
+    const td_u8 *state_val = TD_NULL;
+    td_s32 ret;
+    td_u32 length = 0;
+    td_u32 type = crypto_hash_remove_hmac_flag(hash_type);
+    td_u32 i;
+
+    crypto_chk_return(state_iv == TD_NULL,
+        DRV_COMPAT_ERRNO(ERROR_MODULE_HASH, ERROR_INVALID_PARAM), "state_iv is NULL!\n");
+
+    for (i = 0; i < crypto_array_size(g_state_iv_table); i++) {
+        if (type == g_state_iv_table[i].hash_type) {
+            state_val = g_state_iv_table[i].state_val;
+            length = g_state_iv_table[i].state_length;
+            break;
+        }
+    }
+    if (state_val == TD_NULL) {
+        crypto_log_err("Invalid Hash Mode!\n");
+        return DRV_COMPAT_ERRNO(ERROR_MODULE_HASH, ERROR_INVALID_PARAM);
+    }
+
+    ret = memcpy_s(state_iv, state_iv_len, state_val, length);
+    crypto_chk_return(ret != EOK, DRV_COMPAT_ERRNO(ERROR_MODULE_HASH, ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    if (iv_size != TD_NULL) {
+        *iv_size = length;
+    }
+    return TD_SUCCESS;
+}
+
+td_s32 hash_mutex_init(td_void)
+{
+    return crypto_mutex_init(&g_hash_mutex);
+}
+
+td_void hash_mutex_destroy(td_void)
+{
+    return crypto_mutex_destroy(&g_hash_mutex);
+}
+
+td_void hash_common_lock(td_void)
+{
+    crypto_mutex_lock(&g_hash_mutex);
+}
+
+td_void hash_common_unlock(td_void)
+{
+    crypto_mutex_unlock(&g_hash_mutex);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/crypto_hash_common.h b/bsp/security_subsys/security_subsys_common/common/crypto_hash_common.h
new file mode 100644
index 0000000..7bcf78e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/crypto_hash_common.h
@@ -0,0 +1,26 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver hash utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2024-01-22, Create file. \n
+ */
+
+#ifndef CRYPTO_HASH_COMMON_H
+#define CRYPTO_HASH_COMMON_H
+
+#include "crypto_hash_struct.h"
+#include "crypto_drv_common.h"
+
+td_s32 drv_hash_get_state_iv(crypto_hash_type hash_type, td_u32 *iv_size, td_u32 *state_iv, td_u32 state_iv_len);
+
+td_s32 hash_mutex_init(td_void);
+
+td_void hash_mutex_destroy(td_void);
+
+td_void hash_common_lock(td_void);
+
+td_void hash_common_unlock(td_void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/crypto_log.h b/bsp/security_subsys/security_subsys_common/common/crypto_log.h
new file mode 100644
index 0000000..922d75e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/crypto_log.h
@@ -0,0 +1,68 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver log utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#ifndef CRYPTO_LOG_H
+#define CRYPTO_LOG_H
+
+#if !defined(CRYPTO_LOG_DEF)
+
+#ifndef crypto_print
+#error "crypto_print is not set!"
+#endif
+
+#ifndef CRYPTO_LOG_LEVEL
+#define CRYPTO_LOG_LEVEL 0
+#endif
+
+#if defined(CONFIG_CRYPTO_LOG_INFO_DISABLE)
+#define crypto_log_fmt(LOG_LEVEL_LABEL, fmt, ...)   crypto_print(fmt, ##__VA_ARGS__)
+#else
+#define crypto_log_fmt(LOG_LEVEL_LABEL, fmt, ...)   \
+    crypto_print("[%s:%d]" LOG_LEVEL_LABEL ": " fmt, __func__, __LINE__, ##__VA_ARGS__)
+#endif
+
+#if defined(CRYPTO_LOG_LEVEL) && (CRYPTO_LOG_LEVEL == 0)
+#define crypto_log_err(fmt, ...) crypto_log_fmt("ERROR", fmt, ##__VA_ARGS__)
+#define crypto_log_warn(fmt, ...)
+#define crypto_log_notice(fmt, ...)
+#define crypto_log_dbg(fmt, ...)
+#define crypto_log_trace(fmt, ...)
+#elif defined(CRYPTO_LOG_LEVEL) && (CRYPTO_LOG_LEVEL == 1)
+#define crypto_log_err(fmt, ...) crypto_log_fmt("ERROR", fmt, ##__VA_ARGS__)
+#define crypto_log_warn(fmt, ...) crypto_log_fmt("WARN:", fmt, ##__VA_ARGS__)
+#define crypto_log_notice(fmt, ...)
+#define crypto_log_dbg(fmt, ...)
+#define crypto_log_trace(fmt, ...)
+#elif defined(CRYPTO_LOG_LEVEL) && (CRYPTO_LOG_LEVEL == 2)
+#define crypto_log_err(fmt, ...) crypto_log_fmt("ERROR", fmt, ##__VA_ARGS__)
+#define crypto_log_warn(fmt, ...) crypto_log_fmt("WARN:", fmt, ##__VA_ARGS__)
+#define crypto_log_notice(fmt, ...) crypto_log_fmt("NOTICE", fmt, ##__VA_ARGS__)
+#define crypto_log_dbg(fmt, ...)
+#define crypto_log_trace(fmt, ...)
+#elif defined(CRYPTO_LOG_LEVEL) && (CRYPTO_LOG_LEVEL == 3)
+#define crypto_log_err(fmt, ...) crypto_log_fmt("ERROR", fmt, ##__VA_ARGS__)
+#define crypto_log_warn(fmt, ...) crypto_log_fmt("WARN:", fmt, ##__VA_ARGS__)
+#define crypto_log_notice(fmt, ...) crypto_log_fmt("NOTICE", fmt, ##__VA_ARGS__)
+#define crypto_log_dbg(fmt, ...) crypto_log_fmt("DBG", fmt, ##__VA_ARGS__)
+#define crypto_log_trace(fmt, ...)
+#elif defined(CRYPTO_LOG_LEVEL) && (CRYPTO_LOG_LEVEL == 4)
+#define crypto_log_err(fmt, ...) crypto_log_fmt("ERROR", fmt, ##__VA_ARGS__)
+#define crypto_log_warn(fmt, ...) crypto_log_fmt("WARN:", fmt, ##__VA_ARGS__)
+#define crypto_log_notice(fmt, ...) crypto_log_fmt("NOTICE", fmt, ##__VA_ARGS__)
+#define crypto_log_dbg(fmt, ...) crypto_log_fmt("DBG", fmt, ##__VA_ARGS__)
+#define crypto_log_trace(fmt, ...) crypto_log_fmt("TRACE", fmt, ##__VA_ARGS__)
+#endif
+
+#define crypto_param_trace(fmt, ...)    crypto_print("[%s] " fmt, __func__, ##__VA_ARGS__)
+#define crypto_param_dump_trace(name, data, data_len)   do {    \
+    crypto_print("[%s] ", __func__);                            \
+    crypto_dump_data(name, data, data_len);                     \
+} while (0)
+
+#endif
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/crypto_pke_common.c b/bsp/security_subsys/security_subsys_common/common/crypto_pke_common.c
new file mode 100644
index 0000000..a10bb50
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/crypto_pke_common.c
@@ -0,0 +1,49 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#include "crypto_pke_common.h"
+
+static const pke_default_parameters *g_ecc_params;
+static td_u32 g_ecc_num = 0;
+
+td_void hal_pke_alg_init_ecc_param(const pke_default_parameters *ecc_params, uint32_t ecc_num)
+{
+    g_ecc_params = ecc_params;
+    g_ecc_num = ecc_num;
+}
+
+int get_ecc_param(drv_pke_ecc_curve_type curve_type,
+    const drv_pke_ecc_curve **ecc_curve, const pke_ecc_init_param **ecc_init_param)
+{
+    uint32_t i;
+    const pke_default_parameters *param = NULL;
+    if (g_ecc_params == NULL) {
+        crypto_log_err("call drv_cipher_pke_init_ecc_param first!\n");
+        return CRYPTO_FAILURE;
+    }
+
+    crypto_chk_return(ecc_curve == NULL, CRYPTO_FAILURE, "ecc_curve is NULL\n");
+    crypto_chk_return(ecc_init_param == NULL, CRYPTO_FAILURE, "ecc_init_param is NULL\n");
+
+    for (i = 0; i < g_ecc_num; i++) {
+        param = &g_ecc_params[i];
+        if (param->curve_param == NULL) {
+            continue;
+        }
+        if (param->curve_param->ecc_type == curve_type) {
+            *ecc_curve = param->curve_param;
+            *ecc_init_param = param->default_param;
+            return CRYPTO_SUCCESS;
+        }
+    }
+
+    *ecc_curve = NULL;
+    *ecc_init_param = NULL;
+    crypto_log_err("curve_type 0x%x not register!\n", curve_type);
+    return DRV_COMPAT_ERRNO(ERROR_MODULE_PKE, ERROR_UNSUPPORT);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/crypto_pke_common.h b/bsp/security_subsys/security_subsys_common/common/crypto_pke_common.h
new file mode 100644
index 0000000..2670e3a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/crypto_pke_common.h
@@ -0,0 +1,40 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#ifndef CRYPTO_PKE_COMMON_H
+#define CRYPTO_PKE_COMMON_H
+
+#include "crypto_pke_struct.h"
+#include "crypto_drv_common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_void hal_pke_alg_init_ecc_param(const pke_default_parameters *ecc_params, uint32_t ecc_num);
+
+const drv_pke_ecc_curve *get_ecc_curve(drv_pke_ecc_curve_type curve_type);
+
+const pke_ecc_init_param *get_ecc_init_param(drv_pke_ecc_curve_type curve_type);
+
+int get_ecc_param(drv_pke_ecc_curve_type curve_type,
+    const drv_pke_ecc_curve **ecc_curve, const pke_ecc_init_param **ecc_init_param);
+
+td_void crypto_curve_param_init(td_void);
+
+td_void crypto_curve_param_deinit(td_void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/crypto_security.h b/bsp/security_subsys/security_subsys_common/common/crypto_security.h
new file mode 100644
index 0000000..23bcee0
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/crypto_security.h
@@ -0,0 +1,178 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides crypto security utils header \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-27, Create file. \n
+ */
+#ifndef CRYPTO_SECURITY_H
+#define CRYPTO_SECURITY_H
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/************************************************** secure enhance start************************************/
+/* here is the standard API define for cooperate with the secure enhance and no secure enhance version.
+   you can follow the hal_pke.h to define your own version.
+   eg.
+   define API: void hal_pke_get_ram(td_u32 ram_section, unsigned char *data, td_u32 data_len CIPHER_CHECK_WORD);
+   call API: hal_pke_get_ram(sec_arg_add_cs(ram_section, data, data_len));
+   inner chk_sum == check_word: check_sum_inspect(ram_section, data, data_len);
+*/
+
+/* for boot default open secure enhance */
+#ifdef SEC_ENHANCE
+#define CIPHER_CHECK_WORD                  , const unsigned long check_word
+#define CRYPTO_ROM_CHECK_WORD       , check_word
+
+#ifndef SEC_CS_CONST
+#define SEC_CS_CONST                        0x0
+#endif
+
+#define security_inner_sec_count_args(dummy, a, b, c, d, e, f, g, count, ...) count
+#define security_sec_count_args(...) security_inner_sec_count_args(dummy, ##__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0)
+
+#define security_sec_cs_1(a) ((unsigned long) ~((unsigned long)a) ^ SEC_CS_CONST)
+#define security_sec_cs_2(a, b) ((unsigned long)(a) ^ (unsigned long)(b) ^ SEC_CS_CONST)
+#define security_sec_cs_3(a, b, c) ((unsigned long)(a) ^ (unsigned long)(b) ^ (unsigned long)(c) ^ SEC_CS_CONST)
+#define security_sec_cs_4(a, b, c, d)   \
+    ((unsigned long)(a) ^ (unsigned long)(b) ^ (unsigned long)(c) ^ (unsigned long)(d) ^ SEC_CS_CONST)
+#define security_sec_cs_5(a, b, c, d, e) ((unsigned long)(a) ^ (unsigned long)(b) ^ (unsigned long)(c) ^ \
+    (unsigned long)(d) ^ (unsigned long)(e) ^ SEC_CS_CONST)
+#define security_sec_cs_6(a, b, c, d, e, f) \
+    ((unsigned long)(a) ^ (unsigned long)(b) ^ (unsigned long)(c) ^ (unsigned long)(d) ^ (unsigned long)(e) ^ \
+    (unsigned long)(f) ^ SEC_CS_CONST)
+#define security_sec_cs_7(a, b, c, d, e, f, g) \
+    ((unsigned long)(a) ^ (unsigned long)(b) ^ (unsigned long)(c) ^ (unsigned long)(d) ^ (unsigned long)(e) ^ \
+    (unsigned long)(f) ^ (unsigned long)(g) ^ SEC_CS_CONST)
+#define security_inner_sec_cs(a, ...) security_sec_cs_##a(__VA_ARGS__)
+#define security_sec_cs(...) security_inner_sec_cs(__VA_ARGS__)
+
+#define sec_cs(...) security_sec_cs(_sec_count_args(__VA_ARGS__), __VA_ARGS__)
+
+#define check_sum_inspect(err_ret, ...) do {    \
+        if (check_word != sec_cs(__VA_ARGS__)) { \
+            return err_ret;                     \
+        };                                      \
+} while (0)
+
+#define check_sum_assert(...) do {    \
+    crypto_log_err("drv_assert_eq \n"); \
+    drv_assert_eq(check_word, sec_cs(__VA_ARGS__)); \
+} while (0)
+
+#define sec_arg_add_cs(...) __VA_ARGS__, sec_cs(__VA_ARGS__)
+
+/* call back for secure enhancement */
+#define reg_callback_chk(reg_micro, expect_val) do {        \
+    crypto_log_err("drv_assert_eq \n"); \
+    drv_assert_eq(pke_reg_read(reg_micro), expect_val);   \
+} while (0)
+#define val_enhance_chk(chk_val, expect_val) do {  \
+    crypto_log_err("drv_assert_eq \n"); \
+    drv_assert_eq(chk_val, expect_val);    \
+} while (0)
+#define ret_enhance_chk(chk_val, expect_val) do {  \
+    crypto_log_err("drv_assert_eq \n"); \
+    drv_assert_eq(chk_val, expect_val);    \
+} while (0)
+
+/* for security functions */
+#define memset_enhance_chk_return(ret, dest, destMax, c, count) do { \
+    ret = memset_ss(sec_arg_add_cs(dest, destMax, c, count)); \
+    crypto_chk_func_return(memset_ss, ret);    \
+} while (0)
+#define memcpy_enhance_chk_return(ret, dest, destMax, c, count) do { \
+    ret = memcpy_ss(sec_arg_add_cs(dest, destMax, c, count)); \
+    crypto_chk_func_return(memcpy_ss, ret); \
+} while (0)
+#define memcmp_enhance_chk_return(ret, cs, ct, count) do { \
+    ret = memcmp_ss(sec_arg_add_cs(cs, ct, count)); \
+    crypto_chk_func_return(memcmp_ss, ret); \
+} while (0)
+#define memset_enhance_chk_goto(ret, dest, destMax, c, count, label) do { \
+    ret = memset_ss(sec_arg_add_cs(dest, destMax, c, count)); \
+    crypto_chk_goto(((ret) != TD_SUCCESS), label, "memset_ss failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+#define memcpy_enhance_chk_goto(ret, dest, destMax, c, count, label) do { \
+    ret = memcpy_ss(sec_arg_add_cs(dest, destMax, c, count)); \
+    crypto_chk_goto(((ret) != TD_SUCCESS), label, "memcpy_ss failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+#define memcmp_enhance_chk_goto(ret, cs, ct, count, label) do { \
+    ret = memcmp_ss(sec_arg_add_cs(cs, ct, count)); \
+    crypto_chk_goto(((ret) != TD_SUCCESS), label, "memcmp_ss failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+
+#else /* SEC_ENHANCE */
+#define CIPHER_CHECK_WORD
+#define CRYPTO_ROM_CHECK_WORD
+#define sec_cs(...)
+#define check_sum_inspect(err_ret, ...)
+#define check_sum_assert(...)
+#define sec_arg_add_cs(...)  __VA_ARGS__
+#define reg_callback_chk(reg_micro, expect_val)
+#define val_enhance_chk(chk_val, expect_val)
+#define ret_enhance_chk(chk_val, expect_val) do {  \
+    crypto_chk_return(((chk_val) != (expect_val)), chk_val);    \
+} while (0)
+
+/* for security functions */
+#define memset_enhance_chk_return(ret, dest, destMax, c, count) do { \
+    ret = memset_s(dest, destMax, c, count);  \
+    crypto_chk_return(((ret) != EOK), TD_FAILURE, "memset_s failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+
+#define memcpy_enhance_chk_return(ret, dest, destMax, c, count) do { \
+    ret = memcpy_s(dest, destMax, c, count); \
+    crypto_chk_return(((ret) != EOK), TD_FAILURE, "memcpy_s failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+
+#define memcmp_enhance_chk_return(ret, cs, ct, count) do { \
+    ret = memcmp(cs, ct, count); \
+    crypto_chk_return(((ret) != EOK), TD_FAILURE, "memcmp failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+
+#define memset_enhance_chk_goto(ret, dest, destMax, c, count, label) do { \
+    ret = memset_s(dest, destMax, c, count);  \
+    crypto_chk_goto_with_ret(ret, ((ret) != EOK), label, TD_FAILURE, "memset_s failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+
+#define memcpy_enhance_chk_goto(ret, dest, destMax, c, count, label) do { \
+    ret = memcpy_s(dest, destMax, c, count); \
+    crypto_chk_goto_with_ret(ret, ((ret) != EOK), label, TD_FAILURE, "memcpy_s failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+
+#define memcmp_enhance_chk_goto(ret, cs, ct, count) do { \
+    ret = memcmp(cs, ct, count); \
+    crypto_chk_goto_with_ret(ret, ((ret) != EOK), label, TD_FAILURE, "memcmp failed, ret = 0x%x\r\n", ret);    \
+} while (0)
+
+#endif /* SEC_ENHANCE */
+/************************************************** secure enhance end************************************/
+
+/* for secure enhance. */
+int memcmp_ss(const void *cs, const void *ct, unsigned int count, unsigned long check_word);
+
+int memset_ss(void *dest, unsigned int dest_max, unsigned char c, unsigned int count, unsigned long check_word);
+
+int memcpy_ss(void *dest, unsigned int dest_max, const void *src, unsigned int count, unsigned long check_word);
+
+int memcmp_enhance(const void *cs, const void *ct, unsigned int count);
+
+int memset_enhance(void *dest, unsigned int dest_max, unsigned char c, unsigned int count);
+
+int memcpy_enhance(void *dest, unsigned int dest_max, const void *src, unsigned int count);
+
+void drv_assert_eq(unsigned int val1, unsigned int val2);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_256r1.c b/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_256r1.c
new file mode 100644
index 0000000..05a134c
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_256r1.c
@@ -0,0 +1,113 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke ecc_curve_param brainpool_256r1. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-29, Create file. \n
+ */
+#if defined(CONFIG_PKE_SUPPORT_ECC_BP256R)
+
+#include "ecc_curve_param.h"
+
+static const td_u8 ecc_brainpool_256r1_p[] = {
+    0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72,
+    0x6e, 0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53, 0x77
+};
+
+static const td_u8 ecc_brainpool_256r1_a[] = {
+    0x7d, 0x5a, 0x09, 0x75, 0xfc, 0x2c, 0x30, 0x57, 0xee, 0xf6, 0x75, 0x30, 0x41, 0x7a, 0xff, 0xe7,
+    0xfb, 0x80, 0x55, 0xc1, 0x26, 0xdc, 0x5c, 0x6c, 0xe9, 0x4a, 0x4b, 0x44, 0xf3, 0x30, 0xb5, 0xd9
+};
+
+static const td_u8 ecc_brainpool_256r1_b[] = {
+    0x26, 0xdc, 0x5c, 0x6c, 0xe9, 0x4a, 0x4b, 0x44, 0xf3, 0x30, 0xb5, 0xd9, 0xbb, 0xd7, 0x7c, 0xbf,
+    0x95, 0x84, 0x16, 0x29, 0x5c, 0xf7, 0xe1, 0xce, 0x6b, 0xcc, 0xdc, 0x18, 0xff, 0x8c, 0x07, 0xb6
+};
+
+static const td_u8 ecc_brainpool_256r1_gx[] = {
+    0x8b, 0xd2, 0xae, 0xb9, 0xcb, 0x7e, 0x57, 0xcb, 0x2c, 0x4b, 0x48, 0x2f, 0xfc, 0x81, 0xb7, 0xaf,
+    0xb9, 0xde, 0x27, 0xe1, 0xe3, 0xbd, 0x23, 0xc2, 0x3a, 0x44, 0x53, 0xbd, 0x9a, 0xce, 0x32, 0x62
+};
+
+static const td_u8 ecc_brainpool_256r1_gy[] = {
+    0x54, 0x7e, 0xf8, 0x35, 0xc3, 0xda, 0xc4, 0xfd, 0x97, 0xf8, 0x46, 0x1a, 0x14, 0x61, 0x1d, 0xc9,
+    0xc2, 0x77, 0x45, 0x13, 0x2d, 0xed, 0x8e, 0x54, 0x5c, 0x1d, 0x54, 0xc7, 0x2f, 0x04, 0x69, 0x97
+};
+
+static const td_u8 ecc_brainpool_256r1_n[] = {
+    0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x71,
+    0x8c, 0x39, 0x7a, 0xa3, 0xb5, 0x61, 0xa6, 0xf7, 0x90, 0x1e, 0x0e, 0x82, 0x97, 0x48, 0x56, 0xa7
+};
+
+const drv_pke_ecc_curve g_brainpool_256r1_param = {
+    .p = ecc_brainpool_256r1_p,
+    .a = ecc_brainpool_256r1_a,
+    .b = ecc_brainpool_256r1_b,
+    .gx = ecc_brainpool_256r1_gx,
+    .gy = ecc_brainpool_256r1_gy,
+    .n = ecc_brainpool_256r1_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_RFC5639_P256
+};
+
+static const td_u8 ecc_brainpool_256r1_mont_a[] = {
+    0x1e, 0x46, 0x76, 0xab, 0xd6, 0x66, 0xbc, 0x17, 0x95, 0xec, 0x1e, 0x5e, 0x63, 0x98, 0x55, 0x6e,
+    0xa6, 0x81, 0x23, 0xf1, 0xc1, 0xd2, 0x0c, 0x64, 0xd5, 0xd1, 0x8e, 0xdf, 0x69, 0x69, 0x62, 0x61
+};
+
+static const td_u8 ecc_brainpool_256r1_mont_b[] = {
+    0x17, 0x51, 0x84, 0x96, 0x77, 0xb9, 0xfb, 0xe8, 0xa3, 0x32, 0x55, 0xdf, 0x6e, 0x0c, 0x81, 0x37,
+    0x8c, 0xeb, 0x14, 0xe8, 0xf1, 0x5f, 0xab, 0xca, 0x22, 0x71, 0x2a, 0xce, 0xd5, 0xc5, 0xc0, 0x9b
+};
+
+static const td_u8 ecc_brainpool_256r1_mont_1_p[] = {
+    0x56, 0x04, 0xa8, 0x24, 0x5e, 0x11, 0x56, 0x43, 0xc1, 0x99, 0xf5, 0x6f, 0x62, 0x7c, 0x72, 0x8d,
+    0x91, 0xc4, 0x09, 0xdc, 0x2a, 0xd9, 0xdf, 0xd7, 0xdf, 0xec, 0xb7, 0xe2, 0xe0, 0x91, 0xac, 0x89
+};
+
+static const td_u8 ecc_brainpool_256r1_mont_1_n[] = {
+    0x56, 0x04, 0xa8, 0x24, 0x5e, 0x11, 0x56, 0x43, 0xc1, 0x99, 0xf5, 0x6f, 0x62, 0x7c, 0x72, 0x8e,
+    0x73, 0xc6, 0x85, 0x5c, 0x4a, 0x9e, 0x59, 0x08, 0x6f, 0xe1, 0xf1, 0x7d, 0x68, 0xb7, 0xa9, 0x59
+};
+
+static const td_u8 ecc_brainpool_256r1_rrp[] = {
+    0x47, 0x17, 0xaa, 0x21, 0xe5, 0x95, 0x7f, 0xa8, 0xa1, 0xec, 0xda, 0xcd, 0x6b, 0x1a, 0xc8, 0x07,
+    0x5c, 0xce, 0x4c, 0x26, 0x61, 0x4d, 0x4f, 0x4d, 0x8c, 0xfe, 0xdf, 0x7b, 0xa6, 0x46, 0x5b, 0x6c
+};
+
+static const td_u8 ecc_brainpool_256r1_rrn[] = {
+    0x0b, 0x25, 0xf1, 0xb9, 0xc3, 0x23, 0x67, 0x62, 0x9b, 0x7f, 0x25, 0xe7, 0x6c, 0x81, 0x5c, 0xb0,
+    0xf3, 0x5d, 0x17, 0x6a, 0x11, 0x34, 0xe4, 0xa0, 0xe1, 0xd8, 0xd8, 0xde, 0x33, 0x12, 0xfc, 0xa6
+};
+
+static const td_u8 ecc_brainpool_256r1_p_minus_2[] = {
+    0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72,
+    0x6e, 0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53, 0x75
+};
+
+static const td_u8 ecc_brainpool_256r1_n_minus_2[] = {
+    0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x71,
+    0x8c, 0x39, 0x7a, 0xa3, 0xb5, 0x61, 0xa6, 0xf7, 0x90, 0x1e, 0x0e, 0x82, 0x97, 0x48, 0x56, 0xa5
+};
+
+static const td_u32 ecc_brainpool_256r1_mont_param_n[PKE_MONT_PARAM_LEN] = {0xfbffbebd, 0xcbb40ee9};
+
+static const td_u32 ecc_brainpool_256r1_mont_param_p[PKE_MONT_PARAM_LEN] = {0xc6a75590, 0xcefd89b9};
+
+const pke_ecc_init_param g_brainpool_256r1_init_param = {
+    .mont_a = ecc_brainpool_256r1_mont_a,
+    .mont_b = ecc_brainpool_256r1_mont_b,
+    .mont_1_p = ecc_brainpool_256r1_mont_1_p,
+    .mont_1_n = ecc_brainpool_256r1_mont_1_n,
+    .rrp = ecc_brainpool_256r1_rrp,
+    .rrn = ecc_brainpool_256r1_rrn,
+    .const_1 = g_const_1 + PKE_LEN_256_OFFSET,
+    .const_0 = g_const_0,
+    .mont_param_n = ecc_brainpool_256r1_mont_param_n,
+    .mont_param_p = ecc_brainpool_256r1_mont_param_p,
+    .n_minus_2 = ecc_brainpool_256r1_n_minus_2,
+    .p_minus_2 = ecc_brainpool_256r1_p_minus_2,
+};
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_384r1.c b/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_384r1.c
new file mode 100644
index 0000000..08e6511
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_384r1.c
@@ -0,0 +1,127 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke ecc_curve_param brainpool_384r1. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-29, Create file. \n
+ */
+#if defined(CONFIG_PKE_SUPPORT_ECC_BP384R)
+
+#include "ecc_curve_param.h"
+
+static const td_u8 ecc_brainpool_384r1_p[] = {
+    0x8c, 0xb9, 0x1e, 0x82, 0xa3, 0x38, 0x6d, 0x28, 0x0f, 0x5d, 0x6f, 0x7e, 0x50, 0xe6, 0x41, 0xdf,
+    0x15, 0x2f, 0x71, 0x09, 0xed, 0x54, 0x56, 0xb4, 0x12, 0xb1, 0xda, 0x19, 0x7f, 0xb7, 0x11, 0x23,
+    0xac, 0xd3, 0xa7, 0x29, 0x90, 0x1d, 0x1a, 0x71, 0x87, 0x47, 0x00, 0x13, 0x31, 0x07, 0xec, 0x53
+};
+
+static const td_u8 ecc_brainpool_384r1_a[] = {
+    0x7b, 0xc3, 0x82, 0xc6, 0x3d, 0x8c, 0x15, 0x0c, 0x3c, 0x72, 0x08, 0x0a, 0xce, 0x05, 0xaf, 0xa0,
+    0xc2, 0xbe, 0xa2, 0x8e, 0x4f, 0xb2, 0x27, 0x87, 0x13, 0x91, 0x65, 0xef, 0xba, 0x91, 0xf9, 0x0f,
+    0x8a, 0xa5, 0x81, 0x4a, 0x50, 0x3a, 0xd4, 0xeb, 0x04, 0xa8, 0xc7, 0xdd, 0x22, 0xce, 0x28, 0x26
+};
+
+static const td_u8 ecc_brainpool_384r1_b[] = {
+    0x04, 0xa8, 0xc7, 0xdd, 0x22, 0xce, 0x28, 0x26, 0x8b, 0x39, 0xb5, 0x54, 0x16, 0xf0, 0x44, 0x7c,
+    0x2f, 0xb7, 0x7d, 0xe1, 0x07, 0xdc, 0xd2, 0xa6, 0x2e, 0x88, 0x0e, 0xa5, 0x3e, 0xeb, 0x62, 0xd5,
+    0x7c, 0xb4, 0x39, 0x02, 0x95, 0xdb, 0xc9, 0x94, 0x3a, 0xb7, 0x86, 0x96, 0xfa, 0x50, 0x4c, 0x11
+};
+
+static const td_u8 ecc_brainpool_384r1_gx[] = {
+    0x1D, 0x1C, 0x64, 0xF0, 0x68, 0xCF, 0x45, 0xFF, 0xA2, 0xA6, 0x3A, 0x81, 0xB7, 0xC1, 0x3F, 0x6B,
+    0x88, 0x47, 0xA3, 0xE7, 0x7E, 0xF1, 0x4F, 0xE3, 0xDB, 0x7F, 0xCA, 0xFE, 0x0C, 0xBD, 0x10, 0xE8,
+    0xE8, 0x26, 0xE0, 0x34, 0x36, 0xD6, 0x46, 0xAA, 0xEF, 0x87, 0xB2, 0xE2, 0x47, 0xD4, 0xAF, 0x1E
+};
+
+static const td_u8 ecc_brainpool_384r1_gy[] = {
+    0x8A, 0xBE, 0x1D, 0x75, 0x20, 0xF9, 0xC2, 0xA4, 0x5C, 0xB1, 0xEB, 0x8E, 0x95, 0xCF, 0xD5, 0x52,
+    0x62, 0xB7, 0x0B, 0x29, 0xFE, 0xEC, 0x58, 0x64, 0xE1, 0x9C, 0x05, 0x4F, 0xF9, 0x91, 0x29, 0x28,
+    0x0E, 0x46, 0x46, 0x21, 0x77, 0x91, 0x81, 0x11, 0x42, 0x82, 0x03, 0x41, 0x26, 0x3C, 0x53, 0x15
+};
+
+static const td_u8 ecc_brainpool_384r1_n[] = {
+    0x8C, 0xB9, 0x1E, 0x82, 0xA3, 0x38, 0x6D, 0x28, 0x0F, 0x5D, 0x6F, 0x7E, 0x50, 0xE6, 0x41, 0xDF,
+    0x15, 0x2F, 0x71, 0x09, 0xED, 0x54, 0x56, 0xB3, 0x1F, 0x16, 0x6E, 0x6C, 0xAC, 0x04, 0x25, 0xA7,
+    0xCF, 0x3A, 0xB6, 0xAF, 0x6B, 0x7F, 0xC3, 0x10, 0x3B, 0x88, 0x32, 0x02, 0xE9, 0x04, 0x65, 0x65
+};
+
+const drv_pke_ecc_curve g_brainpool_384r1_param = {
+    .p = ecc_brainpool_384r1_p,
+    .a = ecc_brainpool_384r1_a,
+    .b = ecc_brainpool_384r1_b,
+    .gx = ecc_brainpool_384r1_gx,
+    .gy = ecc_brainpool_384r1_gy,
+    .n = ecc_brainpool_384r1_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_384,
+    .ecc_type = DRV_PKE_ECC_TYPE_RFC5639_P384
+};
+
+static const td_u8 ecc_brainpool_384r1_mont_a[] = {
+    0x7c, 0x33, 0x80, 0x21, 0xa2, 0xe8, 0xc0, 0xd1, 0x40, 0x0a, 0x8f, 0xdf, 0x42, 0xb0, 0x0c, 0x60,
+    0xe7, 0xff, 0xe9, 0xe5, 0x35, 0x52, 0x93, 0x74, 0x93, 0x67, 0x71, 0xb9, 0xd7, 0xf1, 0x0d, 0xb4,
+    0x75, 0xd7, 0xf3, 0xfe, 0xf1, 0x57, 0xb0, 0x7b, 0xdb, 0x26, 0xb8, 0x95, 0x46, 0x6c, 0x3c, 0x99
+};
+
+static const td_u8 ecc_brainpool_384r1_mont_b[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x1b, 0xd6, 0xab, 0x49, 0xbd, 0xe7, 0xbf, 0x35, 0xfb, 0x50, 0xed, 0xe9, 0xf6, 0x29, 0xd0, 0xc1,
+    0xbf, 0x50, 0xbd, 0xc6, 0x38, 0x2b, 0xdd, 0xd0, 0xa1, 0x96, 0x7a, 0x26, 0x66, 0xb6, 0x63, 0x72
+};
+
+static const td_u8 ecc_brainpool_384r1_mont_1_p[] = {
+    0x73, 0x46, 0xe1, 0x7d, 0x5c, 0xc7, 0x92, 0xd7, 0xf0, 0xa2, 0x90, 0x81, 0xaf, 0x19, 0xbe, 0x20,
+    0xea, 0xd0, 0x8e, 0xf6, 0x12, 0xab, 0xa9, 0x4b, 0xed, 0x4e, 0x25, 0xe6, 0x80, 0x48, 0xee, 0xdc,
+    0x53, 0x2c, 0x58, 0xd6, 0x6f, 0xe2, 0xe5, 0x8e, 0x78, 0xb8, 0xff, 0xec, 0xce, 0xf8, 0x13, 0xad
+};
+
+static const td_u8 ecc_brainpool_384r1_mont_1_n[] = {
+    0x73, 0x46, 0xe1, 0x7d, 0x5c, 0xc7, 0x92, 0xd7, 0xf0, 0xa2, 0x90, 0x81, 0xaf, 0x19, 0xbe, 0x20,
+    0xea, 0xd0, 0x8e, 0xf6, 0x12, 0xab, 0xa9, 0x4c, 0xe0, 0xe9, 0x91, 0x93, 0x53, 0xfb, 0xda, 0x58,
+    0x30, 0xc5, 0x49, 0x50, 0x94, 0x80, 0x3c, 0xef, 0xc4, 0x77, 0xcd, 0xfd, 0x16, 0xfb, 0x9a, 0x9b
+};
+
+static const td_u8 ecc_brainpool_384r1_rrp[] = {
+    0x36, 0xbf, 0x68, 0x83, 0x17, 0x8d, 0xf8, 0x42, 0xd5, 0xc6, 0xef, 0x3b, 0xa5, 0x7e, 0x05, 0x2c,
+    0x62, 0x14, 0x01, 0x91, 0x99, 0x18, 0xd5, 0xaf, 0x8e, 0x28, 0xf9, 0x9c, 0xc9, 0x94, 0x08, 0x99,
+    0x53, 0x52, 0x83, 0x34, 0x3d, 0x7f, 0xd9, 0x65, 0x08, 0x7c, 0xef, 0xff, 0x40, 0xb6, 0x4b, 0xde
+};
+
+static const td_u8 ecc_brainpool_384r1_rrn[] = {
+    0x0c, 0xe8, 0x94, 0x1a, 0x61, 0x4e, 0x97, 0xc2, 0x8f, 0x88, 0x6d, 0xc9, 0x65, 0x16, 0x5f, 0xdb,
+    0x57, 0x4a, 0x74, 0xcb, 0x52, 0xd7, 0x48, 0xff, 0x2a, 0x92, 0x7e, 0x3b, 0x98, 0x02, 0x68, 0x8a,
+    0x37, 0x26, 0x4e, 0x20, 0x2f, 0x2b, 0x6b, 0x6e, 0xac, 0x4e, 0xd3, 0xa2, 0xde, 0x77, 0x1c, 0x8e
+};
+
+static const td_u8 ecc_brainpool_384r1_p_minus_2[] = {
+    0x8c, 0xb9, 0x1e, 0x82, 0xa3, 0x38, 0x6d, 0x28, 0x0f, 0x5d, 0x6f, 0x7e, 0x50, 0xe6, 0x41, 0xdf,
+    0x15, 0x2f, 0x71, 0x09, 0xed, 0x54, 0x56, 0xb4, 0x12, 0xb1, 0xda, 0x19, 0x7f, 0xb7, 0x11, 0x23,
+    0xac, 0xd3, 0xa7, 0x29, 0x90, 0x1d, 0x1a, 0x71, 0x87, 0x47, 0x00, 0x13, 0x31, 0x07, 0xec, 0x51
+};
+
+static const td_u8 ecc_brainpool_384r1_n_minus_2[] = {
+    0x8C, 0xB9, 0x1E, 0x82, 0xA3, 0x38, 0x6D, 0x28, 0x0F, 0x5D, 0x6F, 0x7E, 0x50, 0xE6, 0x41, 0xDF,
+    0x15, 0x2F, 0x71, 0x09, 0xED, 0x54, 0x56, 0xB3, 0x1F, 0x16, 0x6E, 0x6C, 0xAC, 0x04, 0x25, 0xA7,
+    0xCF, 0x3A, 0xB6, 0xAF, 0x6B, 0x7F, 0xC3, 0x10, 0x3B, 0x88, 0x32, 0x02, 0xE9, 0x04, 0x65, 0x63
+};
+
+static const td_u32 ecc_brainpool_384r1_mont_param_n[PKE_MONT_PARAM_LEN] = {0x5cfedd2a, 0x5cb5bb93};
+
+static const td_u32 ecc_brainpool_384r1_mont_param_p[PKE_MONT_PARAM_LEN] = {0x9a6ea96c, 0xea9ec825};
+
+const pke_ecc_init_param g_brainpool_384r1_init_param = {
+    .mont_a = ecc_brainpool_384r1_mont_a,
+    .mont_b = ecc_brainpool_384r1_mont_b,
+    .mont_1_p = ecc_brainpool_384r1_mont_1_p,
+    .mont_1_n = ecc_brainpool_384r1_mont_1_n,
+    .rrp = ecc_brainpool_384r1_rrp,
+    .rrn = ecc_brainpool_384r1_rrn,
+    .const_1 = g_const_1 + PKE_LEN_384_OFFSET,
+    .const_0 = g_const_0,
+    .mont_param_n = ecc_brainpool_384r1_mont_param_n,
+    .mont_param_p = ecc_brainpool_384r1_mont_param_p,
+    .n_minus_2 = ecc_brainpool_384r1_n_minus_2,
+    .p_minus_2 = ecc_brainpool_384r1_p_minus_2,
+};
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_512r1.c b/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_512r1.c
new file mode 100644
index 0000000..87ecd6e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/curve_param/brainpool_512r1.c
@@ -0,0 +1,141 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke ecc_curve_param brainpool_512r1. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-29, Create file. \n
+ */
+#if defined(CONFIG_PKE_SUPPORT_ECC_BP512R)
+
+#include "ecc_curve_param.h"
+
+static const td_u8 ecc_brainpool_512r1_p[] = {
+    0xaa, 0xdd, 0x9d, 0xb8, 0xdb, 0xe9, 0xc4, 0x8b, 0x3f, 0xd4, 0xe6, 0xae, 0x33, 0xc9, 0xfc, 0x07,
+    0xcb, 0x30, 0x8d, 0xb3, 0xb3, 0xc9, 0xd2, 0x0e, 0xd6, 0x63, 0x9c, 0xca, 0x70, 0x33, 0x08, 0x71,
+    0x7d, 0x4d, 0x9b, 0x00, 0x9b, 0xc6, 0x68, 0x42, 0xae, 0xcd, 0xa1, 0x2a, 0xe6, 0xa3, 0x80, 0xe6,
+    0x28, 0x81, 0xff, 0x2f, 0x2d, 0x82, 0xc6, 0x85, 0x28, 0xaa, 0x60, 0x56, 0x58, 0x3a, 0x48, 0xf3
+};
+
+static const td_u8 ecc_brainpool_512r1_a[] = {
+    0x78, 0x30, 0xa3, 0x31, 0x8b, 0x60, 0x3b, 0x89, 0xe2, 0x32, 0x71, 0x45, 0xac, 0x23, 0x4c, 0xc5,
+    0x94, 0xcb, 0xdd, 0x8d, 0x3d, 0xf9, 0x16, 0x10, 0xa8, 0x34, 0x41, 0xca, 0xea, 0x98, 0x63, 0xbc,
+    0x2d, 0xed, 0x5d, 0x5a, 0xa8, 0x25, 0x3a, 0xa1, 0x0a, 0x2e, 0xf1, 0xc9, 0x8b, 0x9a, 0xc8, 0xb5,
+    0x7f, 0x11, 0x17, 0xa7, 0x2b, 0xf2, 0xc7, 0xb9, 0xe7, 0xc1, 0xac, 0x4d, 0x77, 0xfc, 0x94, 0xca
+};
+
+static const td_u8 ecc_brainpool_512r1_b[] = {
+    0x3d, 0xf9, 0x16, 0x10, 0xa8, 0x34, 0x41, 0xca, 0xea, 0x98, 0x63, 0xbc, 0x2d, 0xed, 0x5d, 0x5a,
+    0xa8, 0x25, 0x3a, 0xa1, 0x0a, 0x2e, 0xf1, 0xc9, 0x8b, 0x9a, 0xc8, 0xb5, 0x7f, 0x11, 0x17, 0xa7,
+    0x2b, 0xf2, 0xc7, 0xb9, 0xe7, 0xc1, 0xac, 0x4d, 0x77, 0xfc, 0x94, 0xca, 0xdc, 0x08, 0x3e, 0x67,
+    0x98, 0x40, 0x50, 0xb7, 0x5e, 0xba, 0xe5, 0xdd, 0x28, 0x09, 0xbd, 0x63, 0x80, 0x16, 0xf7, 0x23
+};
+
+static const td_u8 ecc_brainpool_512r1_gx[] = {
+    0x81, 0xae, 0xe4, 0xbd, 0xd8, 0x2e, 0xd9, 0x64, 0x5a, 0x21, 0x32, 0x2e, 0x9c, 0x4c, 0x6a, 0x93,
+    0x85, 0xed, 0x9f, 0x70, 0xb5, 0xd9, 0x16, 0xc1, 0xb4, 0x3b, 0x62, 0xee, 0xf4, 0xd0, 0x09, 0x8e,
+    0xff, 0x3b, 0x1f, 0x78, 0xe2, 0xd0, 0xd4, 0x8d, 0x50, 0xd1, 0x68, 0x7b, 0x93, 0xb9, 0x7d, 0x5f,
+    0x7c, 0x6d, 0x50, 0x47, 0x40, 0x6a, 0x5e, 0x68, 0x8b, 0x35, 0x22, 0x09, 0xbc, 0xb9, 0xf8, 0x22
+};
+
+static const td_u8 ecc_brainpool_512r1_gy[] = {
+    0x7d, 0xde, 0x38, 0x5d, 0x56, 0x63, 0x32, 0xec, 0xc0, 0xea, 0xbf, 0xa9, 0xcf, 0x78, 0x22, 0xfd,
+    0xf2, 0x09, 0xf7, 0x00, 0x24, 0xa5, 0x7b, 0x1a, 0xa0, 0x00, 0xc5, 0x5b, 0x88, 0x1f, 0x81, 0x11,
+    0xb2, 0xdc, 0xde, 0x49, 0x4a, 0x5f, 0x48, 0x5e, 0x5b, 0xca, 0x4b, 0xd8, 0x8a, 0x27, 0x63, 0xae,
+    0xd1, 0xca, 0x2b, 0x2f, 0xa8, 0xf0, 0x54, 0x06, 0x78, 0xcd, 0x1e, 0x0f, 0x3a, 0xd8, 0x08, 0x92
+};
+
+static const td_u8 ecc_brainpool_512r1_n[] = {
+    0xaa, 0xdd, 0x9d, 0xb8, 0xdb, 0xe9, 0xc4, 0x8b, 0x3f, 0xd4, 0xe6, 0xae, 0x33, 0xc9, 0xfc, 0x07,
+    0xcb, 0x30, 0x8d, 0xb3, 0xb3, 0xc9, 0xd2, 0x0e, 0xd6, 0x63, 0x9c, 0xca, 0x70, 0x33, 0x08, 0x70,
+    0x55, 0x3e, 0x5c, 0x41, 0x4c, 0xa9, 0x26, 0x19, 0x41, 0x86, 0x61, 0x19, 0x7f, 0xac, 0x10, 0x47,
+    0x1d, 0xb1, 0xd3, 0x81, 0x08, 0x5d, 0xda, 0xdd, 0xb5, 0x87, 0x96, 0x82, 0x9c, 0xa9, 0x00, 0x69
+};
+
+const drv_pke_ecc_curve g_brainpool_512r1_param = {
+    .p = ecc_brainpool_512r1_p,
+    .a = ecc_brainpool_512r1_a,
+    .b = ecc_brainpool_512r1_b,
+    .gx = ecc_brainpool_512r1_gx,
+    .gy = ecc_brainpool_512r1_gy,
+    .n = ecc_brainpool_512r1_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_512,
+    .ecc_type = DRV_PKE_ECC_TYPE_RFC5639_P512
+};
+
+static const td_u8 ecc_brainpool_512r1_mont_a[] = {
+    0x5e, 0xc4, 0xf1, 0x87, 0x22, 0x7d, 0x2a, 0x83, 0xb8, 0x3b, 0x84, 0xfa, 0xe2, 0xd0, 0x85, 0x0c,
+    0x18, 0x2d, 0x0f, 0x59, 0xf4, 0x1e, 0x87, 0x78, 0xa5, 0xec, 0x30, 0xc8, 0x3f, 0x80, 0xd1, 0xc7,
+    0xcf, 0x8f, 0x01, 0x11, 0x9e, 0x6e, 0x87, 0xff, 0x40, 0xb0, 0x4b, 0x72, 0x46, 0x75, 0xbb, 0xab,
+    0x14, 0xe4, 0x95, 0x7d, 0xaf, 0xa7, 0xd2, 0x83, 0xda, 0x1f, 0x8a, 0x34, 0xea, 0x10, 0xc4, 0x46
+};
+
+static const td_u8 ecc_brainpool_512r1_mont_b[] = {
+    0x6a, 0x4a, 0xab, 0xb4, 0x47, 0x1e, 0x8e, 0xa7, 0x64, 0x23, 0x12, 0xa5, 0x0b, 0xb5, 0xaa, 0xa2,
+    0xcb, 0xda, 0x57, 0xac, 0x6d, 0x17, 0xd8, 0x1d, 0x97, 0xe0, 0x0c, 0x63, 0xfe, 0x22, 0x24, 0x33,
+    0xc7, 0x3e, 0x30, 0xe8, 0x98, 0x77, 0xbe, 0x02, 0xe1, 0x6b, 0xa4, 0x56, 0x2d, 0x87, 0x24, 0xaa,
+    0x00, 0x9b, 0x63, 0xc7, 0xe5, 0x8e, 0x5a, 0x34, 0x50, 0x7e, 0x83, 0x96, 0x20, 0xe9, 0x2a, 0x34
+};
+
+static const td_u8 ecc_brainpool_512r1_mont_1_p[] = {
+    0x55, 0x22, 0x62, 0x47, 0x24, 0x16, 0x3b, 0x74, 0xc0, 0x2b, 0x19, 0x51, 0xcc, 0x36, 0x03, 0xf8,
+    0x34, 0xcf, 0x72, 0x4c, 0x4c, 0x36, 0x2d, 0xf1, 0x29, 0x9c, 0x63, 0x35, 0x8f, 0xcc, 0xf7, 0x8e,
+    0x82, 0xb2, 0x64, 0xff, 0x64, 0x39, 0x97, 0xbd, 0x51, 0x32, 0x5e, 0xd5, 0x19, 0x5c, 0x7f, 0x19,
+    0xd7, 0x7e, 0x00, 0xd0, 0xd2, 0x7d, 0x39, 0x7a, 0xd7, 0x55, 0x9f, 0xa9, 0xa7, 0xc5, 0xb7, 0x0d
+};
+
+static const td_u8 ecc_brainpool_512r1_mont_1_n[] = {
+    0x55, 0x22, 0x62, 0x47, 0x24, 0x16, 0x3b, 0x74, 0xc0, 0x2b, 0x19, 0x51, 0xcc, 0x36, 0x03, 0xf8,
+    0x34, 0xcf, 0x72, 0x4c, 0x4c, 0x36, 0x2d, 0xf1, 0x29, 0x9c, 0x63, 0x35, 0x8f, 0xcc, 0xf7, 0x8f,
+    0xaa, 0xc1, 0xa3, 0xbe, 0xb3, 0x56, 0xd9, 0xe6, 0xbe, 0x79, 0x9e, 0xe6, 0x80, 0x53, 0xef, 0xb8,
+    0xe2, 0x4e, 0x2c, 0x7e, 0xf7, 0xa2, 0x25, 0x22, 0x4a, 0x78, 0x69, 0x7d, 0x63, 0x56, 0xff, 0x97
+};
+
+static const td_u8 ecc_brainpool_512r1_rrp[] = {
+    0x3c, 0x4c, 0x9d, 0x05, 0xa9, 0xff, 0x64, 0x50, 0x20, 0x2e, 0x19, 0x40, 0x20, 0x56, 0xee, 0xcc,
+    0xa1, 0x6d, 0xaa, 0x5f, 0xd4, 0x2b, 0xff, 0x83, 0x19, 0x48, 0x6f, 0xd8, 0xd5, 0x89, 0x80, 0x57,
+    0xe0, 0xc1, 0x9a, 0x77, 0x83, 0x51, 0x4a, 0x25, 0x53, 0xb7, 0xf9, 0xbc, 0x90, 0x5a, 0xff, 0xd3,
+    0x79, 0x3f, 0xb1, 0x30, 0x27, 0x15, 0x79, 0x05, 0x49, 0xad, 0x14, 0x4a, 0x61, 0x58, 0xf2, 0x05
+};
+
+static const td_u8 ecc_brainpool_512r1_rrn[] = {
+    0xa7, 0x94, 0x58, 0x6a, 0x71, 0x84, 0x07, 0xb0, 0x95, 0xdf, 0x1b, 0x4c, 0x19, 0x4b, 0x2e, 0x56,
+    0x72, 0x3c, 0x37, 0xa2, 0x2f, 0x16, 0xbb, 0xdf, 0xd7, 0xf9, 0xcc, 0x26, 0x3b, 0x79, 0x0d, 0xe3,
+    0xa6, 0xf2, 0x30, 0xc7, 0x2f, 0x02, 0x07, 0xe8, 0x3e, 0xc6, 0x4b, 0xd0, 0x33, 0xb7, 0x62, 0x7f,
+    0x08, 0x86, 0xb7, 0x58, 0x95, 0x28, 0x3d, 0xdd, 0xd2, 0xa3, 0x68, 0x1e, 0xcd, 0xa8, 0x16, 0x71
+};
+
+static const td_u8 ecc_brainpool_512r1_p_minus_2[] = {
+    0xaa, 0xdd, 0x9d, 0xb8, 0xdb, 0xe9, 0xc4, 0x8b, 0x3f, 0xd4, 0xe6, 0xae, 0x33, 0xc9, 0xfc, 0x07,
+    0xcb, 0x30, 0x8d, 0xb3, 0xb3, 0xc9, 0xd2, 0x0e, 0xd6, 0x63, 0x9c, 0xca, 0x70, 0x33, 0x08, 0x71,
+    0x7d, 0x4d, 0x9b, 0x00, 0x9b, 0xc6, 0x68, 0x42, 0xae, 0xcd, 0xa1, 0x2a, 0xe6, 0xa3, 0x80, 0xe6,
+    0x28, 0x81, 0xff, 0x2f, 0x2d, 0x82, 0xc6, 0x85, 0x28, 0xaa, 0x60, 0x56, 0x58, 0x3a, 0x48, 0xf1
+};
+
+static const td_u8 ecc_brainpool_512r1_n_minus_2[] = {
+    0xaa, 0xdd, 0x9d, 0xb8, 0xdb, 0xe9, 0xc4, 0x8b, 0x3f, 0xd4, 0xe6, 0xae, 0x33, 0xc9, 0xfc, 0x07,
+    0xcb, 0x30, 0x8d, 0xb3, 0xb3, 0xc9, 0xd2, 0x0e, 0xd6, 0x63, 0x9c, 0xca, 0x70, 0x33, 0x08, 0x70,
+    0x55, 0x3e, 0x5c, 0x41, 0x4c, 0xa9, 0x26, 0x19, 0x41, 0x86, 0x61, 0x19, 0x7f, 0xac, 0x10, 0x47,
+    0x1d, 0xb1, 0xd3, 0x81, 0x08, 0x5d, 0xda, 0xdd, 0xb5, 0x87, 0x96, 0x82, 0x9c, 0xa9, 0x00, 0x67
+};
+
+static const td_u32 ecc_brainpool_512r1_mont_param_n[PKE_MONT_PARAM_LEN] = {0xad49541f, 0xf1b7027};
+
+static const td_u32 ecc_brainpool_512r1_mont_param_p[PKE_MONT_PARAM_LEN] = {0x839b3220, 0x7d89efc5};
+
+const pke_ecc_init_param g_brainpool_512r1_init_param = {
+    .mont_a = ecc_brainpool_512r1_mont_a,
+    .mont_b = ecc_brainpool_512r1_mont_b,
+    .mont_1_p = ecc_brainpool_512r1_mont_1_p,
+    .mont_1_n = ecc_brainpool_512r1_mont_1_n,
+    .rrp = ecc_brainpool_512r1_rrp,
+    .rrn = ecc_brainpool_512r1_rrn,
+    .const_1 = g_const_1 + PKE_LEN_512_OFFSET,
+    .const_0 = g_const_0,
+    .mont_param_n = ecc_brainpool_512r1_mont_param_n,
+    .mont_param_p = ecc_brainpool_512r1_mont_param_p,
+    .n_minus_2 = ecc_brainpool_512r1_n_minus_2,
+    .p_minus_2 = ecc_brainpool_512r1_p_minus_2,
+};
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p256r.c b/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p256r.c
new file mode 100644
index 0000000..155fe12
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p256r.c
@@ -0,0 +1,114 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke ecc_curve_param nist_p256r. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-29, Create file. \n
+ */
+#if defined(CONFIG_PKE_SUPPORT_ECC_FIPS_P256R)
+
+#include "ecc_curve_param.h"
+
+static const td_u8 ecc_nist_p256_p[] = {
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+};
+
+static const td_u8 ecc_nist_p256_a[] = {
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc
+};
+
+static const td_u8 ecc_nist_p256_b[] = {
+    0x5a, 0xc6, 0x35, 0xd8, 0xaa, 0x3a, 0x93, 0xe7, 0xb3, 0xeb, 0xbd, 0x55, 0x76, 0x98, 0x86, 0xbc,
+    0x65, 0x1d, 0x06, 0xb0, 0xcc, 0x53, 0xb0, 0xf6, 0x3b, 0xce, 0x3c, 0x3e, 0x27, 0xd2, 0x60, 0x4b
+};
+
+static const td_u8 ecc_nist_p256_gx[] = {
+    0x6b, 0x17, 0xd1, 0xf2, 0xe1, 0x2c, 0x42, 0x47, 0xf8, 0xbc, 0xe6, 0xe5, 0x63, 0xa4, 0x40, 0xf2,
+    0x77, 0x03, 0x7d, 0x81, 0x2d, 0xeb, 0x33, 0xa0, 0xf4, 0xa1, 0x39, 0x45, 0xd8, 0x98, 0xc2, 0x96
+};
+
+static const td_u8 ecc_nist_p256_gy[] = {
+    0x4f, 0xe3, 0x42, 0xe2, 0xfe, 0x1a, 0x7f, 0x9b, 0x8e, 0xe7, 0xeb, 0x4a, 0x7c, 0x0f, 0x9e, 0x16,
+    0x2b, 0xce, 0x33, 0x57, 0x6b, 0x31, 0x5e, 0xce, 0xcb, 0xb6, 0x40, 0x68, 0x37, 0xbf, 0x51, 0xf5
+};
+
+static const td_u8 ecc_nist_p256_n[] = {
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51
+};
+
+const drv_pke_ecc_curve g_nist_p256_param = {
+    .p = ecc_nist_p256_p,
+    .a = ecc_nist_p256_a,
+    .b = ecc_nist_p256_b,
+    .gx = ecc_nist_p256_gx,
+    .gy = ecc_nist_p256_gy,
+    .n = ecc_nist_p256_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_FIPS_P256R
+};
+
+static const td_u8 ecc_nist_p256_mont_a[] = {
+    0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc
+};
+
+static const td_u8 ecc_nist_p256_mont_b[] = {
+    0x76, 0x1b, 0x22, 0xc0, 0x80, 0xc3, 0xc6, 0xac, 0x26, 0xf1, 0x55, 0x0c, 0x23, 0xf4, 0xf7, 0x8f,
+    0x3b, 0x1b, 0xfa, 0x97, 0xb2, 0x54, 0xbc, 0xb8, 0xdc, 0x43, 0xd9, 0x9b, 0x5e, 0xe4, 0x86, 0x5f
+};
+
+static const td_u8 ecc_nist_p256_mont_1_p[] = {
+    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
+};
+
+static const td_u8 ecc_nist_p256_mont_1_n[] = {
+    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x43, 0x19, 0x05, 0x52, 0x58, 0xe8, 0x61, 0x7b, 0x0c, 0x46, 0x35, 0x3d, 0x03, 0x9c, 0xda, 0xaf
+};
+
+static const td_u8 ecc_nist_p256_rrp[] = {
+    0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
+    0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
+};
+
+static const td_u8 ecc_nist_p256_rrn[] = {
+    0x66, 0xe1, 0x2d, 0x94, 0xf3, 0xd9, 0x56, 0x20, 0x28, 0x45, 0xb2, 0x39, 0x2b, 0x6b, 0xec, 0x59,
+    0x46, 0x99, 0x79, 0x9c, 0x49, 0xbd, 0x6f, 0xa6, 0x83, 0x24, 0x4c, 0x95, 0xbe, 0x79, 0xee, 0xa2
+};
+
+static const td_u8 ecc_nist_p256_p_minus_2[] = {
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd
+};
+
+static const td_u8 ecc_nist_p256_n_minus_2[] = {
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x4f
+};
+
+static const td_u32 ecc_nist_p256_mont_param_n[PKE_MONT_PARAM_LEN] = {0xccd1c8aa, 0xee00bc4f};
+
+static const td_u32 ecc_nist_p256_mont_param_p[PKE_MONT_PARAM_LEN] = {0x0, 0x1};
+
+const pke_ecc_init_param g_nist_p256_init_param = {
+    .mont_a = ecc_nist_p256_mont_a,
+    .mont_b = ecc_nist_p256_mont_b,
+    .mont_1_p = ecc_nist_p256_mont_1_p,
+    .mont_1_n = ecc_nist_p256_mont_1_n,
+    .rrp = ecc_nist_p256_rrp,
+    .rrn = ecc_nist_p256_rrn,
+    .const_1 = g_const_1 + PKE_LEN_256_OFFSET, /* here use the same value,
+                                                  but the length is determined by the curve->ksize. */
+    .const_0 = g_const_0,
+    .mont_param_n = ecc_nist_p256_mont_param_n,
+    .mont_param_p = ecc_nist_p256_mont_param_p,
+    .n_minus_2 = ecc_nist_p256_n_minus_2,
+    .p_minus_2 = ecc_nist_p256_p_minus_2,
+};
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p384r.c b/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p384r.c
new file mode 100644
index 0000000..fc02678
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p384r.c
@@ -0,0 +1,127 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke ecc_curve_param nist_p384r. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-29, Create file. \n
+ */
+#if defined(CONFIG_PKE_SUPPORT_ECC_FIPS_P384R)
+
+#include "ecc_curve_param.h"
+
+static const td_u8 ecc_nist_p384_p[] = {
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff
+};
+
+static const td_u8 ecc_nist_p384_a[] = {
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfc
+};
+
+static const td_u8 ecc_nist_p384_b[] = {
+    0xb3, 0x31, 0x2f, 0xa7, 0xe2, 0x3e, 0xe7, 0xe4, 0x98, 0x8e, 0x05, 0x6b, 0xe3, 0xf8, 0x2d, 0x19,
+    0x18, 0x1d, 0x9c, 0x6e, 0xfe, 0x81, 0x41, 0x12, 0x03, 0x14, 0x08, 0x8f, 0x50, 0x13, 0x87, 0x5a,
+    0xc6, 0x56, 0x39, 0x8d, 0x8a, 0x2e, 0xd1, 0x9d, 0x2a, 0x85, 0xc8, 0xed, 0xd3, 0xec, 0x2a, 0xef
+};
+
+static const td_u8 ecc_nist_p384_gx[] = {
+    0xaa, 0x87, 0xca, 0x22, 0xbe, 0x8b, 0x05, 0x37, 0x8e, 0xb1, 0xc7, 0x1e, 0xf3, 0x20, 0xad, 0x74,
+    0x6e, 0x1d, 0x3b, 0x62, 0x8b, 0xa7, 0x9b, 0x98, 0x59, 0xf7, 0x41, 0xe0, 0x82, 0x54, 0x2a, 0x38,
+    0x55, 0x02, 0xf2, 0x5d, 0xbf, 0x55, 0x29, 0x6c, 0x3a, 0x54, 0x5e, 0x38, 0x72, 0x76, 0x0a, 0xb7
+};
+
+static const td_u8 ecc_nist_p384_gy[] = {
+    0x36, 0x17, 0xde, 0x4a, 0x96, 0x26, 0x2c, 0x6f, 0x5d, 0x9e, 0x98, 0xbf, 0x92, 0x92, 0xdc, 0x29,
+    0xf8, 0xf4, 0x1d, 0xbd, 0x28, 0x9a, 0x14, 0x7c, 0xe9, 0xda, 0x31, 0x13, 0xb5, 0xf0, 0xb8, 0xc0,
+    0x0a, 0x60, 0xb1, 0xce, 0x1d, 0x7e, 0x81, 0x9d, 0x7a, 0x43, 0x1d, 0x7c, 0x90, 0xea, 0x0e, 0x5f
+};
+
+static const td_u8 ecc_nist_p384_n[] = {
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
+    0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73
+};
+
+const drv_pke_ecc_curve g_nist_p384_param = {
+    .p = ecc_nist_p384_p,
+    .a = ecc_nist_p384_a,
+    .b = ecc_nist_p384_b,
+    .gx = ecc_nist_p384_gx,
+    .gy = ecc_nist_p384_gy,
+    .n = ecc_nist_p384_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_384,
+    .ecc_type = DRV_PKE_ECC_TYPE_FIPS_P384R
+};
+
+static const td_u8 ecc_nist_p384_mont_a[] = {
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb,
+    0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xfc
+};
+
+static const td_u8 ecc_nist_p384_mont_b[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x85, 0x4d, 0xde, 0x64, 0x9b, 0x65, 0x0a, 0xc2, 0x3b, 0x4e, 0x88, 0xaa, 0xd9, 0x9a, 0xef, 0xfb,
+    0xd3, 0xc1, 0xf8, 0x58, 0xa0, 0x25, 0x5e, 0x78, 0xe7, 0x10, 0x0f, 0xf1, 0x68, 0x07, 0x4a, 0x30
+};
+
+static const td_u8 ecc_nist_p384_mont_1_p[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01
+};
+
+static const td_u8 ecc_nist_p384_mont_1_n[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x9c, 0xb2, 0x7e, 0x0b, 0xc8, 0xd2, 0x20,
+    0xa7, 0xe5, 0xf2, 0x4d, 0xb7, 0x4f, 0x58, 0x85, 0x13, 0x13, 0xe6, 0x95, 0x33, 0x3a, 0xd6, 0x8d
+};
+
+static const td_u8 ecc_nist_p384_rrp[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x01
+};
+
+static const td_u8 ecc_nist_p384_rrn[] = {
+    0x0c, 0x84, 0xee, 0x01, 0x2b, 0x39, 0xbf, 0x21, 0x3f, 0xb0, 0x5b, 0x7a, 0x28, 0x26, 0x68, 0x95,
+    0xd4, 0x0d, 0x49, 0x17, 0x4a, 0xab, 0x1c, 0xc5, 0xbc, 0x3e, 0x48, 0x3a, 0xfc, 0xb8, 0x29, 0x47,
+    0xff, 0x3d, 0x81, 0xe5, 0xdf, 0x1a, 0xa4, 0x19, 0x2d, 0x31, 0x9b, 0x24, 0x19, 0xb4, 0x09, 0xa9
+};
+
+static const td_u8 ecc_nist_p384_p_minus_2[] = {
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfd
+};
+
+static const td_u8 ecc_nist_p384_n_minus_2[] = {
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
+    0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x71
+};
+
+static const td_u32 ecc_nist_p384_mont_param_n[PKE_MONT_PARAM_LEN] = {0x6ed46089, 0xe88fdc45};
+
+static const td_u32 ecc_nist_p384_mont_param_p[PKE_MONT_PARAM_LEN] = {0x1, 0x1};
+
+const pke_ecc_init_param g_nist_p384_init_param = {
+    .mont_a = ecc_nist_p384_mont_a,
+    .mont_b = ecc_nist_p384_mont_b,
+    .mont_1_p = ecc_nist_p384_mont_1_p,
+    .mont_1_n = ecc_nist_p384_mont_1_n,
+    .rrp = ecc_nist_p384_rrp,
+    .rrn = ecc_nist_p384_rrn,
+    .const_1 = g_const_1 + PKE_LEN_384_OFFSET,
+    .const_0 = g_const_0,
+    .mont_param_n = ecc_nist_p384_mont_param_n,
+    .mont_param_p = ecc_nist_p384_mont_param_p,
+    .n_minus_2 = ecc_nist_p384_n_minus_2,
+    .p_minus_2 = ecc_nist_p384_p_minus_2,
+};
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p521r.c b/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p521r.c
new file mode 100644
index 0000000..afb0830
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/curve_param/nist_p521r.c
@@ -0,0 +1,155 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke ecc_curve_param nist_p521r. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-29, Create file. \n
+ */
+#if defined(CONFIG_PKE_SUPPORT_ECC_FIPS_P521R)
+
+#include "ecc_curve_param.h"
+
+static const td_u8 ecc_nist_p521_p[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+};
+
+static const td_u8 ecc_nist_p521_a[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc
+};
+
+static const td_u8 ecc_nist_p521_b[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x95, 0x3e, 0xb9, 0x61, 0x8e, 0x1c, 0x9a, 0x1f,
+    0x92, 0x9a, 0x21, 0xa0, 0xb6, 0x85, 0x40, 0xee, 0xa2, 0xda, 0x72, 0x5b, 0x99, 0xb3, 0x15, 0xf3,
+    0xb8, 0xb4, 0x89, 0x91, 0x8e, 0xf1, 0x09, 0xe1, 0x56, 0x19, 0x39, 0x51, 0xec, 0x7e, 0x93, 0x7b,
+    0x16, 0x52, 0xc0, 0xbd, 0x3b, 0xb1, 0xbf, 0x07, 0x35, 0x73, 0xdf, 0x88, 0x3d, 0x2c, 0x34, 0xf1,
+    0xef, 0x45, 0x1f, 0xd4, 0x6b, 0x50, 0x3f, 0x00
+};
+
+static const td_u8 ecc_nist_p521_gx[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x85, 0x8e, 0x06, 0xb7, 0x04, 0x04, 0xe9, 0xcd,
+    0x9e, 0x3e, 0xcb, 0x66, 0x23, 0x95, 0xb4, 0x42, 0x9c, 0x64, 0x81, 0x39, 0x05, 0x3f, 0xb5, 0x21,
+    0xf8, 0x28, 0xaf, 0x60, 0x6b, 0x4d, 0x3d, 0xba, 0xa1, 0x4b, 0x5e, 0x77, 0xef, 0xe7, 0x59, 0x28,
+    0xfe, 0x1d, 0xc1, 0x27, 0xa2, 0xff, 0xa8, 0xde, 0x33, 0x48, 0xb3, 0xc1, 0x85, 0x6a, 0x42, 0x9b,
+    0xf9, 0x7e, 0x7e, 0x31, 0xc2, 0xe5, 0xbd, 0x66
+};
+
+static const td_u8 ecc_nist_p521_gy[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x18, 0x39, 0x29, 0x6a, 0x78, 0x9a, 0x3b, 0xc0, 0x04,
+    0x5c, 0x8a, 0x5f, 0xb4, 0x2c, 0x7d, 0x1b, 0xd9, 0x98, 0xf5, 0x44, 0x49, 0x57, 0x9b, 0x44, 0x68,
+    0x17, 0xaf, 0xbd, 0x17, 0x27, 0x3e, 0x66, 0x2c, 0x97, 0xee, 0x72, 0x99, 0x5e, 0xf4, 0x26, 0x40,
+    0xc5, 0x50, 0xb9, 0x01, 0x3f, 0xad, 0x07, 0x61, 0x35, 0x3c, 0x70, 0x86, 0xa2, 0x72, 0xc2, 0x40,
+    0x88, 0xbe, 0x94, 0x76, 0x9f, 0xd1, 0x66, 0x50
+};
+
+static const td_u8 ecc_nist_p521_n[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f, 0x96, 0x6b,
+    0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09, 0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c, 0x47, 0xae,
+    0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38, 0x64, 0x09
+};
+
+const drv_pke_ecc_curve g_nist_p521_param = {
+    .p = ecc_nist_p521_p,
+    .a = ecc_nist_p521_a,
+    .b = ecc_nist_p521_b,
+    .gx = ecc_nist_p521_gx,
+    .gy = ecc_nist_p521_gy,
+    .n = ecc_nist_p521_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_576,
+    .ecc_type = DRV_PKE_ECC_TYPE_FIPS_P521R
+};
+
+static const td_u8 ecc_nist_p521_mont_a[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+};
+
+static const td_u8 ecc_nist_p521_mont_b[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x9b, 0xc6, 0x9d, 0xc3, 0x35, 0x4a, 0x1a,
+    0x51, 0x27, 0xc1, 0x67, 0xca, 0xf7, 0xf3, 0x19, 0x0c, 0xd3, 0x1d, 0xaf, 0x93, 0xf6, 0xd2, 0x75,
+    0x74, 0x56, 0x6e, 0x5d, 0x7b, 0x95, 0x8d, 0xee
+};
+
+static const td_u8 ecc_nist_p521_mont_1_p[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static const td_u8 ecc_nist_p521_mont_1_n[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x02, 0xd7, 0x3c, 0xbc, 0x3e, 0x20, 0x68, 0x34, 0xca, 0x40, 0x19, 0xff, 0x5b, 0x84, 0x7b, 0x2d,
+    0x17, 0xe2, 0x25, 0x1b, 0x23, 0xbb, 0x31, 0xdc, 0x28, 0xa2, 0x48, 0x24, 0x70, 0xb7, 0x63, 0xcd,
+    0xfb, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static const td_u8 ecc_nist_p521_rrp[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static const td_u8 ecc_nist_p521_rrn[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x2d, 0x8e, 0x03, 0xd1, 0x49, 0x2d, 0x0d, 0x45,
+    0x5b, 0xcc, 0x6d, 0x61, 0xa8, 0xe5, 0x67, 0xbc, 0xcf, 0xf3, 0xd1, 0x42, 0xb7, 0x75, 0x6e, 0x3e,
+    0xdd, 0x6e, 0x23, 0xd8, 0x2e, 0x49, 0xc7, 0xdb, 0xd3, 0x72, 0x1e, 0xf5, 0x57, 0xf7, 0x5e, 0x06,
+    0x12, 0xa7, 0x8d, 0x38, 0x79, 0x45, 0x73, 0xff, 0xf7, 0x07, 0xba, 0xdc, 0xe5, 0x54, 0x7e, 0xa3,
+    0x13, 0x7c, 0xd0, 0x4d, 0xcf, 0x15, 0xdd, 0x04
+};
+
+static const td_u8 ecc_nist_p521_p_minus_2[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd
+};
+
+static const td_u8 ecc_nist_p521_n_minus_2[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f, 0x96, 0x6b,
+    0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09, 0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c, 0x47, 0xae,
+    0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38, 0x64, 0x07
+};
+
+static const td_u32 ecc_nist_p521_mont_param_n[PKE_MONT_PARAM_LEN] = {0x1d2f5ccd, 0x79a995c7};
+
+static const td_u32 ecc_nist_p521_mont_param_p[PKE_MONT_PARAM_LEN] = {0x0, 0x1};
+
+const pke_ecc_init_param g_nist_p521_init_param = {
+    .mont_a = ecc_nist_p521_mont_a,
+    .mont_b = ecc_nist_p521_mont_b,
+    .mont_1_p = ecc_nist_p521_mont_1_p,
+    .mont_1_n = ecc_nist_p521_mont_1_n,
+    .rrp = ecc_nist_p521_rrp,
+    .rrn = ecc_nist_p521_rrn,
+    .const_1 = g_const_1,
+    .const_0 = g_const_0,
+    .mont_param_n = ecc_nist_p521_mont_param_n,
+    .mont_param_p = ecc_nist_p521_mont_param_p,
+    .n_minus_2 = ecc_nist_p521_n_minus_2,
+    .p_minus_2 = ecc_nist_p521_p_minus_2,
+};
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/curve_param/sm2.c b/bsp/security_subsys/security_subsys_common/common/curve_param/sm2.c
new file mode 100644
index 0000000..df947c0
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/curve_param/sm2.c
@@ -0,0 +1,113 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke ecc_curve_param sm2. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-29, Create file. \n
+ */
+#if defined(CONFIG_PKE_SUPPORT_SM2)
+
+#include "ecc_curve_param.h"
+
+static const td_u8 sm2_p[] = {
+    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+};
+
+static const td_u8 sm2_a[] = {
+    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc
+};
+
+static const td_u8 sm2_b[] = {
+    0x28, 0xe9, 0xfa, 0x9e, 0x9d, 0x9f, 0x5e, 0x34, 0x4d, 0x5a, 0x9e, 0x4b, 0xcf, 0x65, 0x09, 0xa7,
+    0xf3, 0x97, 0x89, 0xf5, 0x15, 0xab, 0x8f, 0x92, 0xdd, 0xbc, 0xbd, 0x41, 0x4d, 0x94, 0x0e, 0x93
+};
+
+static const td_u8 sm2_gx[] = {
+    0x32, 0xc4, 0xae, 0x2c, 0x1f, 0x19, 0x81, 0x19, 0x5f, 0x99, 0x04, 0x46, 0x6a, 0x39, 0xc9, 0x94,
+    0x8f, 0xe3, 0x0b, 0xbf, 0xf2, 0x66, 0x0b, 0xe1, 0x71, 0x5a, 0x45, 0x89, 0x33, 0x4c, 0x74, 0xc7
+};
+
+static const td_u8 sm2_gy[] = {
+    0xbc, 0x37, 0x36, 0xa2, 0xf4, 0xf6, 0x77, 0x9c, 0x59, 0xbd, 0xce, 0xe3, 0x6b, 0x69, 0x21, 0x53,
+    0xd0, 0xa9, 0x87, 0x7c, 0xc6, 0x2a, 0x47, 0x40, 0x02, 0xdf, 0x32, 0xe5, 0x21, 0x39, 0xf0, 0xa0
+};
+
+static const td_u8 sm2_n[] = {
+    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0x72, 0x03, 0xdf, 0x6b, 0x21, 0xc6, 0x05, 0x2b, 0x53, 0xbb, 0xf4, 0x09, 0x39, 0xd5, 0x41, 0x23
+};
+
+const drv_pke_ecc_curve g_sm2_param = {
+    .p = sm2_p,
+    .a = sm2_a,
+    .b = sm2_b,
+    .gx = sm2_gx,
+    .gy = sm2_gy,
+    .n = sm2_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_SM2
+};
+
+static const td_u8 sm2_mont_a[] = {
+    0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc
+};
+
+static const td_u8 sm2_mont_b[] = {
+    0x31, 0xbd, 0x80, 0x59, 0xbb, 0x3d, 0x1b, 0x0d, 0x69, 0x65, 0xa1, 0xe7, 0x3c, 0x26, 0xf2, 0xce,
+    0x30, 0x6a, 0xee, 0x54, 0xf4, 0x7f, 0xd3, 0x39, 0xcd, 0xd2, 0xcb, 0x79, 0x36, 0xac, 0xe4, 0x51
+};
+
+static const td_u8 sm2_mont_1_p[] = {
+    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
+};
+
+static const td_u8 sm2_mont_1_n[] = {
+    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8d, 0xfc, 0x20, 0x94, 0xde, 0x39, 0xfa, 0xd4, 0xac, 0x44, 0x0b, 0xf6, 0xc6, 0x2a, 0xbe, 0xdd
+};
+
+static const td_u8 sm2_rrp[] = {
+    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
+    0x00, 0x00, 0x00, 0x02, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03
+};
+
+static const td_u8 sm2_rrn[] = {
+    0x1e, 0xb5, 0xe4, 0x12, 0xa2, 0x2b, 0x3d, 0x3b, 0x62, 0x0f, 0xc8, 0x4c, 0x3a, 0xff, 0xe0, 0xd4,
+    0x34, 0x64, 0x50, 0x4a, 0xde, 0x6f, 0xa2, 0xfa, 0x90, 0x11, 0x92, 0xaf, 0x7c, 0x11, 0x4f, 0x20
+};
+
+static const td_u8 sm2_p_minus_2[] = {
+    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd
+};
+
+static const td_u8 sm2_n_minus_2[] = {
+    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0x72, 0x03, 0xdf, 0x6b, 0x21, 0xc6, 0x05, 0x2b, 0x53, 0xbb, 0xf4, 0x09, 0x39, 0xd5, 0x41, 0x21
+};
+
+static const td_u32 sm2_mont_param_n[PKE_MONT_PARAM_LEN] = {0x327f9e88, 0x72350975};
+
+static const td_u32 sm2_mont_param_p[PKE_MONT_PARAM_LEN] = {0x0, 0x1};
+
+const pke_ecc_init_param g_sm2_init_param = {
+    .mont_a = sm2_mont_a,
+    .mont_b = sm2_mont_b,
+    .mont_1_p = sm2_mont_1_p,
+    .mont_1_n = sm2_mont_1_n,
+    .rrp = sm2_rrp,
+    .rrn = sm2_rrn,
+    .const_1 = g_const_1 + PKE_LEN_256_OFFSET,
+    .const_0 = g_const_0,
+    .mont_param_n = sm2_mont_param_n,
+    .mont_param_p = sm2_mont_param_p,
+    .n_minus_2 = sm2_n_minus_2,
+    .p_minus_2 = sm2_p_minus_2,
+};
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/ecc_curve_param.c b/bsp/security_subsys/security_subsys_common/common/ecc_curve_param.c
new file mode 100644
index 0000000..1784748
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/ecc_curve_param.c
@@ -0,0 +1,80 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: pke parameter get
+ * Author: @CompanyNameTag
+ * Create: 2023-05-31
+*/
+
+#include "ecc_curve_param.h"
+
+const td_u8 g_const_0[DRV_PKE_LEN_576] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+const td_u8 g_const_1[DRV_PKE_LEN_576] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
+};
+
+static const pke_default_parameters g_crypto_ecc_params[] = {
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP160R
+    {&g_brainpool_160r1_param, &g_brainpool_160r1_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP192R
+    {&g_brainpool_192r1_param, &g_brainpool_192r1_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP224R
+    {&g_brainpool_224r1_param, &g_brainpool_224r1_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP256R
+    {&g_brainpool_256r1_param, &g_brainpool_256r1_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP320R
+    {&g_brainpool_320r1_param, &g_brainpool_320r1_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP384R
+    {&g_brainpool_384r1_param, &g_brainpool_384r1_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP512R
+    {&g_brainpool_512r1_param, &g_brainpool_512r1_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P192R
+    {&g_nist_p192_param, &g_nist_p192_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P224R
+    {&g_nist_p224_param, &g_nist_p224_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P256R
+    {&g_nist_p256_param, &g_nist_p256_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P384R
+    {&g_nist_p384_param, &g_nist_p384_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P521R
+    {&g_nist_p521_param, &g_nist_p521_init_param},
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_CURVE_448
+    {&g_curve_448_param, &g_curve_448_init_param},
+#endif
+#if defined(CONFIG_PKE_SUPPORT_SM2)
+    {&g_sm2_param, &g_sm2_init_param},
+#endif
+};
+static const td_u32 g_crypto_ecc_num = sizeof(g_crypto_ecc_params) / sizeof(g_crypto_ecc_params[0]);
+
+td_void crypto_curve_param_init(td_void)
+{
+    hal_pke_alg_init_ecc_param(g_crypto_ecc_params, g_crypto_ecc_num);
+}
+
+td_void crypto_curve_param_deinit(td_void)
+{
+    hal_pke_alg_init_ecc_param(NULL, 0);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/common/ecc_curve_param.h b/bsp/security_subsys/security_subsys_common/common/ecc_curve_param.h
new file mode 100644
index 0000000..f47cca1
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/common/ecc_curve_param.h
@@ -0,0 +1,88 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides cipher driver pke ecc_curve_param. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-29, Create file. \n
+ */
+
+#ifndef ECC_CURVE_PARAM_H
+#define ECC_CURVE_PARAM_H
+
+#include "crypto_pke_common.h"
+
+#define PKE_MONT_PARAM_LEN 2
+#define PKE_LEN_160_OFFSET 48
+#define PKE_LEN_192_OFFSET 48
+#define PKE_LEN_224_OFFSET 40
+#define PKE_LEN_256_OFFSET 40
+#define PKE_LEN_320_OFFSET 32
+#define PKE_LEN_384_OFFSET 24
+#define PKE_LEN_448_OFFSET 16
+#define PKE_LEN_512_OFFSET 8
+
+extern const td_u8 g_const_0[DRV_PKE_LEN_576];
+extern const td_u8 g_const_1[DRV_PKE_LEN_576];
+
+/* NIST-P192 */
+extern const drv_pke_ecc_curve g_nist_p192_param;
+extern const pke_ecc_init_param g_nist_p192_init_param;
+
+/* NIST-P224 */
+extern const drv_pke_ecc_curve g_nist_p224_param;
+extern const pke_ecc_init_param g_nist_p224_init_param;
+
+/* NIST-P256 */
+extern const drv_pke_ecc_curve g_nist_p256_param;
+extern const pke_ecc_init_param g_nist_p256_init_param;
+
+/* NIST-P384 */
+extern const drv_pke_ecc_curve g_nist_p384_param;
+extern const pke_ecc_init_param g_nist_p384_init_param;
+
+/* NIST-P521 */
+extern const drv_pke_ecc_curve g_nist_p521_param;
+extern const pke_ecc_init_param g_nist_p521_init_param;
+
+/* Brainpool-160R1 */
+extern const drv_pke_ecc_curve g_brainpool_160r1_param;
+extern const pke_ecc_init_param g_brainpool_160r1_init_param;
+
+/* Brainpool-192R1 */
+extern const drv_pke_ecc_curve g_brainpool_192r1_param;
+extern const pke_ecc_init_param g_brainpool_192r1_init_param;
+
+/* Brainpool-224R1 */
+extern const drv_pke_ecc_curve g_brainpool_224r1_param;
+extern const pke_ecc_init_param g_brainpool_224r1_init_param;
+
+/* Brainpool-256R1 */
+extern const drv_pke_ecc_curve g_brainpool_256r1_param;
+extern const pke_ecc_init_param g_brainpool_256r1_init_param;
+
+/* Brainpool-320R1 */
+extern const drv_pke_ecc_curve g_brainpool_320r1_param;
+extern const pke_ecc_init_param g_brainpool_320r1_init_param;
+
+/* Brainpool-384R1 */
+extern const drv_pke_ecc_curve g_brainpool_384r1_param;
+extern const pke_ecc_init_param g_brainpool_384r1_init_param;
+
+/* Brainpool-512R1 */
+extern const drv_pke_ecc_curve g_brainpool_512r1_param;
+extern const pke_ecc_init_param g_brainpool_512r1_init_param;
+
+/* SM2 */
+extern const drv_pke_ecc_curve g_sm2_param;
+extern const pke_ecc_init_param g_sm2_init_param;
+
+/* ED25519 */
+
+/* Curve448 */
+extern const drv_pke_ecc_curve g_curve_448_param;
+extern const pke_ecc_init_param g_curve_448_init_param;
+
+/* Curve25519 */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/dispatch_code/crypto_dispatch.c b/bsp/security_subsys/security_subsys_common/dispatch_code/crypto_dispatch.c
new file mode 100644
index 0000000..1454044
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/dispatch_code/crypto_dispatch.c
@@ -0,0 +1,2383 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "crypto_dispatch.h"
+#include "crypto_ioctl_cmd.h"
+#include "crypto_drv_common.h"
+#include "kapi_hash.h"
+#include "kapi_trng.h"
+#include "kapi_symc.h"
+#include "kapi_pke.h"
+#include "kapi_pke_cal.h"
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+#include "kapi_symc_impl.h"
+#endif
+#if defined(CONFIG_HASH_HARDEN_INTERFACE_SUPPORT)
+#include "kapi_hash_impl.h"
+#endif
+
+#define SYMC_COMPAT_ERRNO(err_code)     DISPATCH_COMPAT_ERRNO(ERROR_MODULE_SYMC, err_code)
+#define HASH_COMPAT_ERRNO(err_code)     DISPATCH_COMPAT_ERRNO(ERROR_MODULE_HASH, err_code)
+#define PKE_COMPAT_ERRNO(err_code)      DISPATCH_COMPAT_ERRNO(ERROR_MODULE_PKE, err_code)
+#define TRNG_COMPAT_ERRNO(err_code)     DISPATCH_COMPAT_ERRNO(ERROR_MODULE_TRNG, err_code)
+
+#if defined(CONFIG_CRYPTO_DISPATCH_CMD_CHK_ENABLE)
+#define dispatch_symc_cmd_chk(expected_cmd)   \
+    crypto_chk_return(cmd != (expected_cmd), SYMC_COMPAT_ERRNO(ERROR_CMD_DISMATCH), \
+        "cmd is dismatched, real cmd is 0x%x, expected_cmd is 0x%x\n", cmd, (td_u32)(expected_cmd))
+#define dispatch_hash_cmd_chk(expected_cmd)   \
+    crypto_chk_return(cmd != (expected_cmd), HASH_COMPAT_ERRNO(ERROR_CMD_DISMATCH), \
+        "cmd is dismatched, real cmd is 0x%x, expected_cmd is 0x%x\n", cmd, (td_u32)(expected_cmd))
+#define dispatch_pke_cmd_chk(expected_cmd)   \
+    crypto_chk_return(cmd != (expected_cmd), PKE_COMPAT_ERRNO(ERROR_CMD_DISMATCH),  \
+        "cmd is dismatched, real cmd is 0x%x, expected_cmd is 0x%x\n", cmd, (td_u32)(expected_cmd))
+#define dispatch_trng_cmd_chk(expected_cmd)   \
+    crypto_chk_return(cmd != (expected_cmd), TRNG_COMPAT_ERRNO(ERROR_CMD_DISMATCH), \
+        "cmd is dismatched, real cmd is 0x%x, expected_cmd is 0x%x\n", cmd, (td_u32)(expected_cmd))
+#else
+#define dispatch_symc_cmd_chk(expected_cmd)     crypto_unused(cmd)
+#define dispatch_hash_cmd_chk(expected_cmd)     crypto_unused(cmd)
+#define dispatch_pke_cmd_chk(expected_cmd)      crypto_unused(cmd)
+#define dispatch_trng_cmd_chk(expected_cmd)     crypto_unused(cmd)
+#endif
+
+#define CRYPTO_MAX_DATA_LEN                 (64 * 1024)
+
+/* Notice: For Sensitive Information, You Should Clean it Before Free. */
+#define crypto_chk_free_with_clean(ptr, length, free_func) do {                \
+    if ((ptr) != NULL) {                                      \
+        (td_void)memset_s(ptr, length, 0, length);          \
+        free_func(ptr);                                     \
+        ptr = NULL;                                         \
+    }                                                       \
+} while (0)
+
+#define crypto_chk_crypto_free_with_clean(ptr, length)  crypto_chk_free_with_clean(ptr, length, crypto_free)
+
+static td_s32 dispatch_hash_init(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    crypto_unused(argp);
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_INIT);
+    return kapi_cipher_hash_init();
+}
+
+static td_s32 dispatch_hash_deinit(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    crypto_unused(argp);
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_DEINIT);
+    return kapi_cipher_hash_deinit();
+}
+
+static td_s32 dispatch_hash_start(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_start_ctl_t *start_ctl = (hash_start_ctl_t *)argp;
+    crypto_hash_attr hash_attr = {
+        .hash_type = start_ctl->hash_type,
+        .is_long_term = start_ctl->is_long_term,
+        .is_keyslot = start_ctl->is_keyslot,
+        .key_len = start_ctl->key_len,
+        .drv_keyslot_handle = start_ctl->drv_keyslot_handle,
+    };
+    td_u8 *hmac_key = TD_NULL;
+
+    crypto_dispatch_func_enter();
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_START);
+    crypto_unused(private_data);
+
+    if ((hash_attr.is_keyslot == TD_FALSE) && (crypto_hash_is_hmac(hash_attr.hash_type) == TD_TRUE) &&
+        (hash_attr.key_len != 0)) {
+        hash_null_ptr_chk(start_ctl->key.p);
+        crypto_chk_return(hash_attr.key_len > CRYPTO_HASH_KEY_MAX_LENGTH, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "key length is too long\n");
+        hmac_key = crypto_malloc(hash_attr.key_len);
+        crypto_chk_return(hmac_key == TD_NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+        ret = crypto_copy_from_user(hmac_key, hash_attr.key_len, start_ctl->key.p, start_ctl->key_len);
+        crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_clean, HASH_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed\n");
+    }
+    hash_attr.key = hmac_key;
+
+    ret = kapi_cipher_hash_start(&start_ctl->kapi_hash_handle, &hash_attr);
+    if (ret != CRYPTO_SUCCESS) {
+        crypto_log_err("kapi_cipher_hash_start failed\n");
+        goto exit_clean;
+    }
+
+exit_clean:
+    if (hmac_key != TD_NULL) {
+        (td_void)memset_s(hmac_key, start_ctl->key_len, 0, start_ctl->key_len);
+        crypto_free(hmac_key);
+    }
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_hash_update(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    crypto_buf_attr src_buf = {0};
+    hash_update_ctl_t *update_ctl = (hash_update_ctl_t *)argp;
+    td_u8 *data_buffer = TD_NULL;
+    td_u32 left = update_ctl->len;
+    td_u32 malloc_size = 0;
+    td_u32 processing_len = 0;
+    td_u32 processed_len = 0;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_UPDATE);
+    hash_null_ptr_chk(update_ctl->src_buf.p);
+
+    crypto_chk_return(update_ctl->len == 0 || update_ctl->len > CRYPTO_HASH_UPDATE_MAX_LEN,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "len is invalid\n");
+
+    malloc_size = crypto_min(CRYPTO_MAX_DATA_LEN, left);
+    data_buffer = crypto_malloc_coherent(malloc_size, "dispatch_hash_buf");
+    crypto_chk_return(data_buffer == TD_NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+    src_buf.virt_addr = data_buffer;
+
+    while (left > 0) {
+        processing_len = crypto_min(CRYPTO_MAX_DATA_LEN, left);
+        ret = crypto_copy_from_user(data_buffer, malloc_size, (td_u8 *)update_ctl->src_buf.p + processed_len,
+            processing_len);
+        crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_clean, HASH_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed\n");
+
+        ret = kapi_cipher_hash_update(update_ctl->kapi_hash_handle, &src_buf, processing_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_clean, "kapi_cipher_hash_update failed\n");
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+
+exit_clean:
+    (td_void)memset_s(data_buffer, malloc_size, 0, malloc_size);
+    crypto_free_coherent(data_buffer);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_hash_finish(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_finish_ctl_t *finish_ctl = (hash_finish_ctl_t *)argp;
+    td_u8 out_hash[CRYPTO_HASH_MAX_LEN] = {0};
+    td_u32 out_len = CRYPTO_HASH_MAX_LEN;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_FINISH);
+    hash_null_ptr_chk(finish_ctl->out.p);
+
+    ret = kapi_cipher_hash_finish(finish_ctl->kapi_hash_handle, out_hash, &out_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "kapi_cipher_hash_finish failed\n");
+
+    ret = crypto_copy_to_user(finish_ctl->out.p, finish_ctl->out_len, out_hash, out_len);
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_clean, HASH_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed\n");
+    finish_ctl->out_len = out_len;
+
+exit_clean:
+    (td_void)memset_s(out_hash, sizeof(out_hash), 0, sizeof(out_hash));
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_HASH_CLONE_SUPPORT)
+static td_s32 dispatch_hash_get(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_clone_ctl_t *clone_ctl = (hash_clone_ctl_t *)argp;
+    crypto_hash_clone_ctx *clone_ctx = TD_NULL;
+
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_GET);
+    hash_null_ptr_chk(clone_ctl->hash_clone_ctx.p);
+    crypto_chk_return(clone_ctl->ctx_size != sizeof(crypto_hash_clone_ctx), HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "clone_ctx's size is invalid\n");
+    clone_ctx = (crypto_hash_clone_ctx *)crypto_malloc(sizeof(crypto_hash_clone_ctx));
+    crypto_chk_return(clone_ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    ret = kapi_cipher_hash_get(clone_ctl->kapi_hash_handle, clone_ctx);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_clean, "kapi_cipher_hash_get failed\n");
+
+    ret = crypto_copy_to_user(clone_ctl->hash_clone_ctx.p, clone_ctl->ctx_size,
+        clone_ctx, sizeof(crypto_hash_clone_ctx));
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_clean, HASH_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed\n");
+
+exit_clean:
+    (td_void)memset_s(clone_ctx, sizeof(crypto_hash_clone_ctx), 0, sizeof(crypto_hash_clone_ctx));
+    crypto_free(clone_ctx);
+
+    return ret;
+}
+
+static td_s32 dispatch_hash_set(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_clone_ctl_t *clone_ctl = (hash_clone_ctl_t *)argp;
+    crypto_hash_clone_ctx *clone_ctx = TD_NULL;
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_SET);
+
+    hash_null_ptr_chk(clone_ctl->hash_clone_ctx.p);
+    crypto_chk_return(clone_ctl->ctx_size != sizeof(crypto_hash_clone_ctx), HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "clone_ctx's size is invalid\n");
+
+    clone_ctx = (crypto_hash_clone_ctx *)crypto_malloc(sizeof(crypto_hash_clone_ctx));
+    crypto_chk_return(clone_ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    ret = crypto_copy_from_user(clone_ctx, sizeof(crypto_hash_clone_ctx),
+        clone_ctl->hash_clone_ctx.p, clone_ctl->ctx_size);
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_clean, HASH_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed\n");
+
+    ret = kapi_cipher_hash_set(clone_ctl->kapi_hash_handle, clone_ctx);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_clean, "kapi_cipher_hash_set failed\n");
+
+exit_clean:
+    (td_void)memset_s(clone_ctx, sizeof(crypto_hash_clone_ctx), 0, sizeof(crypto_hash_clone_ctx));
+    crypto_free(clone_ctx);
+    return ret;
+}
+#endif
+
+static td_s32 dispatch_hash_destroy(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_handle_ctl_t *handle_ctl = (hash_handle_ctl_t *)argp;
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_DESTROY);
+
+    ret = kapi_cipher_hash_destroy(handle_ctl->kapi_hash_handle);
+    if (ret != CRYPTO_SUCCESS) {
+        crypto_log_err("kapi_cipher_hash_destroy failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    return ret;
+}
+
+#if defined(CONFIG_HASH_HARDEN_INTERFACE_SUPPORT)
+static td_s32 dispatch_hash_start_impl(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    crypto_hash_type hash_type;
+    hash_start_impl_ctl_t *start_ctl = (hash_start_impl_ctl_t *)argp;
+
+    crypto_dispatch_func_enter();
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_START_IMPL);
+    crypto_unused(private_data);
+
+    hash_type = start_ctl->hash_type;
+
+    ret = kapi_hash_start_impl(&start_ctl->ctx, hash_type);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_hash_start_impl failed\n");
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_hash_update_impl(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_update_impl_ctl_t *update_ctl = (hash_update_impl_ctl_t *)argp;
+    td_u8 *data_buffer = TD_NULL;
+    td_u32 left = update_ctl->data_len;
+    td_u32 malloc_size = 0;
+    td_u32 processing_len = 0;
+    td_u32 processed_len = 0;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_UPDATE_IMPL);
+    hash_null_ptr_chk(update_ctl->data.p);
+
+    crypto_chk_return(left == 0 || left > CRYPTO_HASH_UPDATE_MAX_LEN,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "len is invalid\n");
+
+    malloc_size = crypto_min(CRYPTO_MAX_DATA_LEN, left);
+    data_buffer = crypto_malloc_coherent(malloc_size, "dispatch_hash_buf");
+    crypto_chk_return(data_buffer == TD_NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    while (left > 0) {
+        processing_len = crypto_min(CRYPTO_MAX_DATA_LEN, left);
+        ret = crypto_copy_from_user(data_buffer, malloc_size, (td_u8 *)update_ctl->data.p + processed_len,
+            processing_len);
+        crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_clean, HASH_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed\n");
+
+        ret = kapi_hash_update_impl(&update_ctl->ctx, data_buffer, processing_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_clean, "kapi_hash_update_impl failed\n");
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+
+exit_clean:
+    (td_void)memset_s(data_buffer, malloc_size, 0, malloc_size);
+    crypto_free_coherent(data_buffer);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_hash_finish_impl(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_finish_impl_ctl_t *finish_ctl = (hash_finish_impl_ctl_t *)argp;
+    td_u8 out_hash[CRYPTO_HASH_MAX_LEN] = {0};
+    td_u32 out_len = CRYPTO_HASH_MAX_LEN;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_HASH_FINISH_IMPL);
+    hash_null_ptr_chk(finish_ctl->out.p);
+
+    ret = kapi_hash_finish_impl(&finish_ctl->ctx, out_hash, &out_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "kapi_hash_finish_impl failed\n");
+
+    ret = crypto_copy_to_user(finish_ctl->out.p, finish_ctl->out_len, out_hash, out_len);
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_clean, HASH_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed\n");
+    finish_ctl->out_len = out_len;
+
+exit_clean:
+    (td_void)memset_s(out_hash, sizeof(out_hash), 0, sizeof(out_hash));
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_HASH_PBKDF2_SUPPORT)
+static td_s32 dispatch_cipher_pbkdf2(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    pbkdf2_ctl_t *pbkdf2_ctl = (pbkdf2_ctl_t *)argp;
+    td_u8 *password = TD_NULL;
+    td_u8 *salt = TD_NULL;
+    td_u8 *out = TD_NULL;
+    td_u8 *buffer = TD_NULL;
+    crypto_kdf_pbkdf2_param param = {0};
+    td_u32 total_len = 0;
+    crypto_unused(private_data);
+    dispatch_hash_cmd_chk(CRYPTO_CMD_PBKDF2);
+
+    hash_null_ptr_chk(pbkdf2_ctl->out.p);
+    crypto_chk_return(pbkdf2_ctl->out_len == 0 || pbkdf2_ctl->out_len > CRYPTO_PBKDF2_OUT_MAX_LENGTH,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "out_len is Invalid\n");
+    crypto_chk_return(pbkdf2_ctl->plen > CRYPTO_PBKDF2_PASS_MAX_LENGTH, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "plen is too long!\n");
+    crypto_chk_return(pbkdf2_ctl->slen > CRYPTO_PBKDF2_SALT_MAX_LENGTH, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "slen is too long!\n");
+
+    total_len = pbkdf2_ctl->plen + pbkdf2_ctl->slen + pbkdf2_ctl->out_len;
+    buffer = crypto_malloc(total_len);
+    crypto_chk_return(buffer == TD_NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    password = buffer;
+    if (pbkdf2_ctl->plen != 0) {
+        crypto_chk_goto_with_ret(ret, pbkdf2_ctl->password.p == TD_NULL, exit_free,
+            HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "pbkdf2_ctl->password.p is NULL\n");
+        ret = crypto_copy_from_user(password, total_len, pbkdf2_ctl->password.p, pbkdf2_ctl->plen);
+        crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_free, HASH_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed\n");
+    }
+
+    salt = password + pbkdf2_ctl->plen;
+    if (pbkdf2_ctl->slen != 0) {
+        crypto_chk_goto_with_ret(ret, pbkdf2_ctl->salt.p == TD_NULL, exit_free, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL),
+            "pbkdf2_ctl->salt.p is NULL\n");
+        ret = crypto_copy_from_user(salt, total_len - pbkdf2_ctl->plen, pbkdf2_ctl->salt.p, pbkdf2_ctl->slen);
+        crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_free, HASH_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed\n");
+    }
+
+    out = salt + pbkdf2_ctl->slen;
+    param.hash_type = pbkdf2_ctl->hash_type;
+    param.password = (pbkdf2_ctl->plen == 0) ? TD_NULL : password;
+    param.plen = pbkdf2_ctl->plen;
+    param.salt = (pbkdf2_ctl->slen == 0) ? TD_NULL : salt;
+    param.slen = pbkdf2_ctl->slen;
+    param.count = pbkdf2_ctl->count;
+
+    ret = kapi_cipher_pbkdf2(&param, out, pbkdf2_ctl->out_len);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "kapi_cipher_pbkdf2 failed\n");
+
+    ret = crypto_copy_to_user(pbkdf2_ctl->out.p, pbkdf2_ctl->out_len, out, pbkdf2_ctl->out_len);
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_free, HASH_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed\n");
+
+exit_free:
+    (td_void)memset_s(buffer, total_len, 0, total_len);
+    crypto_free(buffer);
+    return ret;
+}
+#endif
+
+static td_s32 dispatch_trng_get_random(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    trng_ctl_t *trng_ctl = (trng_ctl_t *)argp;
+    crypto_unused(private_data);
+    dispatch_trng_cmd_chk(CRYPTO_CMD_TRNG_GET_RANDOM);
+    ret = kapi_cipher_trng_get_random(&trng_ctl->randnum);
+    if (ret != CRYPTO_SUCCESS) {
+        crypto_log_err("kapi_cipher_trng_get_random failed\n");
+        return ret;
+    }
+    return ret;
+}
+
+static td_s32 dispatch_trng_get_multi_random(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    trng_multi_ctl_t *trng_multi_ctl = (trng_multi_ctl_t *)argp;
+    td_u32 size = 0;
+    td_u8 *randnum;
+    crypto_unused(private_data);
+    dispatch_trng_cmd_chk(CRYPTO_CMD_TRNG_GET_MULTI_RANDOM);
+
+    trng_null_ptr_chk(trng_multi_ctl->randnum.p);
+    size = trng_multi_ctl->size;
+    crypto_chk_return(size == 0 || size > CRYPTO_MULTI_RANDOM_MAX_LENGTH, TRNG_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "size is invalid!\n");
+    randnum = crypto_malloc(size);
+    crypto_chk_return(randnum == TD_NULL, TRNG_COMPAT_ERRNO(ERROR_INVALID_PARAM), "crypto_malloc failed\n");
+    ret = kapi_cipher_trng_get_multi_random(size, randnum);
+    if (ret != CRYPTO_SUCCESS) {
+        crypto_log_err("kapi_cipher_trng_get_multi_random failed\n");
+        goto exit_free;
+    }
+    ret = crypto_copy_to_user(trng_multi_ctl->randnum.p, size, randnum, size);
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_free, TRNG_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed\n");
+exit_free:
+    if (randnum != TD_NULL) {
+        (void)memset_s(randnum, size, 0, size);
+        crypto_free(randnum);
+    }
+    return ret;
+}
+
+static td_s32 dispatch_symc_init(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    crypto_unused(argp);
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_INIT);
+    return kapi_cipher_symc_init();
+}
+
+static td_s32 dispatch_symc_deinit(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    crypto_unused(argp);
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_DEINIT);
+    return kapi_cipher_symc_deinit();
+}
+
+static td_s32 dispatch_symc_create(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_create_t *symc_create = (symc_create_t *)argp;
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_CREATE);
+
+    ret = kapi_cipher_symc_create(&symc_create->symc_handle, &symc_create->symc_attr);
+    if (ret != CRYPTO_SUCCESS) {
+        crypto_log_err("kapi_cipher_symc_create failed\n");
+        return ret;
+    }
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_symc_destroy(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_destroy_t *symc_destroy = (symc_destroy_t *)argp;
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_DESTROY);
+
+    ret = kapi_cipher_symc_destroy(symc_destroy->symc_handle);
+    if (ret != CRYPTO_SUCCESS) {
+        crypto_log_err("kapi_cipher_symc_destroy failed\n");
+        return ret;
+    }
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_symc_set_config(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_config_t *symc_config = (symc_config_t *)argp;
+    crypto_symc_ctrl_t symc_ctrl = {0};
+    crypto_symc_config_aes_ccm_gcm ccm_gcm_config;
+    td_u8 *aad_buf = TD_NULL;
+    td_u32 aad_len = symc_config->aad_len;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_SET_CONFIG);
+
+    (td_void)memset_s(&ccm_gcm_config, sizeof(ccm_gcm_config), 0, sizeof(ccm_gcm_config));
+    symc_ctrl.symc_alg = symc_config->symc_alg;
+    symc_ctrl.work_mode = symc_config->work_mode;
+    symc_ctrl.symc_bit_width = symc_config->symc_bit_width;
+    symc_ctrl.symc_key_length = symc_config->symc_key_length;
+    symc_ctrl.iv_change_flag = symc_config->iv_change_flag;
+    symc_ctrl.iv_length = symc_config->iv_length;
+    ret = memcpy_s(symc_ctrl.iv, sizeof(symc_ctrl.iv), symc_config->iv, sizeof(symc_config->iv));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    if (symc_config->work_mode == CRYPTO_SYMC_WORK_MODE_GCM || symc_config->work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        crypto_chk_return(aad_len > CRYPTO_SYMC_AAD_MAX_SIZE, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "aad_len is too long\n");
+        ccm_gcm_config.total_aad_len = symc_config->total_aad_len;
+        ccm_gcm_config.aad_len = aad_len;
+        ccm_gcm_config.data_len = symc_config->data_len;
+        ccm_gcm_config.tag_len = symc_config->tag_len;
+        ccm_gcm_config.aad_buf.phys_addr = symc_config->aad_phys_addr;
+        if (aad_len != 0) {
+            symc_null_ptr_chk(symc_config->aad.p);
+            crypto_chk_return(crypto_data_buf_check(&ccm_gcm_config.aad_buf, ccm_gcm_config.aad_len) == TD_FALSE,
+                SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS), "ccm_gcm_config.aad_buf access refused\n");
+            aad_buf = crypto_malloc(aad_len);
+            crypto_chk_return(aad_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+            ret = crypto_copy_from_user(aad_buf, aad_len, symc_config->aad.p, aad_len);
+            crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit_free, SYMC_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+                "crypto_copy_from_user failed\n");
+            ccm_gcm_config.aad_buf.virt_addr = aad_buf;
+        }
+        symc_ctrl.param = (td_void *)&ccm_gcm_config;
+    }
+
+    ret = kapi_cipher_symc_set_config(symc_config->symc_handle, &symc_ctrl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "kapi_cipher_symc_set_config failed\n");
+
+exit_free:
+    if (aad_buf != TD_NULL) {
+        (td_void)memset_s(aad_buf, aad_len, 0, aad_len);
+        crypto_free(aad_buf);
+    }
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_SYMC_GET_CONFIG_SUPPORT)
+static td_s32 dispatch_symc_get_config(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_config_t *symc_config = (symc_config_t *)argp;
+    crypto_symc_ctrl_t symc_ctrl = {0};
+    crypto_symc_config_aes_ccm_gcm ccm_gcm_config;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_GET_CONFIG);
+
+    (td_void)memset_s(&ccm_gcm_config, sizeof(ccm_gcm_config), 0, sizeof(ccm_gcm_config));
+    symc_ctrl.param = (td_void *)&ccm_gcm_config;
+
+    ret = kapi_cipher_symc_get_config(symc_config->symc_handle, &symc_ctrl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_cipher_symc_get_config failed\n");
+
+    symc_config->symc_alg = symc_ctrl.symc_alg;
+    symc_config->work_mode = symc_ctrl.work_mode;
+    symc_config->symc_bit_width = symc_ctrl.symc_bit_width;
+    symc_config->symc_key_length = symc_ctrl.symc_key_length;
+    symc_config->iv_change_flag = symc_ctrl.iv_change_flag;
+    symc_config->iv_length = symc_ctrl.iv_length;
+    ret = memcpy_s(symc_config->iv, sizeof(symc_config->iv), symc_ctrl.iv, sizeof(symc_ctrl.iv));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    if (symc_config->work_mode == CRYPTO_SYMC_WORK_MODE_GCM || symc_config->work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        symc_config->aad_len = ccm_gcm_config.aad_len;
+        symc_config->data_len = ccm_gcm_config.data_len;
+        symc_config->tag_len = ccm_gcm_config.tag_len;
+    }
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+static td_s32 dispatch_symc_attach(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_attach_t *symc_attch = (symc_attach_t *)argp;
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_ATTACH);
+
+    ret = kapi_cipher_symc_attach(symc_attch->symc_handle, symc_attch->keyslot_handle);
+    if (ret != CRYPTO_SUCCESS) {
+        crypto_log_err("kapi_cipher_symc_attach failed\n");
+        return ret;
+    }
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_symc_crypto(td_u32 cmd, td_void *argp, td_void *private_data, td_u32 crypto_type)
+{
+    td_s32 ret;
+    symc_crypto_t *symc_crypto = (symc_crypto_t *)argp;
+    crypto_buf_attr src_buf = {0};
+    crypto_buf_attr dst_buf = {0};
+    td_u32 length = symc_crypto->length;
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    ret = crypto_osal_mem_handle_get(symc_crypto->src_mem_handle, &src_buf);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, mem_handle_put_exit,
+        SYMC_COMPAT_ERRNO(ERROR_MEM_HANDLE_GET), "crypto_osal_mem_handle_get failed\n");
+    src_buf.phys_addr = symc_crypto->src_phys_addr;
+    src_buf.buf_sec = symc_crypto->src_buf_sec;
+    src_buf.addr_offset = symc_crypto->src_addr_offset;
+    ret = crypto_osal_mem_handle_get(symc_crypto->dst_mem_handle, &dst_buf);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, mem_handle_put_exit,
+        SYMC_COMPAT_ERRNO(ERROR_MEM_HANDLE_GET), "crypto_osal_mem_handle_get failed\n");
+    dst_buf.phys_addr = symc_crypto->dst_phys_addr;
+    dst_buf.buf_sec = symc_crypto->dst_buf_sec;
+    dst_buf.addr_offset = symc_crypto->dst_addr_offset;
+
+    switch (crypto_type) {
+        case CRYPTO_TYPE_ENCRYPT:
+            ret = kapi_cipher_symc_encrypt(symc_crypto->symc_handle, &src_buf, &dst_buf, length);
+            break;
+        case CRYPTO_TYPE_DECRYPT:
+            ret = kapi_cipher_symc_decrypt(symc_crypto->symc_handle, &src_buf, &dst_buf, length);
+            break;
+        default:
+            crypto_log_err("Invalid Crypto Type!\n");
+            ret = SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+mem_handle_put_exit:
+    crypto_osal_mem_handle_put(&src_buf);
+    crypto_osal_mem_handle_put(&dst_buf);
+    return ret;
+}
+
+static td_s32 dispatch_symc_encrypt(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    crypto_dispatch_func_enter();
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_ENCRYPT);
+    ret = dispatch_symc_crypto(cmd, argp, private_data, CRYPTO_TYPE_ENCRYPT);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_symc_decrypt(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    crypto_dispatch_func_enter();
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_DECRYPT);
+    ret = dispatch_symc_crypto(cmd, argp, private_data, CRYPTO_TYPE_DECRYPT);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+static td_s32 dispatch_symc_crypt_impl(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_crypto_impl_t *symc_crypto = (symc_crypto_impl_t *)argp;
+    td_handle keyslot_handle = symc_crypto->keyslot_handle;
+    crypto_symc_ctrl_t *symc_ctrl = &symc_crypto->symc_ctrl;
+    crypto_buf_attr src_buf = {0};
+    crypto_buf_attr dst_buf = {0};
+    td_u32 length = symc_crypto->crypto_info.length;
+    td_bool is_decrypt = symc_crypto->is_decrypt;
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+    crypto_dispatch_func_enter();
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_CRYPT_IMPL);
+
+    src_buf.phys_addr = symc_crypto->crypto_info.src_phys_addr;
+    src_buf.buf_sec = symc_crypto->crypto_info.src_buf_sec;
+    dst_buf.phys_addr = symc_crypto->crypto_info.dst_phys_addr;
+    dst_buf.buf_sec = symc_crypto->crypto_info.dst_buf_sec;
+
+    ret = kapi_cipher_symc_crypt_impl(symc_ctrl, &src_buf, &dst_buf, length, keyslot_handle, is_decrypt);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_cipher_symc_crypt_impl failed\n");
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_SYMC_CENC_DECRYPT_SUPPORT)
+static td_s32 dispatch_symc_cenc_decrypt(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    crypto_symc_cenc_t *symc_cenc = (crypto_symc_cenc_t *)argp;
+    crypto_symc_cenc_param cenc_param;
+    crypto_buf_attr src_buf = {0};
+    crypto_buf_attr dst_buf = {0};
+    td_u32 subsample_num = symc_cenc->subsample_num;
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_CENC_DECRYPT);
+    symc_null_ptr_chk(symc_cenc->subsample_addr.p);
+    crypto_chk_return(subsample_num > CRYPTO_SYMC_CENC_SUBSAMPLE_MAX_SIZE, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "subsample_num is too large\n");
+
+    (td_void)memset_s(&cenc_param, sizeof(cenc_param), 0, sizeof(cenc_param));
+
+    cenc_param.subsample_num = subsample_num;
+    cenc_param.alg = symc_cenc->alg;
+    cenc_param.work_mode = symc_cenc->work_mode;
+    cenc_param.first_encrypt_offset = symc_cenc->first_encrypt_offset;
+    cenc_param.use_odd_key = symc_cenc->use_odd_key;
+    ret = memcpy_s(cenc_param.iv, sizeof(cenc_param.iv), symc_cenc->iv, sizeof(symc_cenc->iv));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    cenc_param.subsample = crypto_malloc(subsample_num * sizeof(crypto_symc_cenc_subsample));
+    crypto_chk_return(cenc_param.subsample == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    ret = crypto_copy_from_user(cenc_param.subsample, subsample_num * sizeof(crypto_symc_cenc_subsample),
+        symc_cenc->subsample_addr.p, subsample_num * sizeof(crypto_symc_cenc_subsample));
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit_free, SYMC_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed\n");
+
+    ret = crypto_osal_mem_handle_get(symc_cenc->src_mem_handle, &src_buf);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit_mem_handle_put,
+        SYMC_COMPAT_ERRNO(ERROR_MEM_HANDLE_GET), "crypto_osal_mem_handle_get failed\n");
+    src_buf.buf_sec = symc_cenc->src_buf_sec;
+    ret = crypto_osal_mem_handle_get(symc_cenc->dst_mem_handle, &dst_buf);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit_mem_handle_put,
+        SYMC_COMPAT_ERRNO(ERROR_MEM_HANDLE_GET), "crypto_osal_mem_handle_get failed\n");
+    dst_buf.buf_sec = symc_cenc->dst_buf_sec;
+
+    ret = kapi_cipher_symc_cenc_decrypt(symc_cenc->symc_handle, &cenc_param, &src_buf, &dst_buf, symc_cenc->length);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_mem_handle_put, "dispatch_symc_crypto_multi for Decrypt failed\n");
+
+exit_mem_handle_put:
+    crypto_osal_mem_handle_put(&src_buf);
+    crypto_osal_mem_handle_put(&dst_buf);
+exit_free:
+    (td_void)memset_s(cenc_param.subsample, subsample_num * sizeof(crypto_symc_cenc_subsample), 0,
+        subsample_num * sizeof(crypto_symc_cenc_subsample));
+    crypto_free(cenc_param.subsample);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_SYMC_CCM_SUPPORT) || defined(CONFIG_SYMC_GCM_SUPPORT)
+static td_s32 dispatch_symc_get_tag(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_get_tag_t *symc_get_tag = (symc_get_tag_t *)argp;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_GET_TAG);
+
+    ret = kapi_cipher_symc_get_tag(symc_get_tag->symc_handle, symc_get_tag->tag, symc_get_tag->tag_length);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_cipher_symc_get_tag failed\n");
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_SYMC_CMAC_SUPPORT) || defined(CONFIG_SYMC_CBC_MAC_SUPPORT)
+static td_s32 dispatch_symc_mac_start(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_mac_start_t *mac_start = (symc_mac_start_t *)argp;
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_MAC_START);
+
+    ret = kapi_cipher_mac_start(&mac_start->symc_handle, &mac_start->mac_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_cipher_mac_start failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_symc_mac_update(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_mac_update_t *mac_update = (symc_mac_update_t *)argp;
+    td_u8 *data_buffer = TD_NULL;
+    td_u32 left = mac_update->length;
+    td_u32 malloc_size = 0;
+    td_u32 processing_len = 0;
+    td_u32 processed_len = 0;
+    crypto_buf_attr src_buf = {0};
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_MAC_UPDATE);
+    symc_null_ptr_chk(mac_update->src_buf.p);
+    crypto_chk_return(mac_update->length == 0 || mac_update->length > CRYPTO_SYMC_MAC_UPDATE_MAX_LEN,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "length is Invalid\n");
+
+    malloc_size = crypto_min(CRYPTO_MAX_DATA_LEN, left);
+    data_buffer = crypto_malloc(malloc_size);
+    src_buf.virt_addr = data_buffer;
+    crypto_chk_return(data_buffer == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    while (left > 0) {
+        processing_len = crypto_min(CRYPTO_MAX_DATA_LEN, left);
+        ret = crypto_copy_from_user(data_buffer, malloc_size, (td_u8 *)mac_update->src_buf.p + processed_len,
+            processing_len);
+        crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit_free, SYMC_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+        ret = kapi_cipher_mac_update(mac_update->symc_handle, &src_buf, processing_len);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free, "kapi_cipher_mac_update failed, ret is 0x%x\n", ret);
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+
+exit_free:
+    (td_void)memset_s(data_buffer, malloc_size, 0, malloc_size);
+    crypto_free(data_buffer);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_symc_mac_finish(td_u32 cmd, td_void *argp, td_void *private_data)
+{
+    td_s32 ret;
+    symc_mac_finish_t *mac_finish = (symc_mac_finish_t *)argp;
+    crypto_dispatch_func_enter();
+    crypto_unused(private_data);
+    dispatch_symc_cmd_chk(CRYPTO_CMD_SYMC_MAC_FINISH);
+    mac_finish->mac_length = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    ret = kapi_cipher_mac_finish(mac_finish->symc_handle, mac_finish->mac, &mac_finish->mac_length);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_cipher_mac_finish failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_GEN_KEY_SUPPORT)
+static td_s32 dispatch_pke_ecc_gen_key(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_ecc_gen_key_ctl_t *gen_key_ctl = (pke_ecc_gen_key_ctl_t *)argp;
+    drv_pke_ecc_curve_type curve_type = 0;
+    drv_pke_data input_priv_key = { 0 };
+    drv_pke_data output_priv_key = { 0 };
+    drv_pke_ecc_point output_pub_key = { 0 };
+    td_u32 klen = 0;
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_ECC_GEN_KEY);
+
+    crypto_unused(private_data);
+    pke_null_ptr_chk(gen_key_ctl->output_priv_key.data.p);
+
+    if (gen_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC8032) {
+        pke_null_ptr_chk(gen_key_ctl->output_pub_key.x.p);
+    }
+    if (gen_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        pke_null_ptr_chk(gen_key_ctl->output_pub_key.y.p);
+    }
+    curve_type = gen_key_ctl->curve_type;
+    klen = gen_key_ctl->output_priv_key.length;
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+
+    crypto_chk_return(gen_key_ctl->output_pub_key.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "gen_key_ctl->output_pub_key.length is invalid\n");
+
+    /* alloc memory. */
+    if (gen_key_ctl->input_priv_key.length != 0) {
+        pke_null_ptr_chk(gen_key_ctl->input_priv_key.data.p);
+        crypto_chk_return(gen_key_ctl->input_priv_key.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "gen_key_ctl->input_priv_key.length is invalid\n");
+        /* input_priv_key. */
+        input_priv_key.data = crypto_malloc(klen);
+        crypto_chk_goto_with_ret(ret, input_priv_key.data == TD_NULL, free_exit,
+            PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+        input_priv_key.length = klen;
+
+        ret = crypto_copy_from_user(input_priv_key.data, klen, gen_key_ctl->input_priv_key.data.p, klen);
+        crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit,
+            PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER), "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+    }
+
+    /* output_priv_key. */
+    output_priv_key.data = crypto_malloc(klen);
+    crypto_chk_goto_with_ret(ret, output_priv_key.data == TD_NULL, free_exit,
+        PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    output_priv_key.length = klen;
+
+    /* output_pub_key.  */
+    if (gen_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC8032) {
+        output_pub_key.x = crypto_malloc(klen);
+        crypto_chk_goto_with_ret(ret, output_pub_key.x == TD_NULL, free_exit,
+            PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    }
+    if (gen_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        output_pub_key.y = crypto_malloc(klen);
+        crypto_chk_goto_with_ret(ret, output_pub_key.y == TD_NULL, free_exit,
+            PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    }
+    output_pub_key.length = klen;
+
+    if (gen_key_ctl->input_priv_key.length != 0) {
+        ret = kapi_pke_ecc_gen_key(curve_type, &input_priv_key, &output_priv_key, &output_pub_key);
+    } else {
+        ret = kapi_pke_ecc_gen_key(curve_type, TD_NULL, &output_priv_key, &output_pub_key);
+    }
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_ecc_gen_key failed, ret is 0x%x\n", ret);
+    /* copy to user. */
+    ret = crypto_copy_to_user(gen_key_ctl->output_priv_key.data.p, klen, output_priv_key.data, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+    if (gen_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC8032) {
+        ret = crypto_copy_to_user(gen_key_ctl->output_pub_key.x.p, klen, output_pub_key.x, klen);
+        crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+            "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+    }
+    if (gen_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        ret = crypto_copy_to_user(gen_key_ctl->output_pub_key.y.p, klen, output_pub_key.y, klen);
+        crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+            "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+    }
+
+free_exit:
+    if (gen_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        crypto_chk_crypto_free_with_clean(output_pub_key.y, klen);
+    }
+    if (gen_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC8032) {
+        crypto_chk_crypto_free_with_clean(output_pub_key.x, klen);
+    }
+    crypto_chk_crypto_free_with_clean(output_priv_key.data, klen);
+    crypto_chk_crypto_free_with_clean(input_priv_key.data, klen);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_ECDH_SUPPORT)
+static td_s32 dispatch_pke_ecc_gen_ecdh_key(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_ecc_gen_ecdh_key_ctl_t *gen_ecdh_key_ctl = (pke_ecc_gen_ecdh_key_ctl_t *)argp;
+    drv_pke_ecc_curve_type curve_type = 0;
+    drv_pke_data input_priv_key = { 0 };
+    drv_pke_data output_shared_key = { 0 };
+    drv_pke_ecc_point input_pub_key = { 0 };
+    td_u32 klen = 0;
+
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_ECC_GEN_ECDH_KEY);
+
+    crypto_unused(private_data);
+    pke_null_ptr_chk(gen_ecdh_key_ctl->input_priv_key.data.p);
+    pke_null_ptr_chk(gen_ecdh_key_ctl->input_pub_key.x.p);
+    pke_null_ptr_chk(gen_ecdh_key_ctl->output_shared_key.data.p);
+    if (gen_ecdh_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        pke_null_ptr_chk(gen_ecdh_key_ctl->input_pub_key.y.p);
+    }
+
+    klen = gen_ecdh_key_ctl->input_priv_key.length;
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(gen_ecdh_key_ctl->input_pub_key.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "gen_ecdh_key_ctl->input_pub_key.length is Invalid\n");
+    crypto_chk_return(gen_ecdh_key_ctl->output_shared_key.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "gen_ecdh_key_ctl->output_shared_key.length is Invalid\n");
+
+    curve_type = gen_ecdh_key_ctl->curve_type;
+    input_priv_key.length = klen;
+    input_pub_key.length = klen;
+    output_shared_key.length = klen;
+    /* input_priv_key. */
+    input_priv_key.data = crypto_malloc(klen);
+    crypto_chk_goto_with_ret(ret, input_priv_key.data == TD_NULL, free_exit,
+        PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    ret = crypto_copy_from_user(input_priv_key.data, klen, gen_ecdh_key_ctl->input_priv_key.data.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    /* output_shared_key. */
+    output_shared_key.data = crypto_malloc(klen);
+    crypto_chk_goto_with_ret(ret, output_shared_key.data == TD_NULL, free_exit,
+        PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    /* input_pub_key.  */
+    input_pub_key.x = crypto_malloc(klen);
+    crypto_chk_goto_with_ret(ret, input_pub_key.x == TD_NULL, free_exit,
+        PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    if (gen_ecdh_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        input_pub_key.y = crypto_malloc(klen);
+        crypto_chk_goto_with_ret(ret, input_pub_key.y == TD_NULL, free_exit,
+            PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    }
+
+    ret = crypto_copy_from_user(input_pub_key.x, klen, gen_ecdh_key_ctl->input_pub_key.x.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    if (gen_ecdh_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        ret = crypto_copy_from_user(input_pub_key.y, klen, gen_ecdh_key_ctl->input_pub_key.y.p, klen);
+        crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+    }
+
+    ret = kapi_pke_ecc_gen_ecdh_key(curve_type, &input_pub_key, &input_priv_key, &output_shared_key);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_ecc_gen_key failed, ret is 0x%x\n", ret);
+
+    /* copy to user. */
+    ret = crypto_copy_to_user(gen_ecdh_key_ctl->output_shared_key.data.p, klen, output_shared_key.data, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+free_exit:
+    if (gen_ecdh_key_ctl->curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        crypto_chk_crypto_free_with_clean(input_pub_key.y, klen);
+    }
+    crypto_chk_crypto_free_with_clean(input_pub_key.x, klen);
+    crypto_chk_crypto_free_with_clean(output_shared_key.data, klen);
+    crypto_chk_crypto_free_with_clean(input_priv_key.data, klen);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_ECDSA_SIGN_SUPPORT)
+static td_s32 dispatch_pke_ecdsa_sign(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_ecdsa_sign_ctl_t *ecdsa_sign_ctl = (pke_ecdsa_sign_ctl_t *)argp;
+    drv_pke_ecc_curve_type curve_type = 0;
+    drv_pke_data priv_key = { 0 };
+    drv_pke_data hash = { 0 };
+    drv_pke_ecc_sig sig = { 0 };
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    crypto_dispatch_func_enter();
+
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_ECDSA_SIGN);
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(ecdsa_sign_ctl->priv_key.data.p);
+    pke_null_ptr_chk(ecdsa_sign_ctl->hash.data.p);
+    pke_null_ptr_chk(ecdsa_sign_ctl->sig.r.p);
+    pke_null_ptr_chk(ecdsa_sign_ctl->sig.s.p);
+    klen = ecdsa_sign_ctl->priv_key.length;
+    hash_len = ecdsa_sign_ctl->hash.length;
+
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(hash_len < CRYPTO_HASH_MIN_LEN || hash_len > CRYPTO_HASH_MAX_LEN,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_len is Invalid\n");
+    crypto_chk_return(ecdsa_sign_ctl->sig.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "ecdsa_sign_ctl->sig.length is Invalid\n");
+    curve_type = ecdsa_sign_ctl->curve_type;
+
+    /* alloc memory. */
+    buffer_size = klen * 3 + hash_len;      // 3: for priv->d, sig->r and sig->s
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    priv_key.data = buffer;
+    priv_key.length = klen;
+
+    hash.data = priv_key.data + priv_key.length;
+    hash.length = hash_len;
+
+    sig.r = hash.data + hash.length;
+    sig.s = sig.r + klen;
+    sig.length = klen;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(priv_key.data, klen, ecdsa_sign_ctl->priv_key.data.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(hash.data, hash_len, ecdsa_sign_ctl->hash.data.p, hash_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_ecdsa_sign(curve_type, &priv_key, &hash, &sig);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_ecdsa_sign failed, ret is 0x%x\n", ret);
+
+    /* copy to user. */
+    ret = crypto_copy_to_user(ecdsa_sign_ctl->sig.r.p, klen, sig.r, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_to_user(ecdsa_sign_ctl->sig.s.p, klen, sig.s, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_ECDSA_VERIFY_SUPPORT)
+static td_s32 dispatch_pke_ecdsa_verify(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_ecdsa_verify_ctl_t *ecdsa_verify_ctl = (pke_ecdsa_verify_ctl_t *)argp;
+    drv_pke_ecc_curve_type curve_type = 0;
+    drv_pke_ecc_point pub_key = { 0 };
+    drv_pke_data hash = { 0 };
+    drv_pke_ecc_sig sig = { 0 };
+    td_u32 klen = 0;
+    td_u32 hash_length = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_ECDSA_VERIFY);
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(ecdsa_verify_ctl->pub_key.x.p);
+    pke_null_ptr_chk(ecdsa_verify_ctl->pub_key.y.p);
+    pke_null_ptr_chk(ecdsa_verify_ctl->hash.data.p);
+    pke_null_ptr_chk(ecdsa_verify_ctl->sig.r.p);
+    pke_null_ptr_chk(ecdsa_verify_ctl->sig.s.p);
+
+    klen = ecdsa_verify_ctl->pub_key.length;
+    hash_length = ecdsa_verify_ctl->hash.length;
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(hash_length < CRYPTO_HASH_MIN_LEN || hash_length > CRYPTO_HASH_MAX_LEN,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_len is Invalid\n");
+    crypto_chk_return(ecdsa_verify_ctl->sig.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "ecdsa_verify_ctl->sig.length is Invalid\n");
+
+    curve_type = ecdsa_verify_ctl->curve_type;
+
+    /* alloc memory. */
+    buffer_size = klen * 4 + hash_length; // 4: for pub.x, pub.y, sig.r, sig.s
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_goto_with_ret(ret, buffer == TD_NULL, free_exit, PKE_COMPAT_ERRNO(ERROR_MALLOC),
+        "crypto_malloc failed\n");
+
+    pub_key.x = buffer;
+    pub_key.y = buffer + klen;
+    pub_key.length = klen;
+
+    hash.data = pub_key.y + pub_key.length;
+    hash.length = hash_length;
+
+    sig.r = hash.data + hash.length;
+    sig.s = sig.r + klen;
+    sig.length = klen;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(pub_key.x, klen, ecdsa_verify_ctl->pub_key.x.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(pub_key.y, klen, ecdsa_verify_ctl->pub_key.y.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(hash.data, hash_length, ecdsa_verify_ctl->hash.data.p, hash_length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(sig.r, klen, ecdsa_verify_ctl->sig.r.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(sig.s, klen, ecdsa_verify_ctl->sig.s.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_ecdsa_verify(curve_type, &pub_key, &hash, &sig);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_ecdsa_verify failed, ret is 0x%x\n", ret);
+
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_EDDSA_SIGN_SUPPORT)
+static td_s32 dispatch_pke_eddsa_sign(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_eddsa_sign_ctl_t *eddsa_sign_ctl = (pke_eddsa_sign_ctl_t *)argp;
+    drv_pke_ecc_curve_type curve_type = 0;
+    drv_pke_data priv_key = { 0 };
+    drv_pke_msg msg = { 0 };
+    drv_pke_ecc_sig sig = { 0 };
+    td_u32 klen = 0;
+    td_u32 msg_len = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    crypto_dispatch_func_enter();
+
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_EDDSA_SIGN);
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(eddsa_sign_ctl->priv_key.data.p);
+    pke_null_ptr_chk(eddsa_sign_ctl->msg.data.p);
+    pke_null_ptr_chk(eddsa_sign_ctl->sig.r.p);
+    pke_null_ptr_chk(eddsa_sign_ctl->sig.s.p);
+    klen = eddsa_sign_ctl->priv_key.length;
+    msg_len = eddsa_sign_ctl->msg.length;
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(msg_len < CRYPTO_PKE_MSG_MIN_SIZE || msg_len > CRYPTO_PKE_MSG_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "msg_len is Invalid\n");
+    crypto_chk_return(eddsa_sign_ctl->sig.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "eddsa_sign_ctl->sig.length is Invalid\n");
+
+    curve_type = eddsa_sign_ctl->curve_type;
+
+    /* alloc memory. */
+    buffer_size = klen * 3 + msg_len;   // 3: for priv.d, sig.r, sig.s
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    priv_key.data = buffer;
+    priv_key.length = klen;
+
+    msg.data = priv_key.data + priv_key.length;
+    msg.length = msg_len;
+    msg.buf_sec = eddsa_sign_ctl->msg.buf_sec;
+
+    sig.r = msg.data + msg.length;
+    sig.s = sig.r + klen;
+    sig.length = klen;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(priv_key.data, klen, eddsa_sign_ctl->priv_key.data.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(msg.data, msg_len, eddsa_sign_ctl->msg.data.p, msg_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_eddsa_sign(curve_type, &priv_key, &msg, &sig);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_ecdsa_sign failed, ret is 0x%x\n", ret);
+
+    /* copy to user. */
+    ret = crypto_copy_to_user(eddsa_sign_ctl->sig.r.p, klen, sig.r, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_to_user(eddsa_sign_ctl->sig.s.p, klen, sig.s, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_EDDSA_VERIFY_SUPPORT)
+static td_s32 dispatch_pke_eddsa_verify(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_eddsa_verify_ctl_t *eddsa_verify_ctl = (pke_eddsa_verify_ctl_t *)argp;
+    drv_pke_ecc_curve_type curve_type = 0;
+    drv_pke_ecc_point pub_key = { 0 };
+    drv_pke_msg msg = { 0 };
+    drv_pke_ecc_sig sig = { 0 };
+    td_u32 klen = 0;
+    td_u32 msg_len = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_EDDSA_VERIFY);
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(eddsa_verify_ctl->pub_key.y.p);
+    pke_null_ptr_chk(eddsa_verify_ctl->msg.data.p);
+    pke_null_ptr_chk(eddsa_verify_ctl->sig.r.p);
+    pke_null_ptr_chk(eddsa_verify_ctl->sig.s.p);
+
+    klen = eddsa_verify_ctl->pub_key.length;
+    msg_len = eddsa_verify_ctl->msg.length;
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(msg_len < CRYPTO_PKE_MSG_MIN_SIZE || msg_len > CRYPTO_PKE_MSG_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "msg_len is Invalid\n");
+    crypto_chk_return(eddsa_verify_ctl->sig.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "eddsa_verify_ctl->sig.length is Invalid\n");
+    curve_type = eddsa_verify_ctl->curve_type;
+
+    /* alloc memory. */
+    buffer_size = klen * 3 + msg_len;   // 3: for pub_key.y, sig.r, sig.s
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    pub_key.y = buffer;
+    pub_key.length = klen;
+
+    msg.data = pub_key.y + klen;
+    msg.length = msg_len;
+    msg.buf_sec = eddsa_verify_ctl->msg.buf_sec;
+
+    sig.r = msg.data + msg.length;
+    sig.s = sig.r + klen;
+    sig.length = klen;
+
+    /* copy from user. */
+
+    ret = crypto_copy_from_user(pub_key.y, klen, eddsa_verify_ctl->pub_key.y.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(msg.data, msg_len, eddsa_verify_ctl->msg.data.p, msg_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(sig.r, klen, eddsa_verify_ctl->sig.r.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(sig.s, klen, eddsa_verify_ctl->sig.s.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_eddsa_verify(curve_type, &pub_key, &msg, &sig);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_ecdsa_verify failed, ret is 0x%x\n", ret);
+
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_CHECK_DOT_ON_CURVE_SUPPORT)
+static td_s32 dispatch_pke_check_dot_on_curve(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_check_dot_on_curve_ctl_t *dot_on_curve_ctl = (pke_check_dot_on_curve_ctl_t *)argp;
+    drv_pke_ecc_curve_type curve_type = 0;
+    drv_pke_ecc_point pub_key = { 0 };
+    td_u32 klen = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    crypto_dispatch_func_enter();
+
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_CHECK_DOT_ON_CURVE);
+
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(dot_on_curve_ctl->pub_key.x.p);
+    pke_null_ptr_chk(dot_on_curve_ctl->pub_key.y.p);
+    klen = dot_on_curve_ctl->pub_key.length;
+
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is invalid\n");
+    curve_type = dot_on_curve_ctl->curve_type;
+
+    buffer_size = klen * 2; // 2: for pub_key.x, pub_key.y
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    /* pub_key.  */
+    pub_key.x = buffer;
+    pub_key.y = buffer + klen;
+    pub_key.length = klen;
+    /* copy from user. */
+    ret = crypto_copy_from_user(pub_key.x, klen, dot_on_curve_ctl->pub_key.x.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(pub_key.y, klen, dot_on_curve_ctl->pub_key.y.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_check_dot_on_curve(curve_type, &pub_key, &dot_on_curve_ctl->is_on_curve);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_check_dot_on_curve failed, ret is 0x%x\n", ret);
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_SM2_DSA_HASH_SUPPORT)
+static td_s32 dispatch_pke_sm2_dsa_hash(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_sm2_dsa_hash_ctl_t *dsa_hash_ctl = (pke_sm2_dsa_hash_ctl_t *)argp;
+    drv_pke_data sm2_id = { 0 };
+    drv_pke_ecc_point pub_key = { 0 };
+    drv_pke_msg msg = { 0 };
+    drv_pke_data hash = { 0 };
+    td_u32 klen = 0;
+    td_u32 msg_len = 0;
+    td_u32 hash_len = 0;
+    td_u32 sm2_id_len = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    crypto_dispatch_func_enter();
+
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_SM2_DSA_HASH);
+
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(dsa_hash_ctl->sm2_id.data.p);
+    pke_null_ptr_chk(dsa_hash_ctl->pub_key.x.p);
+    pke_null_ptr_chk(dsa_hash_ctl->pub_key.y.p);
+    pke_null_ptr_chk(dsa_hash_ctl->msg.data.p);
+    pke_null_ptr_chk(dsa_hash_ctl->hash.data.p);
+    klen = dsa_hash_ctl->pub_key.length;
+    msg_len = dsa_hash_ctl->msg.length;
+    hash_len = dsa_hash_ctl->hash.length;
+    sm2_id_len = dsa_hash_ctl->sm2_id.length;
+
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(msg_len < CRYPTO_PKE_MSG_MIN_SIZE || msg_len > CRYPTO_PKE_MSG_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "msg_len is Invalid\n");
+    crypto_chk_return(hash_len < CRYPTO_HASH_MIN_LEN || hash_len > CRYPTO_HASH_MAX_LEN,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_len is Invalid\n");
+    crypto_chk_return(sm2_id_len < CRYPTO_PKE_SM2_ID_MIN_SIZE || sm2_id_len > CRYPTO_PKE_SM2_ID_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "sm2_id_len is Invalid\n");
+
+    buffer_size = sm2_id_len + klen * 2 + msg_len + hash_len;   // 2: for pub_key.x, pub_key.y
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    sm2_id.data = buffer;
+    sm2_id.length = sm2_id_len;
+
+    pub_key.x = sm2_id.data + sm2_id.length;
+    pub_key.y = pub_key.x + klen;
+    pub_key.length = klen;
+
+    msg.data = pub_key.y + pub_key.length;
+    msg.length = msg_len;
+    msg.buf_sec = dsa_hash_ctl->msg.buf_sec;
+
+    hash.data = msg.data + msg.length;
+    hash.length = hash_len;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(sm2_id.data, sm2_id_len, dsa_hash_ctl->sm2_id.data.p, sm2_id_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(pub_key.x, klen, dsa_hash_ctl->pub_key.x.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(pub_key.y, klen, dsa_hash_ctl->pub_key.y.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(msg.data, msg_len, dsa_hash_ctl->msg.data.p, msg_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_sm2_dsa_hash(&sm2_id, &pub_key, &msg, &hash);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_sm2_dsa_hash failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_to_user(dsa_hash_ctl->hash.data.p, hash_len, hash.data, hash_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_SM2_PUB_ENC_SUPPORT)
+static td_s32 dispatch_pke_sm2_public_encrypt(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_sm2_public_encrypt_ctl_t *public_encrypt_ctl = (pke_sm2_public_encrypt_ctl_t *)argp;
+    drv_pke_ecc_point pub_key = { 0 };
+    drv_pke_data plain_text = { 0 };
+    drv_pke_data cipher_text = { 0 };
+    td_u32 klen = 0;
+    td_u32 plain_text_len = 0;
+    td_u32 cipher_text_len = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_SM2_PUBLIC_ENCRYPT);
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(public_encrypt_ctl->pub_key.x.p);
+    pke_null_ptr_chk(public_encrypt_ctl->pub_key.y.p);
+    pke_null_ptr_chk(public_encrypt_ctl->plain_text.data.p);
+    pke_null_ptr_chk(public_encrypt_ctl->cipher_text.data.p);
+
+    klen = public_encrypt_ctl->pub_key.length;
+    plain_text_len = public_encrypt_ctl->plain_text.length;
+    cipher_text_len = public_encrypt_ctl->cipher_text.length;
+
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(plain_text_len < CRYPTO_PKE_SM2_PLAIN_TEXT_MIN_SIZE ||
+        plain_text_len > CRYPTO_PKE_SM2_PLAIN_TEXT_MAX_SIZE, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "plain_text_len is Invalid\n");
+    crypto_chk_return(cipher_text_len < CRYPTO_PKE_SM2_PLAIN_TEXT_MIN_SIZE ||
+        cipher_text_len > CRYPTO_PKE_SM2_PLAIN_TEXT_MAX_SIZE, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "cipher_text_len is Invalid\n");
+
+    buffer_size = klen * 2 + plain_text_len + cipher_text_len;    // 2: for pub_key.x, pub_key.y
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    pub_key.x = buffer;
+    pub_key.y = buffer + klen;
+    pub_key.length = klen;
+
+    plain_text.data = pub_key.y + klen;
+    plain_text.length = plain_text_len;
+
+    cipher_text.data = plain_text.data + plain_text.length;
+    cipher_text.length = cipher_text_len;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(plain_text.data, plain_text_len, public_encrypt_ctl->plain_text.data.p, plain_text_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(pub_key.x, klen, public_encrypt_ctl->pub_key.x.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(pub_key.y, klen, public_encrypt_ctl->pub_key.y.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_sm2_public_encrypt(&pub_key, &plain_text, &cipher_text);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_sm2_public_encrypt failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_to_user(public_encrypt_ctl->cipher_text.data.p, public_encrypt_ctl->cipher_text.length,
+        cipher_text.data, cipher_text.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+    public_encrypt_ctl->cipher_text.length = cipher_text.length;
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_SM2_PRIV_DEC_SUPPORT)
+static td_s32 dispatch_pke_sm2_private_decrypt(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_sm2_private_decrypt_ctl_t *private_decrypt_ctl = (pke_sm2_private_decrypt_ctl_t *)argp;
+    drv_pke_data priv_key = { 0 };
+    drv_pke_data cipher_text = { 0 };
+    drv_pke_data plain_text = { 0 };
+    td_u32 klen = 0;
+    td_u32 plain_text_len = 0;
+    td_u32 cipher_text_len = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_SM2_PRIVATE_DECRYPT);
+
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(private_decrypt_ctl->priv_key.data.p);
+    pke_null_ptr_chk(private_decrypt_ctl->cipher_text.data.p);
+    pke_null_ptr_chk(private_decrypt_ctl->plain_text.data.p);
+
+    klen = private_decrypt_ctl->priv_key.length;
+    plain_text_len = private_decrypt_ctl->plain_text.length;
+    cipher_text_len = private_decrypt_ctl->cipher_text.length;
+
+    crypto_chk_return(klen < CRYPTO_PKE_ECC_KEY_MIN_SIZE || klen > CRYPTO_PKE_ECC_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(plain_text_len < CRYPTO_PKE_SM2_PLAIN_TEXT_MIN_SIZE ||
+        plain_text_len > CRYPTO_PKE_SM2_PLAIN_TEXT_MAX_SIZE, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "plain_text_len is Invalid\n");
+    crypto_chk_return(cipher_text_len < CRYPTO_PKE_SM2_PLAIN_TEXT_MIN_SIZE ||
+        cipher_text_len > CRYPTO_PKE_SM2_PLAIN_TEXT_MAX_SIZE, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "cipher_text_len is Invalid\n");
+    buffer_size = klen + plain_text_len + cipher_text_len;
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    priv_key.data = buffer;
+    priv_key.length = klen;
+
+    cipher_text.data = priv_key.data + priv_key.length;
+    cipher_text.length = cipher_text_len;
+
+    plain_text.data = cipher_text.data + cipher_text.length;
+    plain_text.length = plain_text_len;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(cipher_text.data, cipher_text_len, private_decrypt_ctl->cipher_text.data.p,
+        cipher_text_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(priv_key.data, klen, private_decrypt_ctl->priv_key.data.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_sm2_private_decrypt(&priv_key, &cipher_text, &plain_text);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_sm2_private_decrypt failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_to_user(private_decrypt_ctl->plain_text.data.p, private_decrypt_ctl->plain_text.length,
+        plain_text.data, plain_text.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+    private_decrypt_ctl->plain_text.length = plain_text.length;
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_MOD_SUPPORT)
+static td_s32 dispatch_pke_mod(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_mod_ctl_t *mod_ctr = (pke_mod_ctl_t *)argp;
+    drv_pke_data a;
+    drv_pke_data p;
+    drv_pke_data c;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    td_u32 klen;
+    crypto_dispatch_func_enter();
+
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_MOD);
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(mod_ctr->a.data.p);
+    pke_null_ptr_chk(mod_ctr->p.data.p);
+    pke_null_ptr_chk(mod_ctr->c.data.p);
+
+    klen = crypto_max(mod_ctr->a.length, mod_ctr->p.length);
+    klen = crypto_max(klen, mod_ctr->c.length);
+    crypto_chk_return(klen < CRYPTO_PKE_RSA_KEY_MIN_SIZE || klen > CRYPTO_PKE_RSA_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+
+    buffer_size = klen * 3;   // 3: for apc
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "crypto_malloc failed\n");
+    (void)memset_s(buffer, buffer_size, 0, buffer_size);
+
+    a.data = buffer;
+    a.length = mod_ctr->a.length;
+
+    p.data = buffer + a.length;
+    p.length = mod_ctr->p.length;
+
+    c.data = buffer + a.length + p.length;
+    c.length = mod_ctr->c.length;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(a.data, a.length, mod_ctr->a.data.p, mod_ctr->a.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+    ret = crypto_copy_from_user(p.data, p.length, mod_ctr->p.data.p, mod_ctr->p.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_cipher_pke_mod(&a, &p, &c);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_cipher_pke_mod failed, ret is 0x%x\n", ret);
+
+    /* copy to user. */
+    ret = crypto_copy_to_user(mod_ctr->c.data.p, mod_ctr->c.length, c.data, c.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_EXP_MOD_SUPPORT)
+static td_s32 dispatch_pke_exp_mod(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_exp_mod_ctl_t *exp_mod_ctr = (pke_exp_mod_ctl_t *)argp;
+    drv_pke_data n;
+    drv_pke_data k;
+    drv_pke_data in;
+    drv_pke_data out;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    td_u32 klen;
+    crypto_dispatch_func_enter();
+
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_EXP_MOD);
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(exp_mod_ctr->n.data.p);
+    pke_null_ptr_chk(exp_mod_ctr->k.data.p);
+    pke_null_ptr_chk(exp_mod_ctr->in.data.p);
+    pke_null_ptr_chk(exp_mod_ctr->out.data.p);
+
+    klen = crypto_max(exp_mod_ctr->n.length, exp_mod_ctr->k.length);
+    klen = crypto_max(klen, exp_mod_ctr->in.length);
+    klen = crypto_max(klen, exp_mod_ctr->out.length);
+    crypto_chk_return(klen < CRYPTO_PKE_RSA_KEY_MIN_SIZE || klen > CRYPTO_PKE_RSA_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+        
+    buffer_size = klen * 4;   // 4: for nkinout
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "crypto_malloc failed\n");
+    (void)memset_s(buffer, buffer_size, 0, buffer_size);
+
+    n.data = buffer;
+    n.length = exp_mod_ctr->n.length;
+
+    k.data = buffer + n.length;
+    k.length = exp_mod_ctr->k.length;
+
+    in.data = buffer + n.length + k.length;
+    in.length = exp_mod_ctr->in.length;
+
+    out.data = buffer + n.length + k.length + in.length;
+    out.length = exp_mod_ctr->out.length;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(n.data, n.length, exp_mod_ctr->n.data.p, exp_mod_ctr->n.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+    ret = crypto_copy_from_user(k.data, k.length, exp_mod_ctr->k.data.p, exp_mod_ctr->k.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+    ret = crypto_copy_from_user(in.data, in.length, exp_mod_ctr->in.data.p, exp_mod_ctr->in.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_cipher_pke_exp_mod(&n, &k, &in, &out);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_cipher_pke_exp_mod failed, ret is 0x%x\n", ret);
+
+    /* copy to user. */
+    ret = crypto_copy_to_user(exp_mod_ctr->out.data.p, exp_mod_ctr->out.length, out.data, out.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_GEN_KEY_SUPPORT)
+static td_s32 dispatch_pke_rsa_gen_key(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 klen = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    pke_rsa_gen_key_ctl_t *rsa_gen_key_ctl = (pke_rsa_gen_key_ctl_t *)argp;
+    drv_pke_data input_e;
+    drv_pke_rsa_priv_key priv_key;
+
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_RSA_GEN_KEY);
+
+    crypto_unused(private_data);
+    pke_null_ptr_chk(rsa_gen_key_ctl->input_e.data.p);
+    pke_null_ptr_chk(rsa_gen_key_ctl->priv_key.n.p);
+    pke_null_ptr_chk(rsa_gen_key_ctl->priv_key.d.p);
+
+    klen = rsa_gen_key_ctl->input_e.length;
+    crypto_chk_return(klen < CRYPTO_PKE_RSA_KEY_MIN_SIZE || klen > CRYPTO_PKE_RSA_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(rsa_gen_key_ctl->priv_key.n_len != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "rsa_gen_key_ctl->priv_key.n_len is Invalid\n");
+    crypto_chk_return(rsa_gen_key_ctl->priv_key.d_len != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "rsa_gen_key_ctl->priv_key.d_len is Invalid\n");
+    /* alloc memory. */
+    buffer_size = klen * 3;   // 3: for priv_key.n, priv_key.d, input_e.data
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "crypto_malloc failed\n");
+
+    input_e.data = buffer;
+    input_e.length = klen;
+
+    priv_key.n = input_e.data + input_e.length;
+    priv_key.n_len = klen;
+
+    priv_key.d = priv_key.n + priv_key.n_len;
+    priv_key.d_len = klen;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(input_e.data, klen, rsa_gen_key_ctl->input_e.data.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_rsa_gen_key(&input_e, &priv_key);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_rsa_gen_key failed, ret is 0x%x\n", ret);
+
+    /* copy to user. */
+    ret = crypto_copy_to_user(rsa_gen_key_ctl->priv_key.n.p, klen, priv_key.n, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+    ret = crypto_copy_to_user(rsa_gen_key_ctl->priv_key.d.p, klen, priv_key.d, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_SIGN_SUPPORT)
+static td_s32 dispatch_pke_rsa_sign(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_rsa_sign_ctl_t *rsa_sign_ctl = (pke_rsa_sign_ctl_t *)argp;
+    drv_pke_rsa_priv_key priv_key;
+    drv_pke_rsa_scheme scheme;
+    drv_pke_hash_type hash_type;
+    drv_pke_data input_hash;
+    drv_pke_data sig;
+    td_u32 klen = 0;
+    td_u32 hash_length = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    crypto_dispatch_func_enter();
+
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_RSA_SIGN);
+    crypto_unused(private_data);
+
+    pke_null_ptr_chk(rsa_sign_ctl->priv_key.d.p);
+    pke_null_ptr_chk(rsa_sign_ctl->priv_key.n.p);
+    pke_null_ptr_chk(rsa_sign_ctl->input_hash.data.p);
+    pke_null_ptr_chk(rsa_sign_ctl->sig.data.p);
+
+    klen = rsa_sign_ctl->priv_key.d_len;
+    hash_length = rsa_sign_ctl->input_hash.length;
+    crypto_chk_return(klen < CRYPTO_PKE_RSA_KEY_MIN_SIZE || klen > CRYPTO_PKE_RSA_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(hash_length < CRYPTO_HASH_MIN_LEN || hash_length > CRYPTO_HASH_MAX_LEN,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_len is Invalid\n");
+    crypto_chk_return(rsa_sign_ctl->sig.length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "rsa_sign_ctl->sig.length is Invalid\n");
+    crypto_chk_return(rsa_sign_ctl->priv_key.n_len != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "rsa_sign_ctl->priv_key.n_len is Invalid\n");
+
+    scheme = rsa_sign_ctl->scheme;
+    hash_type = rsa_sign_ctl->hash_type;
+
+    /* alloc memory. */
+    buffer_size = hash_length + klen * 3;   // 3: for priv_key.n, priv_key.d, sign
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "crypto_malloc failed\n");
+
+    input_hash.data = buffer;
+    input_hash.length = hash_length;
+
+    sig.data = input_hash.data + input_hash.length;
+    sig.length = klen;
+
+    priv_key.n = sig.data + sig.length;
+    priv_key.n_len = klen;
+
+    priv_key.d = priv_key.n + priv_key.n_len;
+    priv_key.d_len = klen;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(input_hash.data, hash_length, rsa_sign_ctl->input_hash.data.p, hash_length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(priv_key.n, klen, rsa_sign_ctl->priv_key.n.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(priv_key.d, klen, rsa_sign_ctl->priv_key.d.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_rsa_sign(&priv_key, scheme, hash_type, &input_hash, &sig);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_rsa_sign failed, ret is 0x%x\n", ret);
+
+    /* copy to user. */
+    ret = crypto_copy_to_user(rsa_sign_ctl->sig.data.p, klen, sig.data, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+    rsa_sign_ctl->sig.length = klen;
+
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_VERIFY_SUPPORT)
+static td_s32 dispatch_pke_rsa_verify(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_rsa_verify_ctl_t *rsa_verify_ctl = (pke_rsa_verify_ctl_t *)argp;
+
+    drv_pke_rsa_pub_key pub_key = { 0 };
+    drv_pke_data input_hash = { 0 };
+    drv_pke_data sig = { 0 };
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    td_u8 *buffer = TD_NULL;
+    td_u32 buffer_size = 0;
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_RSA_VERIFY);
+
+    crypto_unused(private_data);
+    pke_null_ptr_chk(rsa_verify_ctl->pub_key.e.p);
+    pke_null_ptr_chk(rsa_verify_ctl->pub_key.n.p);
+    pke_null_ptr_chk(rsa_verify_ctl->input_hash.data.p);
+    pke_null_ptr_chk(rsa_verify_ctl->sig.data.p);
+
+    klen = rsa_verify_ctl->pub_key.len;
+    hash_len = rsa_verify_ctl->input_hash.length;
+    crypto_chk_return(klen < CRYPTO_PKE_RSA_KEY_MIN_SIZE || klen > CRYPTO_PKE_RSA_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(hash_len < CRYPTO_HASH_MIN_LEN || hash_len > CRYPTO_HASH_MAX_LEN,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_len is Invalid\n");
+
+    crypto_chk_return(rsa_verify_ctl->sig.length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+
+    /* alloc memory. */
+    buffer_size = klen * 3 + hash_len;  // 3: for pub_key.n, pub_key.e, sign hash_len: for input_hash
+    buffer = crypto_malloc(buffer_size);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    pub_key.n = buffer;
+    pub_key.e = buffer + klen;
+    pub_key.len = klen;
+
+    input_hash.data = pub_key.e + pub_key.len;
+    input_hash.length = hash_len;
+
+    sig.data = input_hash.data + input_hash.length;
+    sig.length = klen;
+
+    /* copy from user. */
+    ret = crypto_copy_from_user(pub_key.n, klen, rsa_verify_ctl->pub_key.n.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(pub_key.e, klen, rsa_verify_ctl->pub_key.e.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(input_hash.data, hash_len, rsa_verify_ctl->input_hash.data.p, hash_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(sig.data, klen, rsa_verify_ctl->sig.data.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_pke_rsa_verify(&pub_key, rsa_verify_ctl->scheme, rsa_verify_ctl->hash_type, &input_hash, &sig);
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_rsa_verify failed, ret is 0x%x\n", ret);
+
+free_exit:
+    crypto_chk_crypto_free_with_clean(buffer, buffer_size);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_PUB_ENC_SUPPORT)
+static td_s32 dispatch_pke_rsa_public_encrypt(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u8 *data_buffer = TD_NULL;
+    pke_rsa_pub_crypto_ctl_t *crypto_ctl = (pke_rsa_pub_crypto_ctl_t *)argp;
+    drv_pke_rsa_pub_key pub_key = { 0 };
+    drv_pke_data input = { 0 };
+    drv_pke_data label = { 0 };
+    drv_pke_data output = { 0 };
+    td_u32 total_len = 0;
+    td_u32 klen = 0;
+    td_u32 input_len = 0;
+    td_u32 label_len = 0;
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_RSA_PUBLIC_ENCRYPT);
+
+    crypto_unused(private_data);
+    pke_null_ptr_chk(crypto_ctl->pub_key.e.p);
+    pke_null_ptr_chk(crypto_ctl->pub_key.n.p);
+    pke_null_ptr_chk(crypto_ctl->input.data.p);
+    pke_null_ptr_chk(crypto_ctl->output.data.p);
+
+    klen = crypto_ctl->pub_key.len;
+    input_len = crypto_ctl->input.length;
+    label_len = crypto_ctl->label.length;
+    crypto_chk_return(klen < CRYPTO_PKE_RSA_KEY_MIN_SIZE || klen > CRYPTO_PKE_RSA_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(input_len == 0 || input_len > CRYPTO_PKE_RSA_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "input_len is Invalid\n");
+    crypto_chk_return(crypto_ctl->output.length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "crypto_ctl->output.length is Invalid\n");
+    crypto_chk_return(label_len > CRYPTO_PKE_RSA_LABLE_MAX_SIZE, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "label_len is Invalid\n");
+
+    /* 2 pub_key len */
+    total_len = klen * 3 + input_len + label_len;   // 3: for pub_key.n, pub_key.e,output_data
+    /* alloc memory. */
+    data_buffer = crypto_malloc(total_len);
+    crypto_chk_return(data_buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    pub_key.n = data_buffer;
+    pub_key.e = pub_key.n + klen;
+    pub_key.len = klen;
+
+    input.data = pub_key.e + klen;
+    input.length = input_len;
+
+    output.data = input.data + input.length;
+    output.length = klen;
+
+    label.data = output.data + output.length;
+    label.length = label_len;
+
+    ret = crypto_copy_from_user(pub_key.n, klen, crypto_ctl->pub_key.n.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(pub_key.e, klen, crypto_ctl->pub_key.e.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(input.data, input_len, crypto_ctl->input.data.p, input_len);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    if (label_len != 0) {
+        ret = crypto_copy_from_user(label.data, label_len, crypto_ctl->label.data.p, label_len);
+        crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+        ret = kapi_pke_rsa_public_encrypt(crypto_ctl->scheme, crypto_ctl->hash_type, &pub_key, &input, &label, &output);
+    } else {
+        ret =
+            kapi_pke_rsa_public_encrypt(crypto_ctl->scheme, crypto_ctl->hash_type, &pub_key, &input, TD_NULL, &output);
+    }
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_rsa_public_encrypt failed, ret is 0x%x\n", ret);
+    /* copy to user. */
+    ret = crypto_copy_to_user(crypto_ctl->output.data.p, klen, output.data, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+    crypto_ctl->output.length = klen;
+free_exit:
+    crypto_chk_crypto_free_with_clean(data_buffer, total_len);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_PRIV_DEC_SUPPORT)
+static td_s32 dispatch_pke_rsa_private_decrypt(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u8 *data_buffer = TD_NULL;
+    pke_rsa_priv_crypto_ctl_t *crypto_ctl = (pke_rsa_priv_crypto_ctl_t *)argp;
+
+    drv_pke_rsa_priv_key priv_key = { 0 };
+    drv_pke_data input = { 0 };
+    drv_pke_data label = { 0 };
+    drv_pke_data output = { 0 };
+
+    td_u32 total_len = 0;
+    td_u32 klen = 0;
+    td_u32 label_len = 0;
+    crypto_dispatch_func_enter();
+    dispatch_pke_cmd_chk(CRYPTO_CMD_PKE_RSA_PRIVATE_DECRYPT);
+
+    crypto_unused(private_data);
+    pke_null_ptr_chk(crypto_ctl->priv_key.d.p);
+    pke_null_ptr_chk(crypto_ctl->priv_key.n.p);
+    pke_null_ptr_chk(crypto_ctl->input.data.p);
+    pke_null_ptr_chk(crypto_ctl->output.data.p);
+
+    klen = crypto_ctl->priv_key.n_len;
+    label_len = crypto_ctl->label.length;
+    crypto_chk_return(klen < CRYPTO_PKE_RSA_KEY_MIN_SIZE || klen > CRYPTO_PKE_RSA_KEY_MAX_SIZE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klen is Invalid\n");
+    crypto_chk_return(crypto_ctl->priv_key.d_len != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "crypto_ctl->priv_key.d_len is Invalid\n");
+    crypto_chk_return(crypto_ctl->input.length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "crypto_ctl->input.length is Invalid\n");
+    crypto_chk_return(crypto_ctl->output.length == 0, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "crypto_ctl->output.length is Invalid\n");
+    crypto_chk_return(label_len > CRYPTO_PKE_RSA_LABLE_MAX_SIZE, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "label_len is Invalid\n");
+
+    total_len = klen * 4 + label_len;   // 4: for priv_key.n, priv_key.d, input.data, output.data
+    /* alloc memory. */
+    data_buffer = crypto_malloc(total_len);
+    crypto_chk_return(data_buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    priv_key.n = data_buffer;
+    priv_key.n_len = klen;
+    priv_key.d = priv_key.n + priv_key.n_len;
+    priv_key.d_len = klen;
+
+    input.data = priv_key.d + priv_key.d_len;
+    input.length = klen;
+
+    output.data = input.data + input.length;
+    output.length = klen;
+
+    label.data = output.data + output.length;
+    label.length = label_len;
+
+    ret = crypto_copy_from_user(priv_key.n, klen, crypto_ctl->priv_key.n.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(priv_key.d, klen, crypto_ctl->priv_key.d.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = crypto_copy_from_user(input.data, klen, crypto_ctl->input.data.p, klen);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+        "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    if (label_len != 0) {
+        ret = crypto_copy_from_user(label.data, label_len, crypto_ctl->label.data.p, label_len);
+        crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_FROM_USER),
+            "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+        ret =
+            kapi_pke_rsa_private_decrypt(crypto_ctl->scheme, crypto_ctl->hash_type, &priv_key, &input, &label, &output);
+    } else {
+        ret = kapi_pke_rsa_private_decrypt(crypto_ctl->scheme, crypto_ctl->hash_type, &priv_key, &input, TD_NULL,
+            &output);
+    }
+    crypto_chk_goto(ret != TD_SUCCESS, free_exit, "kapi_pke_rsa_private_decrypt failed, ret is 0x%x\n", ret);
+    /* copy to user. */
+    ret = crypto_copy_to_user(crypto_ctl->output.data.p, crypto_ctl->output.length, output.data, output.length);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, free_exit, PKE_COMPAT_ERRNO(ERROR_COPY_TO_USER),
+        "crypto_copy_to_user failed, ret is 0x%x\n", ret);
+    crypto_ctl->output.length = output.length;
+free_exit:
+    crypto_chk_crypto_free_with_clean(data_buffer, total_len);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+static crypto_ioctl_cmd g_dispatch_func[] = {
+    { CRYPTO_CMD_HASH_INIT,                     dispatch_hash_init },
+    { CRYPTO_CMD_HASH_DEINIT,                   dispatch_hash_deinit },
+    { CRYPTO_CMD_HASH_START,                    dispatch_hash_start },
+    { CRYPTO_CMD_HASH_UPDATE,                   dispatch_hash_update },
+    { CRYPTO_CMD_HASH_FINISH,                   dispatch_hash_finish },
+#if defined(CONFIG_HASH_CLONE_SUPPORT)
+    { CRYPTO_CMD_HASH_GET,                      dispatch_hash_get },
+    { CRYPTO_CMD_HASH_SET,                      dispatch_hash_set },
+#else
+    { CRYPTO_CMD_HASH_GET,                      NULL },
+    { CRYPTO_CMD_HASH_SET,                      NULL },
+#endif
+    { CRYPTO_CMD_HASH_DESTROY,                  dispatch_hash_destroy },
+
+#if defined(CONFIG_HASH_PBKDF2_SUPPORT)
+    { CRYPTO_CMD_PBKDF2,                        dispatch_cipher_pbkdf2 },
+#else
+    { CRYPTO_CMD_PBKDF2,                        NULL },
+#endif
+    { CRYPTO_CMD_TRNG_GET_RANDOM,               dispatch_trng_get_random },
+    { CRYPTO_CMD_TRNG_GET_MULTI_RANDOM,         dispatch_trng_get_multi_random },
+
+    { CRYPTO_CMD_SYMC_INIT,                     dispatch_symc_init },
+    { CRYPTO_CMD_SYMC_DEINIT,                   dispatch_symc_deinit },
+    { CRYPTO_CMD_SYMC_CREATE,                   dispatch_symc_create },
+    { CRYPTO_CMD_SYMC_DESTROY,                  dispatch_symc_destroy },
+    { CRYPTO_CMD_SYMC_SET_CONFIG,               dispatch_symc_set_config },
+#if defined(CONFIG_SYMC_GET_CONFIG_SUPPORT)
+    { CRYPTO_CMD_SYMC_GET_CONFIG,               dispatch_symc_get_config },
+#else
+    { CRYPTO_CMD_SYMC_GET_CONFIG,               NULL },
+#endif
+    { CRYPTO_CMD_SYMC_ATTACH,                   dispatch_symc_attach },
+#if defined(CONFIG_SYMC_GET_KEYSLOT_HANDLE_SUPPORT)
+    { CRYPTO_CMD_SYMC_GET_KEYSLOT_HANDLE,       dispatch_symc_get_keyslot_handle },
+#else
+    { CRYPTO_CMD_SYMC_GET_KEYSLOT_HANDLE,       NULL },
+#endif
+#if defined(CONFIG_SYMC_SET_KEY_SUPPORT)
+    { CRYPTO_CMD_SYMC_SET_KEY,                  dispatch_symc_set_key },
+#else
+    { CRYPTO_CMD_SYMC_SET_KEY,                  NULL },
+#endif
+    { CRYPTO_CMD_SYMC_ENCRYPT,                  dispatch_symc_encrypt },
+    { CRYPTO_CMD_SYMC_DECRYPT,                  dispatch_symc_decrypt },
+#if defined(CONFIG_SYMC_MULTI_PACK_SUPPORT)
+    { CRYPTO_CMD_SYMC_ENCRYPT_MULTI,            dispatch_symc_encrypt_multi },
+    { CRYPTO_CMD_SYMC_DECRYPT_MULTI,            dispatch_symc_decrypt_multi },
+#else
+    { CRYPTO_CMD_SYMC_ENCRYPT_MULTI,            NULL },
+    { CRYPTO_CMD_SYMC_DECRYPT_MULTI,            NULL },
+#endif
+#if defined(CONFIG_SYMC_CENC_DECRYPT_SUPPORT)
+    { CRYPTO_CMD_SYMC_CENC_DECRYPT,             dispatch_symc_cenc_decrypt },
+#else
+    { CRYPTO_CMD_SYMC_CENC_DECRYPT,             NULL },
+#endif
+#if defined(CONFIG_SYMC_CCM_SUPPORT) || defined(CONFIG_SYMC_GCM_SUPPORT)
+    { CRYPTO_CMD_SYMC_GET_TAG,                  dispatch_symc_get_tag },
+#else
+    { CRYPTO_CMD_SYMC_GET_TAG,                  NULL },
+#endif
+#if defined(CONFIG_SYMC_CMAC_SUPPORT) || defined(CONFIG_SYMC_CBC_MAC_SUPPORT)
+    { CRYPTO_CMD_SYMC_MAC_START,                dispatch_symc_mac_start },
+    { CRYPTO_CMD_SYMC_MAC_UPDATE,               dispatch_symc_mac_update },
+    { CRYPTO_CMD_SYMC_MAC_FINISH,               dispatch_symc_mac_finish },
+#else
+    { CRYPTO_CMD_SYMC_MAC_START,                NULL },
+    { CRYPTO_CMD_SYMC_MAC_UPDATE,               NULL },
+    { CRYPTO_CMD_SYMC_MAC_FINISH,               NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_GEN_KEY_SUPPORT)
+    { CRYPTO_CMD_PKE_ECC_GEN_KEY,               dispatch_pke_ecc_gen_key },
+#else
+    { CRYPTO_CMD_PKE_ECC_GEN_KEY,               NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_ECDH_SUPPORT)
+    { CRYPTO_CMD_PKE_ECC_GEN_ECDH_KEY,          dispatch_pke_ecc_gen_ecdh_key },
+#else
+    { CRYPTO_CMD_PKE_ECC_GEN_ECDH_KEY,          NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_ECDSA_SIGN_SUPPORT)
+    { CRYPTO_CMD_PKE_ECDSA_SIGN,                dispatch_pke_ecdsa_sign },
+#else
+    { CRYPTO_CMD_PKE_ECDSA_SIGN,                NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_ECDSA_VERIFY_SUPPORT)
+    { CRYPTO_CMD_PKE_ECDSA_VERIFY,              dispatch_pke_ecdsa_verify },
+#else
+    { CRYPTO_CMD_PKE_ECDSA_VERIFY,              NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_EDDSA_SIGN_SUPPORT)
+    { CRYPTO_CMD_PKE_EDDSA_SIGN,                dispatch_pke_eddsa_sign },
+#else
+    { CRYPTO_CMD_PKE_EDDSA_SIGN,                NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_EDDSA_VERIFY_SUPPORT)
+    { CRYPTO_CMD_PKE_EDDSA_VERIFY,              dispatch_pke_eddsa_verify },
+#else
+    { CRYPTO_CMD_PKE_EDDSA_VERIFY,              NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_CHECK_DOT_ON_CURVE_SUPPORT)
+    { CRYPTO_CMD_PKE_CHECK_DOT_ON_CURVE,        dispatch_pke_check_dot_on_curve },
+#else
+    { CRYPTO_CMD_PKE_CHECK_DOT_ON_CURVE,        NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_SM2_DSA_HASH_SUPPORT)
+    { CRYPTO_CMD_PKE_SM2_DSA_HASH,              dispatch_pke_sm2_dsa_hash },
+#else
+    { CRYPTO_CMD_PKE_SM2_DSA_HASH,              NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_SM2_PUB_ENC_SUPPORT)
+    { CRYPTO_CMD_PKE_SM2_PUBLIC_ENCRYPT,        dispatch_pke_sm2_public_encrypt },
+#else
+    { CRYPTO_CMD_PKE_SM2_PUBLIC_ENCRYPT,        NULL },
+#endif
+#if defined(CONFIG_PKE_ECC_SM2_PRIV_DEC_SUPPORT)
+    { CRYPTO_CMD_PKE_SM2_PRIVATE_DECRYPT,       dispatch_pke_sm2_private_decrypt },
+#else
+    { CRYPTO_CMD_PKE_SM2_PRIVATE_DECRYPT,       NULL },
+#endif
+    /* PKE MOD. */
+#if defined(CONFIG_PKE_MOD_SUPPORT)
+    { CRYPTO_CMD_PKE_MOD,                       dispatch_pke_mod},
+#else
+    { CRYPTO_CMD_PKE_MOD,                       NULL},
+#endif
+    /* PKE EXP MOD. */
+#if defined(CONFIG_PKE_EXP_MOD_SUPPORT)
+    { CRYPTO_CMD_PKE_EXP_MOD,                   dispatch_pke_exp_mod},
+#else
+    { CRYPTO_CMD_PKE_EXP_MOD,                   NULL},
+#endif
+    /* RSA GEN KEY. */
+#if defined(CONFIG_PKE_RSA_GEN_KEY_SUPPORT)
+    { CRYPTO_CMD_PKE_RSA_GEN_KEY,               dispatch_pke_rsa_gen_key },
+#else
+    { CRYPTO_CMD_PKE_RSA_GEN_KEY,               NULL },
+#endif
+#if defined(CONFIG_PKE_RSA_SIGN_SUPPORT)
+    { CRYPTO_CMD_PKE_RSA_SIGN,                  dispatch_pke_rsa_sign },
+#else
+    { CRYPTO_CMD_PKE_RSA_SIGN,                  NULL },
+#endif
+#if defined(CONFIG_PKE_RSA_VERIFY_SUPPORT)
+    { CRYPTO_CMD_PKE_RSA_VERIFY,                dispatch_pke_rsa_verify },
+#else
+    { CRYPTO_CMD_PKE_RSA_VERIFY,                NULL },
+#endif
+#if defined(CONFIG_PKE_RSA_PUB_ENC_SUPPORT)
+    { CRYPTO_CMD_PKE_RSA_PUBLIC_ENCRYPT,        dispatch_pke_rsa_public_encrypt },
+#else
+    { CRYPTO_CMD_PKE_RSA_PUBLIC_ENCRYPT,        NULL },
+#endif
+#if defined(CONFIG_PKE_RSA_PRIV_DEC_SUPPORT)
+    { CRYPTO_CMD_PKE_RSA_PRIVATE_DECRYPT,       dispatch_pke_rsa_private_decrypt },
+#else
+    { CRYPTO_CMD_PKE_RSA_PRIVATE_DECRYPT,       NULL },
+#endif
+
+#ifdef CONFIG_CRYPTO_CHIP_HDCP_SUPPORT
+    { CRYPTO_CMD_HDCP_ENCRYPT,                  dispatch_hdcp_encrypt },
+#else
+    { CRYPTO_CMD_HDCP_ENCRYPT,                  NULL },
+#endif /* CONFIG_CRYPTO_CHIP_HDCP_SUPPORT */
+#if defined(CONFIG_HASH_HARDEN_INTERFACE_SUPPORT)
+    { CRYPTO_CMD_HASH_START_IMPL,               dispatch_hash_start_impl },
+    { CRYPTO_CMD_HASH_UPDATE_IMPL,              dispatch_hash_update_impl },
+    { CRYPTO_CMD_HASH_FINISH_IMPL,              dispatch_hash_finish_impl },
+#else
+    { CRYPTO_CMD_HASH_START_IMPL,               NULL },
+    { CRYPTO_CMD_HASH_UPDATE_IMPL,              NULL },
+    { CRYPTO_CMD_HASH_FINISH_IMPL,              NULL },
+#endif
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+    { CRYPTO_CMD_SYMC_CRYPT_IMPL,               dispatch_symc_crypt_impl },
+#else
+    { CRYPTO_CMD_SYMC_CRYPT_IMPL,               NULL },
+#endif
+    { CRYPTO_CMD_CCM_UPDATE_AD_IMPL,               NULL },
+    { CRYPTO_CMD_CCM_UPDATE_IMPL,                  NULL },
+    { CRYPTO_CMD_CCM_FINISH_IMPL,                  NULL },
+};
+
+crypto_ioctl_cmd *crypto_get_ioctl_cmd_list(td_void)
+{
+    return g_dispatch_func;
+}
+
+td_u32 crypto_get_ioctl_cmd_cnt(td_void)
+{
+    return sizeof(g_dispatch_func) / sizeof(crypto_ioctl_cmd);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/dispatch_code/crypto_dispatch.h b/bsp/security_subsys/security_subsys_common/dispatch_code/crypto_dispatch.h
new file mode 100644
index 0000000..c659a91
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/dispatch_code/crypto_dispatch.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef CRYPTO_DISPATCH_H
+#define CRYPTO_DISPATCH_H
+
+#include "crypto_type.h"
+#include "crypto_drv_common.h"
+
+crypto_ioctl_cmd *crypto_get_ioctl_cmd_list(td_void);
+
+td_u32 crypto_get_ioctl_cmd_cnt(td_void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_km.c b/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_km.c
new file mode 100644
index 0000000..fafa877
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_km.c
@@ -0,0 +1,397 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "dispatch_km.h"
+#include "crypto_common_macro.h"
+#include "kapi_km.h"
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+#include "kapi_km_impl.h"
+#endif
+
+#define KM_COMPAT_ERRNO(err_code)     DISPATCH_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+static td_s32 dispatch_keyslot_create(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    keyslot_create_ctl_t *keyslot_create_t = TD_NULL;
+    td_handle keyslot_handle;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    keyslot_create_t = (keyslot_create_ctl_t *)argp;
+    ret = kapi_keyslot_create(&keyslot_handle, keyslot_create_t->keyslot_type);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_keyslot_create failed, ret is 0x%x\n", ret);
+    keyslot_create_t->kapi_keyslot_handle = keyslot_handle;
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_keyslot_destroy(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    keyslot_destroy_ctl_t *keyslot_destroy_t = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    keyslot_destroy_t = (keyslot_destroy_ctl_t *)argp;
+    ret = kapi_keyslot_destroy(keyslot_destroy_t->kapi_keyslot_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_keyslot_destroy failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_klad_create(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_handle_ctl_t *klad_handle_ctl = TD_NULL;
+    td_handle klad_handle;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_handle_ctl = (klad_handle_ctl_t *)argp;
+    ret = kapi_klad_create(&klad_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_keyslot_create failed, ret is 0x%x\n", ret);
+    klad_handle_ctl->kapi_klad_handle = (td_handle)klad_handle;
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_klad_destroy(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_handle_ctl_t *klad_handle_ctl = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_handle_ctl = (klad_handle_ctl_t *)argp;
+    ret = kapi_klad_destroy(klad_handle_ctl->kapi_klad_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_klad_destroy failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_klad_set_attr(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_attr_ctl_t *klad_attr_ctl = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_attr_ctl = (klad_attr_ctl_t *)argp;
+    ret = kapi_klad_set_attr(klad_attr_ctl->kapi_klad_handle, &klad_attr_ctl->attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_klad_set_attr failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_klad_get_attr(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_attr_ctl_t *klad_attr_ctl = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_attr_ctl = (klad_attr_ctl_t *)argp;
+
+    ret = kapi_klad_get_attr(klad_attr_ctl->kapi_klad_handle, &klad_attr_ctl->attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_klad_get_attr failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_klad_attach(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_attach_ctl_t *klad_attach_ctl = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_attach_ctl = (klad_attach_ctl_t *)argp;
+    ret = kapi_klad_attach(klad_attach_ctl->kapi_klad_handle, klad_attach_ctl->klad_type,
+        klad_attach_ctl->kapi_keyslot_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_klad_attach failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_klad_detach(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_attach_ctl_t *klad_attach_ctl = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_attach_ctl = (klad_attach_ctl_t *)argp;
+    ret = kapi_klad_detach(klad_attach_ctl->kapi_klad_handle, klad_attach_ctl->klad_type,
+        klad_attach_ctl->kapi_keyslot_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_klad_detach failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+#define MAX_KEY_LEN     128
+static td_s32 dispatch_klad_set_clear_key(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_set_clear_key_ctl_t *klad_set_clear_key_ctl = TD_NULL;
+    td_u8 key[MAX_KEY_LEN] = {0};
+    crypto_klad_clear_key clear_key = {0};
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_set_clear_key_ctl = (klad_set_clear_key_ctl_t *)argp;
+
+    crypto_chk_return(klad_set_clear_key_ctl->key_size > MAX_KEY_LEN, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "Unsupported key_len, the max lenth of the key is: %d\n", MAX_KEY_LEN);
+    crypto_param_require(klad_set_clear_key_ctl->key.p != TD_NULL);
+
+    ret = crypto_copy_from_user(key, MAX_KEY_LEN, klad_set_clear_key_ctl->key.p,  \
+        klad_set_clear_key_ctl->key_size);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    clear_key.key = key;
+    clear_key.hmac_type = klad_set_clear_key_ctl->hmac_type;
+    clear_key.key_length = klad_set_clear_key_ctl->key_size;
+    clear_key.key_parity = klad_set_clear_key_ctl->key_parity;
+
+    ret = kapi_klad_set_clear_key(klad_set_clear_key_ctl->kapi_klad_handle, &clear_key);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "kapi_klad_set_clear_key failed, ret is 0x%x\n", ret);
+
+exit:
+    (td_void)memset_s(key, MAX_KEY_LEN, 0, MAX_KEY_LEN);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_KM_SESSION_KEY_SUPPORT)
+static td_s32 dispatch_klad_set_session_key(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_set_session_key_ctl_t *klad_set_session_key_ctl = TD_NULL;
+    crypto_klad_session_key session_key = {0};
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_set_session_key_ctl = (klad_set_session_key_ctl_t *)argp;
+
+    crypto_chk_return(klad_set_session_key_ctl->key_size > MAX_KEY_LEN, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "Unsupported key_len, the max lenth of the key is: %d\n", MAX_KEY_LEN);
+    crypto_param_require(klad_set_session_key_ctl->key.p != TD_NULL);
+
+    ret = crypto_copy_from_user(session_key.key, sizeof(session_key.key), klad_set_session_key_ctl->key.p,  \
+        klad_set_session_key_ctl->key_size);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+    session_key.alg = klad_set_session_key_ctl->alg;
+    session_key.key_length = klad_set_session_key_ctl->key_size;
+    session_key.level = klad_set_session_key_ctl->level;
+
+    ret = kapi_klad_set_session_key(klad_set_session_key_ctl->kapi_klad_handle, &session_key);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_klad_set_session_key failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_KM_CONTENT_KEY_SUPPORT)
+static td_s32 dispatch_klad_set_content_key(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_set_content_key_ctl_t *klad_set_content_key_ctl = TD_NULL;
+    crypto_klad_content_key content_key = {0};
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_set_content_key_ctl = (klad_set_content_key_ctl_t *)argp;
+
+    crypto_chk_return(klad_set_content_key_ctl->key_size > MAX_KEY_LEN, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "Unsupported key_len, the max lenth of the key is: %d\n", MAX_KEY_LEN);
+    crypto_param_require(klad_set_content_key_ctl->key.p != TD_NULL);
+
+    ret = crypto_copy_from_user(content_key.key, sizeof(content_key.key), klad_set_content_key_ctl->key.p,  \
+        klad_set_content_key_ctl->key_size);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    content_key.alg = klad_set_content_key_ctl->alg;
+    content_key.key_length = klad_set_content_key_ctl->key_size;
+    content_key.key_parity = klad_set_content_key_ctl->key_parity;
+
+    ret = kapi_klad_set_content_key(klad_set_content_key_ctl->kapi_klad_handle, &content_key);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_klad_set_content_key failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+#define EFFECTIVE_KEY_LENGTH 28
+static td_s32 dispatch_klad_set_effective_key(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_set_effective_key_ctl_t *klad_set_effective_key_ctl = TD_NULL;
+    td_u8 salt[EFFECTIVE_KEY_LENGTH] = {0};
+    crypto_klad_effective_key effective_key = {0};
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    klad_set_effective_key_ctl = (klad_set_effective_key_ctl_t *)argp;
+
+    crypto_chk_return(klad_set_effective_key_ctl == NULL, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "effective_key is NULL\n");
+
+    effective_key.kdf_hard_alg = klad_set_effective_key_ctl->kdf_hard_alg;
+    effective_key.key_parity = klad_set_effective_key_ctl->key_parity;
+    effective_key.key_size = klad_set_effective_key_ctl->key_size;
+    effective_key.oneway = klad_set_effective_key_ctl->oneway;
+    effective_key.salt_length = klad_set_effective_key_ctl->salt_length;
+
+    ret = crypto_copy_from_user(salt, EFFECTIVE_KEY_LENGTH, klad_set_effective_key_ctl->salt,
+        klad_set_effective_key_ctl->salt_length);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    effective_key.salt = salt;
+
+    ret = kapi_klad_set_effective_key(klad_set_effective_key_ctl->kapi_klad_handle, &effective_key);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "kapi_klad_set_effective_key failed, ret is 0x%x\n", ret);
+
+exit:
+    (td_void)memset_s(salt, EFFECTIVE_KEY_LENGTH, 0, EFFECTIVE_KEY_LENGTH);
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+static td_s32 dispatch_km_create_key_impl(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    km_create_key_impl_ctl_t *km_key = TD_NULL;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    km_key = (km_create_key_impl_ctl_t *)argp;
+    crypto_chk_return(km_key == NULL, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "km_key is NULL\n");
+
+    ret = kapi_km_create_key_impl(&km_key->kapi_kslot_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_km_create_key_impl failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_km_set_key_impl(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    km_set_impl_ctl_t *km_key = TD_NULL;
+    td_u8 key[MAX_KEY_LEN] = {0};
+
+    crypto_dispatch_func_enter();
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    km_key = (km_set_impl_ctl_t *)argp;
+    crypto_chk_return(km_key->key_size > MAX_KEY_LEN, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "Unsupported key_len, the max lenth of the key is: %d\n", MAX_KEY_LEN);
+    crypto_param_require(km_key->key.p != TD_NULL);
+
+    ret = crypto_copy_from_user(key, sizeof(key), km_key->key.p, km_key->key_size);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_copy_from_user failed, ret is 0x%x\n", ret);
+
+    ret = kapi_km_set_key_impl(km_key->kapi_kslot_handle, key, km_key->key_size, km_key->tee_open);
+    crypto_chk_goto(ret != TD_SUCCESS, clean_key, "kapi_km_set_key_impl failed, ret is 0x%x\n", ret);
+clean_key:
+    (td_void)memset_s(key, sizeof(key), 0, sizeof(key));
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_km_destroy_key_impl(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    km_destroy_key_impl_ctl_t *km_handle = TD_NULL;
+
+    crypto_dispatch_func_enter();
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    km_handle = (km_destroy_key_impl_ctl_t *)argp;
+    crypto_chk_return(km_handle == NULL, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "km_handle is NULL\n");
+
+    ret = kapi_km_desroy_key_impl(km_handle->kapi_keyslot_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_km_desroy_key_impl failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+#endif
+
+static crypto_ioctl_cmd g_km_func_list[] = {
+    {CMD_KEYSLOT_CREATE_HANDLE,             dispatch_keyslot_create},
+    {CMD_KEYSLOT_DESTROY_HANDLE,            dispatch_keyslot_destroy},
+    {CMD_KLAD_CREATE_HANDLE,                dispatch_klad_create},
+    {CMD_KLAD_DESTROY_HANDLE,               dispatch_klad_destroy},
+    {CMD_KLAD_ATTACH,                       dispatch_klad_attach},
+    {CMD_KLAD_DETACH,                       dispatch_klad_detach},
+    {CMD_KLAD_SET_ATTR,                     dispatch_klad_set_attr},
+    {CMD_KLAD_GET_ATTR,                     dispatch_klad_get_attr},
+#if defined(CONFIG_KM_CONTENT_KEY_SUPPORT)
+    {CMD_KLAD_SET_SESSION_KEY,              dispatch_klad_set_session_key},
+    {CMD_KLAD_SET_CONTENT_KEY,              dispatch_klad_set_content_key},
+#else
+    {CMD_KLAD_SET_SESSION_KEY,              NULL},
+    {CMD_KLAD_SET_CONTENT_KEY,              NULL},
+#endif
+    {CMD_KLAD_SET_CLEAR_KEY,                dispatch_klad_set_clear_key},
+    {CMD_KLAD_SET_EFFECTVE_KEY,             dispatch_klad_set_effective_key},
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+    {CMD_KM_CREATE_KEY_IMPL,                dispatch_km_create_key_impl},
+    {CMD_KM_SET_KEY_IMPL,                   dispatch_km_set_key_impl},
+    {CMD_KM_DESTROY_KEY_IMPL,               dispatch_km_destroy_key_impl},
+#else
+    {CMD_KM_CREATE_KEY_IMPL,                NULL},
+    {CMD_KM_SET_KEY_IMPL,                   NULL},
+    {CMD_KM_DESTROY_KEY_IMPL,               NULL},
+#endif
+};
+
+crypto_ioctl_cmd *get_km_func_list(td_void)
+{
+    return g_km_func_list;
+}
+
+td_u32 get_km_func_num(td_void)
+{
+    return crypto_array_size(g_km_func_list);
+}
diff --git a/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_km.h b/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_km.h
new file mode 100644
index 0000000..e6fef0d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_km.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef DISPATCH_KM_H
+#define DISPATCH_KM_H
+
+#include "ioctl_km.h"
+#include "crypto_drv_common.h"
+
+crypto_ioctl_cmd *get_km_func_list(td_void);
+
+td_u32 get_km_func_num(td_void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_otp.c b/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_otp.c
new file mode 100644
index 0000000..a53e928
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_otp.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "dispatch_otp.h"
+#include "crypto_osal_lib.h"
+#include "crypto_common_macro.h"
+#include "kapi_otp.h"
+
+static td_s32 dispatch_otp_read_word(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    otp_word_ctl_t *otp_word_ctl = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    otp_word_ctl = (otp_word_ctl_t *)argp;
+
+    ret = kapi_otp_read_word(otp_word_ctl->addr, &otp_word_ctl->word);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_otp_read_word failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_otp_read_byte(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    otp_byte_ctl_t *otp_byte_ctl = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    otp_byte_ctl = (otp_byte_ctl_t *)argp;
+
+#ifdef CONFIG_DISPATCH_DEBUG
+    crypto_print("addr is 0x%x\n", otp_byte_ctl->addr);
+    crypto_print("byte is 0x%x\n", &otp_byte_ctl->byte);
+#endif
+
+    ret = kapi_otp_read_byte(otp_byte_ctl->addr, &otp_byte_ctl->byte);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_otp_read_byte failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static td_s32 dispatch_otp_write_byte(unsigned int cmd, td_void *argp, void *private_data)
+{
+    td_s32 ret = TD_SUCCESS;
+    otp_byte_ctl_t *otp_byte_ctl = TD_NULL;
+    crypto_dispatch_func_enter();
+
+    crypto_unused(cmd);
+    crypto_unused(private_data);
+
+    otp_byte_ctl = (otp_byte_ctl_t *)argp;
+
+    ret = kapi_otp_write_byte(otp_byte_ctl->addr, otp_byte_ctl->byte);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_otp_write_byte failed, ret is 0x%x\n", ret);
+
+    crypto_dispatch_func_exit();
+    return ret;
+}
+
+static crypto_ioctl_cmd g_otp_func_list[] = {
+    {CMD_OTP_READ_WORD,                 dispatch_otp_read_word},
+    {CMD_OTP_READ_BYTE,                 dispatch_otp_read_byte},
+    {CMD_OTP_WRITE_BYTE,                dispatch_otp_write_byte},
+};
+
+crypto_ioctl_cmd *get_otp_func_list(td_void)
+{
+    return g_otp_func_list;
+}
+
+td_u32 get_otp_func_num(td_void)
+{
+    return crypto_array_size(g_otp_func_list);
+}
diff --git a/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_otp.h b/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_otp.h
new file mode 100644
index 0000000..cc26aaa
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/dispatch_code/dispatch_otp.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef DISPATCH_OTP_H
+#define DISPATCH_OTP_H
+
+#include "ioctl_otp.h"
+#include "crypto_drv_common.h"
+
+crypto_ioctl_cmd *get_otp_func_list(td_void);
+
+td_u32 get_otp_func_num(td_void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_clone.c b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_clone.c
new file mode 100644
index 0000000..c9d6a80
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_clone.c
@@ -0,0 +1,137 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver trng. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "drv_hash_inner.h"
+
+#include "crypto_drv_common.h"
+
+#if defined(CONFIG_HASH_CLONE_SUPPORT)
+td_s32 drv_cipher_hash_get(td_handle drv_hash_handle, crypto_hash_clone_ctx *hash_ctx)
+{
+    td_s32 ret = TD_SUCCESS;
+    drv_hash_simple_context *ctx = TD_NULL;
+    crypto_drv_func_enter();
+
+    hash_null_ptr_chk(hash_ctx);
+
+    ctx = inner_get_hash_ctx(drv_hash_handle);
+    crypto_chk_return(ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid hash_handle\n");
+
+    (td_void)memset_s(hash_ctx, sizeof(crypto_hash_clone_ctx), 0, sizeof(crypto_hash_clone_ctx));
+    /* Clone Length. */
+    ret = memcpy_s(hash_ctx->length, sizeof(hash_ctx->length), ctx->length, sizeof(ctx->length));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    /* Clone state. */
+    ret = memcpy_s(hash_ctx->state, sizeof(hash_ctx->state), ctx->state, sizeof(ctx->state));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    /* Copy tail. */
+    ret = memcpy_s(hash_ctx->tail, sizeof(hash_ctx->tail), ctx->tail, sizeof(ctx->tail));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    hash_ctx->tail_len = ctx->tail_length;
+#if defined(CONFIG_HASH_SOFT_HMAC_SUPPORT)
+    /* Clone o_key_pad. */
+    ret = memcpy_s(hash_ctx->o_key_pad, sizeof(hash_ctx->o_key_pad), ctx->o_key_pad, sizeof(ctx->o_key_pad));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    /* Clone i_key_pad. */
+    ret = memcpy_s(hash_ctx->i_key_pad, sizeof(hash_ctx->i_key_pad), ctx->i_key_pad, sizeof(ctx->i_key_pad));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+#endif
+    /* Clone Hash Type. */
+    hash_ctx->hash_type = ctx->hash_type;
+    crypto_drv_func_exit();
+
+    return ret;
+error_clear_hash_ctx:
+    (td_void)memset_s(hash_ctx, sizeof(crypto_hash_clone_ctx), 0, sizeof(crypto_hash_clone_ctx));
+    return ret;
+}
+
+td_s32 drv_cipher_hash_set(td_handle drv_hash_handle, const crypto_hash_clone_ctx *hash_ctx)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 chn_num = (td_u32)drv_hash_handle;
+    drv_hash_simple_context *ctx = TD_NULL;
+
+    crypto_drv_func_enter();
+
+    hash_null_ptr_chk(hash_ctx);
+
+    ctx = inner_get_hash_ctx(drv_hash_handle);
+    crypto_chk_return(ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid hash_handle\n");
+
+    /* Clone Length. */
+    ret = memcpy_s(ctx->length, sizeof(ctx->length), hash_ctx->length, sizeof(hash_ctx->length));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    /* Clone state. */
+    ret = memcpy_s(ctx->state, sizeof(ctx->state), hash_ctx->state, sizeof(hash_ctx->state));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    /* Copy tail. */
+    ret = memcpy_s(ctx->tail, sizeof(ctx->tail), hash_ctx->tail, sizeof(hash_ctx->tail));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    ctx->tail_length = hash_ctx->tail_len;
+#if defined(CONFIG_HASH_SOFT_HMAC_SUPPORT)
+    /* Clone o_key_pad. */
+    ret = memcpy_s(ctx->o_key_pad, sizeof(ctx->o_key_pad), hash_ctx->o_key_pad, sizeof(hash_ctx->o_key_pad));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    /* Clone i_key_pad. */
+    ret = memcpy_s(ctx->i_key_pad, sizeof(ctx->i_key_pad), hash_ctx->i_key_pad, sizeof(hash_ctx->i_key_pad));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_clear_hash_ctx,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+#endif
+    /* Clone Hash Type. */
+    ctx->hash_type = hash_ctx->hash_type;
+
+    /* Set Hash Config. */
+    ret = hal_cipher_hash_config(chn_num, ctx->hash_type, ctx->state);
+    if (ret != TD_SUCCESS) {
+        crypto_print("hal_cipher_hash_config expected is 0x%x, real ret is 0x%x\n", TD_SUCCESS, ret);
+        goto error_clear_hash_ctx;
+    }
+    crypto_drv_func_exit();
+
+    return ret;
+error_clear_hash_ctx:
+#if defined(CONFIG_HASH_SOFT_HMAC_SUPPORT)
+    (td_void)memset_s(ctx->o_key_pad, sizeof(ctx->o_key_pad), 0, sizeof(ctx->o_key_pad));
+    (td_void)memset_s(ctx->i_key_pad, sizeof(ctx->i_key_pad), 0, sizeof(ctx->i_key_pad));
+#endif
+    return ret;
+}
+#else
+td_s32 drv_cipher_hash_get(td_handle drv_hash_handle, crypto_hash_clone_ctx *hash_ctx)
+{
+    crypto_unused(drv_hash_handle);
+    crypto_unused(hash_ctx);
+
+    return HASH_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+
+td_s32 drv_cipher_hash_set(td_handle drv_hash_handle, const crypto_hash_clone_ctx *hash_ctx)
+{
+    crypto_unused(drv_hash_handle);
+    crypto_unused(hash_ctx);
+
+    return HASH_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_inner.c b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_inner.c
new file mode 100644
index 0000000..fc71300
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_inner.c
@@ -0,0 +1,35 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hash inner source. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#include "drv_hash.h"
+#include "drv_hash_inner.h"
+#include "crypto_hash_struct.h"
+#include "crypto_drv_common.h"
+
+td_s32 inner_hash_drv_handle_chk(td_handle hash_handle)
+{
+    td_u32 chn_num = (td_u32)hash_handle;
+    crypto_chk_return(chn_num >= CONFIG_HASH_HARD_CHN_CNT, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE),
+        "hash_handle[%u] is invalid\n", hash_handle);
+    crypto_chk_return(((1 << chn_num) & CONFIG_HASH_HARD_CHN_MASK) == 0, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE),
+        "hash_handle[%u] is invalid\n", hash_handle);
+
+    return TD_SUCCESS;
+}
+
+td_void inner_drv_hash_length_add(td_u32 length[2], td_u32 addition)
+{
+    td_u32 diff = 0;
+    if (length[1] > length[1] + addition) {
+        length[0]++;
+        diff = 0xFFFFFFFF - length[1] + 1;
+        length[1] = addition - diff;
+        return;
+    }
+    length[1] += addition;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_inner.h b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_inner.h
new file mode 100644
index 0000000..0864da3
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_inner.h
@@ -0,0 +1,87 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hash driver inner header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef DRV_HASH_INNER_H
+#define DRV_HASH_INNER_H
+
+#include "crypto_hash_common.h"
+#include "hal_hash.h"
+
+#define HASH_COMPAT_ERRNO(err_code)     DRV_COMPAT_ERRNO(ERROR_MODULE_HASH, err_code)
+#if defined(CONFIG_DRV_HASH_PARAM_TRACE_ENABLE)
+#define drv_hash_param_trace            crypto_param_trace
+#else
+#define drv_hash_param_trace(...)
+#endif
+
+typedef struct {
+    td_u8 chn_num;
+    crypto_hash_type hash_type;
+    td_u32 state[CRYPTO_HASH_RESULT_SIZE_MAX_IN_WORD];
+    td_u8 tail[CRYPTO_HASH_BLOCK_SIZE_MAX];
+    td_u32 tail_length;
+    td_u32 length[2];
+    td_bool is_keyslot;
+#if defined(CONFIG_HASH_SOFT_HMAC_SUPPORT)
+    td_u8 o_key_pad[CRYPTO_HASH_BLOCK_SIZE_MAX];
+    td_u8 i_key_pad[CRYPTO_HASH_BLOCK_SIZE_MAX];
+#endif
+    td_u8 *data_buffer;
+    td_u32 data_buffer_len;
+} drv_hash_simple_context;
+
+typedef struct {
+    td_u32 length[2];
+    td_u32 state[CRYPTO_HASH_RESULT_SIZE_MAX_IN_WORD];
+#if defined(CONFIG_HASH_SOFT_HMAC_SUPPORT)
+    td_u8 o_key_pad[CRYPTO_HASH_BLOCK_SIZE_MAX];
+    td_u8 i_key_pad[CRYPTO_HASH_BLOCK_SIZE_MAX];
+#endif
+    td_u8 tail[CRYPTO_HASH_BLOCK_SIZE_MAX];
+    td_u32 tail_len;
+    td_u8 *data_buffer;
+    td_u32 data_buffer_len;
+} crypto_hash_ctx;
+
+typedef struct {
+    td_bool open;
+    td_bool is_keyslot;
+    crypto_hash_type hash_type;
+    crypto_hash_ctx hash_ctx;
+} hal_hash_channel_context;
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_void inner_drv_hash_length_add(td_u32 length[2], td_u32 addition);
+
+td_s32 inner_drv_hmac_start(drv_hash_simple_context *ctx, const crypto_hash_attr *hash_attr);
+
+td_s32 inner_drv_hmac_finish(drv_hash_simple_context *ctx, td_u8 *out, td_u32 out_len);
+
+td_u8 *inner_drv_hash_get_dma_buf(td_void);
+
+drv_hash_simple_context *inner_get_hash_ctx(td_handle hash_handle);
+
+td_s32 inner_drv_hash_process(td_u32 chn_num, drv_hash_simple_context *ctx,
+    td_u8 *data_buffer, td_u32 data_length, td_u32 node_type);
+
+td_s32 inner_hash_drv_handle_chk(td_handle hash_handle);
+
+td_s32 inner_hash_start_param_chk(td_handle *drv_hash_handle, const crypto_hash_attr *hash_attr);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_simple.c b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_simple.c
new file mode 100755
index 0000000..4b35008
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_simple.c
@@ -0,0 +1,422 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hash driver common source. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#include "drv_hash_inner.h"
+
+#define CRYPTO_INVALID_CHN_NUM          (0xFFFFFFFF)
+#define CONFIG_HASH_DRV_BUFFER_SIZE     (2 * 1024)
+
+static drv_hash_simple_context *g_hash_ctx_list[CONFIG_HASH_HARD_CHN_CNT];
+
+drv_hash_simple_context *inner_get_hash_ctx(td_handle hash_handle)
+{
+    td_s32 ret;
+
+    ret = inner_hash_drv_handle_chk(hash_handle);
+    if (ret != TD_SUCCESS) {
+        return TD_NULL;
+    }
+
+    return g_hash_ctx_list[hash_handle];
+}
+
+td_s32 drv_cipher_hash_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    crypto_drv_func_enter();
+
+    ret = hal_cipher_hash_init();
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_cipher_hash_init failed\n");
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_hash_deinit(td_void)
+{
+    td_u32 i;
+    crypto_drv_func_enter();
+
+    for (i = 0; i < CONFIG_HASH_HARD_CHN_CNT; i++) {
+        if (g_hash_ctx_list[i] == NULL) {
+            continue;
+        }
+
+        if (g_hash_ctx_list[i]->data_buffer != TD_NULL) {
+            crypto_free_coherent(g_hash_ctx_list[i]->data_buffer);
+        }
+        hal_hash_unlock(i);
+        crypto_free(g_hash_ctx_list[i]);
+        g_hash_ctx_list[i] = NULL;
+    }
+
+    hal_cipher_hash_deinit();
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_hash_lock_chn(td_u32 *chn_num)
+{
+    td_u32 i;
+    td_s32 ret = TD_SUCCESS;
+    *chn_num = CRYPTO_INVALID_CHN_NUM;
+    /* Lock one free Hash Hard Channel. */
+    for (i = 0; i < CONFIG_HASH_HARD_CHN_CNT; i++) {
+        if (g_hash_ctx_list[i] != NULL) {
+            continue;
+        }
+
+        ret = hal_hash_lock(i);
+        if (ret == TD_SUCCESS) {
+            *chn_num = i;
+            break;
+        }
+    }
+
+    if (*chn_num == CRYPTO_INVALID_CHN_NUM) {
+        crypto_log_err("Hash Channel is Busy\n");
+        return HASH_COMPAT_ERRNO(ERROR_CHN_BUSY);
+    }
+    return TD_SUCCESS;
+}
+
+td_s32 drv_cipher_hash_start(td_handle *drv_hash_handle, const crypto_hash_attr *hash_attr)
+{
+    td_u32 chn_num = CRYPTO_INVALID_CHN_NUM;
+    td_s32 ret = TD_FAILURE;
+    drv_hash_simple_context *ctx = TD_NULL;
+    crypto_hash_type type;
+    crypto_drv_func_enter();
+
+    hash_null_ptr_chk(drv_hash_handle);
+    hash_null_ptr_chk(hash_attr);
+    drv_hash_param_trace("hash_attr->hash_type is 0x%x\n", hash_attr->hash_type);
+
+    type = crypto_hash_remove_hmac_flag(hash_attr->hash_type);
+    crypto_chk_return(type != CRYPTO_HASH_TYPE_SHA1 && type != CRYPTO_HASH_TYPE_SHA224 &&
+        type != CRYPTO_HASH_TYPE_SHA256 && type != CRYPTO_HASH_TYPE_SHA384 &&
+        type != CRYPTO_HASH_TYPE_SHA512 && type != CRYPTO_HASH_TYPE_SM3,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is invalid!\n");
+
+    /* Lock one free Hash Hard Channel. */
+    ret = drv_hash_lock_chn(&chn_num);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("drv_hash_lock_chn failed\n");
+        return ret;
+    }
+
+    g_hash_ctx_list[chn_num] = crypto_malloc(sizeof(drv_hash_simple_context));
+    crypto_chk_goto_with_ret(ret, g_hash_ctx_list[chn_num] == NULL, error_hash_unlock,
+        ERROR_MALLOC, "crypto_malloc failed\n");
+    ctx = g_hash_ctx_list[chn_num];
+    (td_void)memset_s(ctx, sizeof(drv_hash_simple_context), 0, sizeof(drv_hash_simple_context));
+
+    ctx->data_buffer = crypto_malloc_mmz(CONFIG_HASH_DRV_BUFFER_SIZE, "crypto_hash_harden_support_buffer");
+    if (ctx->data_buffer == TD_NULL) {
+        crypto_log_err("hash data buff malloc failed\n");
+        ret = HASH_COMPAT_ERRNO(ERROR_MALLOC);
+        goto error_free_ctx;
+    }
+    ctx->data_buffer_len = CONFIG_HASH_DRV_BUFFER_SIZE;
+    ctx->hash_type = hash_attr->hash_type;
+    ctx->chn_num = chn_num;
+
+    /* Set Config. */
+    ret = drv_hash_get_state_iv(type, TD_NULL, ctx->state, sizeof(ctx->state));
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, err_mem_free, "drv_hash_get_state_iv failed\n");
+
+    ret = hal_cipher_hash_config(chn_num, type, ctx->state);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, err_mem_free, "hal_cipher_hash_config failed\n");
+
+    if (crypto_hash_is_hmac(hash_attr->hash_type) == TD_TRUE) {
+        if (hash_attr->is_keyslot) {
+#if defined(CONFIG_HASH_HMAC_KEYSLOT_SUPPORT)
+            ret = hal_cipher_hash_attach(chn_num, hash_attr->drv_keyslot_handle);
+            crypto_chk_goto(ret != CRYPTO_SUCCESS, err_mem_free, "hal_cipher_hash_attach failed\n");
+#else
+            crypto_log_err("hard hmac unsupport!\n");
+            ret = HASH_COMPAT_ERRNO(ERROR_UNSUPPORT);
+            goto err_mem_free;
+#endif
+        } else {
+#if defined(CONFIG_HASH_SOFT_HMAC_SUPPORT)
+            ret = inner_drv_hmac_start(ctx, hash_attr);
+            crypto_chk_goto(ret != TD_SUCCESS, err_mem_free, "inner_drv_hmac_start failed\n");
+#else
+            crypto_log_err("soft hmac unsupport!\n");
+            ret = HASH_COMPAT_ERRNO(ERROR_UNSUPPORT);
+            goto err_mem_free;
+#endif
+        }
+        ctx->is_keyslot = hash_attr->is_keyslot;
+    }
+
+    *drv_hash_handle = chn_num;
+    drv_hash_param_trace("create hash handle is 0x%x\n", *drv_hash_handle);
+    crypto_drv_func_exit();
+    return ret;
+err_mem_free:
+    crypto_free_coherent(ctx->data_buffer);
+error_free_ctx:
+    crypto_free(g_hash_ctx_list[chn_num]);
+    g_hash_ctx_list[chn_num] = NULL;
+error_hash_unlock:
+    (td_void)hal_hash_unlock(chn_num);
+    return ret;
+}
+
+td_s32 inner_drv_hash_process(td_u32 chn_num, drv_hash_simple_context *ctx,
+    td_u8 *data_buffer, td_u32 data_length, td_u32 node_type)
+{
+    td_s32 ret;
+
+    crypto_cache_flush((uintptr_t)data_buffer, data_length);
+    ret = hal_cipher_hash_add_in_node(chn_num, crypto_get_phys_addr(data_buffer), data_length, node_type);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_hash_add_in_node failed\n");
+
+    ret = hal_cipher_hash_start(chn_num, TD_FALSE);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_hash_start failed\n");
+
+    ret = hal_cipher_hash_wait_done(chn_num, ctx->state, sizeof(ctx->state));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_hash_wait_done failed\n");
+
+    return ret;
+}
+
+td_s32 drv_cipher_hash_update(td_handle drv_hash_handle,  const crypto_buf_attr *src_buf, const td_u32 len)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 chn_num = (td_u32)drv_hash_handle;
+    drv_hash_simple_context *ctx = TD_NULL;
+    td_u32 block_size;
+    td_u32 left = 0;
+    td_u32 tail_len = 0;
+    td_u32 processed_len = 0;
+    td_u32 processing_len = 0;
+    in_node_type_e node_type = IN_NODE_TYPE_FIRST;
+    crypto_drv_func_enter();
+
+    hash_null_ptr_chk(src_buf);
+    hash_null_ptr_chk(src_buf->virt_addr);
+    crypto_chk_return(len == 0 || len > CRYPTO_HASH_UPDATE_MAX_LEN, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "len is invalid\n");
+
+    drv_hash_param_trace("drv_hash_handle is 0x%x\n", drv_hash_handle);
+    drv_hash_param_trace("len is 0x%x\n", len);
+
+#if defined(CONFIG_HASH_TRACE_ENABLE)
+    crypto_dump_data("hash update", src_buf->virt_addr, len);
+#endif
+    ctx = inner_get_hash_ctx(drv_hash_handle);
+    crypto_chk_return(ctx == NULL, HASH_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed!\n");
+
+    if (ctx->is_keyslot == TD_FALSE) {
+        node_type |= IN_NODE_TYPE_LAST;
+    }
+
+    block_size = crypto_hash_get_block_size(ctx->hash_type) / CRYPTO_BITS_IN_BYTE;
+    left = len;
+    tail_len = ctx->tail_length;
+    if (tail_len + left < block_size) {
+        processing_len = left;
+        ret = memcpy_s(ctx->tail + tail_len, sizeof(ctx->tail) - tail_len,
+            src_buf->virt_addr, processing_len);
+        crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+        inner_drv_hash_length_add(ctx->length, len * CRYPTO_BITS_IN_BYTE);
+        ctx->tail_length += processing_len;
+        return TD_SUCCESS;
+    }
+
+    ret = memcpy_s(ctx->data_buffer, ctx->data_buffer_len, ctx->tail, tail_len);
+    crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    processing_len = block_size - tail_len;
+    ret = memcpy_s(ctx->data_buffer + tail_len, ctx->data_buffer_len - tail_len,
+        src_buf->virt_addr, processing_len);
+    crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = inner_drv_hash_process(chn_num, ctx, ctx->data_buffer, block_size, node_type);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_hash_process failed\n");
+
+    left -= processing_len;
+    processed_len += processing_len;
+    ctx->tail_length = 0;
+
+#if defined(CONFIG_SPACC_NONALIGNED_ADDR_SUPPORT)
+    processing_len = left - left % block_size;
+    if (processing_len != 0) {
+        ret = inner_drv_hash_process(chn_num, ctx, src_buf->virt_addr + processed_len, processing_len, node_type);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_hash_process failed\n");
+    }
+
+    left -= processing_len;
+    processed_len += processing_len;
+#else
+    while (left >= block_size) {
+        if (left >= ctx->data_buffer_len) {
+            processing_len = ctx->data_buffer_len;
+        } else {
+            processing_len = left - left % block_size;
+        }
+
+        ret = memcpy_s(ctx->data_buffer, ctx->data_buffer_len,
+            (td_u8 *)((uintptr_t)(src_buf->virt_addr) + processed_len), processing_len);
+        crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = inner_drv_hash_process(chn_num, ctx, ctx->data_buffer, processing_len, node_type);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_hash_process failed\n");
+
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+#endif
+    if (left != 0) {
+        ret = memcpy_s(ctx->tail, sizeof(ctx->tail),
+        (td_u8 *)((uintptr_t)(src_buf->virt_addr) + processed_len), left);
+        crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    }
+
+    ctx->tail_length = left;
+    inner_drv_hash_length_add(ctx->length, len * CRYPTO_BITS_IN_BYTE);
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_process_tail(td_u32 chn_num, drv_hash_simple_context *ctx)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 max_message_len = crypto_hash_get_message_len(ctx->hash_type) / CRYPTO_BITS_IN_BYTE;
+    td_u32 block_size = crypto_hash_get_block_size(ctx->hash_type) / CRYPTO_BITS_IN_BYTE;
+    td_u32 processing_len = 0;
+    td_u32 tail_length = ctx->tail_length;
+    td_u32 *length = ctx->length;
+    td_u32 tail_max_len = block_size * 2;   // 2: 2 blocks max
+    td_u8 *tail_buf = crypto_malloc_coherent(tail_max_len, "tail_buf");
+    crypto_chk_return(tail_buf == NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+    crypto_chk_return(tail_length >= block_size, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "tail_len is invalid!\n");
+
+    (void)memset_s(tail_buf, tail_max_len, 0, tail_max_len);
+
+    ret = memcpy_s(tail_buf, tail_max_len, ctx->tail, tail_length);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    if (tail_length + 1 + max_message_len > block_size) {
+        processing_len = tail_max_len;
+    } else {
+        processing_len = block_size;
+    }
+    tail_buf[tail_length] = 0x80;
+    if (ctx->is_keyslot) {
+        inner_drv_hash_length_add(length, block_size * CRYPTO_BITS_IN_BYTE);
+    }
+    length[1] = crypto_cpu_to_be32(length[1]);
+    length[0] = crypto_cpu_to_be32(length[0]);
+
+    ret = memcpy_s(tail_buf + processing_len - sizeof(ctx->length), sizeof(ctx->length),
+        length, sizeof(ctx->length));
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = inner_drv_hash_process(chn_num, ctx, tail_buf, processing_len, IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "inner_drv_hash_process failed\n");
+
+exit_free:
+    crypto_free_coherent(tail_buf);
+    return ret;
+}
+
+static td_s32 inner_hash_finish_common(td_handle drv_hash_handle, td_u8 *out, td_u32 *out_len, td_bool is_destroy)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 chn_num = (td_u32)drv_hash_handle;
+    drv_hash_simple_context *ctx = TD_NULL;
+    td_u32 result_size;
+
+    crypto_drv_func_enter();
+
+    hash_null_ptr_chk(out);
+    hash_null_ptr_chk(out_len);
+
+    ctx = inner_get_hash_ctx(drv_hash_handle);
+    crypto_chk_return(ctx == NULL, HASH_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed!\n");
+
+    result_size = crypto_hash_get_result_size(ctx->hash_type) / CRYPTO_BITS_IN_BYTE;
+    crypto_chk_return(*out_len < result_size, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "out's size is not enough\n");
+
+    /* Process the Tail Data. */
+    ret = drv_process_tail(chn_num, ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_hash_unlock, "drv_process_tail failed\n");
+
+    if (crypto_hash_is_hmac(ctx->hash_type) && ctx->is_keyslot == TD_FALSE) {
+#if defined(CONFIG_HASH_SOFT_HMAC_SUPPORT)
+        ret = inner_drv_hmac_finish(ctx, (uint8_t *)ctx->state, result_size);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_hash_unlock, "inner_drv_hmac_finish failed\n");
+#else
+        crypto_log_err("hmac without keyslot is unsupport\n");
+        ret = HASH_COMPAT_ERRNO(ERROR_UNSUPPORT);
+        goto exit_hash_unlock;
+#endif
+    }
+    ret = memcpy_s(out, *out_len, ctx->state, *out_len);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_hash_unlock,
+        HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    *out_len = result_size;
+    ret = CRYPTO_SUCCESS;
+exit_hash_unlock:
+    ctx->tail_length = 0;
+    if (is_destroy) {
+        if (ctx->data_buffer != TD_NULL) {
+            crypto_free_coherent(ctx->data_buffer);
+        }
+        hal_hash_unlock(chn_num);
+        crypto_free(g_hash_ctx_list[chn_num]);
+        g_hash_ctx_list[chn_num] = NULL;
+    }
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_hash_finish(td_handle drv_hash_handle, td_u8 *out, td_u32 *out_len)
+{
+    return inner_hash_finish_common(drv_hash_handle, out, out_len, TD_TRUE);
+}
+
+#if defined(CONFIG_HASH_HARDEN_INTERFACE_SUPPORT)
+td_s32 drv_cipher_hash_finish_data(td_handle drv_hash_handle, td_u8 *out, td_u32 *out_len)
+{
+    return inner_hash_finish_common(drv_hash_handle, out, out_len, TD_FALSE);
+}
+#endif
+
+td_s32 drv_cipher_hash_destroy(td_handle drv_hash_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 chn_num = (td_u32)drv_hash_handle;
+    drv_hash_simple_context *ctx = TD_NULL;
+
+    crypto_drv_func_enter();
+
+    ret = inner_hash_drv_handle_chk(drv_hash_handle);
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    ctx = inner_get_hash_ctx(drv_hash_handle);
+    crypto_chk_return(ctx == NULL, HASH_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed!\n");
+
+    if (ctx->data_buffer != TD_NULL) {
+        crypto_free_coherent(ctx->data_buffer);
+    }
+    hal_hash_unlock(chn_num);
+    crypto_free(g_hash_ctx_list[chn_num]);
+    g_hash_ctx_list[chn_num] = NULL;
+
+    crypto_drv_func_exit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_soft_hmac_simple.c b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_soft_hmac_simple.c
new file mode 100644
index 0000000..d9dab9c
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_hash_soft_hmac_simple.c
@@ -0,0 +1,97 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hash soft hmac source. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#include "drv_hash.h"
+#include "drv_hash_inner.h"
+
+#include "hal_hash.h"
+
+#include "crypto_drv_common.h"
+
+#if defined(CONFIG_HASH_SOFT_HMAC_SUPPORT)
+td_s32 inner_drv_hmac_start(drv_hash_simple_context *ctx, const crypto_hash_attr *hash_attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 i;
+    td_u32 block_size = crypto_hash_get_block_size(hash_attr->hash_type) / CRYPTO_BITS_IN_BYTE;
+    td_u8 *i_key_pad_buf = NULL;
+
+    if (hash_attr->key_len != 0) {
+        ret = memcpy_s(ctx->tail, sizeof(ctx->tail), hash_attr->key, hash_attr->key_len);
+        crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    }
+
+    /* Calc o_key_pad and i_key_pad */
+    for (i = 0; i < block_size; i++) {
+        ctx->o_key_pad[i] = 0x5c ^ ctx->tail[i];
+        ctx->i_key_pad[i] = 0x36 ^ ctx->tail[i];
+    }
+    inner_drv_hash_length_add(ctx->length, block_size * CRYPTO_BITS_IN_BYTE);
+
+    i_key_pad_buf = crypto_malloc_mmz(block_size, "i_key_pad_buf");
+    crypto_chk_return(i_key_pad_buf == NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_mmz failed\n");
+
+    ret = memcpy_s(i_key_pad_buf, block_size, ctx->i_key_pad, block_size);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = inner_drv_hash_process(ctx->chn_num, ctx, i_key_pad_buf, block_size,
+        IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "inner_drv_hash_process failed\n");
+
+exit_free:
+    memset_s(i_key_pad_buf, block_size, 0, block_size);
+    crypto_free_coherent(i_key_pad_buf);
+    return ret;
+}
+
+td_s32 inner_drv_hmac_finish(drv_hash_simple_context *ctx, td_u8 *out, td_u32 out_len)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u8 *buffer = NULL;
+    td_u32 *length = ctx->length;
+    td_u32 processed_len = 0;
+    td_u32 block_size = crypto_hash_get_block_size(ctx->hash_type) / 8; // 8 means 1 byte = 8 bits
+    td_u32 buffer_len = block_size * 2;
+
+    buffer = crypto_malloc_mmz(buffer_len, "hmac_tail_buf");
+    crypto_chk_return(buffer == NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_mmz failed\n");
+
+    (td_void)memset_s(buffer, buffer_len, 0, buffer_len);
+    /* Copy o_key_pad */
+    ret = memcpy_s(buffer, buffer_len, ctx->o_key_pad, block_size);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    processed_len += block_size;
+
+    /* Copy hash. */
+    ret = memcpy_s(buffer + processed_len, buffer_len - processed_len, out, out_len);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    processed_len += out_len;
+    buffer[processed_len] = 0x80;
+    length[1] = crypto_cpu_to_be32(processed_len * 8); // 8 means 1 byte = 8 bits
+    ret = memcpy_s(buffer + 2 * block_size - sizeof(ctx->length), // 2 block offset
+        sizeof(ctx->length), length, sizeof(ctx->length));
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = drv_hash_get_state_iv(ctx->hash_type, TD_NULL, ctx->state, sizeof(ctx->state));
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "drv_hash_get_state_iv failed\n");
+
+    ret = hal_cipher_hash_config(ctx->chn_num, ctx->hash_type, ctx->state);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_hash_config failed\n");
+
+    ret = inner_drv_hash_process(ctx->chn_num, ctx, buffer, 2 * block_size,  // 2 block_size needed
+        IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "inner_drv_hash_process failed\n");
+
+exit_free:
+    memset_s(buffer, buffer_len, 0, buffer_len);
+    crypto_free_coherent(buffer);
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_pbkdf2_hard.c b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_pbkdf2_hard.c
new file mode 100644
index 0000000..e99d98a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_pbkdf2_hard.c
@@ -0,0 +1,534 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+#if defined(CONFIG_HASH_PBKDF2_HARD_SUPPORT)
+#include "drv_hash.h"
+#include "drv_hash_inner.h"
+#include "drv_trng.h"
+
+#include "hal_hash.h"
+
+#include "crypto_drv_common.h"
+
+#define PBKDF2_COMPAT_ERRNO(err_code)     DRV_COMPAT_ERRNO(ERROR_MODULE_HASH, err_code)
+#define pbkdf2_null_ptr_chk(ptr)   \
+    crypto_chk_return((ptr) == TD_NULL, PBKDF2_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), #ptr" is NULL\n")
+#define CRYPTO_U8_TO_U32_BIT_SHIFT(data, i) \
+    ((td_u32)(data)[(i)*4]  | ((td_u32)(data)[(i)*4+1] << 8) | ((td_u32)(data)[(i)*4+2] << 16) | \
+    ((td_u32)(data)[(i)*4+3]<< 24))
+
+/* Current CPU ID Status .
+8'h35: AIDSP;
+8'h6a: PCPU;
+8'ha5: TEE;
+8'haa: ACPU.
+*/
+#define PCPU_STAT     0x6a
+#define AIDSP_STAT    0x35
+#define TEE_STAT      0xa5
+#define ACPU_STAT     0xaa
+
+/* KDF */
+
+#define KM_CPU_PCPU  4
+#define KM_CPU_AIDSP 5
+#define KM_CPU_TEE   2
+#define KM_CPU_REE   1
+#define KM_CPU_IDLE  0
+
+#define PBKDF2_ALG_HMAC_SHA1       1
+#define PBKDF2_ALG_HMAC_SHA256     0
+#define PBKDF2_ALG_HMAC_SHA384     3
+#define PBKDF2_ALG_HMAC_SHA512     4
+#define PBKDF2_ALG_HMAC_SM3        5
+
+#define HMAC_SHA1_OUTPUT_LEN       20
+#define HMAC_SHA256_OUTPUT_LEN     32
+#define HMAC_SHA384_OUTPUT_LEN     48
+#define HMAC_SHA512_OUTPUT_LEN     64
+#define HMAC_SM3_OUTPUT_LEN        32
+
+#define KDF_KEY_BLOCK_SIZE_512     64
+#define KDF_KEY_BLOCK_SIZE_1024    128
+#define KDF_KEY_CONFIG_LEN         32
+#define KDF_SALT_CONFIG_LEN        32
+#define KDF_VAL_CONFIG_LEN         16
+#define KDF_ALG_TYPE               5
+#define DRV_KDF_OTP_KEY_MRK1       0
+#define DRV_KDF_OTP_KEY_USK        1
+#define DRV_KDF_OTP_KEY_RUSK       2
+
+/*
+    pbkdf2_key_config
+*/
+#define KDF_SW_GEN              3
+
+/*
+ * rkp
+ */
+#define RKP_LOCK                (0x000)
+#define RKP_CMD_CFG             (0x004)
+#define KDF_ERROR               (0x008)
+#define RKP_DEOB_CFG            (0x020)
+#define DEOB_ERROR              (0x028)
+#define RK_RDY                  (0x050)
+#define RKP_USD_DIS             (0x054)
+#define RKP_LOW_POWER           (0x058)
+#define RKP_INIT                (0x05C)
+#define SW_CFG                  (0x060)
+#define RKP_RAW_INT             (0x010)
+#define RKP_INT_ENABLE          (0x014)
+#define RKP_INT                 (0x018)
+#define RKP_PBKDF2_DATA(a)      (0x100 + 4 * (a)) /* a 0~31 */
+#define RKP_PBKDF2_KEY(a)       (0x180 + 4 * (a)) /* a 0~31 */
+#define RKP_PBKDF2_VAL(b)       (0x200 + 4 * (b)) /* b 0~16 */
+#define RKP_USD(c)              (0x300 + 4 * (c)) /* c 0~8 */
+
+/* salt len */
+#define SALT_RESERVED_LEN_512   21
+#define SALT_RESERVED_LEN_256   13
+
+/* Define the union U_RKP_RKP_LOCK */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    km_lock_status            : 3; /* [2..0]  */
+        unsigned int    reserved                  : 29; /* [31..3]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} rkp_lock;
+
+/* Define the union U_RKP_CMD_CFG */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    sw_calc_req               : 1; /* [0]  */
+        unsigned int    pbkdf2_alg_sel_cfg        : 3; /* [3..1]  */
+        unsigned int    pbkdf2_key_sel_cfg        : 5; /* [8..4]  */
+        unsigned int    reserved                  : 7; /* [15..9]  */
+        unsigned int    rkp_pbkdf_calc_time       : 16; /* [31..16]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} rkp_cmd_cfg;
+
+static td_s32 priv_wait_rkp_to_be_lock(void)
+{
+    rkp_lock lock_val = {0};
+    td_u32 rkp_config_val = KM_CPU_IDLE;
+    crypto_cpu_type cpu = crypto_get_cpu_type();
+    switch (cpu) {
+        case CRYPTO_CPU_TYPE_SCPU:
+            rkp_config_val = KM_CPU_TEE;
+            break;
+        case CRYPTO_CPU_TYPE_ACPU:
+            rkp_config_val = KM_CPU_REE;
+            break;
+        default:
+            return PBKDF2_COMPAT_ERRNO(ERROR_UNEXPECTED);
+    }
+
+    km_reg_write(RKP_LOCK, rkp_config_val);
+    lock_val.u32 = km_reg_read(RKP_LOCK);
+    if (lock_val.bits.km_lock_status != rkp_config_val) {
+        return PBKDF2_COMPAT_ERRNO(ERROR_CHN_BUSY);
+    }
+
+    return TD_SUCCESS;
+}
+
+#define RKP_TIME_OUT                1000000
+static td_s32 priv_rkp_lock(td_void)
+{
+    td_u32 i = 0;
+    td_s32 ret;
+
+    for (i = 0; i < RKP_TIME_OUT; i++) {
+        ret = priv_wait_rkp_to_be_lock();
+        if (ret == TD_SUCCESS) {
+            break;
+        }
+        crypto_udelay(1);
+    }
+
+    if (i >= RKP_TIME_OUT) {
+        crypto_log_err("priv_rkp_lock busy.\n");
+        return PBKDF2_COMPAT_ERRNO(ERROR_RKP_LOCK_TIMEOUT);
+    }
+
+    return TD_SUCCESS;
+}
+
+static td_void priv_rkp_unlock(void)
+{
+    km_reg_write(RKP_LOCK, KM_CPU_IDLE);
+}
+
+static td_s32 priv_kdf_param_salt_padding(td_u8 *salt_pad, td_u32 pad_len, td_u32 block_len,
+    const crypto_kdf_pbkdf2_param *param, td_u32 cnt_bit)
+{
+    td_u32 i = 0;
+    td_u32 j = 0;
+    td_u32 salt_pad_total_len = 0;
+    td_u32 random_val = 0;
+    td_s32 ret;
+    crypto_unused(pad_len);
+    /* Formatting of the PBKDF2 salt Padding
+     * The PBKDF2 salt Padding formatted as shown below:
+     *                        big endian
+     *         salt length || 32 bit(i) || 1 bit(1) || 2 word tail length
+     *
+     * sm3:
+     * sha1:
+     * sha256:   salt_len  ||   32 bit  ||   8 bit  ||  64 bit
+     *
+     * sha384:
+     * sha512:   salt_len  ||   32 bit  ||   8 bit  ||  128 bit
+     */
+    ret = drv_cipher_trng_get_random(&random_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_random failed\n");
+
+    for (i = 0, j = random_val % param->slen; i < param->slen; i++) {
+        salt_pad[j] = param->salt[j]; /* copy salt */
+        j++;
+        j %= param->slen;
+    }
+
+    salt_pad[i + 3] = cnt_bit & 0xff;         /* 3: need fill 32bit i, big endian padding */
+    salt_pad[i + 2] = (cnt_bit >> 8) & 0xff;  /* 2/8: need fill 32bit i, big endian padding */
+    salt_pad[i + 1] = (cnt_bit >> 16) & 0xff; /* 16: need fill 32bit i, big endian padding */
+    salt_pad[i] = (cnt_bit >> 24) & 0xff;     /* 24: need fill 32bit i, big endian padding */
+    salt_pad[i + 4] = 0x80;                   /* 4: message data fill 1 */
+
+    if (block_len == KDF_KEY_BLOCK_SIZE_512) {
+        /* need to connect i_key_pad length, the i_key_pad length is block size */
+        salt_pad_total_len = KDF_KEY_BLOCK_SIZE_512 * CRYPTO_BITS_IN_BYTE;
+    } else {
+        /* need to connect i_key_pad length, the i_key_pad length is block size */
+        salt_pad_total_len = KDF_KEY_BLOCK_SIZE_1024 * CRYPTO_BITS_IN_BYTE;
+    }
+    salt_pad_total_len += 32 + param->slen * 8;          /* length: 32 bit i + slen * 8 */
+
+    salt_pad[block_len - 1] = salt_pad_total_len & 0xff;
+    salt_pad[block_len - 2] = (salt_pad_total_len >> 8) & 0xff;  /* 2: 2bit 8: right move 8 */
+    salt_pad[block_len - 3] = (salt_pad_total_len >> 16) & 0xff; /* 3: 3bit 16: right move 16 */
+    salt_pad[block_len - 4] = (salt_pad_total_len >> 24) & 0xff; /* 4: 4bit 24: right move 24 */
+
+    return TD_SUCCESS;
+}
+
+
+static td_s32 priv_kdf_config_val(crypto_hash_type hash_type)
+{
+    td_u32 i = 0;
+    td_s32 ret = TD_SUCCESS;
+    td_u32 val_len = 0;
+    td_u32 state_iv[64];
+
+    ret = drv_hash_get_state_iv(hash_type, &val_len, state_iv, sizeof(state_iv));
+    if (ret != TD_SUCCESS) {
+        return PBKDF2_COMPAT_ERRNO(ERROR_UNEXPECTED);
+    }
+
+    val_len /= CRYPTO_WORD_WIDTH;
+
+    for (i = 0; i < val_len; i++) {
+        km_reg_write(RKP_PBKDF2_VAL(i), state_iv[i]);
+    }
+
+    return TD_SUCCESS;
+}
+
+static td_s32 priv_kdf_config_data(const td_u8 *pswd_pad, td_u32 pswd_len, const td_u8 *salt_pad, td_u32 salt_len)
+{
+    td_u32 ret;
+    td_u32 i = 0;
+    td_u32 j = 0;
+    td_u32 random_val = 0;
+    td_u32 x = sizeof(td_u32) / sizeof(td_u8);
+    td_u32 pswd_tmp = 0;
+    td_u32 salt_tmp = 0;
+
+    if (pswd_len != KDF_KEY_CONFIG_LEN * x ||
+        salt_len != KDF_KEY_CONFIG_LEN * x) {
+        return PBKDF2_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    ret = drv_cipher_trng_get_random(&random_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_random failed\n");
+
+    for (i = 0, j = random_val % KDF_KEY_CONFIG_LEN; i < KDF_KEY_CONFIG_LEN; i++) {
+        pswd_tmp = CRYPTO_U8_TO_U32_BIT_SHIFT(pswd_pad, j);
+        km_reg_write(RKP_PBKDF2_KEY(j), pswd_tmp);
+        j++;
+        j %= KDF_KEY_CONFIG_LEN;
+    }
+
+    ret = drv_cipher_trng_get_random(&random_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_random failed\n");
+
+    for (i = 0, j = random_val % KDF_SALT_CONFIG_LEN; i < KDF_SALT_CONFIG_LEN; i++) {
+        salt_tmp = CRYPTO_U8_TO_U32_BIT_SHIFT(salt_pad, j);
+        km_reg_write(RKP_PBKDF2_DATA(j), salt_tmp);
+        j++;
+        j %= KDF_SALT_CONFIG_LEN;
+    }
+
+    return TD_SUCCESS;
+}
+
+static td_void priv_kdf_sw_config_start(td_u32 alg_cfg, td_u16 count)
+{
+    rkp_cmd_cfg cfgval = {0};
+
+    cfgval.u32 = km_reg_read(RKP_CMD_CFG);
+    cfgval.bits.rkp_pbkdf_calc_time = count;
+    cfgval.bits.pbkdf2_alg_sel_cfg = alg_cfg;
+    cfgval.bits.pbkdf2_key_sel_cfg = KDF_SW_GEN;
+    cfgval.bits.sw_calc_req = 0x1;         /* start calculation */
+    km_reg_write(RKP_CMD_CFG, cfgval.u32);
+}
+
+static td_s32 priv_rkp_wait_idle(void)
+{
+    rkp_cmd_cfg cfg_val = {0};
+    td_s32 ret;
+    td_u32 i = 0;
+
+    for (i = 0; i < RKP_TIME_OUT; ++i) {
+        cfg_val.u32 = km_reg_read(RKP_CMD_CFG);
+        if (cfg_val.bits.sw_calc_req == 0x0) {
+            km_reg_write(RKP_RAW_INT, 0x1);
+            break;
+        }
+        crypto_udelay(1);
+    }
+    if (i < RKP_TIME_OUT) {
+        ret = TD_SUCCESS;
+    } else {
+        ret = PBKDF2_COMPAT_ERRNO(ERROR_RKP_CALC_TIMEOUT);
+    }
+
+    return ret;
+}
+
+static td_void priv_rkp_chk_err(void)
+{
+    td_s32 kdf_err;
+
+    kdf_err = km_reg_read(KDF_ERROR);
+    if (kdf_err != 0) {
+        crypto_log_err("KDF Error: 0x%x\n", kdf_err);
+    }
+}
+
+static td_s32 priv_kdf_calculation(const crypto_kdf_pbkdf2_param *param, td_u32 alg_cfg, td_u32 block_size,
+    td_u32 cnt_bit)
+{
+    td_u8 kdf_passwd_pad[KDF_KEY_BLOCK_SIZE_1024];
+    td_u8 kdf_salt_pad[KDF_KEY_BLOCK_SIZE_1024];
+
+    td_s32 ret;
+
+    (td_void)memset_s(kdf_passwd_pad, KDF_KEY_BLOCK_SIZE_1024, 0, KDF_KEY_BLOCK_SIZE_1024);
+    (td_void)memset_s(kdf_salt_pad, KDF_KEY_BLOCK_SIZE_1024, 0, KDF_KEY_BLOCK_SIZE_1024);
+
+    /* password padding */
+    if (param->plen != 0) {
+        ret = memcpy_s(kdf_passwd_pad, KDF_KEY_BLOCK_SIZE_1024, param->password, param->plen);
+        crypto_chk_return(ret != EOK, ret, "memcpy_s failed\n");
+    }
+
+    /* salt padding */
+    ret = priv_kdf_param_salt_padding(kdf_salt_pad, KDF_KEY_BLOCK_SIZE_1024, block_size, param, cnt_bit);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "priv_kdf_param_salt_padding failed\n");
+
+    ret = priv_kdf_config_val(param->hash_type);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "priv_kdf_config_val failed\n");
+
+    ret = priv_kdf_config_data(kdf_passwd_pad, KDF_KEY_BLOCK_SIZE_1024, kdf_salt_pad, KDF_KEY_BLOCK_SIZE_1024);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "priv_kdf_config_data failed\n");
+
+    priv_kdf_sw_config_start(alg_cfg, param->count);
+    ret = priv_rkp_wait_idle();
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "priv_rkp_wait_idle failed\n");
+
+    priv_rkp_chk_err();
+
+exit_clean:
+    (td_void)memset_s(kdf_passwd_pad, KDF_KEY_BLOCK_SIZE_1024, 0, KDF_KEY_BLOCK_SIZE_1024);
+    (td_void)memset_s(kdf_salt_pad, KDF_KEY_BLOCK_SIZE_1024, 0, KDF_KEY_BLOCK_SIZE_1024);
+    return ret;
+}
+
+static td_void priv_kdf_clear_reg_key(td_void)
+{
+    td_u32 i = 0;
+    td_u32 clear_key_val = 0;
+
+    (td_void)drv_cipher_trng_get_random(&clear_key_val);
+
+    for (i = 0; i < KDF_KEY_CONFIG_LEN; i++) {
+        km_reg_write(RKP_PBKDF2_KEY(i), clear_key_val);
+    }
+
+    for (i = 0; i < KDF_SALT_CONFIG_LEN; i++) {
+        km_reg_write(RKP_PBKDF2_DATA(i), clear_key_val);
+    }
+
+    for (i = 0; i < KDF_VAL_CONFIG_LEN; i++) {
+        km_reg_write(RKP_PBKDF2_VAL(i), clear_key_val);
+    }
+}
+
+#define PBKDF2_ALG_HMAC_SHA256     0
+#define PBKDF2_ALG_HMAC_SHA384     3
+#define PBKDF2_ALG_HMAC_SHA512     4
+#define PBKDF2_ALG_HMAC_SM3        5
+
+static td_s32 priv_get_alg_cfg(crypto_hash_type hash_type, td_u32 *alg_cfg, td_u32 *block_size, td_u32 *out_key_len)
+{
+    *block_size = crypto_hash_get_block_size(hash_type) / CRYPTO_BITS_IN_BYTE;
+    *out_key_len = crypto_hash_get_result_size(hash_type) / CRYPTO_BITS_IN_BYTE;
+    switch (hash_type) {
+        case CRYPTO_HASH_TYPE_HMAC_SHA256:
+            *alg_cfg = PBKDF2_ALG_HMAC_SHA256;
+            break;
+        case CRYPTO_HASH_TYPE_HMAC_SHA384:
+            *alg_cfg = PBKDF2_ALG_HMAC_SHA384;
+            break;
+        case CRYPTO_HASH_TYPE_HMAC_SHA512:
+            *alg_cfg = PBKDF2_ALG_HMAC_SHA512;
+            break;
+        case CRYPTO_HASH_TYPE_HMAC_SM3:
+            *alg_cfg = PBKDF2_ALG_HMAC_SM3;
+            break;
+        default:
+            return PBKDF2_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return TD_SUCCESS;
+}
+
+static td_s32 priv_kdf_output_key_remain(td_u8 *out, const td_u32 out_len, td_u32 out_key_len, td_u32 cnt_count,
+    td_u32 remain_num)
+{
+    td_s32 ret;
+    td_u32 i = 0;
+    td_u32 readval[KDF_VAL_CONFIG_LEN];
+    for (i = 0; i < out_key_len / CRYPTO_WORD_WIDTH; i++) {
+        readval[i] = km_reg_read(RKP_PBKDF2_VAL(i));
+    }
+
+    ret = memcpy_s(out + cnt_count * out_key_len, out_len - cnt_count * out_key_len, readval, remain_num);
+    crypto_chk_return(ret != EOK, PBKDF2_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return TD_SUCCESS;
+}
+
+static td_s32 priv_kdf_output_key(td_u8 *out, const td_u32 out_len, td_u32 out_key_len, td_u32 cnt_count)
+{
+    td_u32 i = 0;
+    td_u32 j = 0;
+    td_u32 readval[KDF_VAL_CONFIG_LEN];
+    td_u32 random_val = 0;
+    td_u32 ret;
+    
+    ret = drv_cipher_trng_get_random(&random_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_random failed\n");
+
+    for (i = 0, j = random_val % (out_key_len / CRYPTO_WORD_WIDTH); i < out_key_len / CRYPTO_WORD_WIDTH; i++) {
+        readval[j] = km_reg_read(RKP_PBKDF2_VAL(j));
+        j++;
+        j %= (out_key_len / CRYPTO_WORD_WIDTH);
+    }
+
+    ret = memcpy_s(out + cnt_count * out_key_len, out_len - cnt_count * out_key_len, readval, out_key_len);
+    crypto_chk_return(ret != EOK, PBKDF2_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return TD_SUCCESS;
+}
+
+td_s32 drv_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len)
+{
+    td_s32 ret;
+    td_u32 alg_cfg = 0;
+    td_u32 block_size = 0;
+    td_u32 out_key_len = 0;
+    td_u32 cal_count = 0;
+    td_u32 remain_num = 0;
+    td_u32 i = 0;
+
+    pbkdf2_null_ptr_chk(param);
+    pbkdf2_null_ptr_chk(out);
+    if (param->plen != 0) {
+        pbkdf2_null_ptr_chk(param->password);
+    }
+    if (param->slen != 0) {
+        pbkdf2_null_ptr_chk(param->salt);
+    }
+
+    if (param->hash_type == CRYPTO_HASH_TYPE_HMAC_SM3) {
+        crypto_chk_return(crypto_sm3_support() == TD_FALSE, PBKDF2_COMPAT_ERRNO(ERROR_UNSUPPORT),
+            "SM3 alg is unsupport\n");
+    }
+
+    ret = priv_get_alg_cfg(param->hash_type, &alg_cfg, &block_size, &out_key_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_get_alg_cfg failed\n");
+    crypto_chk_return(param->plen > block_size, PBKDF2_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "plen should not be Bigger Than Block Size!\n");
+    crypto_chk_return(out_key_len == 0, PBKDF2_COMPAT_ERRNO(ERROR_INVALID_PARAM), "out_key_len is Invalid!\n");
+
+    /* Formatting of the PBKDF2 salt Padding
+     * The PBKDF2 salt Padding formatted as shown below:
+     *                        big endian
+     *         salt length || 32 bit(i) || 1 bit(1) || 2 word tail length
+     *
+     * sm3:
+     * sha1:
+     * sha256:   salt_len  ||   4 byte  ||   1 byte  ||  8 byte
+     * so salt_len smaller block_size - (4 + 1 + 8 = 13)
+     * sha384:
+     * sha512:   salt_len  ||   4 byte  ||   1 byte  ||  16 byte
+     * so salt_len smaller block_size - (4 + 1 + 16 = 21)
+     */
+    if (block_size == KDF_KEY_BLOCK_SIZE_512) {
+        crypto_chk_return(param->slen > block_size - SALT_RESERVED_LEN_256, PBKDF2_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "Invalid Salt Len!\n");   /* 13: byte */
+    } else {
+        crypto_chk_return(param->slen > block_size - SALT_RESERVED_LEN_512, PBKDF2_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "Invalid Salt Len!\n");   /* 21: byte */
+    }
+
+    remain_num = out_len % out_key_len;      /* residual processing */
+    if (remain_num != 0) {
+        cal_count = (out_len / out_key_len) + 1;  /* if remain_num is not 0, need to calculate one more block. */
+    } else {
+        cal_count = out_len / out_key_len;
+    }
+    ret = priv_rkp_lock();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_rkp_lock failed\n");
+
+    for (i = 0; i < cal_count; i++) {
+        ret = priv_kdf_calculation(param, alg_cfg, block_size, i + 1);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_rkp_unlock, "priv_kdf_calculation failed\n");
+        if (remain_num != 0) {
+            if (i == cal_count - 1) { /* calculation the last conut */
+                ret = priv_kdf_output_key_remain(out, out_len, out_key_len, i, remain_num);
+                crypto_chk_goto(ret != TD_SUCCESS, exit_rkp_unlock, "priv_kdf_output_key_remain failed\n");
+            } else {
+                ret = priv_kdf_output_key(out, out_len, out_key_len, i);
+                crypto_chk_goto(ret != TD_SUCCESS, exit_rkp_unlock, "priv_kdf_output_key failed\n");
+            }
+        } else {
+            ret = priv_kdf_output_key(out, out_len, out_key_len, i);
+            crypto_chk_goto(ret != TD_SUCCESS, exit_rkp_unlock, "priv_kdf_output_key failed\n");
+        }
+    }
+
+exit_rkp_unlock:
+    priv_kdf_clear_reg_key();    /* clear key */
+    priv_rkp_unlock();     /* unlock rkp */
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_pbkdf2_soft.c b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_pbkdf2_soft.c
new file mode 100644
index 0000000..85a0102
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/hash/drv_pbkdf2_soft.c
@@ -0,0 +1,160 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: pbkdf2 soft alg source. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#if defined(CONFIG_HASH_PBKDF2_SOFT_SUPPORT)
+#include "drv_hash.h"
+
+#include "hal_hash.h"
+
+#include "crypto_drv_common.h"
+
+#define HASH_COMPAT_ERRNO(err_code)     DRV_COMPAT_ERRNO(ERROR_MODULE_HASH, err_code)
+
+static td_s32 priv_hmac(const crypto_kdf_pbkdf2_param *param, td_u8 *data, td_u32 data_len,
+    td_u8 *hmac, td_u32 *out_hmac_len)
+{
+    td_s32 ret;
+    td_handle drv_hash_handle = 0xffffffff;
+    crypto_hash_attr hash_attr = {0};
+    crypto_buf_attr src_buf = {0};
+    td_u8 *key = param->password;
+    td_u32 key_len = param->plen;
+    crypto_hash_type hash_type = param->hash_type;
+
+    src_buf.virt_addr = data;
+    hash_attr.hash_type = hash_type;
+    hash_attr.key = key;
+    hash_attr.key_len = key_len;
+    ret = drv_cipher_hash_start(&drv_hash_handle, &hash_attr);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("drv_cipher_hash_start failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    ret = drv_cipher_hash_update(drv_hash_handle, &src_buf, data_len);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("drv_cipher_hash_update failed, ret is 0x%x\n", ret);
+        (td_void)drv_cipher_hash_finish(drv_hash_handle, hmac, out_hmac_len);
+        return ret;
+    }
+
+    ret = drv_cipher_hash_finish(drv_hash_handle, hmac, out_hmac_len);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("drv_cipher_hash_finish failed, ret is 0x%x\n", ret);
+    }
+    return ret;
+}
+
+static td_void priv_pbkdf2_parse_param(const crypto_kdf_pbkdf2_param *param, td_u32 out_len,
+    td_u32 *result_size, td_u32 *times)
+{
+    td_u32 remain_size = 0;
+    *result_size = crypto_hash_get_result_size(param->hash_type) / CRYPTO_BITS_IN_BYTE;
+
+    *times = out_len / (*result_size);
+    remain_size = out_len - (*result_size) * (*times);
+
+    if (remain_size != 0) {
+        (*times)++;
+    }
+}
+
+td_s32 inner_pbkdf2_param_chk(const crypto_kdf_pbkdf2_param *param, td_u8 *out, td_u32 out_len)
+{
+    crypto_hash_type type;
+    td_u32 block_size = 0;
+
+    crypto_chk_return(param == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "param is NULL\n");
+    crypto_chk_return(out == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "param is NULL\n");
+
+    if (param->plen != 0) {
+        crypto_chk_return(param->password == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "password is NULL\n");
+    }
+    if (param->slen != 0) {
+        crypto_chk_return(param->salt == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "salt is NULL\n");
+    }
+    crypto_chk_return(param->count == 0, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "count is invalid\n");
+
+    crypto_chk_return(out_len == 0 || out_len >= CRYPTO_PBKDF2_OUT_MAX_LENGTH,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "out_len is invalid\n");
+    crypto_chk_return(param->slen > CRYPTO_PBKDF2_SALT_MAX_LENGTH,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "slen is invalid!\n");
+
+    type = param->hash_type;
+    crypto_chk_return(type != CRYPTO_HASH_TYPE_HMAC_SHA224 &&
+        type != CRYPTO_HASH_TYPE_HMAC_SHA256 && type != CRYPTO_HASH_TYPE_HMAC_SHA384 &&
+        type != CRYPTO_HASH_TYPE_HMAC_SHA512 && type != CRYPTO_HASH_TYPE_HMAC_SM3,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is invalid!\n");
+    block_size = crypto_hash_get_block_size(type) / CRYPTO_BITS_IN_BYTE;
+    /* plen should not larger than block_size. */
+    crypto_chk_return(param->plen > block_size, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "plen should not larger than block_size\n");
+
+    return TD_SUCCESS;
+}
+
+td_s32 drv_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u8 *data = TD_NULL;
+    td_u32 data_len;
+    td_u8 hmac[64] = {0};
+    td_u8 result_hmac[64] = {0};
+    td_u32 hmac_len = 64;
+    td_u32 i, j, k;
+    td_u32 result_size;
+    td_u32 times;
+    td_u32 value;
+    crypto_drv_func_enter();
+
+    ret = inner_pbkdf2_param_chk(param, out, out_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pbkdf2_param_chk failed\n");
+
+    priv_pbkdf2_parse_param(param, out_len, &result_size, &times);
+
+    data_len = param->slen + sizeof(td_u32);
+    data = (td_u8 *)crypto_malloc_mmz(data_len, "crypto_pbkdf2_buffer");
+    crypto_chk_return(data == TD_NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_mmz failed\n");
+
+    if (param->slen != 0) {
+        ret = memcpy_s(data, data_len, param->salt, param->slen);
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    }
+
+    for (i = 0; i < times; i++) {
+        value = crypto_cpu_to_be32(i + 1);
+        (td_void)memcpy_s(data + param->slen, sizeof(td_u32), &value, sizeof(td_u32));
+
+        ret = priv_hmac(param, data, data_len, hmac, &hmac_len);
+        crypto_chk_goto(ret != EOK, exit_free, "priv_hmac failed\n");
+
+        ret = memcpy_s(result_hmac, sizeof(result_hmac), hmac, hmac_len);
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        for (j = 1; j < param->count; j++) {
+            ret = priv_hmac(param, hmac, hmac_len, hmac, &hmac_len);
+            crypto_chk_goto(ret != EOK, exit_free, "priv_hmac failed\n");
+
+            for (k = 0; k < hmac_len; k++) {
+                result_hmac[k] ^= hmac[k];
+            }
+        }
+        if (hmac_len <= out_len - i * result_size) {
+            ret = memcpy_s(out + i * result_size, out_len - i * result_size, result_hmac, hmac_len);
+        } else {
+            ret = memcpy_s(out + i * result_size, out_len - i * result_size, result_hmac, out_len - i * result_size);
+        }
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    }
+exit_free:
+    (td_void)memset_s(data, data_len, 0, data_len);
+    crypto_free_coherent(data);
+    crypto_drv_func_exit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/km/drv_keyslot.c b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_keyslot.c
new file mode 100644
index 0000000..89357b2
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_keyslot.c
@@ -0,0 +1,75 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver keyslot. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "drv_keyslot.h"
+#include "hal_keyslot.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#define EXT_ID_KM      0x55
+
+#define id_2_handle(id, key)    \
+    (td_handle)((((EXT_ID_KM) & 0xff) << 24) | ((((key) & 0xff)<< 16)) | (((id) & 0xffff)))
+#define handle_2_modid(handle)      (((handle) >> 24) & 0xff)
+#define handle_2_id(handle)         (((handle)) & 0xffff)
+#define handle_get_type(handle)     (((handle) >> 16) & 0xff)
+
+#define KEYSLOT_MCIPHER_KEYSLOT_CNT     8
+#define KEYSLOT_HMAC_KEYSLOT_CNT        2
+
+#define KM_COMPAT_ERRNO(err_code)     DRV_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+td_s32 drv_keyslot_init(td_void)
+{
+    return TD_SUCCESS;
+}
+
+td_s32 drv_keyslot_deinit(td_void)
+{
+    return TD_SUCCESS;
+}
+
+td_s32 drv_keyslot_create(td_handle *keyslot_handle, crypto_keyslot_type keyslot_type)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 i;
+    td_u32 keyslot_cnt = 0;
+    km_null_ptr_chk(keyslot_handle);
+
+    if (keyslot_type == CRYPTO_KEYSLOT_TYPE_MCIPHER) {
+        keyslot_cnt = KEYSLOT_MCIPHER_KEYSLOT_CNT;
+    } else if (keyslot_type == CRYPTO_KEYSLOT_TYPE_HMAC) {
+        keyslot_cnt = KEYSLOT_HMAC_KEYSLOT_CNT;
+    } else {
+        crypto_log_err("invalid keyslot_type\n");
+        return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    for (i = 0; i < keyslot_cnt; i++) {
+        ret = hal_keyslot_lock(i, keyslot_type);
+        if (ret == TD_SUCCESS) {
+            break;
+        }
+    }
+    if (i >= keyslot_cnt) {
+        crypto_log_err("all keyslot channels are busy\n");
+        return KM_COMPAT_ERRNO(ERROR_CHN_BUSY);
+    }
+
+    *keyslot_handle = id_2_handle(i, (td_u32)keyslot_type);
+    return ret;
+}
+
+td_s32 drv_keyslot_destroy(td_handle keyslot_handle)
+{
+    crypto_keyslot_type keyslot_type_get = handle_get_type(keyslot_handle);
+
+    return hal_keyslot_unlock(handle_2_id(keyslot_handle), keyslot_type_get);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad.c b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad.c
new file mode 100644
index 0000000..0b019ec
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad.c
@@ -0,0 +1,161 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver klad. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "drv_klad.h"
+#include "drv_klad_inner.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#include "hal_klad.h"
+#include "hal_rkp.h"
+
+static drv_klad_context g_klad_ctx = {0};
+
+#define KLAD_VALID_HANDLE       0x2D3C4B5A
+drv_klad_context *inner_klad_get_ctx(void)
+{
+    return &g_klad_ctx;
+}
+
+td_s32 drv_klad_create(td_handle *klad_handle)
+{
+    crypto_drv_func_enter();
+
+    km_null_ptr_chk(klad_handle);
+
+    (td_void)memset_s(&g_klad_ctx, sizeof(drv_klad_context), 0, sizeof(drv_klad_context));
+
+    g_klad_ctx.is_open = TD_TRUE;
+
+    *klad_handle = KLAD_VALID_HANDLE;
+    crypto_drv_func_enter();
+    return TD_SUCCESS;
+}
+
+td_s32 drv_klad_destroy(td_handle klad_handle)
+{
+    crypto_drv_func_enter();
+
+    crypto_chk_return(klad_handle != KLAD_VALID_HANDLE, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid klad_handle\n");
+    if (g_klad_ctx.is_open == TD_FALSE) {
+        return TD_SUCCESS;
+    }
+    (td_void)memset_s(&g_klad_ctx, sizeof(drv_klad_context), 0, sizeof(drv_klad_context));
+
+    crypto_drv_func_enter();
+    return TD_SUCCESS;
+}
+
+td_s32 drv_klad_attach(td_handle klad_handle, crypto_klad_dest klad_dest, td_handle keyslot_handle)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    crypto_klad_flash_key_type flash_key_type = CRYPTO_KLAD_FLASH_KEY_TYPE_INVALID;
+    crypto_drv_func_enter();
+
+    crypto_chk_return(klad_handle != KLAD_VALID_HANDLE, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid klad_handle\n");
+    crypto_chk_return(g_klad_ctx.is_open == TD_FALSE, KM_COMPAT_ERRNO(ERROR_CTX_CLOSED), "call create first\n");
+
+    if (klad_dest == CRYPTO_KLAD_DEST_FLASH) {
+        flash_key_type = (crypto_klad_flash_key_type)keyslot_handle;
+    } else if (klad_dest == CRYPTO_KLAD_DEST_MCIPHER || klad_dest == CRYPTO_KLAD_DEST_HMAC) {
+        ret = hal_klad_set_key_addr(klad_dest, keyslot_handle);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_set_key_addr failed\n");
+    } else if (klad_dest == CRYPTO_KLAD_DEST_NPU) {
+        ret = hal_klad_set_key_addr(klad_dest, keyslot_handle);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_set_key_addr failed\n");
+    } else {
+        crypto_log_err("invalid klad_dest\n");
+        return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    ret = hal_klad_set_key_dest_cfg(klad_dest, flash_key_type);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_set_key_dest_cfg failed\n");
+
+    g_klad_ctx.keyslot_handle = keyslot_handle;
+    g_klad_ctx.klad_dest = klad_dest;
+    g_klad_ctx.is_attached = TD_TRUE;
+    crypto_drv_func_enter();
+    return ret;
+}
+
+td_s32 drv_klad_detach(td_handle klad_handle, crypto_klad_dest klad_dest, td_handle keyslot_handle)
+{
+    crypto_unused(keyslot_handle);
+    crypto_chk_return(klad_handle != KLAD_VALID_HANDLE, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid klad_handle\n");
+    crypto_chk_return(g_klad_ctx.is_open == TD_FALSE, KM_COMPAT_ERRNO(ERROR_CTX_CLOSED), "call create first\n");
+    crypto_chk_return(g_klad_ctx.klad_dest != klad_dest, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "invalid klad_dest\n");
+    crypto_chk_return(g_klad_ctx.keyslot_handle != keyslot_handle, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE),
+        "invalid keyslot_handle\n");
+
+    if (g_klad_ctx.is_attached == TD_FALSE) {
+        return TD_SUCCESS;
+    }
+
+    g_klad_ctx.is_attached = TD_FALSE;
+    g_klad_ctx.keyslot_handle = 0;
+    g_klad_ctx.klad_dest = 0;
+
+    return TD_SUCCESS;
+}
+
+td_s32 drv_klad_set_attr(td_handle klad_handle, const crypto_klad_attr *klad_attr)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    const crypto_klad_key_config *key_cfg = TD_NULL;
+    const crypto_klad_key_secure_config *key_sec_cfg = TD_NULL;
+    crypto_drv_func_enter();
+
+    km_null_ptr_chk(klad_attr);
+    crypto_chk_return(klad_attr->key_sec_cfg.key_sec != TD_FALSE && klad_attr->key_sec_cfg.key_sec != TD_TRUE,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "klad_attr.key_sec_cfg.key_sec is invalid\n");
+    crypto_chk_return(klad_attr->key_cfg.engine >= CRYPTO_KLAD_ENGINE_MAX, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "klad_attr.key_cfg.engine >= CRYPTO_KLAD_ENGINE_MAX\n");
+    crypto_chk_return(klad_handle != KLAD_VALID_HANDLE, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid klad_handle\n");
+    crypto_chk_return(g_klad_ctx.is_open == TD_FALSE, KM_COMPAT_ERRNO(ERROR_CTX_CLOSED), "call create first\n");
+
+    ret = memcpy_s(&g_klad_ctx.klad_attr, sizeof(crypto_klad_attr), klad_attr, sizeof(crypto_klad_attr));
+    crypto_chk_return(ret != EOK, KM_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    key_cfg = &(klad_attr->key_cfg);
+    key_sec_cfg = &(klad_attr->key_sec_cfg);
+
+    ret = hal_klad_set_key_crypto_cfg(key_cfg->encrypt_support, key_cfg->decrypt_support, key_cfg->engine);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_set_key_crypto_cfg failed\n");
+
+    ret = hal_klad_set_key_secure_cfg(key_sec_cfg);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_set_key_secure_cfg failed\n");
+
+    g_klad_ctx.hard_key_type = klad_attr->klad_cfg.rootkey_type;
+    g_klad_ctx.is_set_attr = TD_TRUE;
+    g_klad_ctx.rkp_sw_cfg = klad_attr->rkp_sw_cfg;
+
+    crypto_drv_func_enter();
+    return ret;
+}
+
+#if defined(CONFIG_KLAD_GET_ATTR)
+td_s32 drv_klad_get_attr(td_handle klad_handle, crypto_klad_attr *klad_attr)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    crypto_drv_func_enter();
+
+    km_null_ptr_chk(klad_attr);
+    crypto_chk_return(klad_handle != KLAD_VALID_HANDLE, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid klad_handle\n");
+    crypto_chk_return(g_klad_ctx.is_open == TD_FALSE, KM_COMPAT_ERRNO(ERROR_CTX_CLOSED), "call create first\n");
+    crypto_chk_return(g_klad_ctx.is_set_attr == TD_FALSE, KM_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG),
+        "call set_attr first\n");
+
+    ret = memcpy_s(klad_attr, sizeof(crypto_klad_attr), &g_klad_ctx.klad_attr, sizeof(crypto_klad_attr));
+    crypto_chk_return(ret != EOK, KM_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    crypto_drv_func_enter();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_clear_key.c b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_clear_key.c
new file mode 100644
index 0000000..e5f60d5
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_clear_key.c
@@ -0,0 +1,44 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver klad clear_key. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-06, Create file. \n
+ */
+#if defined(CONFIG_KM_CLEAR_KEY_SUPPORT)
+#include "drv_klad.h"
+#include "drv_klad_inner.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#include "hal_klad.h"
+#include "hal_rkp.h"
+
+td_s32 drv_klad_set_clear_key(td_handle klad_handle, const crypto_klad_clear_key *clear_key)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    drv_klad_context *klad_ctx = inner_klad_get_ctx();
+
+    crypto_drv_func_enter();
+
+    crypto_chk_return(klad_handle != KLAD_VALID_HANDLE, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid klad_handle\n");
+    km_null_ptr_chk(clear_key);
+    km_null_ptr_chk(clear_key->key);
+
+    crypto_chk_return(clear_key->key_parity != TD_FALSE && clear_key->key_parity != TD_TRUE,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "clear_key.key_parity is invalid\n");
+    crypto_chk_return(klad_ctx->is_open == TD_FALSE, KM_COMPAT_ERRNO(ERROR_CTX_CLOSED), "call create first\n");
+    crypto_chk_return(klad_ctx->is_set_attr == TD_FALSE, KM_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG),
+        "call set_attr first\n");
+
+    ret = hal_klad_start_clr_route(klad_ctx->klad_dest, clear_key);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_start_clr_route failed\n");
+
+    klad_ctx->is_set_key = TD_TRUE;
+
+    crypto_drv_func_enter();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_content_key.c b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_content_key.c
new file mode 100644
index 0000000..fc5c4ff
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_content_key.c
@@ -0,0 +1,119 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver klad effective_key. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-06, Create file. \n
+ */
+#if defined(CONFIG_KM_CONTENT_KEY_SUPPORT)
+#include "drv_klad.h"
+#include "drv_klad_inner.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#include "hal_klad.h"
+#include "hal_rkp.h"
+
+static td_s32 inner_drv_set_content_key(const crypto_klad_content_key *content_key)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_bool is_odd = content_key->key_parity;
+    crypto_klad_key_size key_size = CRYPTO_KLAD_KEY_SIZE_128BIT;
+    drv_klad_context *klad_ctx = inner_klad_get_ctx();
+
+    /* set session key. */
+    ret = hal_klad_set_data(klad_ctx->session_key.key, CRYPTO_128_KEY_LEN);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_set_data failed\n");
+
+    ret = hal_klad_com_start(CRYPTO_KLAD_LEVEL_SEL_FIRST, klad_ctx->session_key.alg,
+        CRYPTO_KLAD_KEY_SIZE_128BIT, klad_ctx->hard_key_type);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_com_start failed\n");
+
+    ret = hal_klad_wait_com_route_done();
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_wait_com_route_done failed\n");
+
+    /*
+     * For MCipher:
+     * If key_length is 16, the key_parity is passed by caller;
+     * If key_length is 32, the high 128bit's key_parity is even,
+        the low 128bit's key_parity is odd.
+     */
+    if (content_key->key_length == CRYPTO_256_KEY_LEN) {
+        is_odd = TD_FALSE;
+        key_size = CRYPTO_KLAD_KEY_SIZE_256BIT;
+    }
+    /* config the high 128bit  */
+    if (klad_ctx->klad_dest == CRYPTO_KLAD_DEST_MCIPHER) {
+        hal_klad_set_key_odd(is_odd);
+    }
+
+    ret = hal_klad_set_data(content_key->key, CRYPTO_128_KEY_LEN);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_set_data failed\n");
+
+    ret = hal_klad_com_start(CRYPTO_KLAD_LEVEL_SEL_SECOND, klad_ctx->session_key.alg,
+        key_size, klad_ctx->hard_key_type);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_com_start failed\n");
+
+    ret = hal_klad_wait_com_route_done();
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_wait_com_route_done failed\n");
+
+    /* config the low 128bit */
+    if (content_key->key_length == CRYPTO_256_KEY_LEN) {
+        if (klad_ctx->klad_dest == CRYPTO_KLAD_DEST_MCIPHER) {
+            hal_klad_set_key_odd(TD_TRUE);
+        }
+        ret = hal_klad_set_data(content_key->key + CRYPTO_128_KEY_LEN, CRYPTO_128_KEY_LEN);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_set_data failed\n");
+
+        ret = hal_klad_com_start(CRYPTO_KLAD_LEVEL_SEL_SECOND, klad_ctx->session_key.alg,
+            key_size, klad_ctx->hard_key_type);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_com_start failed\n");
+
+        ret = hal_klad_wait_com_route_done();
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_wait_com_route_done failed\n");
+    }
+exit_clean:
+    hal_klad_clear_data();
+    return ret;
+}
+
+td_s32 drv_klad_set_content_key(const td_handle klad_handle, const crypto_klad_content_key *content_key)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    crypto_kdf_hard_calc_param param = {0};
+    drv_klad_context *klad_ctx = inner_klad_get_ctx();
+    (td_void)(klad_handle);
+
+    km_null_ptr_chk(content_key);
+    crypto_chk_return(content_key->key_length != CRYPTO_128_KEY_LEN && content_key->key_length != CRYPTO_256_KEY_LEN,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "invalid key_length\n");
+
+    (td_void)memset_s(&param, sizeof(crypto_kdf_hard_calc_param), 0, sizeof(crypto_kdf_hard_calc_param));
+
+    /* lock klad */
+    ret = hal_klad_lock();
+    crypto_chk_return((ret != TD_SUCCESS), ret, "hal_klad_lock failed, ret is 0x%x\n", ret);
+
+    /* lock rkp */
+    ret = hal_rkp_lock();
+    crypto_chk_goto((ret != TD_SUCCESS), exit_klad_unlock, "hal_rkp_lock failed, ret is 0x%x\n", ret);
+
+    param.hard_key_type = klad_ctx->hard_key_type;
+    param.hard_alg = CRYPTO_KDF_HARD_ALG_SHA256;        /* default is SHA256. */
+    param.rkp_sw_cfg = klad_ctx->rkp_sw_cfg;
+
+    ret = hal_rkp_kdf_hard_calculation(&param);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_rkp_unlock, "hal_rkp_kdf_hard_calculation failed\n");
+
+    ret = inner_drv_set_content_key(content_key);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_rkp_unlock, "inner_drv_set_content_key failed\n");
+
+exit_rkp_unlock:
+    hal_rkp_unlock();
+exit_klad_unlock:
+    hal_klad_unlock();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_effective_key.c b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_effective_key.c
new file mode 100644
index 0000000..5cab129
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_effective_key.c
@@ -0,0 +1,79 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver klad effective_key. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-06, Create file. \n
+ */
+#if defined(CONFIG_KM_EFFECTIVE_KEY_SUPPORT)
+
+#include "drv_klad.h"
+#include "drv_klad_inner.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#include "hal_klad.h"
+#include "hal_rkp.h"
+
+td_s32 drv_klad_set_effective_key(td_handle klad_handle, const crypto_klad_effective_key *effective_key)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    crypto_kdf_hard_calc_param param = {0};
+    drv_klad_context *klad_ctx = inner_klad_get_ctx();
+
+    crypto_chk_return(effective_key == TD_NULL, TD_FAILURE, "effective_key is NULL\n");
+    crypto_chk_return(effective_key->salt == TD_NULL, TD_FAILURE, "effective_key->salt is NULL\n");
+    if (effective_key->kdf_hard_alg == CRYPTO_KDF_HARD_ALG_SM3) {
+        crypto_chk_return(crypto_sm3_support() == TD_FALSE, TD_FAILURE,
+            "alg is unsupport\n");
+    }
+
+    crypto_chk_return(klad_handle != KLAD_VALID_HANDLE, TD_FAILURE, "invalid klad_handle\n");
+    crypto_chk_return(klad_ctx->is_open == TD_FALSE, TD_FAILURE, "call create first\n");
+    crypto_chk_return(klad_ctx->is_set_attr == TD_FALSE, TD_FAILURE, "call set_attr first\n");
+
+    switch (effective_key->key_size) {
+        case CRYPTO_KLAD_KEY_SIZE_128BIT:
+            param.hard_key_size = CRYPTO_KDF_HARD_KEY_SIZE_128BIT;
+            break;
+        case CRYPTO_KLAD_KEY_SIZE_192BIT:
+            param.hard_key_size = CRYPTO_KDF_HARD_KEY_SIZE_192BIT;
+            break;
+        case CRYPTO_KLAD_KEY_SIZE_256BIT:
+            param.hard_key_size = CRYPTO_KDF_HARD_KEY_SIZE_256BIT;
+            break;
+        default:
+            crypto_log_err("invalid key_size\n");
+            return TD_FAILURE;
+    }
+
+    param.hard_key_type = klad_ctx->hard_key_type;
+    param.hard_alg = effective_key->kdf_hard_alg;
+    param.salt = effective_key->salt;
+    param.salt_length = effective_key->salt_length;
+    param.is_oneway = effective_key->oneway;
+
+    /* klad lock. */
+    ret = hal_klad_lock();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_lock failed\n");
+
+    /* rkp lock. */
+    ret = hal_rkp_lock();
+    crypto_chk_goto(ret != TD_SUCCESS, exit_klad_unlock, "hal_rkp_lock failed\n");
+
+    /* rkp hard calculation. */
+    ret = hal_rkp_kdf_hard_calculation(&param);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_rkp_unlock, "hal_rkp_kdf_hard_calculation failed\n");
+
+    ret = hal_klad_start_com_route(param.hard_key_type, effective_key, klad_ctx->klad_dest);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_rkp_unlock, "hal_klad_start_com_route failed\n");
+
+exit_rkp_unlock:
+    (td_void)hal_rkp_unlock();
+exit_klad_unlock:
+    (td_void)hal_klad_unlock();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_inner.h b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_inner.h
new file mode 100644
index 0000000..90e1091
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_inner.h
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver klad inner header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-06, Create file. \n
+ */
+
+#ifndef DRV_KLAD_INNER_H
+#define DRV_KLAD_INNER_H
+
+#include "drv_klad.h"
+#include "hal_klad.h"
+#include "hal_rkp.h"
+
+#define KLAD_VALID_HANDLE       0x2D3C4B5A
+
+typedef struct {
+    crypto_kdf_hard_key_type hard_key_type;
+    crypto_klad_dest klad_dest;
+    crypto_klad_attr klad_attr;
+    td_handle keyslot_handle;
+    td_u32 rkp_sw_cfg;
+    td_bool is_open;
+    td_bool is_attached;
+    td_bool is_set_attr;
+    td_bool is_set_key;
+    td_bool is_set_session_key;
+    crypto_klad_session_key session_key;
+} drv_klad_context;
+
+#define KM_COMPAT_ERRNO(err_code)     DRV_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+drv_klad_context *inner_klad_get_ctx(void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_session_key.c b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_session_key.c
new file mode 100644
index 0000000..97c4e72
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/km/drv_klad_session_key.c
@@ -0,0 +1,38 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver klad effective_key. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-06, Create file. \n
+ */
+#if defined(CONFIG_KM_SESSION_KEY_SUPPORT)
+
+#include "drv_klad.h"
+#include "drv_klad_inner.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#include "hal_klad.h"
+#include "hal_rkp.h"
+
+td_s32 drv_klad_set_session_key(td_handle klad_handle, const crypto_klad_session_key *session_key)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    drv_klad_context *klad_ctx = inner_klad_get_ctx();
+    crypto_drv_func_enter();
+
+    crypto_chk_return(klad_handle != KLAD_VALID_HANDLE, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid klad_handle\n");
+    km_null_ptr_chk(session_key);
+
+    ret = memcpy_s(&klad_ctx->session_key, sizeof (crypto_klad_session_key),
+        session_key, sizeof(crypto_klad_session_key));
+    crypto_chk_return(ret != EOK, KM_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    klad_ctx->is_set_session_key = TD_TRUE;
+
+    crypto_drv_func_enter();
+    return 0;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/otp/drv_otp.c b/bsp/security_subsys/security_subsys_common/drv_code/otp/drv_otp.c
new file mode 100644
index 0000000..5f070c7
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/otp/drv_otp.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "drv_otp.h"
+
+#include "crypto_drv_common.h"
+#include "otpc_register.h"
+#include "crypto_common_macro.h"
+
+#define OTP_READ_DELAY_TIME_IN_US 1
+#define OTP_WRITE_DELAY_TIME_IN_US 1
+#define OTP_NON_SPECIAL_VAL 0xA5C36987
+
+#define OTP_TIMEOUT                 1000000
+#define OTP_ADDR_4BYTES_ALIGN       4
+#define OTP_DIE_ID_OFFSET           0xf0
+#define OTP_DIE_ID_LEN              16
+#define OTP_WORD_LEN                4
+
+#define OTP_COMPAT_ERRNO(err_code)      DRV_COMPAT_ERRNO(ERROR_MODULE_OTP, err_code)
+
+td_s32 otp_lock_on(void);
+void otp_unlock_off(void);
+
+#define CPU_ID_STAT                         (0x0018)
+td_s32 otp_lock_on(void)
+{
+    otp_lock lock_ctrl = {.u32 = OTP_NON_SPECIAL_VAL};
+    td_u32 lock_status = OTP_NON_SPECIAL_VAL;
+    td_u32 lock_code = ca_misc_reg_read(CPU_ID_STAT);
+    td_u32 i = 0;
+
+    /* lock otp */
+    for (i = 0; i < OTP_LOCK_TIMEOUT; i++) {
+        /* otp unlock ? */
+        lock_status = otpc_reg_read(OTP_LOCK_STATUS);
+        if (lock_status != OTP_LOCK_UNLOCK) {
+            crypto_udelay(OTP_READ_DELAY_TIME_IN_US);
+            continue;
+        }
+
+        /* try to lock otp */
+        lock_ctrl.u32 = otpc_reg_read(OTP_LOCK);
+        lock_ctrl.bits.otp_lock_type = OTP_LOCK_TYPE_LOCK; /* lock command */
+        lock_ctrl.bits.otp_lock = OTP_LOCK_CMD;
+        otpc_reg_write(OTP_LOCK, lock_ctrl.u32);
+
+        /* check lock result */
+        lock_status = otpc_reg_read(OTP_LOCK_STATUS);
+        if (lock_status == lock_code) {
+            break;
+        }
+    }
+
+    if (i >= OTP_LOCK_TIMEOUT) {
+        crypto_log_err("otp lock timeout\n");
+        return OTP_COMPAT_ERRNO(ERROR_CHN_BUSY);
+    }
+
+    return TD_SUCCESS;
+}
+
+void otp_unlock_off(void)
+{
+    otp_lock lock_ctrl = {.u32 = OTP_NON_SPECIAL_VAL};
+
+    /* unlock otp */
+    lock_ctrl.u32 = otpc_reg_read(OTP_LOCK);
+    lock_ctrl.bits.otp_lock_type = OTP_LOCK_TYPE_UNLOCK; /* unlock command */
+    lock_ctrl.bits.otp_lock = OTP_LOCK_CMD;
+    otpc_reg_write(OTP_LOCK, lock_ctrl.u32);
+}
+
+td_s32 drv_otp_read_word(const td_u32 addr, td_u32 *data)
+{
+    otp_rw_ctrl_u un_otp_rw_ctrl = {.u32 = OTP_NON_SPECIAL_VAL};
+    otp_status otp_status_reg = {.u32 = OTP_NON_SPECIAL_VAL};
+    td_u32 time_out = 0;
+    volatile td_s32 ret = TD_FAILURE;
+
+    crypto_param_check(addr > CONFIG_OTP_MEMORY_MAX_ADDR);
+    crypto_param_check(data == TD_NULL);
+    crypto_chk_return((addr % OTP_ADDR_4BYTES_ALIGN) != 0, OTP_COMPAT_ERRNO(ERROR_OTP_ADDR_NOT_ALIGNED),
+        "otp_addr is not aligned\n");
+
+    ret = otp_lock_on();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    // 1.Configure Address OTP_ADDR
+    otpc_reg_write(OTP_ADDR, addr);
+
+    // 2.Configure OTP_RW_CTRL
+    un_otp_rw_ctrl.u32 = otpc_reg_read(OTP_RW_CTRL);
+#ifdef EFUSE_OTP
+    un_otp_rw_ctrl.bits.wr_sel = OTP_WR_SEL_TSMC_EFUSE_NORMAL_RD;
+#else
+    un_otp_rw_ctrl.bits.wr_sel = OTP_WR_SEL_OTP_RD;
+#endif
+    un_otp_rw_ctrl.bits.start = OTP_START_BUSY;               // 1'b1 means busy.
+    un_otp_rw_ctrl.bits.test_mode = OTP_TEST_MODE_NORMAL;     // 3'b000 means normal mode;
+    otpc_reg_write(OTP_RW_CTRL, un_otp_rw_ctrl.u32);
+
+    // 3.Wait idle
+    while (time_out++ < OTP_TIMEOUT) {
+        if ((otpc_reg_read(OTP_RW_CTRL) & 0x1) == OTP_START_IDLE) {
+            break;
+        }
+        crypto_udelay(OTP_READ_DELAY_TIME_IN_US);
+    }
+    if (time_out >= OTP_TIMEOUT) {
+        crypto_log_err("otp time out on read!\n");
+        otp_unlock_off();
+        return OTP_COMPAT_ERRNO(ERROR_OTP_TIMEOUT);
+    }
+
+    // 4.Check OTP_STATUS.
+    otp_status_reg.u32 = otpc_reg_read(OTP_STATUS);
+    if (otp_status_reg.bits.check_fail == OTP_CHECK_FAIL) { // 0x0 means pass; 0x1 means fail.
+        crypto_log_err("OTP read fail\n");
+        otp_unlock_off();
+        return OTP_COMPAT_ERRNO(ERROR_OTP_PERMISSION);
+    }
+
+    // 5.Read Data
+    *data = otpc_reg_read(OTP_RDATA);
+
+    otp_unlock_off();
+    return TD_SUCCESS;
+}
+
+#if defined(CONFIG_OTP_READ_BYTE_SUPPORT)
+td_s32 drv_otp_read_byte(const td_u32 addr, td_u8 *data)
+{
+    td_u32 read_data = 0;
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 align_addr = OTP_NON_SPECIAL_VAL;
+
+    crypto_drv_func_enter();
+
+    crypto_param_check(addr > CONFIG_OTP_MEMORY_MAX_ADDR);
+    crypto_param_check(data == TD_NULL);
+
+    align_addr = addr - (addr % OTP_ADDR_4BYTES_ALIGN);
+
+    ret = drv_otp_read_word(align_addr, &read_data);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("OTP read word fail\n");
+        return ret;
+    }
+
+    *data = (td_u8)(read_data >> (8 * (addr % OTP_ADDR_4BYTES_ALIGN))); // 8 bits one byte
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_OTP_WRITE_BYTE_SUPPORT)
+td_s32 drv_otp_write_byte(const td_u32 addr, const td_u8 data)
+{
+    otp_rw_ctrl_u un_otp_rw_ctrl = {.u32 = OTP_NON_SPECIAL_VAL};
+    otp_status otp_status_reg = {.u32 = OTP_NON_SPECIAL_VAL};
+    td_u32 time_out = 0;
+    volatile td_s32 ret = TD_FAILURE;
+
+    crypto_param_check(addr > CONFIG_OTP_MEMORY_MAX_ADDR);
+
+    if (data == 0) { // Default value is 0, no need and no necessary to write 0 directly
+        return TD_SUCCESS;
+    }
+
+    ret = otp_lock_on();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    // 1.Configure Address OTP_ADDR,
+    otpc_reg_write(OTP_ADDR, addr);
+    // 2.OTP_RW_ST_1 Check:(1)Readback Address (2)whether write is successful or not
+
+    // 3.Write Data
+    otpc_reg_write(OTP_WDATA, data);
+
+    // 4.Configure OTP_RW_CTRL
+    un_otp_rw_ctrl.u32 = otpc_reg_read(OTP_RW_CTRL);
+    un_otp_rw_ctrl.bits.wr_sel = OTP_WR_SEL_PGM_ACCESS;         // (3'b010) 0x2 means pgm access;
+    un_otp_rw_ctrl.bits.start = OTP_START_BUSY;                 // (1'b1)   0x1 means busy. 0x0: idle.
+    un_otp_rw_ctrl.bits.test_mode = OTP_TEST_MODE_NORMAL;       // (3'b000) 0x0 means normal mode;
+    otpc_reg_write(OTP_RW_CTRL, un_otp_rw_ctrl.u32);
+
+    // 5.Wait idle
+    while (time_out++ < OTP_TIMEOUT) {
+        un_otp_rw_ctrl.u32 = otpc_reg_read(OTP_RW_CTRL);
+        if (un_otp_rw_ctrl.bits.start == OTP_START_IDLE) { // 0x0: idle.
+            break;
+        }
+        crypto_udelay(OTP_WRITE_DELAY_TIME_IN_US);
+    }
+    if (time_out >= OTP_TIMEOUT) {
+        crypto_log_err("OTP write time out!\n");
+        otp_unlock_off();
+        return OTP_COMPAT_ERRNO(ERROR_OTP_TIMEOUT);
+    }
+
+    // 6.Check OTP_STATUS.
+    otp_status_reg.u32 = otpc_reg_read(OTP_STATUS);
+    if (otp_status_reg.bits.check_fail == OTP_CHECK_PASS) { // 0x0 means pass; 0x1 means fail.
+        otp_unlock_off();
+        return TD_SUCCESS;
+    } else {
+        crypto_log_err("OTP write fail\n");
+        otp_unlock_off();
+        return OTP_COMPAT_ERRNO(ERROR_OTP_PERMISSION);
+    }
+}
+#endif
+
+#if defined(CONFIG_OTP_GET_DIE_ID_SUPPORT)
+td_s32 drv_otp_get_die_id(td_u8 *die_id, const td_u32 len)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 addr = OTP_DIE_ID_OFFSET;
+    td_u32 word_data = 0;
+    td_u32 i = 0;
+
+    crypto_chk_return(len < OTP_DIE_ID_LEN, OTP_COMPAT_ERRNO(ERROR_INVALID_PARAM), "len < OTP_DIE_ID_LEN\n");
+
+    for (i = 0; i < OTP_DIE_ID_LEN; i += OTP_WORD_LEN) {
+        ret = drv_otp_read_word(addr, &word_data);
+        if (ret != TD_SUCCESS) {
+            crypto_log_err("OTP read word fail\n");
+            return ret;
+        }
+        (void)memcpy_s(die_id, len, &word_data, OTP_WORD_LEN);
+        addr += OTP_WORD_LEN;
+        die_id += OTP_WORD_LEN;
+    }
+
+    return TD_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/otp/otpc_register.h b/bsp/security_subsys/security_subsys_common/drv_code/otp/otpc_register.h
new file mode 100644
index 0000000..24fb637
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/otp/otpc_register.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef OTPC_REGISTER_H
+#define OTPC_REGISTER_H
+
+#include "crypto_type.h"
+
+#define OTP_RW_CTRL         (0x1000)
+
+// [9:0] -- otp_addr , OTP read only support word operation, so addr[1:0] will be ignored.
+#define OTP_ADDR            (0x1004)
+
+#define OTP_WDATA           (0x1008)
+#define OTP_RDATA           (0x100C)
+#define OTP_STATUS          (0x1010)
+#define OTP_UPDATE          (0x1014)
+#define OTP_LOCK            (0x1038)
+#define OTP_LOCK_STATUS     (0x103C)
+#define OTP_AUTO_SB_CTRL    (0x1050)
+
+#define OTP_LOCK_UNLOCK     0x0
+#define OTP_LOCK_TIMEOUT    1000000
+
+#define OTP_LOCK_CMD                1
+#define OTP_UNLOCK_CMD              0
+#define OTP_LOCK_TYPE_LOCK          0
+#define OTP_LOCK_TYPE_UNLOCK        1
+
+#define OTP_AUTO_STANDBY_ENABLE     1
+#define OTP_AUTO_STANDBY_DISABLE    0
+
+#define OTP_TEST_MODE_NORMAL            0x0
+#define OTP_WR_SEL_TSMC_EFUSE_NORMAL_RD 0x4
+
+#define OTP_WR_SEL_OTP_STANDBY      0x0
+#define OTP_WR_SEL_OTP_RD           0x1
+#define OTP_WR_SEL_PGM_ACCESS       0x2
+
+#define OTP_START_BUSY 0x1
+#define OTP_START_IDLE 0x0
+
+#define OTP_CHECK_PASS 0x0
+#define OTP_CHECK_FAIL 0x1
+
+#define OTP_UPDATE_REQ_BUSY 0x1
+#define OTP_UPDATE_REQ_IDLE 0x0
+
+/* ! Define the offset of OTPC Shadow reg */
+#define SOC_TEE_ENABLE_REG                         (0x0010)
+
+#define TEE_NOT_ENABLE                             0x42
+/* Define the union U_OTP_BYTE_ALIGNED_LOCKABLE_0 */
+typedef union {
+    struct {
+        td_u32 otp_not_blank               : 16; /* [15:0] */
+        td_u32 soc_tee_enable              : 8;  /* [23:16] */
+        td_u32 obfu_mrk1_owner_id_low      : 8;  /* [31:24] */
+    } bits;
+    td_u32 u32;
+} otp_byte_aligned_lockable_0; /* 0x10 */
+
+/*
+1.otp_start: [0]
+    OTP operation start.
+    1'b0: idle;
+    1'b1: busy.
+    Software sets 1'b1 to start operation, logic clears to 1'b0 after operation is done.
+2.otp_wr_sel: [3:1]
+    OTP normal mode control.
+    Ememory:
+    3'b000: standby;
+    3'b001: read access;
+    3'b010: pgm access;
+    3'b011: pgm verify; (recommend)
+    3'b100: pgm margin read;
+    3'b101: initial margin read single;
+    others: standby.
+3.otp_test_mode: [6:4]
+    OTP test mode control. Only used for SOC JTAG in blank chipset.
+    Ememory:
+    3'b000: normal mode;
+    3'b001: initial margin read;
+    3'b010: repair margin read;
+    3'b011: repair check mode;
+    3'b100: repair pgm mode;
+    3'b101: puf auto enrollment;
+    3'b110: puf check mode;
+    others: normal mode.
+*/
+typedef union {
+    struct {
+        td_u32 start                   : 1;  // [0]
+        td_u32 wr_sel                  : 3;  // [3:1]
+        td_u32 test_mode               : 3;  // [4:6]
+        td_u32 reserved                : 25; // [31:7]
+    } bits;
+    td_u32 u32;
+} otp_rw_ctrl_u;
+
+typedef union {
+    struct {
+        td_u32 init_rdy                : 1;  // [0]
+        td_u32 check_fail              : 1;  // [1] 1'b0: pass; 1'b1: fail.
+        td_u32 check_alarm             : 1;  // [2]
+        td_u32 reserved                : 29; // [31:3]
+    } bits;
+    td_u32 u32;
+} otp_status;
+
+typedef union {
+    struct {
+        td_u32 req                     : 1;  // [0] 0: idle; 1: busy
+        td_u32 reserved                : 31; // [31:1]
+    } bits;
+    td_u32 u32;
+} otp_update;
+
+typedef union {
+    struct {
+        td_u32 otp_lock                : 1;  // [0]
+        td_u32 otp_lock_type           : 1;  // [1] 1'b0: lock command; 1'b1: unlock command.
+        td_u32 reserved                : 30; // [31:2]
+    } bits;
+    td_u32 u32;
+} otp_lock;
+
+typedef union {
+    struct {
+        td_u32 otp_auto_sb_en          : 1;  // [0] 1'b0: disable; 1'b1: enable.
+        td_u32 reserved                : 31; // [31:1]
+    } bits;
+    td_u32 u32;
+} otp_auto_sb_ctrl;
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_api.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_api.c
new file mode 100644
index 0000000..c2a8f5f
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_api.c
@@ -0,0 +1,30 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke common api. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#include "drv_pke.h"
+#include "hal_pke_v5.h"
+#include "crypto_drv_common.h"
+
+td_s32 drv_cipher_pke_init(void)
+{
+    int ret;
+    crypto_drv_func_enter();
+    ret = hal_pke_init();
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_deinit(void)
+{
+    int ret;
+    crypto_drv_func_enter();
+    ret = hal_pke_deinit();
+    crypto_drv_func_exit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_exp_mod.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_exp_mod.c
new file mode 100644
index 0000000..3ad4b79
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_exp_mod.c
@@ -0,0 +1,40 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke exp_mod. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-13, Create file. \n
+ */
+
+#include "drv_pke_cal.h"
+#include "hal_pke_alg.h"
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+
+td_s32 drv_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out)
+{
+    int ret;
+    pke_null_ptr_chk(n);
+    pke_null_ptr_chk(n->data);
+    pke_null_ptr_chk(k);
+    pke_null_ptr_chk(k->data);
+    pke_null_ptr_chk(in);
+    pke_null_ptr_chk(in->data);
+    pke_null_ptr_chk(out);
+    pke_null_ptr_chk(out->data);
+
+#if defined(CONFIG_PKE_TRACE_ENABLE)
+    crypto_dump_data("n", n->data, n->length);
+    crypto_dump_data("k", k->data, k->length);
+    crypto_dump_data("in", in->data, in->length);
+#endif
+    ret = hal_pke_alg_rsa_exp_mod(n, k, in, out);
+
+#if defined(CONFIG_PKE_TRACE_ENABLE)
+    crypto_dump_data("out = in^k mod n", out->data, out->length);
+#endif
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_inner.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_inner.c
new file mode 100755
index 0000000..fd8935c
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_inner.c
@@ -0,0 +1,446 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke inner utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_RSA_SUPPORT) || defined(CONFIG_PKE_ECC_SUPPORT)
+
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+#if defined(CONFIG_HASH_SUPPORT)
+#include "crypto_hash_struct.h"
+#endif
+
+/* result size */
+#define HASH_SIZE_SHA_1                            20
+#define HASH_SIZE_SHA_224                          28
+#define HASH_SIZE_SHA_256                          32
+#define HASH_SIZE_SHA_384                          48
+#define HASH_SIZE_SHA_512                          64
+#define HASH_SIZE_SHA_MAX                          64
+
+#if defined(CONFIG_HASH_SUPPORT)
+td_s32 drv_get_hash_len(const drv_pke_hash_type hash_type)
+{
+    switch (hash_type) {
+        case DRV_PKE_HASH_TYPE_SHA1:
+            return HASH_SIZE_SHA_1;
+        case DRV_PKE_HASH_TYPE_SHA224:
+            return HASH_SIZE_SHA_224;
+        case DRV_PKE_HASH_TYPE_SHA256:
+            return HASH_SIZE_SHA_256;
+        case DRV_PKE_HASH_TYPE_SHA384:
+            return HASH_SIZE_SHA_384;
+        case DRV_PKE_HASH_TYPE_SHA512:
+            return HASH_SIZE_SHA_512;
+        default:
+            crypto_log_err("unsupport hash type\n");
+            return HASH_SIZE_SHA_256;
+    }
+}
+#endif
+
+static const td_s8 g_bits[] = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4};
+#define MAX_LOW_2BITS              3
+#define MAX_LOW_3BITS              7
+#define MAX_LOW_4BITS              0xF
+#define MAX_LOW_8BITS              0xFF
+
+#define SHIFT_4BITS                4
+#define SHIFT_8BITS                8
+#define SHIFT_16BITS               16
+#define SHIFT_24BITS               24
+
+#define BOUND_VALUE_1              1
+td_u32 rsa_get_bit_num(const td_u8 *big_num, td_u32 num_len)
+{
+    td_u32 i = 0;
+    td_s8 num = 0;
+
+    for (i = 0; i < num_len; i++) {
+        if (big_num[i] == 0x00) {
+            continue;
+        }
+        num = g_bits[(big_num[i] & (MAX_LOW_8BITS - MAX_LOW_4BITS)) >> SHIFT_4BITS];
+        if (num > 0) {
+            return (num_len - i - BOUND_VALUE_1) * CRYPTO_BITS_IN_BYTE + num + CRYPTO_WORD_WIDTH;
+        }
+
+        num = g_bits[big_num[i] & MAX_LOW_4BITS];
+        if (num > 0) {
+            return (num_len - i - BOUND_VALUE_1) * CRYPTO_BITS_IN_BYTE + num;
+        }
+    }
+    return 0;
+}
+
+#if defined(CONFIG_PKE_RSA_SHA1_SUPPORT)
+static const td_u8 g_asn1_sha1[] = {
+    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e,
+    0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14,
+};
+
+static const td_u8 g_empty_l_sha1[] = {
+    0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d,
+    0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90,
+    0xaf, 0xd8, 0x07, 0x09,
+};
+#endif
+
+#if defined(CONFIG_PKE_RSA_SHA224_SUPPORT)
+static const td_u8 g_asn1_sha224[] = {
+    0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05,
+    0x00, 0x04, 0x1c
+};
+
+static const td_u8 g_empty_l_sha224[] = {
+    0xd1, 0x4a, 0x02, 0x8c, 0x2a, 0x3a, 0x2b, 0xc9,
+    0x47, 0x61, 0x02, 0xbb, 0x28, 0x82, 0x34, 0xc4,
+    0x15, 0xa2, 0xb0, 0x1f, 0x82, 0x8e, 0xa6, 0x2a,
+    0xc5, 0xb3, 0xe4, 0x2f
+};
+#endif
+
+#if defined(CONFIG_PKE_RSA_SHA256_SUPPORT)
+static const td_u8 g_asn1_sha256[] = {
+    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
+    0x00, 0x04, 0x20,
+};
+
+static const td_u8 g_empty_l_sha256[] = {
+    0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,
+    0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,
+    0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,
+    0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55,
+};
+#endif
+
+#if defined(CONFIG_PKE_RSA_SHA384_SUPPORT)
+static const td_u8 g_asn1_sha384[] = {
+    0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05,
+    0x00, 0x04, 0x30,
+};
+
+static const td_u8 g_empty_l_sha384[] = {
+    0x38, 0xb0, 0x60, 0xa7, 0x51, 0xac, 0x96, 0x38,
+    0x4c, 0xd9, 0x32, 0x7e, 0xb1, 0xb1, 0xe3, 0x6a,
+    0x21, 0xfd, 0xb7, 0x11, 0x14, 0xbe, 0x07, 0x43,
+    0x4c, 0x0c, 0xc7, 0xbf, 0x63, 0xf6, 0xe1, 0xda,
+    0x27, 0x4e, 0xde, 0xbf, 0xe7, 0x6f, 0x65, 0xfb,
+    0xd5, 0x1a, 0xd2, 0xf1, 0x48, 0x98, 0xb9, 0x5b,
+};
+#endif
+
+#if defined(CONFIG_PKE_RSA_SHA512_SUPPORT)
+static const td_u8 g_asn1_sha512[] = {
+    0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
+    0x00, 0x04, 0x40,
+};
+
+static const td_u8 g_empty_l_sha512[] = {
+    0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd,
+    0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07,
+    0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc,
+    0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce,
+    0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0,
+    0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f,
+    0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81,
+    0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e,
+};
+#endif
+
+#if defined(CONFIG_PKE_RSA_LABEL_SUPPORT)
+static td_u8 g_l_hash[HASH_SIZE_SHA_512] = {0x0};
+#endif
+
+#if defined(CONFIG_PKE_RSA_SUPPORT)
+typedef struct {
+    drv_pke_hash_type hash_type;
+    td_u32 hash_len;
+    const td_u8 *asn1_data;
+    td_u32 asn1_len;
+    const td_u8 *lhash_data;
+} pke_hash_item;
+
+static const pke_hash_item g_pke_hash_list[] = {
+#if defined(CONFIG_PKE_RSA_SHA1_SUPPORT)
+    {
+        .hash_type = DRV_PKE_HASH_TYPE_SHA1,
+        .hash_len = HASH_SIZE_SHA_1,
+        .asn1_data = g_asn1_sha1,
+        .asn1_len = sizeof(g_asn1_sha1),
+        .lhash_data = g_empty_l_sha1,
+    },
+#endif
+#if defined(CONFIG_PKE_RSA_SHA224_SUPPORT)
+    {
+        .hash_type = DRV_PKE_HASH_TYPE_SHA224,
+        .hash_len = HASH_SIZE_SHA_224,
+        .asn1_data = g_asn1_sha224,
+        .asn1_len = sizeof(g_asn1_sha224),
+        .lhash_data = g_empty_l_sha224,
+    },
+#endif
+#if defined(CONFIG_PKE_RSA_SHA256_SUPPORT)
+    {
+        .hash_type = DRV_PKE_HASH_TYPE_SHA256,
+        .hash_len = HASH_SIZE_SHA_256,
+        .asn1_data = g_asn1_sha256,
+        .asn1_len = sizeof(g_asn1_sha256),
+        .lhash_data = g_empty_l_sha256,
+    },
+#endif
+#if defined(CONFIG_PKE_RSA_SHA384_SUPPORT)
+    {
+        .hash_type = DRV_PKE_HASH_TYPE_SHA384,
+        .hash_len = HASH_SIZE_SHA_384,
+        .asn1_data = g_asn1_sha384,
+        .asn1_len = sizeof(g_asn1_sha384),
+        .lhash_data = g_empty_l_sha384,
+    },
+#endif
+#if defined(CONFIG_PKE_RSA_SHA512_SUPPORT)
+    {
+        .hash_type = DRV_PKE_HASH_TYPE_SHA512,
+        .hash_len = HASH_SIZE_SHA_512,
+        .asn1_data = g_asn1_sha512,
+        .asn1_len = sizeof(g_asn1_sha512),
+        .lhash_data = g_empty_l_sha512,
+    },
+#endif
+};
+
+td_s32 pkcs1_get_hash(const drv_pke_hash_type hash_type, const drv_pke_data *label,
+    rsa_pkcs1_hash_info *hash_info)
+{
+    td_u32 i;
+    td_s32 ret = TD_FAILURE;
+    drv_pke_data h_hash = {0};
+    const pke_hash_item *item = NULL;
+
+    crypto_unused(ret);
+    crypto_unused(h_hash);
+    crypto_unused(label);
+    crypto_unused(hash_info);
+
+    for (i = 0; i < crypto_array_size(g_pke_hash_list); i++) {
+        if (g_pke_hash_list[i].hash_type == hash_type) {
+            item = &g_pke_hash_list[i];
+            hash_info->hash_type = item->hash_type;
+            hash_info->hash_len = item->hash_len;
+            hash_info->asn1_data = (td_u8 *)item->asn1_data;
+            hash_info->asn1_len = item->asn1_len;
+            hash_info->lhash_data = (td_u8 *)item->lhash_data;
+            break;
+        }
+    }
+    if (item == NULL) {
+        crypto_log_err("unsupport hash type\n");
+        return PKE_COMPAT_ERRNO(ERROR_UNSUPPORT);
+    }
+
+#if defined(CONFIG_PKE_RSA_LABEL_SUPPORT)
+    if (label != TD_NULL && label->data != TD_NULL && label->length != 0) {
+        hash_info->lhash_data = g_l_hash;
+        h_hash.data = hash_info->lhash_data;
+        h_hash.length = hash_info->hash_len;
+
+        ret = hal_pke_alg_calc_hash(label, 1, hash_info->hash_type, &h_hash);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_alg_calc_hash failed, ret is 0x%x\n", ret);
+    }
+#endif
+
+    return TD_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_PKE_TRNG_SUPPORT)
+td_s32 inner_get_random(td_u8 *random, const td_u32 size)
+{
+    return drv_cipher_pke_get_multi_random(random, size);
+}
+
+#define PKE_RANDOM_MAX_TRY_TIMES    100
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+td_s32 inner_get_random_with_nonzero_octets(td_u8 *random, td_u32 size)
+{
+    td_s32 ret;
+    td_u32 i;
+    td_u32 try_times = 0;
+
+    ret = drv_cipher_pke_get_multi_random(random, size);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_get_multi_random failed\n");
+
+    for (i = 0; i < size; i++) {
+        try_times = 0;
+        while (random[i] == 0 && try_times < PKE_RANDOM_MAX_TRY_TIMES) {
+            ret = drv_cipher_pke_get_multi_random(&random[i], 1);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_get_multi_random failed\n");
+            try_times++;
+        }
+        if (try_times >= PKE_RANDOM_MAX_TRY_TIMES) {
+            return TD_FAILURE;
+        }
+    }
+    return TD_SUCCESS;
+}
+#endif
+
+td_s32 inner_get_limit_random(td_u8 *rand, const td_u8 *limit, const td_u32 size)
+{
+    unsigned int ret;
+    unsigned int start_idx = 0;
+    while (start_idx < size && limit[start_idx] == 0) {
+        start_idx++;
+    }
+    if (start_idx == size) {
+        crypto_log_err("the limit is zero!\n");
+        return CRYPTO_FAILURE;
+    }
+    (void)memset_s(rand, size, 0, size);
+    ret = inner_get_random(&rand[start_idx], size - start_idx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_get_random failed\n");
+
+    rand[start_idx] = rand[start_idx] % limit[start_idx];
+
+    return TD_SUCCESS;
+}
+
+td_s32 inner_generate_random_in_range(td_u8 *rand, const td_u8 *limit, const td_u32 size)
+{
+    unsigned int ret;
+    unsigned int start_idx = 0;
+    unsigned int i;
+    while (start_idx < size && limit[start_idx] == 0) {
+        start_idx++;
+    }
+    if (start_idx == size) {
+        crypto_log_err("the limit is zero!\n");
+        return CRYPTO_FAILURE;
+    }
+    for (i = 0; i < PKE_RANDOM_MAX_TRY_TIMES; i++) {
+        ret = inner_get_random(&rand[start_idx], size - start_idx);
+        crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_get_random failed\n");
+        rand[start_idx] = rand[start_idx] % limit[start_idx];
+
+        if (inner_drv_is_zero(&rand[start_idx], size - start_idx) != TD_TRUE) {
+            break;
+        }
+    }
+    if (i >= PKE_RANDOM_MAX_TRY_TIMES) {
+        crypto_print("get random try max times!\n");
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+#endif
+
+td_bool inner_drv_is_zero(const td_u8 *val, td_u32 length)
+{
+    unsigned int i;
+    for (i = 0; i < length; i++) {
+        if (val[i] != 0) {
+            return 0;
+        }
+    }
+    return 1;
+}
+
+td_bool inner_drv_is_in_range(const uint8_t *value, const uint8_t *range, uint32_t len)
+{
+    if (memcmp(value, range, len) < 0 && inner_drv_is_zero(value, len) == TD_FALSE) {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+#if defined(CONFIG_PKE_ECC_SM2_PUB_ENC_SUPPORT) || defined(CONFIG_PKE_ECC_SM2_PRIV_DEC_SUPPORT)
+td_s32 inner_sm2_kdf(const drv_pke_ecc_point *param, td_u8 *out, const td_u32 klen)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 block = 0;
+    td_u32 i = 0;
+    td_u32 ct = 0;
+    drv_pke_data arr[3];
+    td_u8 h[SM2_LEN_IN_BYTES] = {0};
+    drv_pke_data hash = {SM2_LEN_IN_BYTES, h};
+
+    crypto_param_check(param == TD_NULL);
+    crypto_param_check(param->x == TD_NULL);
+    crypto_param_check(param->y == TD_NULL);
+    crypto_param_check(out == TD_NULL);
+
+    arr[0].data = param->x;
+    arr[0].length = SM2_LEN_IN_BYTES;
+    arr[1].data = param->y;
+    arr[1].length = SM2_LEN_IN_BYTES;
+    arr[2].data = (td_u8 *)&ct; // 2 is index of arr
+    arr[2].length = sizeof(ct); // 2 is index of arr
+    if (klen == 0) {
+        return TD_SUCCESS;
+    }
+
+    block = (klen + SM2_LEN_IN_BYTES - 1) / SM2_LEN_IN_BYTES;
+    for (i = 0; i < block; i++) {
+        ct = crypto_cpu_to_be32(i + 1);
+        /* *** H = SM3(X || Y || CT) *** */
+        ret = hal_pke_alg_calc_hash(arr, crypto_array_size(arr), DRV_PKE_HASH_TYPE_SM3, &hash);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_alg_calc_hash failed, ret is 0x%x\n", ret);
+
+        if (i == (block - 1)) {
+            ret = memcpy_s(out + i * SM2_LEN_IN_BYTES, SM2_LEN_IN_BYTES, h,
+                klen - i * SM2_LEN_IN_BYTES);
+            crypto_chk_return(ret != EOK, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+        } else {
+            (void)memcpy_s(out + i * SM2_LEN_IN_BYTES, SM2_LEN_IN_BYTES, h, SM2_LEN_IN_BYTES);
+        }
+    }
+    if (inner_drv_is_zero(out, klen) == TD_TRUE) {
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+#endif
+
+td_s32 crypto_rsa_klen_support(td_u32 klen)
+{
+    td_s32 ret = TD_FAILURE;
+
+    switch (klen) {
+#if defined(CONFIG_PKE_RSA_1024_SUPPORT)
+        case DRV_PKE_LEN_1024:
+            ret = TD_SUCCESS;
+            break;
+#endif
+#if defined(CONFIG_PKE_RSA_2048_SUPPORT)
+        case DRV_PKE_LEN_2048:
+            ret = TD_SUCCESS;
+            break;
+#endif
+#if defined(CONFIG_PKE_RSA_3072_SUPPORT)
+        case DRV_PKE_LEN_3072:
+            ret = TD_SUCCESS;
+            break;
+#endif
+#if defined(CONFIG_PKE_RSA_4096_SUPPORT)
+        case DRV_PKE_LEN_4096:
+            ret = TD_SUCCESS;
+            break;
+#endif
+        default:
+            return TD_FAILURE;
+    }
+
+    return ret;
+}
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_inner.h b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_inner.h
new file mode 100644
index 0000000..1811053
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_inner.h
@@ -0,0 +1,118 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke inner header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#ifndef DRV_PKE_INNER_H
+#define DRV_PKE_INNER_H
+
+#include "drv_pke.h"
+#include "hal_pke_alg.h"
+
+typedef struct {
+    td_u32 klen;
+    td_u32 em_bit;
+    td_u8 *em;
+    td_u32 em_len;
+    td_u8 *hash;
+    td_u32 hash_len;
+    td_u8 *data;
+    td_u32 data_len;
+} rsa_pkcs1_pack;
+
+typedef struct {
+    drv_pke_hash_type hash_type;
+    td_u32 hash_len;
+    td_u8 *lhash_data;
+    td_u8 *asn1_data;
+    td_u32 asn1_len;
+} rsa_pkcs1_hash_info;
+
+/* result size */
+#define HASH_SIZE_SHA_1                            20
+#define HASH_SIZE_SHA_224                          28
+#define HASH_SIZE_SHA_256                          32
+#define HASH_SIZE_SHA_384                          48
+#define HASH_SIZE_SHA_512                          64
+#define HASH_SIZE_SHA_MAX                          64
+
+#define PKE_COMPAT_ERRNO(err_code)      DRV_COMPAT_ERRNO(ERROR_MODULE_PKE, err_code)
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/* Common. */
+td_s32 inner_get_random(td_u8 *rand, const td_u32 size);
+
+td_s32 inner_get_random_with_nonzero_octets(td_u8 *random, td_u32 size);
+
+td_s32 inner_get_limit_random(td_u8 *rand, const td_u8 *limit, const td_u32 size);
+
+td_s32 inner_generate_random_in_range(td_u8 *rand, const td_u8 *limit, const td_u32 size);
+
+/* RSA Common */
+td_s32 drv_get_hash_len(const drv_pke_hash_type hash_type);
+
+td_u32 rsa_get_bit_num(const td_u8 *big_num, td_u32 num_len);
+
+td_s32 pkcs1_get_hash(const drv_pke_hash_type hash_type, const drv_pke_data *label,
+    rsa_pkcs1_hash_info *hash_info);
+
+/* out = in^k mod n. */
+td_s32 inner_rsa_exp_mod(const td_u8 *n, const td_u8 *k, td_u32 key_len,
+    const td_u8 *in, td_u8 *out);
+
+/* c = (a + b) mod n.
+ * a or b could be NULL, if a = NULL, means a = 0.
+ */
+td_s32 inner_add_mod(const td_u8 *a, const td_u8 *b, const td_u8 *n, td_u8 *c, td_u32 length);
+
+/* RSA V15. */
+td_s32 pkcs1_v15_sign(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack);
+
+td_s32 pkcs1_v15_verify(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack);
+
+td_s32 pkcs1_v15_encrypt(const rsa_pkcs1_pack *pack);
+
+td_s32 pkcs1_v15_decrypt(rsa_pkcs1_pack *pack);
+
+/* RSA V21. */
+td_s32 pkcs1_pss_sign(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack);
+
+td_s32 pkcs1_pss_verify(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack);
+
+td_s32 pkcs1_oaep_encrypt(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack,
+    const drv_pke_data *label);
+
+td_s32 pkcs1_oaep_decrypt(const drv_pke_hash_type hash_type, rsa_pkcs1_pack *pack,
+    const drv_pke_data *label);
+
+/* r = k * p. */
+td_s32 inner_drv_pke_ecc_mul_dot(const drv_pke_ecc_curve *ecc, const td_u8 *k, const drv_pke_ecc_point *p,
+    const drv_pke_ecc_point *r);
+
+/* c = (a + b) mod p. */
+td_s32 inner_drv_pke_add_mod(const td_u8 *a, const td_u8 *b, const td_u8 *p, td_u8 *c, td_u32 length);
+
+td_bool inner_drv_is_zero(const td_u8 *val, td_u32 length);
+
+td_bool inner_drv_is_in_range(const uint8_t *value, const uint8_t *range, uint32_t len);
+
+td_s32 inner_sm2_kdf(const drv_pke_ecc_point *param, td_u8 *out, const td_u32 klen);
+
+td_s32 crypto_rsa_klen_support(td_u32 klen);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_mod.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_mod.c
new file mode 100644
index 0000000..7151b53
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/drv_pke_mod.c
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke mod. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-13, Create file. \n
+ */
+
+#include "drv_pke_cal.h"
+#include "hal_pke_alg.h"
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+
+#define CONST_1_LEN     32
+/* c = a mod p. */
+td_s32 drv_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    int ret;
+
+    pke_null_ptr_chk(a);
+    pke_null_ptr_chk(a->data);
+    pke_null_ptr_chk(p);
+    pke_null_ptr_chk(p->data);
+    pke_null_ptr_chk(c);
+    pke_null_ptr_chk(c->data);
+
+#if defined(CONFIG_PKE_TRACE_ENABLE)
+    crypto_dump_data("a", a->data, a->length);
+    crypto_dump_data("p", p->data, p->length);
+#endif
+    ret = hal_pke_alg_rsa_mod(a, p, c);
+#if defined(CONFIG_PKE_TRACE_ENABLE)
+    crypto_dump_data("c = a mod p", c->data, c->length);
+#endif
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_check_dot_on_curve.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_check_dot_on_curve.c
new file mode 100644
index 0000000..5e74443
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_check_dot_on_curve.c
@@ -0,0 +1,48 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke ecdsa check dot on curve. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_CHECK_DOT_ON_CURVE_SUPPORT)
+
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+
+static td_s32 inner_ecc_check_dot_on_curve(const drv_pke_ecc_point *pub_key, td_bool *is_on_curve)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    ret = hal_pke_alg_ecc_check_dot_on_curve(pub_key, is_on_curve);
+    return ret;
+}
+
+td_s32 drv_cipher_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve)
+{
+    td_u32 klen;
+    td_s32 ret = TD_FAILURE;
+
+    /* param check. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(is_on_curve);
+
+    /* length check. */
+    klen = crypto_pke_get_klen(curve_type);
+    crypto_chk_return(pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is invalid\n");
+
+    ret = hal_pke_alg_ecc_init(curve_type);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    ret = inner_ecc_check_dot_on_curve(pub_key, is_on_curve);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_deinit, "inner_ecc_check_dot_on_curve failed\n");
+
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_ecdh.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_ecdh.c
new file mode 100644
index 0000000..7756ea5
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_ecdh.c
@@ -0,0 +1,82 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke ecdsa ecdh. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_ECDH_SUPPORT)
+
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+
+#define MAX_ECC_LENGTH      72
+/* According to SEC1 "3.3.2 Elliptic Curve Cofactor Diffie-Hellman Primitive" */
+static td_s32 inner_ecc_gen_ecdh_key(const drv_pke_ecc_point *input_pub_key, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_shared_key)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    drv_pke_ecc_point rr = {0};
+    unsigned char rr_y[MAX_ECC_LENGTH];
+
+    rr.x = output_shared_key->data;
+    rr.y = rr_y;
+    rr.length = output_shared_key->length;
+
+#if defined(CONFIG_PKE_ECDH_TRACE_ENABLE)
+    crypto_dump_data("d", input_priv_key->data, input_priv_key->length);
+    crypto_dump_data("Q(x)", input_pub_key->x, input_pub_key->length);
+    crypto_dump_data("Q(y)", input_pub_key->y, input_pub_key->length);
+#endif
+    /* Step 1. Compute point P(x, y) = h*Du*Qv.
+     * 1) h is the ecc parameter, for brainpool/fips/sm2, the h is 1, so we can compute P(x, y) = Du*Qv directly.
+     * 2) Du is the input priv_key.
+     * 3) Qv is the output pub_key.
+    */
+    ret = hal_pke_alg_ecc_point_mul(input_priv_key, input_pub_key, &rr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_alg_ecc_point_mul failed\n");
+#if defined(CONFIG_PKE_ECDH_TRACE_ENABLE)
+    crypto_dump_data("P(x)", rr.x, input_priv_key->length);
+#endif
+    /* Step 2. Check that if P(x, y) is ZERO. */
+    /* Step 3. Output z = Xp. */
+
+    return TD_SUCCESS;
+}
+
+td_s32 drv_cipher_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key)
+{
+    td_s32 ret = TD_FAILURE;
+    unsigned int klen;
+
+    /* param null check. */
+    pke_null_ptr_chk(input_pub_key);
+    pke_null_ptr_chk(input_pub_key->x);
+    pke_null_ptr_chk(input_pub_key->y);
+    pke_null_ptr_chk(input_priv_key);
+    pke_null_ptr_chk(input_priv_key->data);
+    pke_null_ptr_chk(output_shared_key);
+    pke_null_ptr_chk(output_shared_key->data);
+
+    /* length check. */
+    klen = crypto_pke_get_klen(curve_type);
+    crypto_chk_return(input_priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "input_priv_key->length is invalid\n");
+    crypto_chk_return(input_pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "input_pub_key->length is invalid\n");
+    crypto_chk_return(output_shared_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "output_shared_key->length is invalid\n");
+
+    ret = hal_pke_alg_ecc_init(curve_type);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    ret = inner_ecc_gen_ecdh_key(input_pub_key, input_priv_key, output_shared_key);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_deinit, "inner_ecc_gen_ecdh_key failed\n");
+
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_gen_key.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_gen_key.c
new file mode 100644
index 0000000..705cf3d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_gen_key.c
@@ -0,0 +1,84 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke ecdsa ecdh. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_GEN_KEY_SUPPORT)
+
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+
+/* According to SEC1 "3.2.1 Elliptic Curve Key Pair Generation Primitiv"
+*/
+static td_s32 inner_ecc_gen_key(const drv_pke_data *input_priv_key, const drv_pke_data *output_priv_key,
+    const drv_pke_ecc_point *output_pub_key)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    const unsigned char *ecc_n = hal_pke_alg_ecc_get_n();
+    unsigned int klen = hal_pke_alg_ecc_get_klen();
+
+    /* Step 1. Randomly or pseudorandomly select an integer d in the interval [1, n  1].
+     * Notice: If input_priv_key->data != NULL, then use it as d and skip step1.
+     */
+    if (input_priv_key != NULL && input_priv_key->data != NULL) {
+        ret = memcpy_s(output_priv_key->data, output_priv_key->length, input_priv_key->data, input_priv_key->length);
+        crypto_chk_return(ret != EOK, PKE_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    } else {
+        ret = inner_get_limit_random(output_priv_key->data, ecc_n, klen);
+        crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_get_limit_random failed\n");
+    }
+
+    /* Step 2. Compute Q = d*G. */
+    /* Step 3. Output (d, Q). */
+#if defined(CONFIG_PKE_ECC_GEN_KEY_TRACE_ENABLE)
+    crypto_print("========== Start Compute Q = d*G. ==========\n");
+    crypto_dump_data("d", output_priv_key->data, output_priv_key->length);
+#endif
+    ret = hal_pke_alg_ecc_base_point_mul(output_priv_key, output_pub_key);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_ecc_middle_point_mul failed\n");
+#if defined(CONFIG_PKE_ECC_GEN_KEY_TRACE_ENABLE)
+    crypto_dump_data("Q(x)", output_pub_key->x, output_pub_key->length);
+    crypto_dump_data("Q(y)", output_pub_key->y, output_pub_key->length);
+    crypto_print("========== End Compute Q = d*G. ==========\n");
+#endif
+    return ret;
+}
+
+td_s32 drv_cipher_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key)
+{
+    td_s32 ret = TD_FAILURE;
+    unsigned int klen;
+
+    /* param null check */
+    pke_null_ptr_chk(output_priv_key);
+    pke_null_ptr_chk(output_priv_key->data);
+    pke_null_ptr_chk(output_pub_key);
+    pke_null_ptr_chk(output_pub_key->x);
+    pke_null_ptr_chk(output_pub_key->y);
+
+    /* length check. */
+    klen = crypto_pke_get_klen(curve_type);
+    crypto_chk_return(output_priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "output_priv_key->length is invalid\n");
+    crypto_chk_return(output_pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "output_pub_key->length is invalid\n");
+    if (input_priv_key != NULL && input_priv_key->data != NULL) {
+        crypto_chk_return(input_priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "input_priv_key->length is invalid\n");
+    }
+
+    ret = hal_pke_alg_ecc_init(curve_type);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    ret = inner_ecc_gen_key(input_priv_key, output_priv_key, output_pub_key);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_deinit, "inner_ecc_gen_ecdh_key failed\n");
+
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_sign.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_sign.c
new file mode 100644
index 0000000..38af664
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_sign.c
@@ -0,0 +1,151 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke ecdsa sign. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_ECDSA_SIGN_SUPPORT)
+
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+
+
+#define MAX_TRY_TIMES   100
+#define MAX_ECC_SIZE        72
+
+static td_s32 inner_ecdsa_sign(const drv_pke_data *priv_key, const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    int ret;
+    unsigned char k[MAX_ECC_SIZE];
+    unsigned char kp_point_y[MAX_ECC_SIZE];
+    drv_pke_data k_data = {
+        .data = k,
+        .length = priv_key->length
+    };
+    drv_pke_data r_data = {
+        .data = sig->r,
+        .length = sig->length
+    };
+    drv_pke_data s_data = {
+        .data = sig->s,
+        .length = sig->length
+    };
+    drv_pke_ecc_point kp_point = {
+        .x = sig->r,
+        .y = kp_point_y,
+        .length = priv_key->length
+    };
+    const unsigned char *ecc_n = hal_pke_alg_ecc_get_n();
+
+    /* Step 1. Generate k, which is in [1, n - 1] */
+    ret = inner_get_limit_random(k, ecc_n, priv_key->length);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_get_limit_random failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("random k", k, priv_key->length);
+#endif
+
+    /* Step 2. Compute kp = k * P(x, y) */
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute kp = k * P(x, y) ==========\n");
+    crypto_dump_data("k", k, priv_key->length);
+#endif
+    ret = hal_pke_alg_ecc_base_point_mul(&k_data, &kp_point);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_base_point_mul failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("kp(x)", kp_point.x, kp_point.length);
+    crypto_dump_data("kp(y)", kp_point.y, kp_point.length);
+    crypto_print("========== End Compute kp = k * P(x, y) ==========\n");
+#endif
+    /* Step 3. r = kp(x) mod n, if r == 0, return failure and try again. */
+    if (inner_drv_is_zero(kp_point.x, kp_point.length)) {
+        return PKE_COMPAT_ERRNO(ERROR_ECDSA_SIGN_R_IS_ZERO);
+    }
+    /* Step 4. compute e = H(m), we can skip the step. */
+    /* Step 5. s = k^-1(e + dr) mod n. if s == 0, return failure and try again */
+    r_data.data = kp_point.x;
+    r_data.length = kp_point.length;
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute s = k^-1(e + dr) mod n ==========\n");
+    crypto_dump_data("k", k, priv_key->length);
+    crypto_dump_data("e", hash->data, hash->length);
+    crypto_dump_data("d", priv_key->data, priv_key->length);
+    crypto_dump_data("r", r_data.data, r_data.length);
+#endif
+    ret = hal_pke_alg_ecc_compute_s(&k_data, hash, priv_key, &r_data, &s_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_compute_s failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("s", s_data.data, s_data.length);
+    crypto_print("========== End Compute s = k^-1(e + dr) mod n ==========\n");
+#endif
+    if (inner_drv_is_zero(s_data.data, s_data.length)) {
+        return PKE_COMPAT_ERRNO(ERROR_ECDSA_SIGN_S_IS_ZERO);
+    }
+
+    return ret;
+}
+
+td_s32 drv_cipher_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    int ret;
+    unsigned int i;
+    unsigned int klen;
+    drv_pke_data hash_data;
+
+    /* param check. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->data);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(hash->data);
+    pke_null_ptr_chk(sig);
+    pke_null_ptr_chk(sig->r);
+    pke_null_ptr_chk(sig->s);
+
+    /* length check. */
+    klen = crypto_pke_get_klen(curve_type);
+    crypto_chk_return(priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "priv_key->length is invalid\n");
+    crypto_chk_return(sig->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "sig->length is invalid\n");
+
+    /* increase security strength check. for nist-fips-224, it's the same security strength with SHA224 */
+#if defined(CONFIG_PKE_ECC_SECURITY_STRENGTH_CHECK)
+    drv_crypto_pke_check_param((hash->length < klen) &&
+        !(hash->length == HASH_SIZE_SHA_224 && klen == DRV_PKE_LEN_224) &&
+        !(hash->length == HASH_SIZE_SHA_512 && (klen == DRV_PKE_LEN_521 || klen == DRV_PKE_LEN_576)));
+#endif
+
+    hash_data.data = hash->data;
+    hash_data.length = crypto_min(priv_key->length, hash->length);
+    if (curve_type == DRV_PKE_ECC_TYPE_SM2) {
+        return drv_cipher_pke_sm2_sign(priv_key, &hash_data, sig);
+    }
+
+    ret = hal_pke_alg_ecc_init(curve_type);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    for (i = 0; i < MAX_TRY_TIMES; i++) {
+        ret = inner_ecdsa_sign(priv_key, &hash_data, sig);
+        if (ret == PKE_COMPAT_ERRNO(ERROR_ECDSA_SIGN_R_IS_ZERO) ||
+            ret == PKE_COMPAT_ERRNO(ERROR_ECDSA_SIGN_S_IS_ZERO)) {
+            continue;
+        }
+        if (ret != CRYPTO_SUCCESS) {
+            crypto_log_err("inner_ecdsa_sign failed\n");
+            goto exit_deinit;
+        } else {
+            ret = CRYPTO_SUCCESS;
+            goto exit_deinit;
+        }
+    }
+
+    crypto_log_err("pke sign try max time!\n");
+    ret = PKE_COMPAT_ERRNO(ERROR_TRY_TIMES);
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_verify.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_verify.c
new file mode 100644
index 0000000..936cddd
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_ecdsa_verify.c
@@ -0,0 +1,157 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke ecdsa verify. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+
+
+#define MAX_ECC_SIZE        72
+
+static int inner_ecdsa_verify(const drv_pke_ecc_point *pub_key, const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    int ret;
+    unsigned char w_buf[MAX_ECC_SIZE];
+    unsigned char u1_buf[MAX_ECC_SIZE];
+    unsigned char u2_buf[MAX_ECC_SIZE];
+    unsigned char x_buf[MAX_ECC_SIZE];
+    drv_pke_data sig_s_data = {
+        .data = sig->s,
+        .length = sig->length
+    };
+    drv_pke_data w_data = {
+        .data = w_buf,
+        .length = pub_key->length
+    };
+    drv_pke_data r_data = {
+        .data = sig->r,
+        .length = sig->length
+    };
+    drv_pke_data u1_data = {
+        .data = u1_buf,
+        .length = pub_key->length
+    };
+    drv_pke_data u2_data = {
+        .data = u2_buf,
+        .length = pub_key->length
+    };
+    drv_pke_data x_data = {
+        .data = x_buf,
+        .length = pub_key->length
+    };
+    const unsigned char *ecc_n = hal_pke_alg_ecc_get_n();
+
+    /* Step 1. Check if r is in [1, n - 1], s is in [1, n - 1]. */
+    crypto_chk_return(inner_drv_is_in_range(sig->r, ecc_n, pub_key->length) == TD_FALSE,
+        CRYPTO_FAILURE, "sig->r is not in [1, n - 1]!\n");
+    crypto_chk_return(inner_drv_is_in_range(sig->s, ecc_n, pub_key->length) == TD_FALSE,
+        CRYPTO_FAILURE, "sig->s is not in [1, n - 1]!\n");
+    /* Step 2. compute e = H(m), we can skip the step. */
+    /* Step 3. compute w = s^-1 mod n. */
+
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute w = s^-1 mod n ==========\n");
+    crypto_dump_data("s", sig_s_data.data, sig_s_data.length);
+#endif
+    ret = hal_pke_alg_ecc_inv_mod(&sig_s_data, &w_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_inv_mod failed\n");
+
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("w=s^-1 mod n", w_data.data, w_data.length);
+    crypto_print("========== End Compute w = s^-1 mod n ==========\n");
+#endif
+    /* Step 4. compute u1 = ew mod n, u2 = rw mod n. */
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute u1 = ew mod n, u2 = rw mod n ==========\n");
+    crypto_dump_data("e", hash->data, hash->length);
+    crypto_dump_data("r", r_data.data, r_data.length);
+    crypto_dump_data("w", w_data.data, w_data.length);
+#endif
+    ret = hal_pke_alg_ecc_compute_u1_and_u2(&w_data, hash, &r_data, &u1_data, &u2_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_compute_u1_and_u2 failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("u1 = ew mod n", u1_data.data, u1_data.length);
+    crypto_dump_data("u2 = ew mod n", u2_data.data, u2_data.length);
+    crypto_print("========== End Compute u1 = ew mod n, u2 = rw mod n ==========\n");
+#endif
+    /**
+     * Step 5. compute x = u1 * p(x, y) + u2 * q(x, y).
+     * Step 6. check if x is infinite point.
+    **/
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute x = u1 * p(x, y) + u2 * q(x, y) ==========\n");
+    crypto_dump_data("u1", u1_data.data, u1_data.length);
+    crypto_dump_data("u2", u2_data.data, u2_data.length);
+    crypto_dump_data("Q(x)", pub_key->x, pub_key->length);
+    crypto_dump_data("Q(y)", pub_key->y, pub_key->length);
+#endif
+    ret = hal_pke_alg_ecc_compute_x(&u1_data, &u2_data, pub_key, &x_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_compute_x failed\n");
+
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("x(x)", x_data.data, x_data.length);
+    crypto_print("========== End Compute x = u1 * p(x, y) + u2 * q(x, y) ==========\n");
+#endif
+    /**
+     * Step 7. compute v = x(x).
+     * Step 8. check if v == r.
+    **/
+    if (memcmp(x_data.data, sig->r, x_data.length) == 0) {
+        return CRYPTO_SUCCESS;
+    }
+
+    crypto_log_err("v != r\n");
+    return CRYPTO_FAILURE;
+}
+
+td_s32 drv_cipher_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    int ret;
+    unsigned int klen;
+    drv_pke_data hash_data;
+
+    /* param check. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(hash->data);
+    pke_null_ptr_chk(sig);
+    pke_null_ptr_chk(sig->r);
+    pke_null_ptr_chk(sig->s);
+
+    /* length check. */
+    klen = crypto_pke_get_klen(curve_type);
+    crypto_chk_return(pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is invalid\n");
+    crypto_chk_return(sig->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "sig->length is invalid\n");
+
+    /* increase security strength check. for nist-fips-224, it's the same security strength with SHA224 */
+#if defined(CONFIG_PKE_ECC_SECURITY_STRENGTH_CHECK)
+    drv_crypto_pke_check_param((hash->length < klen) &&
+        !(hash->length == HASH_SIZE_SHA_224 && klen == DRV_PKE_LEN_224) &&
+        !(hash->length == HASH_SIZE_SHA_512 && (klen == DRV_PKE_LEN_521 || klen == DRV_PKE_LEN_576)));
+#endif
+    drv_crypto_pke_check_param(hash->length != HASH_SIZE_SHA_224 && hash->length != HASH_SIZE_SHA_256 &&
+        hash->length != HASH_SIZE_SHA_384 && hash->length != HASH_SIZE_SHA_512);
+    hash_data.data = hash->data;
+    hash_data.length = crypto_min(klen, hash->length);
+
+    ret = hal_pke_alg_ecc_init(curve_type);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    ret = inner_ecdsa_verify(pub_key, &hash_data, sig);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_deinit, "inner_ecdsa_verify failed\n");
+
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_dsa_hash.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_dsa_hash.c
new file mode 100644
index 0000000..6511ec3
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_dsa_hash.c
@@ -0,0 +1,95 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: sm2 hash calculate function implement.
+ * Author: @CompanyNameTag
+ * Create: 2023-05-19
+*/
+#if defined(CONFIG_PKE_ECC_SM2_DSA_HASH_SUPPORT)
+
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+
+
+#define ENTLA_LEN                   2
+#define ZA_ARR_SIZE                 8
+#define E_ARR_SIZE                  2
+
+/* According to SM2 Elliptic Curve Public Key cryptographic algorithm.
+ * Refer to "Patr1 Section 5.5 Other user information" to Compute Za.
+ * Refer to "Part2 Section 6.1. Digital Signature Generation Algorithm Step A1~A2" to Compute the e = H(M')
+ */
+static td_s32 inner_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_u8 entla[ENTLA_LEN];
+    drv_pke_data arr[ZA_ARR_SIZE] = {0};
+    const drv_pke_ecc_curve *sm2 = TD_NULL;
+    drv_pke_data hash_data = {
+        .data = hash->data,
+        .length = hash->length
+    };
+
+    sm2 = hal_pke_alg_ecc_get_curve();
+    /* Za = Hash(ENTLa||IDa||a||b||Xg||Yg||Xa||Ya). */
+    entla[0] = (td_u8)((sm2_id->length * CRYPTO_BITS_IN_BYTE) >> CRYPTO_BITS_IN_BYTE);
+    entla[1] = (td_u8)((sm2_id->length * CRYPTO_BITS_IN_BYTE));
+
+    arr[0] = (const drv_pke_data) { .data = entla, .length = ENTLA_LEN };
+    arr[1] = (const drv_pke_data) { .data = sm2_id->data, .length = sm2_id->length };
+    arr[2] = (const drv_pke_data) { .data = (td_u8 *)sm2->a, .length = SM2_LEN_IN_BYTES };
+    arr[3] = (const drv_pke_data) { .data = (td_u8 *)sm2->b, .length = SM2_LEN_IN_BYTES };
+    arr[4] = (const drv_pke_data) { .data = (td_u8 *)sm2->gx, .length = SM2_LEN_IN_BYTES };
+    arr[5] = (const drv_pke_data) { .data = (td_u8 *)sm2->gy, .length = SM2_LEN_IN_BYTES };
+    arr[6] = (const drv_pke_data) { .data = (td_u8 *)pub_key->x, .length = SM2_LEN_IN_BYTES };
+    arr[7] = (const drv_pke_data) { .data = (td_u8 *)pub_key->y, .length = SM2_LEN_IN_BYTES };
+
+    ret = hal_pke_alg_calc_hash(arr, ZA_ARR_SIZE, DRV_PKE_HASH_TYPE_SM3, &hash_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_calc_hash failed\n");
+
+    /* e = Hash(Za||M) */
+    arr[0] = (const drv_pke_data) { .data = hash_data.data, .length = SM2_LEN_IN_BYTES };
+    arr[1] = (const drv_pke_data) { .data = msg->data, .length = msg->length };
+    ret = hal_pke_alg_calc_hash(arr, E_ARR_SIZE, DRV_PKE_HASH_TYPE_SM3, &hash_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_calc_hash failed\n");
+
+    return ret;
+}
+
+td_s32 drv_cipher_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash)
+{
+    unsigned int klen = DRV_PKE_LEN_256;
+    volatile td_s32 ret = TD_FAILURE;
+    crypto_drv_func_enter();
+
+    /* param check. */
+    pke_null_ptr_chk(sm2_id);
+    pke_null_ptr_chk(sm2_id->data);
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(msg);
+    pke_null_ptr_chk(msg->data);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(hash->data);
+
+    /* length check. */
+    crypto_chk_return(pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is invalid\n");
+    crypto_chk_return(hash->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "hash->length is invalid\n");
+
+    ret = hal_pke_alg_ecc_init(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    ret = inner_sm2_dsa_hash(sm2_id, pub_key, msg, hash);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_deinit, "inner_sm2_dsa_hash failed\n");
+
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    crypto_drv_func_exit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_priv_dec.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_priv_dec.c
new file mode 100644
index 0000000..3088360
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_priv_dec.c
@@ -0,0 +1,183 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke sm2 private decryption. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_SM2_PRIV_DEC_SUPPORT)
+
+#include "drv_pke.h"
+
+#include "drv_pke_inner.h"
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+
+#define SM2_KEY_SIZE            32
+#define SM3_HASH_LEN            32
+#define SM2_PC_UNCOMPRESS       0x04
+/* According to SM2 Elliptic Curve Public Key cryptographic algorithm Part 4 public key encryption algorithm
+ * "Section 7.1. Decryption algorithm"
+ */
+static td_s32 inner_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text)
+{
+    int ret = CRYPTO_FAILURE;
+    unsigned int i;
+    td_bool is_on_curve = TD_FALSE;
+    unsigned int idx = 0;
+    unsigned char u_buf[SM2_KEY_SIZE];
+    unsigned char x2[SM2_KEY_SIZE];
+    unsigned char y2[SM2_KEY_SIZE];
+    drv_pke_ecc_point c1_point = {
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data u_data = {
+        .data = u_buf,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_ecc_point dc1_point = {
+        .x = x2,
+        .y = y2,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data arr[3];    /* 3: Compute u = Hash(x2 || M' || y2). */
+    unsigned char *t = NULL;
+    unsigned char *c2 = NULL;
+    unsigned char *c3 = NULL;
+    unsigned int plain_text_len = cipher_text->length - 1 - SM2_KEY_SIZE * 2 - SM3_HASH_LEN;
+    /* cipher_text = C1 || C3 || C2 */
+    /* According Part1 4.2.8, using uncompress representational form. */
+    if (cipher_text->data[idx] != SM2_PC_UNCOMPRESS) {
+        crypto_log_err("invalid uncompress representational form!\n");
+        return CRYPTO_FAILURE;
+    }
+    idx++;
+    c1_point.x = &cipher_text->data[idx];
+    c1_point.y = &cipher_text->data[idx + SM2_KEY_SIZE];
+    idx += SM2_KEY_SIZE * 2;    // 2: for x and y.
+    c3 = &cipher_text->data[idx];
+    idx += SM3_HASH_LEN;
+    c2 = &cipher_text->data[idx];
+    idx += plain_text_len;
+
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("c2", c2, plain_text_len);
+    crypto_dump_data("cipher_text", cipher_text->data, cipher_text->length);
+#endif
+
+    t = plain_text->data;
+
+    /* Step B1. Get C1 from C and check if C1 is on the curve. */
+    ret = hal_pke_alg_ecc_check_dot_on_curve(&c1_point, &is_on_curve);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_check_dot_on_curve failed\n");
+    crypto_chk_return(is_on_curve != TD_TRUE, CRYPTO_FAILURE, "C1 is not on the curve!\n");
+
+    /* Step B2. Compute S = h * C1, cause h is 1, so we skip this step. */
+    /* Step B3. Compute dC1(x2, y2) = dB * C1. */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute dC1(x2, y2) = dB * C1. ==========\n");
+    crypto_dump_data("dB", priv_key->data, priv_key->length);
+    crypto_dump_data("C1(x)", c1_point.x, c1_point.length);
+    crypto_dump_data("C1(y)", c1_point.y, c1_point.length);
+#endif
+    ret = hal_pke_alg_ecc_point_mul(priv_key, &c1_point, &dc1_point);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_point_mul failed\n");
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("dC1(x1)", dc1_point.x, dc1_point.length);
+    crypto_dump_data("dC1(y1)", dc1_point.y, dc1_point.length);
+    crypto_print("========== End Compute dC1(x2, y2) = dB * C1. ==========\n");
+#endif
+    /*
+     * Step B4. Compute t = kdf(x2 || y2, klen), if t = 0, return failure.
+     * Here klen is plain_text_len.
+     */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute t = kdf(x2 || y2, klen) ==========\n");
+    crypto_dump_data("x2", dc1_point.x, dc1_point.length);
+    crypto_dump_data("y2", dc1_point.y, dc1_point.length);
+#endif
+    ret = inner_sm2_kdf(&dc1_point, t, plain_text_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_sm2_kdf failed\n");
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("t", t, plain_text_len);
+    crypto_print("========== End Compute t = kdf(x2 || y2, klen) ==========\n");
+#endif
+    /* Step B5. Get C2 from C and Compute M' = C2 ^ t. */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute Compute M' = C2 ^ t. ==========\n");
+    crypto_dump_data("C2", c2, plain_text_len);
+    crypto_dump_data("t", t, plain_text_len);
+#endif
+    for (i = 0; i < plain_text_len; i++) {
+        t[i] = t[i] ^ c2[i];
+    }
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("M'", t, plain_text_len);
+    crypto_print("========== End Compute Compute M' = C2 ^ t. ==========\n");
+#endif
+    /* Step B6. Compute u = Hash(x2 || M' || y2), get C3 from C. If u != C3, return failure. */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute Compute u = Hash(x2 || M' || y2). ==========\n");
+    crypto_dump_data("x2", x2, dc1_point.length);
+    crypto_dump_data("M'", t, plain_text_len);
+    crypto_dump_data("y2", y2, dc1_point.length);
+#endif
+    arr[0].data = x2;
+    arr[0].length = SM2_KEY_SIZE;
+    arr[1].data = t;
+    arr[1].length = plain_text_len;
+    arr[2].data = y2;   // 2: position to store y2_data
+    arr[2].length = SM2_KEY_SIZE;   // 2: position to store y2_length
+    ret = hal_pke_alg_calc_hash(arr, crypto_array_size(arr), DRV_PKE_HASH_TYPE_SM3, &u_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_calc_hash failed\n");
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("u", u_buf, SM3_HASH_LEN);
+    crypto_print("========== End Compute Compute u = Hash(x2 || M' || y2) ==========\n");
+#endif
+    if (memcmp(u_buf, c3, SM3_HASH_LEN) != 0) {
+        crypto_log_err("Invalid u!\n");
+        return CRYPTO_FAILURE;
+    }
+
+    /* Step B7. Output plain text M'. */
+    return ret;
+}
+
+td_s32 drv_cipher_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text)
+{
+    unsigned int klen = DRV_PKE_LEN_256;
+    int ret;
+
+    /* param check. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->data);
+    pke_null_ptr_chk(cipher_text);
+    pke_null_ptr_chk(cipher_text->data);
+    pke_null_ptr_chk(plain_text);
+    pke_null_ptr_chk(plain_text->data);
+
+    /* length check. */
+    crypto_chk_return(priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "priv_key->length is invalid\n");
+    crypto_chk_return(cipher_text->length <= CRYPTO_SM2_ADD_LENGTH_IN_BYTE, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "cipher_text->length is not enough\n");
+    /* For SM2 Crypto, the cipher_text is 97 longer than plain_text. */
+    crypto_chk_return(plain_text->length < (cipher_text->length - CRYPTO_SM2_ADD_LENGTH_IN_BYTE),
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "plain_text->length is not enough\n");
+
+    ret = hal_pke_alg_ecc_init(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    ret = inner_sm2_private_decrypt(priv_key, cipher_text, plain_text);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_deinit, "inner_sm2_private_decrypt failed\n");
+
+    plain_text->length = cipher_text->length - CRYPTO_SM2_ADD_LENGTH_IN_BYTE;
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_pub_enc.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_pub_enc.c
new file mode 100644
index 0000000..bbaaf6e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_pub_enc.c
@@ -0,0 +1,182 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke sm2 public encryption. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_SM2_PUB_ENC_SUPPORT)
+#include "drv_pke.h"
+
+#include "drv_pke_inner.h"
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+
+#define SM2_KEY_SIZE        32
+#define SM2_PC_UNCOMPRESS   0x04
+#define SM3_HASH_LEN        32
+
+/* According to SM2 Elliptic Curve Public Key cryptographic algorithm Part 4 public key encryption algorithm
+ * "Section 6.1. Encryption algorithm"
+ */
+static td_s32 inner_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text)
+{
+    int ret = CRYPTO_FAILURE;
+    unsigned int i;
+    unsigned char k[SM2_KEY_SIZE];
+    unsigned char kpb_x[SM2_KEY_SIZE];
+    unsigned char kpb_y[SM2_KEY_SIZE];
+    const unsigned char *sm2_n = hal_pke_alg_ecc_get_n();
+    drv_pke_ecc_point c1_point = {
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data c3_data = {
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_ecc_point kpb_point = {
+        .x = kpb_x,
+        .y = kpb_y,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data k_data = {
+        .data = k,
+        .length = SM2_KEY_SIZE
+    };
+    unsigned int idx = 0;
+    uint8_t *t = NULL;
+    drv_pke_data arr[3];    /* 3: Compute C3 = Hash(x2 || M || y2). */
+
+    /* cipher_text = C1 || C3 || C2 */
+    /* According Part1 4.2.8, using uncompress representational form. */
+    cipher_text->data[idx++] = SM2_PC_UNCOMPRESS;
+    c1_point.x = &cipher_text->data[idx];
+    c1_point.y = &cipher_text->data[idx + SM2_KEY_SIZE];
+    idx += SM2_KEY_SIZE * 2;    // 2: for x and y.
+    c3_data.data = &cipher_text->data[idx];
+    idx += SM3_HASH_LEN;
+    t = &cipher_text->data[idx];
+    idx += plain_text->length;
+    /* Step A1. generate k in [1, n - 1] */
+    ret = inner_generate_random_in_range(k, sm2_n, pub_key->length);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_generate_random_in_range failed\n");
+
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("random k", k, pub_key->length);
+#endif
+
+    /* Step A2. Compte C1(x1, y1) = k * G. */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute C1 = k * G ==========\n");
+    crypto_dump_data("random k", k, pub_key->length);
+#endif
+    ret = hal_pke_alg_ecc_base_point_mul(&k_data, &c1_point);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_base_point_mul failed\n");
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("C1(x1)", c1_point.x, c1_point.length);
+    crypto_dump_data("C1(y1)", c1_point.y, c1_point.length);
+    crypto_print("========== End Compute C1 = k * G ==========\n");
+#endif
+    /* Step A3. Compute S = h * Pb, cause h is 1, so we skip this step.  */
+    /* Step A4. Compute kPb(x2, y2) = k * Pb. */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute kPb(x2, y2) = k * Pb ==========\n");
+    crypto_dump_data("random k", k, pub_key->length);
+    crypto_dump_data("Pb(x)", pub_key->x, pub_key->length);
+    crypto_dump_data("Pb(y)", pub_key->y, pub_key->length);
+#endif
+    ret = hal_pke_alg_ecc_point_mul(&k_data, pub_key, &kpb_point);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_point_mul failed\n");
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("kPb(x)", kpb_point.x, kpb_point.length);
+    crypto_dump_data("kPb(y)", kpb_point.y, kpb_point.length);
+    crypto_print("========== End Compute kPb(x2, y2) = k * Pb ==========\n");
+#endif
+    /*
+     * Step A5. Compute t = kdf(x2 || y2, klen), if t = 0, goto A1.
+     * Here klen is plain_text->length.
+     */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute t = kdf(x2 || y2, klen) ==========\n");
+    crypto_dump_data("x2", kpb_point.x, kpb_point.length);
+    crypto_dump_data("y2", kpb_point.y, kpb_point.length);
+#endif
+    ret = inner_sm2_kdf(&kpb_point, t, plain_text->length);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_sm2_kdf failed\n");
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("t", t, plain_text->length);
+    crypto_print("========== End Compute t = kdf(x2 || y2, klen) ==========\n");
+#endif
+
+    /* Step A6. Compute C2 = M ^ t. */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute Compute C2 = M ^ t ==========\n");
+    crypto_dump_data("M", plain_text->data, plain_text->length);
+    crypto_dump_data("t", t, plain_text->length);
+#endif
+    for (i = 0; i < plain_text->length; i++) {
+        t[i] = t[i] ^ plain_text->data[i];
+    }
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("C2", t, plain_text->length);
+    crypto_print("========== End Compute Compute C2 = M ^ t ==========\n");
+#endif
+    /* Step A7. Compute C3 = Hash(x2 || M || y2). */
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_print("========== Start Compute Compute C3 = Hash(x2 || M || y2). ==========\n");
+    crypto_dump_data("x2", kpb_point.x, kpb_point.length);
+    crypto_dump_data("M", plain_text->data, plain_text->length);
+    crypto_dump_data("y2", kpb_point.y, kpb_point.length);
+#endif
+    arr[0].data = kpb_x;
+    arr[0].length = SM2_KEY_SIZE;
+    arr[1].data = plain_text->data;
+    arr[1].length = plain_text->length;
+    arr[2].data = kpb_y;    // 2: position to store kpb_y_data
+    arr[2].length = SM2_KEY_SIZE;   // 2: position to store kpb_y_length
+    ret = hal_pke_alg_calc_hash(arr, crypto_array_size(arr), DRV_PKE_HASH_TYPE_SM3, &c3_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_calc_hash failed\n");
+#if defined(CONFIG_PKE_SM2_TRACE_ENABLE)
+    crypto_dump_data("C3", c3_data.data, c3_data.length);
+    crypto_print("========== End Compute Compute C3 = Hash(x2 || M || y2) ==========\n");
+#endif
+    /* Step A8. Compute C = C1 || C2 || C3. We can skip this Step. */
+    return ret;
+}
+
+td_s32 drv_cipher_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text)
+{
+    unsigned int klen = DRV_PKE_LEN_256;
+    int ret;
+
+    /* param check. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(plain_text);
+    pke_null_ptr_chk(plain_text->data);
+    pke_null_ptr_chk(cipher_text);
+    pke_null_ptr_chk(cipher_text->data);
+
+    /* length check. */
+    crypto_chk_return(pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is invalid\n");
+    /* For SM2 Crypto, the cipher_text is 97 longer than plain_text. */
+    crypto_chk_return(cipher_text->length < plain_text->length + CRYPTO_SM2_ADD_LENGTH_IN_BYTE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "cipher_text->length is not enough\n");
+
+    ret = hal_pke_alg_ecc_init(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    ret = inner_sm2_public_encrypt(pub_key, plain_text, cipher_text);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_deinit, "inner_sm2_public_encrypt failed\n");
+
+    cipher_text->length = plain_text->length + CRYPTO_SM2_ADD_LENGTH_IN_BYTE;
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_sign.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_sign.c
new file mode 100644
index 0000000..8554411
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_sign.c
@@ -0,0 +1,161 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke sm2 sign. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_SM2_SIGN_SUPPORT)
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+
+
+#define MAX_TRY_TIMES   100
+#define SM2_KEY_SIZE        32
+
+/* According to SM2 Elliptic Curve Public Key cryptographic algorithm.
+ * "Section 6.1. Digital Signature Generation Algorithm"
+ */
+static td_s32 inner_sm2_sign(const drv_pke_data *priv_key, const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    int ret;
+    unsigned char k[SM2_KEY_SIZE];
+    unsigned char kg_buf[SM2_KEY_SIZE * 2];
+    drv_pke_data k_data = {
+        .data = k,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_ecc_point kg_point = {
+        .x = kg_buf,
+        .y = kg_buf + SM2_KEY_SIZE,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data r_data = {
+        .data = sig->r,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data x1_data = {
+        .data = kg_point.x,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data s_data = {
+        .data = sig->s,
+        .length = SM2_KEY_SIZE
+    };
+    const unsigned char *sm2_n = hal_pke_alg_ecc_get_n();
+
+    /* Step A1~A2: compute e = H(ZA || M), we can skip. */
+    /* Step A3. generate k in [1, n - 1] */
+    ret = inner_generate_random_in_range(k, sm2_n, priv_key->length);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_generate_random_in_range failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("random k", k, priv_key->length);
+#endif
+    /* Step A4. compute k * G. */
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute kg = k * G ==========\n");
+    crypto_dump_data("k", k, priv_key->length);
+#endif
+    ret = hal_pke_alg_ecc_base_point_mul(&k_data, &kg_point);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_base_point_mul failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("kg(x)", kg_point.x, kg_point.length);
+    crypto_dump_data("kg(y)", kg_point.y, kg_point.length);
+    crypto_print("========== End Compute kg = k * G ==========\n");
+#endif
+    /* Step A5. compute r = (e + x1) mod n, x1 is kg(x), if r = 0 or r + k = n, continue. */
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute r = (e + x1) mod n ==========\n");
+    crypto_dump_data("e", hash->data, hash->length);
+    crypto_dump_data("x1", x1_data.data, x1_data.length);
+#endif
+    ret = hal_pke_alg_sm2_add_mod(hash, &x1_data, &r_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_sm2_add_mod failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("r", r_data.data, r_data.length);
+    crypto_print("========== End Compute r = (e + x1) mod n==========\n");
+#endif
+    /* check if r is zero. */
+    if (inner_drv_is_zero(r_data.data, r_data.length)) {
+        crypto_log_err("r is zero!\n");
+        return CRYPTO_FAILURE;
+    }
+    /* check if (r + k) mod n is zero, which means r + k = n. */
+    ret = hal_pke_alg_sm2_add_mod(&r_data, &k_data, &s_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_sm2_add_mod failed\n");
+    if (inner_drv_is_zero(s_data.data, s_data.length)) {
+        crypto_log_err("s is zero!\n");
+        return CRYPTO_FAILURE;
+    }
+    /* Step A6. compute s = (((1 + d)^-1) * (k - r * d)) mod n. */
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute s = (((1 + d)^-1) * (k - r * d)) mod n ==========\n");
+    crypto_dump_data("d", priv_key->data, priv_key->length);
+    crypto_dump_data("k", k_data.data, k_data.length);
+    crypto_dump_data("r", r_data.data, r_data.length);
+#endif
+
+    ret = hal_pke_alg_sm2_compute_s(priv_key, &k_data, &r_data, &s_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_sm2_compute_s failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("s", s_data.data, s_data.length);
+    crypto_print("========== End Compute s = (((1 + d)^-1) * (k - r * d)) mod n==========\n");
+#endif
+    return ret;
+}
+
+td_s32 drv_cipher_pke_sm2_sign(const drv_pke_data *priv_key, const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    int ret;
+    unsigned int i;
+    unsigned int klen = DRV_PKE_LEN_256;
+    drv_pke_data hash_data;
+
+    /* param check. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->data);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(hash->data);
+    pke_null_ptr_chk(sig);
+    pke_null_ptr_chk(sig->r);
+    pke_null_ptr_chk(sig->s);
+
+    /* length check. */
+    crypto_chk_return(priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "priv_key->length is invalid\n");
+    crypto_chk_return(sig->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "sig->length is invalid\n");
+#if defined(CONFIG_PKE_ECC_SECURITY_STRENGTH_CHECK)
+    /* increase security strength check. */
+    drv_crypto_pke_check_param(hash->length < klen);
+#endif
+
+    ret = hal_pke_alg_ecc_init(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    hash_data.data = hash->data;
+    hash_data.length = crypto_min(SM2_KEY_SIZE, hash->length);
+
+    for (i = 0; i < MAX_TRY_TIMES; i++) {
+        ret = inner_sm2_sign(priv_key, &hash_data, sig);
+        if (ret == PKE_COMPAT_ERRNO(ERROR_ECDSA_SIGN_R_IS_ZERO) ||
+            ret == PKE_COMPAT_ERRNO(ERROR_ECDSA_SIGN_S_IS_ZERO)) {
+            continue;
+        }
+        if (ret != CRYPTO_SUCCESS) {
+            crypto_log_err("inner_sm2_sign failed\n");
+            goto exit_deinit;
+        } else {
+            ret = CRYPTO_SUCCESS;
+            goto exit_deinit;
+        }
+    }
+
+    ret = PKE_COMPAT_ERRNO(ERROR_TRY_TIMES);
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_verify.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_verify.c
new file mode 100644
index 0000000..aa3f457
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/ecc/drv_pke_sm2_verify.c
@@ -0,0 +1,135 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke sm2 verify. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_SM2_VERIFY_SUPPORT)
+
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+
+
+#define SM2_KEY_SIZE        32
+/*
+ * According to <SM2 Elliptic Curve Public Key cryptographic algorithm>
+ * Section 7.1. Digital Signature Verification Algorithm.
+ */
+static int inner_sm2_verify(const drv_pke_ecc_point *pub_key, const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    int ret;
+    unsigned char t_buf[SM2_KEY_SIZE];
+    unsigned char x_buf[SM2_KEY_SIZE];
+    drv_pke_data r_data = {
+        .data = sig->r,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data s_data = {
+        .data = sig->s,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data t_data = {
+        .data = t_buf,
+        .length = SM2_KEY_SIZE
+    };
+    drv_pke_data x_data = {
+        .data = x_buf,
+        .length = SM2_KEY_SIZE
+    };
+    const unsigned char *sm2_n = hal_pke_alg_ecc_get_n();
+
+    /* Step B1. check if r is in [1, n - 1] */
+    crypto_chk_return(inner_drv_is_in_range(sig->r, sm2_n, SM2_KEY_SIZE) == TD_FALSE,
+        CRYPTO_FAILURE, "sig->r is not in [1, n - 1]!\n");
+    /* Step B2. check if s is in [1, n - 1] */
+    crypto_chk_return(inner_drv_is_in_range(sig->s, sm2_n, SM2_KEY_SIZE) == TD_FALSE,
+        CRYPTO_FAILURE, "sig->s is not in [1, n - 1]!\n");
+    /* Step B3-B4. compute H(ZA || M), we can skip. */
+    /* Step B5. compute t = (r + s) mod n, if t = 0, return failure. */
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute t = (r + s) mod n. ==========\n");
+    crypto_dump_data("r", r_data.data, r_data.length);
+    crypto_dump_data("s", s_data.data, s_data.length);
+#endif
+    ret = hal_pke_alg_sm2_add_mod(&r_data, &s_data, &t_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_sm2_add_mod failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("t", t_data.data, t_data.length);
+    crypto_print("========== End Compute t = (r + s) mod n. ==========\n");
+#endif
+    /* Step B6. compute X(x, y) = s * G + t * P. */
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute X(x, y) = s * G + t * P. ==========\n");
+    crypto_dump_data("s", s_data.data, s_data.length);
+    crypto_dump_data("t", t_data.data, t_data.length);
+    crypto_dump_data("P(x)", pub_key->x, pub_key->length);
+    crypto_dump_data("P(y)", pub_key->y, pub_key->length);
+#endif
+    ret = hal_pke_alg_ecc_compute_x(&s_data, &t_data, pub_key, &x_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_compute_x failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("X(x)", x_data.data, x_data.length);
+    crypto_print("========== End Compute X(x, y) = s * G + t * P. ==========\n");
+#endif
+    /* Step B7. compute r = (e + x) mod n, check if r = sig->r, return success, else return failure. */
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_print("========== Start Compute r = (e + x) mod n. ==========\n");
+    crypto_dump_data("e", hash->data, hash->length);
+    crypto_dump_data("X(x)", x_data.data, x_data.length);
+#endif
+    ret = hal_pke_alg_sm2_add_mod(hash, &x_data, &t_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_sm2_add_mod failed\n");
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("r", t_data.data, t_data.length);
+    crypto_print("========== End Compute r = (e + x) mod n. ==========\n");
+#endif
+    if (memcmp(t_data.data, sig->r, SM2_KEY_SIZE) == 0) {
+        return CRYPTO_SUCCESS;
+    }
+
+    crypto_log_err("compute r is invalid!\n");
+    return CRYPTO_FAILURE;
+}
+
+td_s32 drv_cipher_pke_sm2_verify(const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    int ret;
+    unsigned int klen = DRV_PKE_LEN_256;
+    drv_pke_data hash_data;
+
+    /* param check. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(hash->data);
+    pke_null_ptr_chk(sig);
+    pke_null_ptr_chk(sig->r);
+    pke_null_ptr_chk(sig->s);
+
+    /* length check. */
+    crypto_chk_return(pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is invalid\n");
+    crypto_chk_return(sig->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "sig->length is invalid\n");
+#if defined(CONFIG_PKE_ECC_SECURITY_STRENGTH_CHECK)
+    /* increase security strength check. */
+    drv_crypto_pke_check_param(hash->length < klen);
+#endif
+    ret = hal_pke_alg_ecc_init(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_init failed\n");
+
+    hash_data.data = hash->data;
+    hash_data.length = crypto_min(SM2_KEY_SIZE, hash->length);
+    ret = inner_sm2_verify(pub_key, &hash_data, sig);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_deinit, "inner_sm2_verify failed\n");
+
+exit_deinit:
+    hal_pke_alg_ecc_deinit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_priv_dec.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_priv_dec.c
new file mode 100644
index 0000000..76a170e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_priv_dec.c
@@ -0,0 +1,164 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke rsa private decryption. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+#define RSA_PADLEN_11              11
+#if defined(CONFIG_PKE_RSA_PRIV_DEC_SUPPORT)
+
+static td_s32 rsa_decrypt(const drv_pke_rsa_scheme scheme, const drv_pke_hash_type hash_type, td_u8 *em,
+    const td_u32 klen, const drv_pke_data *label, drv_pke_data *msg)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_pack de_pack = {
+        .klen = klen,
+        .em_bit = 0,
+        .em = em,
+        .em_len = klen,
+        .hash = TD_NULL,
+        .hash_len = 0,
+        .data = msg->data,
+        .data_len = msg->length
+    };
+
+    crypto_unused(de_pack);
+    crypto_unused(hash_type);
+    crypto_unused(label);
+
+    switch (scheme) {
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V15: {
+            ret = pkcs1_v15_decrypt(&de_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_v15_decrypt failed, ret is 0x%x\n", ret);
+            msg->length = de_pack.data_len; // record length of plain text for return
+            break;
+        }
+#endif
+#if defined(CONFIG_PKE_RSA_V21_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V21: {
+            ret = pkcs1_oaep_decrypt(hash_type, &de_pack, label);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_oaep_decrypt failed, ret is 0x%x\n", ret);
+            msg->length = de_pack.data_len; // record length of plain text for return
+            break;
+        }
+#endif
+        default:
+            crypto_log_err("Invalid rsa decrypt padding type.\n");
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return ret;
+}
+
+static td_s32 pke_rsa_decrypt(
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 em[DRV_PKE_LEN_4096];
+    td_u32 klen = priv_key->n_len;
+    drv_pke_data n_data = { .data = priv_key->n, .length = klen };
+    drv_pke_data d_data = { .data = priv_key->d, .length = klen };
+    drv_pke_data em_data = { .data = em, .length = klen };
+
+    (void)memset_s(em, sizeof(em), 0x00, sizeof(em));
+
+    ret = hal_pke_alg_rsa_exp_mod(&n_data, &d_data, input, &em_data);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_alg_rsa_exp_mod failed, ret is 0x%x\n", ret);
+
+    ret = rsa_decrypt(scheme, hash_type, em, klen, label, output);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "rsa_decrypt failed, ret is 0x%x\n", ret);
+    if (memcmp(input->data, output->data, output->length) == 0) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_SAME_DATA);
+    }
+    return ret;
+}
+
+td_s32 drv_cipher_pke_rsa_private_decrypt(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_FAILURE;
+
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    td_u32 output_len = 0;
+    /* check ptr. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->n);
+    pke_null_ptr_chk(priv_key->d);
+    pke_null_ptr_chk(input);
+    pke_null_ptr_chk(input->data);
+    pke_null_ptr_chk(output);
+    pke_null_ptr_chk(output->data);
+    if (label != TD_NULL) {
+        pke_null_ptr_chk(label->data);
+    }
+
+    /* check enum. */
+    crypto_chk_return(scheme >= DRV_PKE_RSA_SCHEME_MAX, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "scheme is Invalid\n");
+    crypto_chk_return(hash_type < DRV_PKE_HASH_TYPE_SHA1 || hash_type > DRV_PKE_HASH_TYPE_SHA512,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    /* check length. */
+    klen = priv_key->n_len;
+    output_len = output->length;
+    hash_len = drv_get_hash_len(hash_type);
+    crypto_chk_return(hash_len == 0, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    crypto_chk_return(crypto_rsa_klen_support(klen) != TD_SUCCESS, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+    crypto_chk_return(priv_key->d_len != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "d_len is Invalid\n");
+    crypto_chk_return(input->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "input_len is Invalid\n");
+
+    /*
+     * For V15, the plain_text's max length is klen - 11.
+     * For OAEP, the plain_text's max length is klen - 2 * hash_len - 2.
+     */
+    if (scheme == DRV_PKE_RSA_SCHEME_PKCS1_V15) {
+        crypto_chk_return(output_len < klen - RSA_PADLEN_11, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "output_len is not enough for V15\n");
+    } else {
+        crypto_chk_return(output_len < klen - 2 * hash_len - 2,  // 2: refer to comment.
+            PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "output_len is not enough for V21\n");
+    }
+    crypto_chk_return(crypto_rsa_support(klen, scheme) == TD_FALSE, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+
+    ret = pke_rsa_decrypt(scheme, hash_type, priv_key, input, label, output);
+    return ret;
+}
+#else
+td_s32 drv_cipher_pke_rsa_private_decrypt(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    crypto_unused(scheme);
+    crypto_unused(hash_type);
+    crypto_unused(priv_key);
+    crypto_unused(input);
+    crypto_unused(label);
+    crypto_unused(output);
+
+    return PKE_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_pub_enc.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_pub_enc.c
new file mode 100644
index 0000000..c51b4a1
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_pub_enc.c
@@ -0,0 +1,169 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke rsa public encryption. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+
+#define RSA_PADLEN_11              11
+#if defined(CONFIG_PKE_RSA_PUB_ENC_SUPPORT)
+
+static td_s32 rsa_encrypt(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    td_u8 *em,
+    const td_u32 klen,
+    const drv_pke_data *msg,
+    const drv_pke_data *label)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_pack en_pack = {
+        .klen = klen,
+        .em_bit = 0,
+        .em = em,
+        .em_len = klen,
+        .hash = TD_NULL,
+        .hash_len = 0,
+        .data = msg->data,
+        .data_len = msg->length
+    };
+
+    crypto_unused(en_pack);
+    crypto_unused(hash_type);
+    crypto_unused(label);
+
+    switch (scheme) {
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V15: {
+            ret = pkcs1_v15_encrypt(&en_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_v15_encrypt failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+#if defined(CONFIG_PKE_RSA_V21_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V21: {
+            ret = pkcs1_oaep_encrypt(hash_type, &en_pack, label);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_oaep_encrypt failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+        default:
+            crypto_log_err("Invalid rsa encrypt padding type.\n");
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return ret;
+}
+
+static td_s32 pke_rsa_encrypt(
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    const drv_pke_data *output)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 em[DRV_PKE_LEN_4096];
+    td_u32 klen = pub_key->len;
+    drv_pke_data n_data = { .data = pub_key->n, .length = klen };
+    drv_pke_data e_data = { .data = pub_key->e, .length = klen };
+    drv_pke_data em_data = { .data = em, .length = klen };
+
+    (void)memset_s(em, sizeof(em), 0x00, sizeof(em));
+    ret = rsa_encrypt(scheme, hash_type, em, klen, input, label);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "rsa_encrypt failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_alg_rsa_exp_mod(&n_data, &e_data, &em_data, output);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_alg_rsa_exp_mod failed, ret is 0x%x\n", ret);
+    if (memcmp(input->data, output->data, input->length) == 0) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_SAME_DATA);
+    }
+
+    return ret;
+}
+
+td_s32 drv_cipher_pke_rsa_public_encrypt(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    td_u32 input_len = 0;
+    /* check ptr. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->n);
+    pke_null_ptr_chk(pub_key->e);
+    pke_null_ptr_chk(input);
+    pke_null_ptr_chk(input->data);
+    pke_null_ptr_chk(output);
+    pke_null_ptr_chk(output->data);
+    if (label != TD_NULL) {
+        pke_null_ptr_chk(label->data);
+    }
+
+    /* check enum. */
+    crypto_chk_return(scheme >= DRV_PKE_RSA_SCHEME_MAX, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "scheme is Invalid\n");
+    crypto_chk_return(hash_type < DRV_PKE_HASH_TYPE_SHA1 || hash_type > DRV_PKE_HASH_TYPE_SHA512,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    /* check length. */
+    klen = pub_key->len;
+    input_len = input->length;
+    hash_len = drv_get_hash_len(hash_type);
+    crypto_chk_return(hash_len == 0, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    crypto_chk_return(crypto_rsa_klen_support(klen) != TD_SUCCESS, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+    /*
+     * For V15, the plain_text's max length is klen - 11.
+     * For OAEP, the plain_text's max length is klen - 2 * hash_len - 2.
+     */
+    if (scheme == DRV_PKE_RSA_SCHEME_PKCS1_V15) {
+        crypto_chk_return(input_len > klen - RSA_PADLEN_11, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "input_len is too long for V15\n");
+    } else {
+        crypto_chk_return(input_len > klen - 2 * hash_len - 2,  // 2: refer to comment.
+            PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "input_len is too long for V21\n");
+    }
+    crypto_chk_return(input_len == 0, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "input_len is zero\n");
+    crypto_chk_return(output->length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "output_len is Invalid\n");
+    crypto_chk_return(crypto_rsa_support(klen, scheme) == TD_FALSE, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+
+    ret = pke_rsa_encrypt(scheme, hash_type, pub_key, input, label, output);
+    if (ret == TD_SUCCESS) {
+        output->length = klen;
+    }
+
+    return ret;
+}
+#else
+td_s32 drv_cipher_pke_rsa_public_encrypt(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    crypto_unused(scheme);
+    crypto_unused(hash_type);
+    crypto_unused(pub_key);
+    crypto_unused(input);
+    crypto_unused(label);
+    crypto_unused(output);
+
+    return PKE_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_sign.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_sign.c
new file mode 100644
index 0000000..57c3983
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_sign.c
@@ -0,0 +1,165 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke rsa sign. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+
+#if defined(CONFIG_PKE_RSA_SIGN_SUPPORT)
+static td_s32 rsa_sign(
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    td_u8 *em,
+    td_u32 klen,
+    td_u32 em_bit,
+    const drv_pke_data *msg)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_pack sg_pack = {
+        .klen = klen,
+        .em_bit = em_bit,
+        .em = em,
+        .em_len = klen,
+        .hash = msg->data,
+        .hash_len = msg->length,
+        .data = TD_NULL,
+        .data_len = 0
+    };
+
+    crypto_unused(sg_pack);
+    crypto_unused(hash_type);
+
+    switch (scheme) {
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V15: {
+            ret = pkcs1_v15_sign(hash_type, &sg_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_v15_sign failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+#if defined(CONFIG_PKE_RSA_V21_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V21: {
+            ret = pkcs1_pss_sign(hash_type, &sg_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_pss_sign failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+        default:
+            crypto_log_err("Invalid rsa sign padding type.\n");
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return ret;
+}
+
+static td_s32 inner_pke_rsa_sign(
+    const drv_pke_rsa_priv_key *priv_key,
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    drv_pke_data *sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *em;
+    td_u32 klen = priv_key->n_len;
+    td_u32 em_bit = 0;
+    drv_pke_data n_data = { .data = priv_key->n, .length = klen };
+    drv_pke_data d_data = { . data = priv_key->d, .length = klen };
+    drv_pke_data em_data = { .length = klen };
+    em = crypto_malloc(DRV_PKE_LEN_4096);
+    if (em == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(em, DRV_PKE_LEN_4096, 0x00, DRV_PKE_LEN_4096);
+
+    em_bit = rsa_get_bit_num((const td_u8 *)priv_key->n, priv_key->n_len);
+    ret = rsa_sign(scheme, hash_type, em, klen, em_bit, input_hash);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit__, ret, "rsa_sign failed, ret is 0x%x\n", ret);
+
+    em_data.data = em;
+    ret = hal_pke_alg_rsa_exp_mod(&n_data, &d_data, &em_data, sign);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit__, ret, "hal_pke_alg_rsa_exp_mod failed, ret is 0x%x\n", ret);
+
+    if (memcmp(input_hash->data, sign->data, input_hash->length) == 0) {
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_RSA_SAME_DATA);
+    }
+
+exit__:
+    if (em != TD_NULL) {
+        (void)memset_s(em, DRV_PKE_LEN_4096, 0, DRV_PKE_LEN_4096);
+        crypto_free(em);
+    }
+    return ret;
+}
+
+td_s32 drv_cipher_pke_rsa_sign(
+    const drv_pke_rsa_priv_key *priv_key,
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    drv_pke_data *sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    /* check ptr. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->n);
+    pke_null_ptr_chk(priv_key->d);
+    pke_null_ptr_chk(input_hash);
+    pke_null_ptr_chk(input_hash->data);
+    pke_null_ptr_chk(sign);
+    pke_null_ptr_chk(sign->data);
+
+    /* check enum. */
+    crypto_chk_return(scheme >= DRV_PKE_RSA_SCHEME_MAX, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "scheme is Invalid\n");
+    crypto_chk_return(hash_type < DRV_PKE_HASH_TYPE_SHA1 || hash_type > DRV_PKE_HASH_TYPE_SHA512,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    /* check length. */
+    klen = priv_key->n_len;
+    hash_len = drv_get_hash_len(hash_type);
+    crypto_chk_return(input_hash->length != hash_len, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "input_hash->length is Invalid\n");
+
+    crypto_chk_return(crypto_rsa_klen_support(klen) != TD_SUCCESS, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+    if ((priv_key->d_len != klen)) {
+        ret = PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        crypto_log_err("d_len is Invalid!\n");
+        return ret;
+    }
+    crypto_chk_return(sign->length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "sign_len is Invalid\n");
+    crypto_chk_return(crypto_rsa_support(klen, scheme) == TD_FALSE, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+
+    ret = inner_pke_rsa_sign(priv_key, scheme, hash_type, input_hash, sign);
+    if (ret == TD_SUCCESS) {
+        sign->length = klen;
+    }
+    return ret;
+}
+#else
+td_s32 drv_cipher_pke_rsa_sign(
+    const drv_pke_rsa_priv_key *priv_key,
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    drv_pke_data *sign)
+{
+    crypto_unused(priv_key);
+    crypto_unused(scheme);
+    crypto_unused(hash_type);
+    crypto_unused(input_hash);
+    crypto_unused(sign);
+
+    return PKE_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_v15.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_v15.c
new file mode 100644
index 0000000..14ea85e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_v15.c
@@ -0,0 +1,178 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke rsa v15. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+/* According to RFC2313. */
+
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+
+#define RSA_PADLEN_1                1
+#define RSA_PADLEN_3                3
+#define RSA_PADLEN_11               11
+
+#if defined(CONFIG_PKE_RSA_SIGN_SUPPORT)
+/* EM = 00 || 01 || PS || 00 || T */
+td_s32 pkcs1_v15_sign(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 *p = TD_NULL;
+    td_u32 idx = 0;
+
+    ret = pkcs1_get_hash(hash_type, TD_NULL, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    p = pack->em;
+    p[idx++] = 0x00;
+    p[idx++] = 0x01;
+
+    /* PS */
+    while (idx < (pack->em_len - hash_info.hash_len - hash_info.asn1_len - 1)) {
+        p[idx++] = CRYPTO_BYTE_MAX;
+    }
+
+    p[idx++] = 0x00;
+
+    /* T */
+    ret = memcpy_s(&p[idx], pack->em_len - idx, hash_info.asn1_data, hash_info.asn1_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    idx += hash_info.asn1_len;
+    ret = memcpy_s(&p[idx], pack->em_len - idx, pack->hash, hash_info.hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_VERIFY_SUPPORT)
+/* check EM = 00 || 01 || PS || 00 || T */
+td_s32 pkcs1_v15_verify(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 *p = TD_NULL;
+    td_u32 idx = 0;
+
+    ret = pkcs1_get_hash(hash_type, TD_NULL, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    p = pack->em;
+    if (p[idx++] != 0x00) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+    if (p[idx++] != 0x01) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+
+    /* PS */
+    while (idx < (pack->em_len - hash_info.hash_len - hash_info.asn1_len - 1)) {
+        if (p[idx++] != CRYPTO_BYTE_MAX) {
+            return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+        }
+    }
+    if (p[idx++] != 0x00) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+
+    /* T */
+    if (memcmp(&p[idx], hash_info.asn1_data, hash_info.asn1_len) != 0) {
+        crypto_log_err("check v15 asn1 failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+
+    idx += hash_info.asn1_len;
+    if (memcmp(&p[idx], pack->hash, hash_info.hash_len) != 0) {
+        crypto_log_err("check v15 hash failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_PUB_ENC_SUPPORT)
+/* EM = 00 || 02 || PS || 00 || M */
+td_s32 pkcs1_v15_encrypt(const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *p = TD_NULL;
+    td_u32 idx = 0;
+    td_u32 ps_len = pack->em_len - pack->data_len - RSA_PADLEN_3;
+
+    p = pack->em;
+    p[idx++] = 0x00;
+    p[idx++] = 0x02; // 0x02 see comment above func
+
+    /* PS */
+    ret = inner_get_random_with_nonzero_octets(&p[idx], ps_len);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("get random ps failed!\n");
+        return ret;
+    }
+    idx += ps_len;
+
+    p[idx++] = 0x00;
+    /* M */
+    if (pack->data_len != 0) {
+        ret = memcpy_s(&p[idx], pack->em_len - idx, pack->data, pack->data_len);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_PRIV_DEC_SUPPORT)
+/* check EM = 00 || 02 || PS || 00 || M */
+td_s32 pkcs1_v15_decrypt(rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *p = TD_NULL;
+    td_u32 idx = 0;
+    td_u32 len = 0;
+
+    p = pack->em;
+    if (p[idx++] != 0x00) {
+        crypto_log_err("padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_V15_CHECK);
+    }
+
+    if (p[idx++] != 0x02) { // 0x02 see comment above func
+        crypto_log_err("padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_V15_CHECK);
+    }
+
+    /* PS */
+    while ((idx < (pack->em_len - RSA_PADLEN_1)) && p[idx] != 0x00) {
+        idx++;
+    }
+
+    if (p[idx++] != 0x00) {
+        crypto_log_err("padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_V15_CHECK);
+    }
+
+    len = pack->em_len - idx;
+    if (len > pack->em_len - RSA_PADLEN_11) {
+        crypto_log_err("padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_V15_CHECK);
+    }
+
+    /* M */
+    if (len != 0) {
+        ret = memcpy_s(pack->data, pack->data_len, &p[idx], len);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+    pack->data_len = len; // record length of plain text for return
+
+    return TD_SUCCESS;
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_v21.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_v21.c
new file mode 100755
index 0000000..6909383
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_v21.c
@@ -0,0 +1,363 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke rsa v21. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_PKE_RSA_V21_SUPPORT)
+
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+
+#define RSA_PAD_XBC                0xBC
+#define BOUND_VALUE_1              1
+#define MAX_LOW_3BITS              7
+#define MAX_LOW_8BITS              0xFF
+
+#define WORD_INDEX_0               0
+#define WORD_INDEX_1               1
+#define WORD_INDEX_2               2
+#define WORD_INDEX_3               3
+
+#define SHIFT_4BITS                4
+#define SHIFT_8BITS                8
+#define SHIFT_16BITS               16
+#define SHIFT_24BITS               24
+
+#define RSA_PADLEN_2               2
+#define RSA_PADLEN_8               8
+
+#if defined(CONFIG_PKE_RSA_V21_SUPPORT)
+#if defined(CONFIG_PKE_RSA_SIGN_SUPPORT) || defined(CONFIG_PKE_RSA_VERIFY_SUPPORT)
+/* H = Hash( M' ) = Hash( Padding1 || mHash || salt ) */
+static td_s32 inner_pkcs1_pss_hash(const rsa_pkcs1_hash_info *hash_info, const td_u8 *m_hash, td_u32 klen,
+    const drv_pke_data *salt, drv_pke_data *hash)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 ps[RSA_PADLEN_8] = {0};
+    drv_pke_data arr[3]; // The capacity of the array is 3.
+
+    /* H = Hash(PS || MHash || SALT) */
+    arr[0].data = ps; // 0 th element is ps
+    arr[0].length = RSA_PADLEN_8; // 0 element is PS
+    arr[1].data = (td_u8 *)m_hash; // 1 element is MHash
+    arr[1].length = klen; // 1 element is MHash
+    arr[2].data = (td_u8 *)salt->data; // 2 element is SALT
+    arr[2].length = salt->length; // 2 element is SALT
+    ret = hal_pke_alg_calc_hash(arr, sizeof(arr) / sizeof(arr[0]), hash_info->hash_type, hash);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_alg_calc_hash failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+#endif
+
+static td_s32 inner_pkcs1_mgf(const rsa_pkcs1_hash_info *hash_info, const td_u8 *seed, const td_u32 seed_len,
+    td_u8 *mask, const td_u32 mask_len)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    td_u32 j = 0;
+    td_u32 out_len = 0;
+    td_u8 cnt[CRYPTO_WORD_WIDTH];
+    td_u8 md[HASH_SIZE_SHA_MAX];
+    drv_pke_data hash = {0};
+    td_u8 seed_buf[DRV_PKE_LEN_4096];
+    drv_pke_data arr[2];
+
+    (void)memset_s(cnt, CRYPTO_WORD_WIDTH, 0x00, CRYPTO_WORD_WIDTH);
+    (void)memset_s(md, HASH_SIZE_SHA_MAX, 0x00, HASH_SIZE_SHA_MAX);
+    ret = memcpy_s(seed_buf, DRV_PKE_LEN_4096, seed, seed_len);
+    crypto_chk_return(ret != EOK, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    hash.length = HASH_SIZE_SHA_MAX;
+    hash.data = md;
+
+    arr[0].data = seed_buf;
+    arr[0].length = seed_len;
+    arr[1].data = cnt;
+    arr[1].length = (uintptr_t)sizeof(cnt);
+
+    for (i = 0; out_len < mask_len; i++) {
+        cnt[WORD_INDEX_0] = (td_u8)((i >> SHIFT_24BITS) & MAX_LOW_8BITS);
+        cnt[WORD_INDEX_1] = (td_u8)((i >> SHIFT_16BITS) & MAX_LOW_8BITS);
+        cnt[WORD_INDEX_2] = (td_u8)((i >> SHIFT_8BITS)) & MAX_LOW_8BITS;
+        cnt[WORD_INDEX_3] = (td_u8)(i & MAX_LOW_8BITS);
+
+        /* H = Hash(seedbuf || cnt) */
+        ret = hal_pke_alg_calc_hash(arr, sizeof(arr) / sizeof(arr[0]), hash_info->hash_type, &hash);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_alg_calc_hash failed, ret is 0x%x\n", ret);
+
+        for (j = 0; (j < hash_info->hash_len) && (out_len < mask_len); j++) {
+            mask[out_len++] ^= md[j];
+        }
+    }
+    return TD_SUCCESS;
+}
+
+#if defined(CONFIG_PKE_RSA_SIGN_SUPPORT)
+td_s32 pkcs1_pss_sign(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 salt_data[HASH_SIZE_SHA_MAX];
+    td_u32 salt_len = 0;
+    td_u32 tmp_len = 0;
+    td_u32 ms_bits = 0;
+    td_u8 *masked_db = TD_NULL;
+    td_u32 masked_db_len = pack->em_len - pack->hash_len - 1; /* 1 byte for bound. */
+    drv_pke_data masked_seed;
+    drv_pke_data salt = {0};
+
+    ret = pkcs1_get_hash(hash_type, TD_NULL, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    salt_len = hash_info.hash_len;
+
+    /* em_bit is the number of bits of key n. */
+    ms_bits = (pack->em_bit - BOUND_VALUE_1) & MAX_LOW_3BITS;
+
+    ret = inner_get_random((td_u8 *)salt_data, salt_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_get_random failed, ret is 0x%x\n", ret);
+
+    /* EM = masked_db || masked_seed || 0xbc */
+    masked_db = pack->em;
+    masked_seed.data = pack->em + masked_db_len;
+    masked_seed.length = pack->hash_len;
+    salt.data = salt_data;
+    salt.length = salt_len;
+    ret = inner_pkcs1_pss_hash(&hash_info, pack->hash, pack->hash_len, &salt, &masked_seed);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pkcs1_pss_hash failed, ret is 0x%x\n", ret);
+
+    /* DB = PS || 0x01 || salt */
+    /* set PS, here tmp_len means the length of PS */
+    tmp_len = pack->em_len - pack->hash_len - salt_len - RSA_PADLEN_2; /* padding2.length - 1 */
+    (void)memset_s(masked_db, tmp_len, 0x00, tmp_len);
+
+    /* set 0x01 after PS */
+    masked_db[tmp_len++] = 0x01;
+
+    /* set salt */
+    ret = memcpy_s(masked_db + tmp_len, pack->em_len - tmp_len, salt_data, salt_len);
+    crypto_chk_return(ret != EOK, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    ret = inner_pkcs1_mgf(&hash_info, masked_seed.data, pack->hash_len, masked_db, masked_db_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    pack->em[0] &= MAX_LOW_8BITS >> (CRYPTO_BITS_IN_BYTE - ms_bits);
+    pack->em[pack->em_len - 1] = RSA_PAD_XBC; /* 1 byte for bound. */
+
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_VERIFY_SUPPORT)
+td_s32 pkcs1_pss_verify(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 em[DRV_PKE_LEN_4096];
+    td_u8 hash[HASH_SIZE_SHA_MAX];
+    td_u32 salt_len = 0;
+    td_u32 ms_bits = 0;
+    td_u8 *masked_db = TD_NULL;
+    td_u32 masked_db_len = pack->em_len - pack->hash_len - 1; /* 1 byte for bound. */
+    td_u8 *masked_seed = TD_NULL;
+    drv_pke_data hash_data = { .data = hash, .length = sizeof(hash) };
+    drv_pke_data salt = {0};
+
+    ret = pkcs1_get_hash(hash_type, TD_NULL, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    if (pack->em[pack->em_len - 1] != RSA_PAD_XBC) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_PSS_CHECK);
+    }
+
+    ms_bits = (pack->em_bit - BOUND_VALUE_1) & MAX_LOW_3BITS;
+    if ((pack->em[0] & (MAX_LOW_8BITS << ms_bits)) != 0) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_PSS_CHECK);
+    }
+
+    ret = memcpy_s(em, DRV_PKE_LEN_4096, pack->em, pack->em_len);
+    crypto_chk_return(ret != EOK, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    masked_db = em;
+    masked_seed = em + masked_db_len;
+    ret = inner_pkcs1_mgf(&hash_info, masked_seed, pack->hash_len, masked_db, masked_db_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    em[0] &= MAX_LOW_8BITS >> (CRYPTO_BITS_IN_BYTE - ms_bits);
+
+    while (masked_db < masked_seed - 1 && *masked_db == 0) {
+        masked_db++;
+    }
+
+    if (*masked_db++ != 0x01) {
+        crypto_log_err("pss padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_PSS_CHECK);
+    }
+
+    salt_len = masked_seed - masked_db;
+    salt.length = salt_len;
+    salt.data = masked_db;
+
+    ret = inner_pkcs1_pss_hash(&hash_info, pack->hash, pack->hash_len, &salt, &hash_data);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pkcs1_pss_hash failed, ret is 0x%x\n", ret);
+
+    if (memcmp(masked_seed, hash, hash_info.hash_len) != 0) {
+        crypto_log_err("pss hash check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_PSS_CHECK);
+    }
+
+    return TD_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_PUB_ENC_SUPPORT)
+td_s32 pkcs1_oaep_encrypt(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack,
+    const drv_pke_data *label)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 *p = TD_NULL;
+    td_u8 *db = TD_NULL;
+    td_u8 *seed = TD_NULL;
+    td_u32 idx = 0;
+    td_u32 hash_len = 0;
+    td_u32 tmp_len = 0;
+
+    crypto_param_check(pack == TD_NULL);
+    crypto_param_check(pack->em == TD_NULL);
+    crypto_param_check(pack->data == TD_NULL && pack->data_len != 0);
+
+    ret = pkcs1_get_hash(hash_type, label, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+    hash_len = hash_info.hash_len;
+
+    crypto_param_check(pack->klen < 2 * hash_len + 2); /* Prevent inversion. eg. RSA-1024-v21-sha512 */
+    crypto_param_check(pack->data_len > pack->klen - 2 * hash_len - 2); /* 2 */
+
+    p = pack->em;
+    seed = p + 1;
+    db = p + hash_len + 1;
+
+    /* 1. set data[0] = 0 */
+    p[idx++] = 0x00;
+
+    /* 2. set data[1, hash_len + 1] = random */
+    ret = inner_get_random(&p[idx], hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_get_random failed, ret is 0x%x\n", ret);
+    idx += hash_len;
+
+    /* 3. set data[hash_len + 1, 2hash_len + 1] = lHash */
+    (void)memcpy_s(p + idx, hash_len, hash_info.lhash_data, hash_len);
+    idx += hash_len;
+
+    /* 4. set PS with 0x00 */
+    tmp_len = pack->klen - pack->data_len - 2 * hash_len - 2; /* 2 */
+    (void)memset_s(p + idx, tmp_len, 0x00, tmp_len);
+    idx += tmp_len;
+
+    /* 5. set 0x01 after PS */
+    p[idx++] = 0x01;
+
+    /* 6. set M */
+    if (pack->data_len != 0) {
+        (void)memcpy_s(p + idx, pack->data_len, pack->data, pack->data_len);
+    }
+    /* 7. MGF: seed -> db */
+    tmp_len = pack->klen - hash_len - 1;
+    ret = inner_pkcs1_mgf(&hash_info, seed, hash_len, db, tmp_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    /* 8. MGF: db -> seed */
+    ret = inner_pkcs1_mgf(&hash_info, db, tmp_len, seed, hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    return TD_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_PRIV_DEC_SUPPORT)
+td_s32 pkcs1_oaep_decrypt(const drv_pke_hash_type hash_type, rsa_pkcs1_pack *pack,
+    const drv_pke_data *label)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u32 idx = 0;
+    td_u32 hash_len = 0;
+    td_u32 tmp_len = 0;
+    td_u8 *p = TD_NULL;
+    td_u8 *db = TD_NULL;
+    td_u8 *seed = TD_NULL;
+
+    ret = pkcs1_get_hash(hash_type, label, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    hash_len = hash_info.hash_len;
+
+    p = pack->em;
+    seed = p + 1;
+    db = p + hash_len + 1;
+
+    /* 1. check data[0] = 0 */
+    if (p[idx++] != 0x00) {
+        crypto_log_err("oaep padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    /* 2. MGF: db -> seed */
+    tmp_len = pack->klen - hash_len - 1;
+    ret = inner_pkcs1_mgf(&hash_info, db, tmp_len, seed, hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    /* 3. MGF: seed -> db */
+    ret = inner_pkcs1_mgf(&hash_info, seed, hash_len, db, tmp_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    /* 4. check data[hash + 1, 2hash + 1] */
+    idx += hash_len;
+    if (memcmp(p + idx, hash_info.lhash_data, hash_len) != 0) {
+        crypto_log_err("oaep lhash check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    /* 5. remove PS */
+    idx += hash_len;
+    for (; idx < pack->klen - 1; idx++) {
+        if (p[idx] != 0x00) {
+            break;
+        }
+    }
+
+    /* 6. check 0x01 */
+    if (p[idx++] != 0x01) {
+        crypto_log_err("oaep check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    /* 7. check data length */
+    tmp_len = pack->klen - idx;
+    if (tmp_len > pack->klen - 2 * hash_len - 2) { /* 2 */
+        crypto_log_err("PS error.\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    if (tmp_len > pack->data_len) {
+        crypto_log_err("Input buffer too small.\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    if (tmp_len != 0) {
+        ret = memcpy_s(pack->data, pack->data_len, p + idx, tmp_len);
+        crypto_chk_return(ret != EOK, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+    pack->data_len = tmp_len; // record length of plain text for return
+
+    return TD_SUCCESS;
+}
+#endif
+#endif
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_verify.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_verify.c
new file mode 100644
index 0000000..75ff215
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/rsa/drv_pke_rsa_verify.c
@@ -0,0 +1,172 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_pke rsa verify. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+#include "drv_pke_inner.h"
+#include "crypto_drv_common.h"
+
+#if defined(CONFIG_PKE_RSA_VERIFY_SUPPORT)
+static td_s32 inner_rsa_verify(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    td_u8 *em,
+    const td_u32 klen,
+    const td_u32 em_bit,
+    const drv_pke_data *msg)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_pack vf_pack = {
+        .klen = klen,
+        .em_bit = em_bit,
+        .em = em,
+        .em_len = klen,
+        .hash = msg->data,
+        .hash_len = msg->length,
+        .data = TD_NULL,
+        .data_len = 0
+    };
+
+    crypto_unused(vf_pack);
+    crypto_unused(hash_type);
+
+    switch (scheme) {
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V15: {
+            ret = pkcs1_v15_verify(hash_type, &vf_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_v15_verify failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+#if defined(CONFIG_PKE_RSA_V21_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V21: {
+            ret = pkcs1_pss_verify(hash_type, &vf_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_pss_verify failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+        default:
+            crypto_log_err("Invalid rsa verify padding type.\n");
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    return ret;
+}
+
+static td_s32 inner_pke_rsa_verify(
+    const drv_pke_rsa_pub_key *pub_key,
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    const drv_pke_data *sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *em;
+    td_u32 klen = pub_key->len;
+    td_u32 em_bit = 0;
+    drv_pke_data n_data = {.data = (unsigned char *)pub_key->n, .length = klen};
+    drv_pke_data k_data = {.data = (unsigned char *)pub_key->e, .length = klen};
+    drv_pke_data out_data;
+
+    em = crypto_malloc(DRV_PKE_LEN_4096);
+    if (em == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(em, DRV_PKE_LEN_4096, 0x00, DRV_PKE_LEN_4096);
+
+#if defined(CONFIG_PKE_RSA_TRACE_ENABLE)
+    crypto_dump_data("pub_key->n", pub_key->n, pub_key->len);
+    crypto_dump_data("pub_key->e", pub_key->e, pub_key->len);
+    crypto_dump_data("sign->data", sign->data, pub_key->len);
+#endif
+    out_data.data = em;
+    out_data.length = klen;
+    ret = hal_pke_alg_rsa_exp_mod(&n_data, &k_data, sign, &out_data);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit, ret, "hal_pke_alg_rsa_exp_mod failed, ret is 0x%x\n", ret);
+#if defined(CONFIG_PKE_RSA_TRACE_ENABLE)
+    crypto_dump_data("em", em, pub_key->len);
+#endif
+
+    if (memcmp(sign->data, em, pub_key->len) == 0) {
+        crypto_log_err("rsa verify invalid em\n");
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_RSA_SAME_DATA);
+        goto exit;
+    }
+
+    em_bit = rsa_get_bit_num((const td_u8 *)pub_key->n, pub_key->len);
+    ret = inner_rsa_verify(scheme, hash_type, em, klen, em_bit, input_hash);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit, ret, "inner_rsa_verify failed, ret is 0x%x\n", ret);
+
+exit:
+    if (em != TD_NULL) {
+        (void)memset_s(em, DRV_PKE_LEN_4096, 0, DRV_PKE_LEN_4096);
+        crypto_free(em);
+    }
+    return ret;
+}
+
+td_s32 drv_cipher_pke_rsa_verify(
+    const drv_pke_rsa_pub_key *pub_key,
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    const drv_pke_data *sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 hash_len;
+    /* check ptr. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->n);
+    pke_null_ptr_chk(pub_key->e);
+    pke_null_ptr_chk(input_hash);
+    pke_null_ptr_chk(input_hash->data);
+    pke_null_ptr_chk(sign);
+    pke_null_ptr_chk(sign->data);
+
+    /* check enum. */
+    crypto_chk_return(scheme >= DRV_PKE_RSA_SCHEME_MAX, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "scheme is Invalid\n");
+    crypto_chk_return(hash_type < DRV_PKE_HASH_TYPE_SHA1 || hash_type > DRV_PKE_HASH_TYPE_SHA512,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    /* check length. */
+    hash_len = drv_get_hash_len(hash_type);
+    crypto_chk_return(input_hash->length != hash_len, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "input_hash->length is Invalid\n");
+
+    klen = pub_key->len;
+    crypto_chk_return(crypto_rsa_klen_support(klen) != TD_SUCCESS, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+
+    crypto_chk_return(sign->length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "sign_len is Invalid\n");
+    crypto_chk_return(crypto_rsa_support(klen, scheme) == TD_FALSE, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+
+    ret = inner_pke_rsa_verify(pub_key, scheme, hash_type, input_hash, sign);
+
+    return ret;
+}
+#else
+td_s32 drv_cipher_pke_rsa_verify(
+    const drv_pke_rsa_pub_key *pub_key,
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    const drv_pke_data *sign)
+{
+    crypto_unused(pub_key);
+    crypto_unused(scheme);
+    crypto_unused(hash_type);
+    crypto_unused(input_hash);
+    crypto_unused(sign);
+
+    crypto_log_err("rsa verify failed\n");
+    return PKE_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/crypto_ecc_curve.h b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/crypto_ecc_curve.h
new file mode 100644
index 0000000..20e2481
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/crypto_ecc_curve.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef CRYPTO_ECC_CURVE_H
+#define CRYPTO_ECC_CURVE_H
+
+#include "crypto_pke_struct.h"
+
+const drv_pke_ecc_curve *get_ecc_curve(drv_pke_ecc_curve_type curve_type);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke.c
new file mode 100644
index 0000000..77c94cc
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke.c
@@ -0,0 +1,799 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "hal_pke_v4.h"
+#include "drv_pke.h"
+#include "drv_pke_inner_v4.h"
+#include "crypto_hash_struct.h"
+#include "crypto_drv_common.h"
+#include "crypto_hash_common.h"
+#include "securec.h"
+#include "drv_hash.h"
+#include "drv_trng.h"
+#define PKE_COMPAT_ERRNO(err_code)      DRV_COMPAT_ERRNO(ERROR_MODULE_PKE, err_code)
+
+static td_u32 g_drv_pke_initialize = TD_FALSE;
+
+static td_u8 g_ed_pd[] = {
+    0x59, 0x04, 0x56, 0xb4, 0xe5, 0x3f, 0x8a, 0x4d, 0xcb, 0x27, 0x24, 0x0f, 0x78, 0x31, 0x0d, 0x20,
+    0x21, 0x43, 0x0e, 0xef, 0x5f, 0x8c, 0x52, 0xe7, 0x01, 0xdb, 0x17, 0xfd, 0xbe, 0x8f, 0xd3, 0xf4,
+};
+
+td_s32 drv_cipher_pke_init(void)
+{
+    g_drv_pke_initialize = TD_TRUE;
+    return hal_pke_init();
+}
+
+td_s32 drv_cipher_pke_deinit(void)
+{
+    g_drv_pke_initialize = TD_FALSE;
+    return hal_pke_deinit();
+}
+
+td_s32 drv_cipher_pke_lock_secure(void)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_chk_return(g_drv_pke_initialize != TD_TRUE, PKE_COMPAT_ERRNO(ERROR_NOT_INIT), "pke not init!\n");
+    ret = hal_pke_lock();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_lock failed, ret is 0x%x\n", ret);
+    hal_pke_secure(TD_TRUE);
+    return TD_SUCCESS;
+}
+
+td_s32 drv_cipher_pke_unlock_secure(void)
+{
+    td_s32 ret = TD_FAILURE;
+    ret = hal_pke_unlock();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_unlock failed, ret is 0x%x\n", ret);
+    hal_pke_secure(TD_FALSE);
+    return TD_SUCCESS;
+}
+
+td_s32 drv_cipher_pke_clean_ram(void)
+{
+    td_s32 ret = TD_FAILURE;
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_CLR_RAM, DRV_PKE_LEN_4096);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    // Redundant cleaning
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_CLR_RAM, DRV_PKE_LEN_4096);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_exp_mod_param_chk(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out)
+{
+    crypto_param_check(n == TD_NULL);
+    crypto_param_check(n->data == TD_NULL);
+    crypto_param_check(k == TD_NULL);
+    crypto_param_check(k->data == TD_NULL);
+    crypto_param_check(in == TD_NULL);
+    crypto_param_check(in->data == TD_NULL);
+    crypto_param_check(out == TD_NULL);
+    crypto_param_check(out->data == TD_NULL);
+    crypto_param_check(n->length != k->length);
+    crypto_param_check(n->length != in->length);
+    crypto_param_check(n->length > out->length);
+    crypto_param_check(n->length != DRV_PKE_LEN_2048 && n->length != DRV_PKE_LEN_3072 &&
+        n->length != DRV_PKE_LEN_4096);
+    return TD_SUCCESS;
+}
+
+/* out = in ^ k mod n */
+td_s32 drv_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    pke_block random;
+    td_u8 *key = TD_NULL;
+    td_u32 key_buf_len = 0;
+
+    ret = drv_cipher_pke_exp_mod_param_chk(n, k, in, out);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_exp_mod_param_chk failed, ret is 0x%x\n", ret);
+
+    klen = n->length;
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    key_buf_len = klen * 2; // 2: for n & k
+    key = crypto_malloc(key_buf_len);
+    crypto_chk_return(key == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    ret = drv_cipher_trng_get_random(&random.word[0]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "drv_cipher_trng_get_random failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_trng_get_random(&random.word[1]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "drv_cipher_trng_get_random failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_EXP_MOD, klen);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    /* key xor random */
+    if (memcpy_s(key, klen, n->data, klen) != EOK || memcpy_s(key + klen, klen, k->data, klen) != EOK) {
+        crypto_log_err("memcpy_s(key, klen, k, klen) != EOK\n");
+        ret = PKE_COMPAT_ERRNO(ERROR_MEMCPY_S);
+        goto exit_free;
+    }
+
+#if defined(CONFIG_CRYPTO_CHIP_SHAOLINSWORD) || defined(CONFIG_CRYPTO_CHIP_HI3751V811)
+    hal_pke_set_key(key, key, klen + klen, &random, klen + klen);
+#endif
+
+    hal_pke_set_ram(PKE_NRAM, key, klen, klen);
+    hal_pke_set_ram(PKE_KRAM, key + klen, klen, klen);
+    hal_pke_set_ram(PKE_MRAM, in->data, klen, klen);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_RRAM, out->data, klen);
+exit_free:
+    if (key != TD_NULL) {
+        (void)memset_s(key, key_buf_len, 0, key_buf_len);
+        crypto_free(key);
+    }
+    return ret;
+}
+
+static td_s32 drv_cipher_pke_add_mod_param_chk(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c)
+{
+    crypto_param_check(a == TD_NULL);
+    crypto_param_check(a->data == TD_NULL);
+    crypto_param_check(b == TD_NULL);
+    crypto_param_check(b->data == TD_NULL);
+    crypto_param_check(p == TD_NULL);
+    crypto_param_check(p->data == TD_NULL);
+    crypto_param_check(c == TD_NULL);
+    crypto_param_check(c->data == TD_NULL);
+    crypto_param_check(p->length == 0);
+    crypto_param_check(p->length != b->length);
+    crypto_param_check(p->length != c->length);
+    return TD_SUCCESS;
+}
+
+/* c = a + b mod p */
+td_s32 drv_cipher_pke_add_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 max_len = 0;
+    ret = drv_cipher_pke_add_mod_param_chk(a, b, p, c);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_add_mod_param_chk failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_align_len(crypto_max(p->length, a->length), &max_len, HAL_ALIGN_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_ADD_MOD, max_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_ram(PKE_NRAM, a->data, a->length, max_len);
+    hal_pke_set_ram(PKE_KRAM, b->data, b->length, max_len);
+    hal_pke_set_ram(PKE_RRAM, p->data, p->length, max_len);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_MRAM, c->data, c->length);
+
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_sub_mod_param_chk(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c)
+{
+    crypto_param_check(a == TD_NULL);
+    crypto_param_check(b == TD_NULL);
+    crypto_param_check(c == TD_NULL);
+    crypto_param_check(p == TD_NULL);
+    crypto_param_check(a->data == TD_NULL);
+    crypto_param_check(b->data == TD_NULL);
+    crypto_param_check(c->data == TD_NULL);
+    crypto_param_check(p->data == TD_NULL);
+    crypto_param_check(a->length == 0);
+    crypto_param_check(a->length != b->length);
+    crypto_param_check(a->length != p->length);
+    crypto_param_check(a->length != c->length);
+    return TD_SUCCESS;
+}
+
+/* c = (a - b) mod p */
+td_s32 drv_cipher_pke_sub_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 max_len = 0;
+    ret = drv_cipher_pke_sub_mod_param_chk(a, b, p, c);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_sub_mod_param_chk failed, ret is 0x%x\n", ret);
+
+    klen = a->length;
+
+    ret = hal_pke_align_len(klen, &max_len, HAL_ALIGN_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_SUB_MOD, max_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_ram(PKE_NRAM, a->data, klen, max_len);
+    hal_pke_set_ram(PKE_KRAM, b->data, klen, max_len);
+    hal_pke_set_ram(PKE_RRAM, p->data, klen, max_len);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_MRAM, c->data, klen);
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_mod_param_chk(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    crypto_param_check(a == TD_NULL);
+    crypto_param_check(a->data == TD_NULL);
+    crypto_param_check(p == TD_NULL);
+    crypto_param_check(p->data == TD_NULL);
+    crypto_param_check(c == TD_NULL);
+    crypto_param_check(c->data == TD_NULL);
+    crypto_param_check(p->length == 0);
+    crypto_param_check(p->length != c->length);
+    return TD_SUCCESS;
+}
+
+/* c = a mod p */
+td_s32 drv_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 max_len = 0;
+    ret = drv_cipher_pke_mod_param_chk(a, p, c);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_mod_param_chk failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_align_len(crypto_max(a->length, p->length), &max_len, HAL_ALIGN_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_MOD, max_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_ram(PKE_MRAM, a->data, a->length, max_len);
+    hal_pke_set_ram(PKE_KRAM, p->data, p->length, max_len);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_RRAM, c->data, c->length);
+
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_mul_dot_param_chk(const drv_pke_ecc_curve *ecc, const drv_pke_data *k,
+    const drv_pke_ecc_point *p, const drv_pke_ecc_point *r)
+{
+    crypto_param_check(ecc == TD_NULL);
+    crypto_param_check(ecc->gx == TD_NULL);
+    crypto_param_check(ecc->gy == TD_NULL);
+    crypto_param_check(ecc->n == TD_NULL);
+    crypto_param_check(ecc->b == TD_NULL);
+    crypto_param_check(ecc->a == TD_NULL);
+    crypto_param_check(ecc->p == TD_NULL);
+    crypto_param_check(k == TD_NULL);
+    crypto_param_check(k->data == TD_NULL);
+    crypto_param_check(p == TD_NULL);
+    crypto_param_check(p->x == TD_NULL);
+    crypto_param_check(p->y == TD_NULL);
+    crypto_param_check(r == TD_NULL);
+    crypto_param_check(r->x == TD_NULL);
+    crypto_param_check(ecc->ksize != k->length);
+    crypto_param_check(ecc->ksize != p->length);
+    crypto_param_check(ecc->ksize != r->length);
+    crypto_param_check(ecc->ksize != DRV_PKE_LEN_256 && ecc->ksize != DRV_PKE_LEN_384 &&
+        ecc->ksize != DRV_PKE_LEN_512 && ecc->ksize != DRV_PKE_LEN_521);
+    return TD_SUCCESS;
+}
+
+/* *** R = k . P(x,y) *** */
+td_s32 drv_cipher_pke_mul_dot(const drv_pke_ecc_curve *ecc, const drv_pke_data *k, const drv_pke_ecc_point *p,
+    const drv_pke_ecc_point *r)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen;
+    td_u32 max_len = 0;
+    td_u8 *key = TD_NULL;
+    td_u32 id;
+    pke_block random;
+    td_u32 ram_section_len = 0;
+    td_u32 set_key_len = 0;
+    ret = drv_cipher_pke_mul_dot_param_chk(ecc, k, p, r);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_mul_dot_param_chk failed, ret is 0x%x\n", ret);
+
+    klen = ecc->ksize;
+
+    ret = hal_pke_align_len(0, &ram_section_len, HAL_RAM_SECTION_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+    ret = hal_pke_align_len(0, &set_key_len, HAL_SET_KEY_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+    ret = hal_pke_align_len(klen, &max_len, HAL_ALIGN_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+
+    key = crypto_malloc(set_key_len);
+    if (key == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    ret = hal_pke_wait_free();
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_MUL_DOT, max_len);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_trng_get_random(&random.word[0]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_trng_get_random failed, ret is 0x%x\n", ret);
+    ret = drv_cipher_trng_get_random(&random.word[1]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_trng_get_random failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_key(k->data, key, klen, &random, set_key_len);
+
+    id = 0;
+    hal_pke_set_ram(PKE_MRAM + (id++) * ram_section_len, p->x, klen, ram_section_len);
+    hal_pke_set_ram(PKE_MRAM + (id++) * ram_section_len, p->y, klen, ram_section_len);
+    hal_pke_set_ram(PKE_MRAM + (id++) * ram_section_len, ecc->gx, klen, ram_section_len);
+    hal_pke_set_ram(PKE_MRAM + (id++) * ram_section_len, ecc->gy, klen, ram_section_len);
+
+    id = 0;
+    hal_pke_set_ram(PKE_KRAM, key, set_key_len, set_key_len);
+    hal_pke_set_ram(PKE_KRAM + set_key_len + (id++) * ram_section_len, ecc->n, klen, ram_section_len);
+    hal_pke_set_ram(PKE_KRAM + set_key_len + (id++) * ram_section_len, ecc->b, klen, ram_section_len);
+    hal_pke_set_ram(PKE_KRAM + set_key_len + (id++) * ram_section_len, ecc->a, klen, ram_section_len);
+    hal_pke_set_ram(PKE_KRAM + set_key_len + (id++) * ram_section_len, ecc->p, klen, ram_section_len);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_RRAM, r->x, klen);
+    // r->y does not need to be provided in the ECDH
+    if (r->y != TD_NULL) {
+        hal_pke_get_ram(PKE_RRAM + ram_section_len, r->y, klen);
+    }
+exit__:
+    if (key != TD_NULL) {
+        (void)memset_s(key, set_key_len, 0, set_key_len);
+        crypto_free(key);
+    }
+    return ret;
+}
+
+static td_s32 drv_cipher_pke_mul_mod_param_chk(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data  *p,
+    const drv_pke_data  *c)
+{
+    crypto_param_check(a == TD_NULL);
+    crypto_param_check(a->data == TD_NULL);
+    crypto_param_check(b == TD_NULL);
+    crypto_param_check(b->data == TD_NULL);
+    crypto_param_check(p == TD_NULL);
+    crypto_param_check(p->data == TD_NULL);
+    crypto_param_check(c == TD_NULL);
+    crypto_param_check(c->data == TD_NULL);
+    crypto_param_check(a->length == 0);
+    crypto_param_check(a->length != b->length);
+    crypto_param_check(a->length != p->length);
+    crypto_param_check(a->length != c->length);
+    return TD_SUCCESS;
+}
+
+/* c = a * b mod p */
+td_s32 drv_cipher_pke_mul_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data  *p,
+    const drv_pke_data  *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 max_len = 0;
+
+    ret = drv_cipher_pke_mul_mod_param_chk(a, b, p, c);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_mul_mod_param_chk failed, ret is 0x%x\n", ret);
+
+    klen = a->length;
+
+    ret = hal_pke_align_len(klen, &max_len, HAL_ALIGN_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+    ret = hal_pke_set_mode(HAL_PKE_MODE_MUL_MOD, max_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_ram(PKE_MRAM, a->data, klen, max_len);
+    hal_pke_set_ram(PKE_KRAM, b->data, klen, max_len);
+    hal_pke_set_ram(PKE_NRAM, p->data, klen, max_len);
+
+    hal_pke_start();
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+    hal_pke_get_ram(PKE_RRAM, c->data, klen);
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_inv_mod_param_chk(const drv_pke_data *a, const drv_pke_data *p, drv_pke_data *c)
+{
+    crypto_param_check(p == TD_NULL);
+    crypto_param_check(p->data == TD_NULL);
+    crypto_param_check(a == TD_NULL);
+    crypto_param_check(a->data == TD_NULL);
+    crypto_param_check(c == TD_NULL);
+    crypto_param_check(c->data == TD_NULL);
+    crypto_param_check(a->length != p->length);
+    crypto_param_check(a->length != c->length);
+    crypto_param_check(a->length != DRV_PKE_LEN_256 && a->length != DRV_PKE_LEN_384 &&
+        a->length != DRV_PKE_LEN_512 && a->length != DRV_PKE_LEN_521);
+    return TD_SUCCESS;
+}
+
+/* c = a ^ -1 mod p */
+td_s32 drv_cipher_pke_inv_mod(const drv_pke_data *a, const drv_pke_data *p, drv_pke_data *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 max_len = 0;
+    ret = drv_cipher_pke_inv_mod_param_chk(a, p, c);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_inv_mod_param_chk failed, ret is 0x%x\n", ret);
+
+    klen = a->length;
+
+    ret = hal_pke_align_len(klen, &max_len, HAL_ALIGN_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_MINV_MOD, max_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_ram(PKE_MRAM, a->data, klen, max_len);
+    hal_pke_set_ram(PKE_KRAM, p->data, klen, max_len);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_RRAM, c->data, klen);
+
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_add_dot_param_chk(const drv_pke_ecc_curve *ecc, const drv_pke_ecc_point *s,
+    const drv_pke_ecc_point *r, const drv_pke_ecc_point *c)
+{
+    crypto_param_check(ecc->a == TD_NULL);
+    crypto_param_check(ecc->p == TD_NULL);
+    crypto_param_check(s == TD_NULL);
+    crypto_param_check(s->x == TD_NULL);
+    crypto_param_check(s->y == TD_NULL);
+    crypto_param_check(r == TD_NULL);
+    crypto_param_check(r->x == TD_NULL);
+    crypto_param_check(r->y == TD_NULL);
+    crypto_param_check(c == TD_NULL);
+    crypto_param_check(c->x == TD_NULL);
+    crypto_param_check(c->y == TD_NULL);
+    crypto_param_check(ecc->ksize != c->length);
+    crypto_param_check(ecc->ksize != s->length);
+    crypto_param_check(ecc->ksize != r->length);
+    crypto_param_check(ecc->ksize != DRV_PKE_LEN_256 && ecc->ksize != DRV_PKE_LEN_384
+        && ecc->ksize != DRV_PKE_LEN_512 && ecc->ksize != DRV_PKE_LEN_521);
+    return TD_SUCCESS;
+}
+
+/* C(x,y) = S(x,y) + R(x,y) */
+td_s32 drv_cipher_pke_add_dot(const drv_pke_ecc_curve *ecc, const drv_pke_ecc_point *s, const drv_pke_ecc_point *r,
+    const drv_pke_ecc_point *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 max_len = 0;
+    td_u32 id = 0;
+    td_u32 ram_section_len = 0;
+    td_u32 set_key_len = 0;
+    ret = drv_cipher_pke_add_dot_param_chk(ecc, s, r, c);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_add_dot_param_chk failed, ret is 0x%x\n", ret);
+
+    klen = ecc->ksize;
+
+    ret = hal_pke_align_len(0, &ram_section_len, HAL_RAM_SECTION_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+    ret = hal_pke_align_len(0, &set_key_len, HAL_SET_KEY_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+    ret = hal_pke_align_len(klen, &max_len, HAL_ALIGN_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_ADD_DOT, max_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_ram(PKE_MRAM + (id++) * ram_section_len, s->x, klen, ram_section_len);
+    hal_pke_set_ram(PKE_MRAM + (id++) * ram_section_len, s->y, klen, ram_section_len);
+    hal_pke_set_ram(PKE_MRAM + (id++) * ram_section_len, r->x, klen, ram_section_len);
+    hal_pke_set_ram(PKE_MRAM + id * ram_section_len, r->y, klen, ram_section_len);
+    id = 2; // KRAM start form 2 ram_section
+    hal_pke_set_ram(PKE_KRAM + set_key_len + (id++) * ram_section_len, ecc->a, klen, ram_section_len);
+    hal_pke_set_ram(PKE_KRAM + set_key_len + (id++) * ram_section_len, ecc->p, klen, ram_section_len);
+    hal_pke_start();
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_RRAM, c->x, klen);
+    hal_pke_get_ram(PKE_RRAM + ram_section_len, c->y, klen);
+
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_mg_mul_dot_param_chk(const drv_pke_data *k, const drv_pke_data *U, const drv_pke_data *p,
+    const drv_pke_data *a24, const drv_pke_data *rx)
+{
+    crypto_param_check(k == TD_NULL);
+    crypto_param_check(k->data == TD_NULL);
+    crypto_param_check(U == TD_NULL);
+    crypto_param_check(U->data == TD_NULL);
+    crypto_param_check(p == TD_NULL);
+    crypto_param_check(p->data == TD_NULL);
+    crypto_param_check(a24 == TD_NULL);
+    crypto_param_check(a24->data == TD_NULL);
+    crypto_param_check(rx == TD_NULL);
+    crypto_param_check(rx->data == TD_NULL);
+    crypto_param_check(k->length != U->length);
+    crypto_param_check(k->length != p->length);
+    crypto_param_check(k->length != a24->length);
+    crypto_param_check(k->length != rx->length);
+    crypto_param_check(k->length != DRV_PKE_LEN_256);
+    return TD_SUCCESS;
+}
+
+/* R = k * U(x) */
+td_s32 drv_cipher_pke_mg_mul_dot(const drv_pke_data *k, const drv_pke_data *U, const drv_pke_data *p,
+    const drv_pke_data *a24, const drv_pke_data *rx)
+{
+    td_s32 ret = TD_FAILURE;
+    pke_block random;
+    td_u32 klen = DRV_PKE_LEN_256;
+    td_u8 key[DRV_PKE_LEN_256] = {0};
+
+    ret = drv_cipher_pke_mg_mul_dot_param_chk(k, U, p, a24, rx);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_mg_mul_dot_param_chk failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_MG_MUL_DOT, klen);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_trng_get_random(&random.word[0]);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_random failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_key(k->data, key, klen, &random, klen);
+    hal_pke_set_ram(PKE_MRAM, U->data, klen, klen);
+    hal_pke_set_ram(PKE_MG_A24, a24->data, klen, klen);
+    hal_pke_set_ram(PKE_KRAM, p->data, klen, klen);
+    hal_pke_set_ram(PKE_MG_K, key, klen, klen);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+    hal_pke_get_ram(PKE_RRAM, rx->data, klen);
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_ed_mul_dot_param_chk(const drv_pke_data *k, const drv_pke_ecc_point *U,
+    const drv_pke_data *p, const drv_pke_ecc_point *r)
+{
+    crypto_param_check(k == TD_NULL);
+    crypto_param_check(k->data == TD_NULL);
+    crypto_param_check(U == TD_NULL);
+    crypto_param_check(U->x == TD_NULL);
+    crypto_param_check(U->y == TD_NULL);
+    crypto_param_check(p == TD_NULL);
+    crypto_param_check(p->data == TD_NULL);
+    crypto_param_check(r == TD_NULL);
+    crypto_param_check(r->x == TD_NULL);
+    crypto_param_check(r->y == TD_NULL);
+    crypto_param_check(k->length != DRV_PKE_LEN_256);
+    crypto_param_check(U->length != DRV_PKE_LEN_256);
+    crypto_param_check(p->length != DRV_PKE_LEN_256);
+    crypto_param_check(r->length != DRV_PKE_LEN_256);
+    return TD_SUCCESS;
+}
+
+/* R = k * U(x,y) */
+td_s32 drv_cipher_pke_ed_mul_dot(const drv_pke_data *k, const drv_pke_ecc_point *U, const drv_pke_data *p,
+    const drv_pke_ecc_point *r)
+{
+    td_s32 ret = TD_FAILURE;
+    pke_block random;
+    td_u32 klen = DRV_PKE_LEN_256;
+    td_u8 key[DRV_PKE_LEN_256] = {0};
+
+    ret = drv_cipher_pke_ed_mul_dot_param_chk(k, U, p, r);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_ed_mul_dot_param_chk failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_ED_MUL_DOT, klen);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_trng_get_random(&random.word[0]);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_random failed, ret is 0x%x\n", ret);
+    ret = drv_cipher_trng_get_random(&random.word[1]);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_random failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_key(k->data, key, klen, &random, klen);
+
+    hal_pke_set_ram(PKE_ED_MRAM(0), U->x, klen, klen);
+    hal_pke_set_ram(PKE_ED_MRAM(1), U->y, klen, klen);
+    hal_pke_set_ram(PKE_ED_PD, g_ed_pd, klen, klen);
+    hal_pke_set_ram(PKE_KRAM, p->data, klen, klen);
+    hal_pke_set_ram(PKE_ED_K, key, klen, klen);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_ED_RRAM(0), r->x, klen);
+    hal_pke_get_ram(PKE_ED_RRAM(1), r->y, klen);
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_pke_ed_add_dot_param_chk(const drv_pke_ecc_curve *ecc, const drv_pke_ecc_point *s,
+    const drv_pke_ecc_point *r, const drv_pke_ecc_point *c)
+{
+    crypto_param_check(ecc == TD_NULL);
+    crypto_param_check(ecc->a == TD_NULL);
+    crypto_param_check(ecc->p == TD_NULL);
+    crypto_param_check(s == TD_NULL);
+    crypto_param_check(s->x == TD_NULL);
+    crypto_param_check(s->y == TD_NULL);
+    crypto_param_check(r == TD_NULL);
+    crypto_param_check(r->x == TD_NULL);
+    crypto_param_check(r->y == TD_NULL);
+    crypto_param_check(c == TD_NULL);
+    crypto_param_check(c->x == TD_NULL);
+    crypto_param_check(c->y == TD_NULL);
+    crypto_param_check(ecc->ksize != DRV_PKE_LEN_256);
+    return TD_SUCCESS;
+}
+
+/* brief: C = S(x,y) + R(x,y) for Ed25519 curve */
+td_s32 drv_cipher_pke_ed_add_dot(const drv_pke_ecc_curve *ecc, const drv_pke_ecc_point *s,
+    const drv_pke_ecc_point *r, const drv_pke_ecc_point *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 ram_section_len = 0;
+    td_u32 klen = DRV_PKE_LEN_256;
+    ret = drv_cipher_pke_ed_add_dot_param_chk(ecc, s, r, c);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_ed_add_dot_param_chk failed, ret is 0x%x\n", ret);
+    
+    ret = hal_pke_align_len(0, &ram_section_len, HAL_RAM_SECTION_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_wait_free();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_free failed, ret is 0x%x\n", ret);
+
+    ret = hal_pke_set_mode(HAL_PKE_MODE_ED_ADD_DOT, klen);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_set_mode failed, ret is 0x%x\n", ret);
+
+    hal_pke_set_ram(PKE_ED_MRAM(0), s->x, klen, ram_section_len); // 0: slot0
+    hal_pke_set_ram(PKE_ED_MRAM(1), s->y, klen, ram_section_len); // 1: slot1
+    hal_pke_set_ram(PKE_ED_NRAM(0), r->x, klen, ram_section_len); // 0: slot0
+    hal_pke_set_ram(PKE_ED_NRAM(1), r->y, klen, ram_section_len); // 1: slot1
+    hal_pke_set_ram(PKE_ED_NRAM(2), g_ed_pd, klen, ram_section_len); // 2: slot2
+    hal_pke_set_ram(PKE_KRAM, ecc->p, klen, ram_section_len);
+
+    hal_pke_start();
+
+    ret = hal_pke_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_wait_done failed, ret is 0x%x\n", ret);
+
+    hal_pke_get_ram(PKE_ED_RRAM(0), c->x, DRV_PKE_LEN_256); // 0: slot0
+    hal_pke_get_ram(PKE_ED_RRAM(1), c->y, DRV_PKE_LEN_256); // 1: slot1
+
+    return TD_SUCCESS;
+}
+
+static crypto_hash_type drv_pke_get_hash_type(drv_pke_hash_type hash_type)
+{
+    switch (hash_type) {
+        case DRV_PKE_HASH_TYPE_SHA224:
+            return CRYPTO_HASH_TYPE_SHA224;
+        case DRV_PKE_HASH_TYPE_SHA256:
+            return CRYPTO_HASH_TYPE_SHA256;
+        case DRV_PKE_HASH_TYPE_SHA384:
+            return CRYPTO_HASH_TYPE_SHA384;
+        case DRV_PKE_HASH_TYPE_SHA512:
+            return CRYPTO_HASH_TYPE_SHA512;
+        case DRV_PKE_HASH_TYPE_SM3:
+            return CRYPTO_HASH_TYPE_SM3;
+        default:
+            return CRYPTO_HASH_TYPE_INVALID;
+    }
+}
+
+#define INVALID_HANDLE  0xFFFF0000
+td_s32 drv_cipher_pke_calc_hash(const drv_pke_data* arr, td_u32 arr_len,
+    const drv_pke_hash_type hash_type, drv_pke_data *hash)
+{
+    td_s32 ret = TD_FAILURE;
+    td_handle h_handle = INVALID_HANDLE;
+    crypto_buf_attr src_buf = {0};
+    td_u32 i;
+    crypto_hash_type hash_alg;
+    crypto_hash_attr hash_attr;
+    crypto_param_check(arr == TD_NULL);
+    crypto_param_check(hash == TD_NULL);
+    crypto_param_check(hash->data == TD_NULL);
+
+    hash_common_lock();
+    hash_alg = drv_pke_get_hash_type(hash_type);
+    crypto_chk_goto_with_ret(ret, hash_alg == CRYPTO_HASH_TYPE_INVALID, exit_free,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash type invalid\n");
+    hash_attr = (crypto_hash_attr){.hash_type = hash_alg};
+
+    ret = drv_cipher_hash_start(&h_handle, &hash_attr);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "drv_cipher_hash_start failed\n");
+
+    for (i = 0;i < arr_len; i++) {
+        src_buf.virt_addr = arr[i].data;
+        ret = drv_cipher_hash_update(h_handle, &src_buf, arr[i].length);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, hash_destroy, "drv_cipher_hash_update failed\n");
+    }
+    ret = drv_cipher_hash_finish(h_handle, hash->data, &(hash->length));
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, hash_destroy, "drv_cipher_hash_finish failed\n");
+    h_handle = INVALID_HANDLE;
+
+hash_destroy:
+    if (h_handle != INVALID_HANDLE) {
+        drv_cipher_hash_destroy(h_handle);
+    }
+exit_free:
+    hash_common_unlock();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_ecc.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_ecc.c
new file mode 100644
index 0000000..d487fec
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_ecc.c
@@ -0,0 +1,2228 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "hal_pke_v4.h"
+#include "drv_pke_v4.h"
+#include "drv_pke_inner_v4.h"
+#include "crypto_hash_struct.h"
+#include "crypto_ecc_curve.h"
+#include "securec.h"
+#include "drv_hash.h"
+#include "drv_trng.h"
+#include "crypto_drv_common.h"
+
+#define PKE_COMPAT_ERRNO(err_code)      DISPATCH_COMPAT_ERRNO(ERROR_MODULE_PKE, err_code)
+
+#define ED25519_MAX_HASH_ELEMENTS                    3
+#define SM2_CRYPTO_ADD_LENGTH_IN_BYTE                97 // 97 = SM2_LEN + SM2_LEN + SM3_LEN + 1
+#define ECC_CHECK_DOT_BUF_CNT                        11
+#define SM2_SIGN_BUF_CNT                             19
+#define SM2_VERIFY_BUF_CNT                           10
+#define ECDSA_SIGN_BUF_CNT                           15
+#define ECDSA_VERIFY_BUF_CNT                         19
+#define GENERATE_X_BUF_CNT                           13
+#define POINT_DECOMPRESS_BUF_CNT                     13
+#define EDDSA_SIGN_BUF_CNT                           14
+#define EDDSA_VERIFY_BUF_CNT                         12
+#define RANDNUM_TRY_TIMES                            20
+
+typedef enum {
+    // need buffer
+    CHECKDOT_MONTGOMERY_P = 0,
+    CHECKDOT_MX,
+    CHECKDOT_MX2,
+    CHECKDOT_MX3,
+    CHECKDOT_MA,
+    CHECKDOT_MAX,
+    CHECKDOT_MB,
+    CHECKDOT_MY,
+    CHECKDOT_MY2,
+    CHECKDOT_MX3_MAX,
+    CHECKDOT_MX3_MAX_MB,
+    // no need buffer
+    CHECKDOT_ECC_P,
+    CHECKDOT_ECC_A,
+    CHECKDOT_ECC_B,
+    CHECKDOT_X,
+    CHECKDOT_Y,
+    PKE_CHECK_DOT_ON_CURVE_VAR_MAX
+} pke_check_dot_on_curve_var;
+
+typedef enum {
+    // need buffer
+    SM2SIGN_E = 0,
+    SM2SIGN_MONTGOMERY_N,
+    SM2SIGN_K,
+    SM2SIGN_R_X,
+    SM2SIGN_R_Y,
+    SM2SIGN_RK,
+    SM2SIGN_MY,
+    SM2SIGN_MR,
+    SM2SIGN_MS,
+    SM2SIGN_MK,
+    SM2SIGN_MRK,
+    SM2SIGN_MRKY,
+    SM2SIGN_TA,
+    SM2SIGN_MTA,
+    SM2SIGN_MTY,
+    SM2SIGN_MTZ,
+    SM2SIGN_MINV,
+    SM2SIGN_ZERO,
+    SM2SIGN_ONE,
+    // no need buffer
+    SM2SIGN_SM2_N,
+    SM2SIGN_SIG_R,
+    SM2SIGN_SIG_S,
+    PKE_SM2_SIGN_VAR_MAX
+} pke_sm2_sign_var;
+
+typedef enum {
+    // need buffer
+    SM2VERIFY_T = 0,
+    SM2VERIFY_E,
+    SM2VERIFY_V,
+    SM2VERIFY_S_GX,
+    SM2VERIFY_S_GY,
+    SM2VERIFY_T_PAX,
+    SM2VERIFY_T_PAY,
+    SM2VERIFY_RX,
+    SM2VERIFY_RY,
+    SM2VERIFY_ZERO,
+    // no need buffer
+    SM2VERIFY_SM2_N,
+    SM2VERIFY_SIG_R,
+    SM2VERIFY_SIG_S,
+    PKE_SM2_VERIFY_VAR_MAX
+} pke_sm2_verify_var;
+
+typedef enum {
+    // need buffer
+    ECCSIGN_K = 0,
+    ECCSIGN_E,
+    ECCSIGN_RX,
+    ECCSIGN_RY,
+    ECCSIGN_MONTGOMERY_N,
+    ECCSIGN_ME,
+    ECCSIGN_MR,
+    ECCSIGN_MS,
+    ECCSIGN_MD,
+    ECCSIGN_MRD,
+    ECCSIGN_MK,
+    ECCSIGN_MKNI,
+    ECCSIGN_Y,
+    ECCSIGN_ZERO,
+    ECCSIGN_ONE,
+    // no need buffer
+    ECCSIGN_ECC_N,
+    ECCSIGN_SIG_R,
+    ECCSIGN_SIG_S,
+    ECCSIGN_HASH,
+    PKE_ECDSA_SIGN_VAR_MAX
+} pke_ecdsa_sign_var;
+
+typedef enum {
+    // need buffer
+    ECCVERIFY_E = 0,
+    ECCVERIFY_V,
+    ECCVERIFY_U1,
+    ECCVERIFY_U2,
+    ECCVERIFY_ME,
+    ECCVERIFY_MS,
+    ECCVERIFY_MR,
+    ECCVERIFY_MSNI,
+    ECCVERIFY_MU1,
+    ECCVERIFY_MU2,
+    ECCVERIFY_RX,
+    ECCVERIFY_RY,
+    ECCVERIFY_U1X,
+    ECCVERIFY_U1Y,
+    ECCVERIFY_U2X,
+    ECCVERIFY_U2Y,
+    ECCVERIFY_MONTGOMERY_N,
+    ECCVERIFY_ZERO,
+    ECCVERIFY_ONE,
+    // no need buffer
+    ECCVERIFY_ECC_N,
+    ECCVERIFY_SIG_R,
+    ECCVERIFY_SIG_S,
+    ECCVERIFY_HASH,
+    PKE_ECDSA_VERIFY_VAR_MAX
+} pke_ecdsa_verify_var;
+
+typedef enum {
+    // need buffer
+    GENERATEX_MAX = 0,
+    GENERATEX_P38,
+    GENERATEX_XX,
+    GENERATEX_C,
+    GENERATEX_P14,
+    GENERATEX_S,
+    GENERATEX_MONTGOMERY_P,
+    GENERATEX_MX,
+    GENERATEX_MS,
+    GENERATEX_MXS,
+    GENERATEX_ONE,
+    GENERATEX_TWO,
+    GENERATEX_THREE,
+    // no need buffer
+    GENERATEX_ECC_P,
+    GENERATEX_X,
+    GENERATEX_X2,
+    GENERATE_X_VAR_MAX
+} generate_x_var;
+
+typedef enum {
+    // need buffer
+    POINTDECOMPRESS_MONTGOMERY_P = 0,
+    POINTDECOMPRESS_MY,
+    POINTDECOMPRESS_MY2,
+    POINTDECOMPRESS_MY21,
+    POINTDECOMPRESS_MD,
+    POINTDECOMPRESS_MDY2,
+    POINTDECOMPRESS_MDY21,
+    POINTDECOMPRESS_MINV,
+    POINTDECOMPRESS_X,
+    POINTDECOMPRESS_X2,
+    POINTDECOMPRESS_MX2,
+    POINTDECOMPRESS_ONE,
+    POINTDECOMPRESS_MONE,
+    // no need buffer
+    POINTDECOMPRESS_ECC_P,
+    POINTDECOMPRESS_ECC_A,
+    POINTDECOMPRESS_OUTX,
+    POINTDECOMPRESS_OUTY,
+    POINT_DECOMPRESS_VAR_MAX
+} point_decompress_var;
+
+typedef enum {
+    // need buffer
+    EDDSIGN_A = 0,
+    EDDSIGN_PREFIX,
+    EDDSIGN_PUBKEY,
+    EDDSIGN_R,
+    EDDSIGN_S,
+    EDDSIGN_RS,
+    EDDSIGN_H,
+    EDDSIGN_MONTGOMERY_N,
+    EDDSIGN_MH,
+    EDDSIGN_MA,
+    EDDSIGN_MHA,
+    EDDSIGN_MR,
+    EDDSIGN_MS,
+    EDDSIGN_ONE,
+    // no need buffer
+    EDDSIGN_ECC_N,
+    EDDSIGN_MSG,
+    PKE_EDDSA_SIGN_VAR_MAX
+} pke_eddsa_sign_var;
+
+/*
+ * generate randnum. if max != TD_NULL. then randnum will < max
+ */
+static td_s32 get_randnum(td_u8 *randnum, td_u8 *max, td_u32 klen)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i;
+    td_u32 index;
+
+    if (max == NULL) {
+        return drv_cipher_trng_get_multi_random(klen, randnum);
+    }
+
+    for (index = 0; index < klen && max[index] == 0; ++index) {}
+
+    if (index == klen) {
+        return TD_FAILURE;
+    }
+
+    (void)memset_s(randnum, klen, 0, klen);
+
+    randnum[index] = max[index];
+    
+    for (i = 0; i < RANDNUM_TRY_TIMES; i++) {
+        ret = drv_cipher_trng_get_multi_random(klen - index - 1, randnum + index + 1);
+        if (ret != TD_SUCCESS) {
+            crypto_log_err("drv_cipher_trng_get_multi_random failed, ret is 0x%x\n", ret);
+            return ret;
+        }
+        
+        if (memcmp(randnum, max, klen) < 0) {
+            return TD_SUCCESS;
+        }
+    }
+
+    crypto_log_err("%s:%d Error! Can't gen randnum < max in %d times!\n", __FUNCTION__, __LINE__, RANDNUM_TRY_TIMES);
+    return TD_FAILURE;
+}
+
+/* check val =? zero */
+static td_bool drv_ecc_is_zero(const td_u8 *val, td_u32 klen)
+{
+    td_u32 i = 0;
+    for (i = 0; i < klen; i++) {
+        if (val[i] != 0x00) {
+            return TD_FALSE;
+        }
+    }
+    return TD_TRUE;
+}
+
+/* check 0 < val < max */
+static td_s32 drv_range_check(const td_u8 *val, const td_u8 *max, td_u32 klen)
+{
+    if (drv_ecc_is_zero(val, klen)) {
+        return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    if (memcmp(val, max, klen) < 0) {
+        return TD_SUCCESS;
+    }
+    return TD_FAILURE;
+}
+
+/*
+ * montgomery_n = (r ^ 2 mod mod_n) = (2 ^ (2 * klen) mod mod_n)
+ */
+static td_s32 cal_montgomery_n(const drv_pke_data *mod_n, const drv_pke_data *montgomery_n)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 max_len = 0;
+    td_u32 r2_len;
+    td_u8 *r2;
+    drv_pke_data r2_data;
+
+    klen = mod_n->length;
+    // for some chips, the 512 length needs to be aligned into 521 length
+    ret = hal_pke_align_len(klen, &max_len, HAL_ALIGN_LEN);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_pke_align_len failed, ret is 0x%x\n", ret);
+    // r_len = 2k_len + 1
+    r2_len = 2 * max_len + 1; // 2 : see comment above
+    r2 = crypto_malloc(r2_len);
+    if (r2 == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(r2, r2_len, 0, r2_len);
+    r2[0] = 1;
+    r2_data = (drv_pke_data){r2_len, r2};
+    ret = drv_cipher_pke_mod(&r2_data, mod_n, montgomery_n);
+    (void)memset_s(r2, r2_len, 0, r2_len);
+    crypto_free(r2);
+    return ret;
+}
+
+/*
+ * check point->y ^ 2 ?= point->x ^ 3 + ecc->a * point->x  + ecc->b
+ */
+static td_s32 pke_check_dot_on_curve(const drv_pke_ecc_curve *ecc, const drv_pke_ecc_point *point, td_bool *is_on_curve)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i;
+    drv_pke_data var_arr[PKE_CHECK_DOT_ON_CURVE_VAR_MAX];
+    td_u8 *buffer;
+
+    buffer = crypto_malloc(ecc->ksize * ECC_CHECK_DOT_BUF_CNT);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    (void)memset_s(buffer, ecc->ksize * ECC_CHECK_DOT_BUF_CNT, 0, ecc->ksize * ECC_CHECK_DOT_BUF_CNT);
+
+    for (i = 0; i < PKE_CHECK_DOT_ON_CURVE_VAR_MAX; i++) {
+        if (i <= CHECKDOT_MX3_MAX_MB) {
+            var_arr[i].data = buffer + ecc->ksize * i;
+        }
+        var_arr[i].length = ecc->ksize;
+    }
+    var_arr[CHECKDOT_ECC_P].data = (td_u8 *)ecc->p;
+    var_arr[CHECKDOT_ECC_A].data = (td_u8 *)ecc->a;
+    var_arr[CHECKDOT_ECC_B].data = (td_u8 *)ecc->b;
+    var_arr[CHECKDOT_X].data = point->x;
+    var_arr[CHECKDOT_Y].data = point->y;
+
+    // Step 1: N = r^2 mod p where N is montgomery multiplier
+    ret = cal_montgomery_n(&var_arr[CHECKDOT_ECC_P], &var_arr[CHECKDOT_MONTGOMERY_P]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+
+    /* Step 1: mx = point->x * N mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[CHECKDOT_X], &var_arr[CHECKDOT_MONTGOMERY_P], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MX]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 2: my = point->y * N mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[CHECKDOT_Y], &var_arr[CHECKDOT_MONTGOMERY_P], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MY]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 3: mx2 = mx * mx mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[CHECKDOT_MX], &var_arr[CHECKDOT_MX], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MX2]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 4: mx3 = mx2 * mx mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[CHECKDOT_MX2], &var_arr[CHECKDOT_MX], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MX3]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 5: ma = a * N mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[CHECKDOT_ECC_A], &var_arr[CHECKDOT_MONTGOMERY_P], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MA]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 6: max = ma * mx mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[CHECKDOT_MA], &var_arr[CHECKDOT_MX], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MAX]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 7: mx3_max = mx3 + max mod p */
+    ret = drv_cipher_pke_add_mod(&var_arr[CHECKDOT_MX3], &var_arr[CHECKDOT_MAX], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MX3_MAX]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 8: mb = b * N mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[CHECKDOT_ECC_B], &var_arr[CHECKDOT_MONTGOMERY_P], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MB]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 9: mx3_max_mb = mx3_max + mb mod p */
+    ret = drv_cipher_pke_add_mod(&var_arr[CHECKDOT_MX3_MAX], &var_arr[CHECKDOT_MB], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MX3_MAX_MB]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 10: my2 = my * my mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[CHECKDOT_MY], &var_arr[CHECKDOT_MY], &var_arr[CHECKDOT_ECC_P],
+        &var_arr[CHECKDOT_MY2]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Step 11: my2 ?= mx3_max_mb */
+    *is_on_curve = memcmp(var_arr[CHECKDOT_MY2].data, var_arr[CHECKDOT_MX3_MAX_MB].data, ecc->ksize) == 0;
+
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, ecc->ksize * ECC_CHECK_DOT_BUF_CNT, 0, ecc->ksize * ECC_CHECK_DOT_BUF_CNT);
+        crypto_free(buffer);
+    }
+    return ret;
+}
+
+static td_s32 sm2_encrypt_decrypt_hash(const drv_pke_ecc_point *param, const drv_pke_data *msg, drv_pke_data *hash)
+{
+    td_s32 ret = TD_FAILURE;
+    drv_pke_data arr[3]; // The capacity of the array is 3.
+
+    arr[0].data = param->x;
+    arr[0].length = DRV_PKE_SM2_LEN_IN_BYTES;
+    arr[1].data = msg->data;
+    arr[1].length = msg->length;
+    arr[2].data = param->y; // 2 is data of the 3th element
+    arr[2].length = DRV_PKE_SM2_LEN_IN_BYTES; // 2 is data of the 3th element
+
+    /* C3 = SM3( x2 || M || y2 ) */
+    ret = drv_cipher_pke_calc_hash(arr, sizeof(arr) / sizeof(arr[0]), DRV_PKE_HASH_TYPE_SM3, hash);
+    return ret;
+}
+
+static td_s32 sm2_kdf(const drv_pke_ecc_point *param, td_u8 *out, const td_u32 klen)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 block = 0;
+    td_u32 i = 0;
+    td_u32 ct = 0;
+    drv_pke_data arr[3]; // The capacity of the array is 3.
+    td_u8 h[DRV_PKE_SM2_LEN_IN_BYTES] = {0};
+    drv_pke_data hash = {DRV_PKE_SM2_LEN_IN_BYTES, h};
+
+    arr[0].data = param->x;
+    arr[0].length = DRV_PKE_SM2_LEN_IN_BYTES;
+    arr[1].data = param->y;
+    arr[1].length = DRV_PKE_SM2_LEN_IN_BYTES;
+    arr[2].data = (td_u8 *)&ct; // 2 is data of the 3th element
+    arr[2].length = sizeof(ct); // 2 is data of the 3th element
+    if (klen == 0) {
+        return TD_SUCCESS;
+    }
+
+    block = (klen + DRV_PKE_SM2_LEN_IN_BYTES - 1) / DRV_PKE_SM2_LEN_IN_BYTES;
+    for (i = 0; i < block; i++) {
+        ct = crypto_cpu_to_be32(i + 1);
+        /* H = SM3( X || Y || CT ) */
+        ret = drv_cipher_pke_calc_hash(arr, sizeof(arr) / sizeof(arr[0]), DRV_PKE_HASH_TYPE_SM3, &hash);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_calc_hash failed, ret is 0x%x\n", ret);
+
+        if (i == (block - 1)) {
+            ret = memcpy_s(out + i * DRV_PKE_SM2_LEN_IN_BYTES, klen - i * DRV_PKE_SM2_LEN_IN_BYTES, h,
+                klen - i * DRV_PKE_SM2_LEN_IN_BYTES);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+        } else {
+            ret = memcpy_s(out + i * DRV_PKE_SM2_LEN_IN_BYTES, klen - i * DRV_PKE_SM2_LEN_IN_BYTES, h,
+                DRV_PKE_SM2_LEN_IN_BYTES);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+        }
+    }
+    if (drv_ecc_is_zero(out, klen)) {
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+static td_s32 pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text)
+{
+    // declaration and assignment of variables and parameter verification
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = DRV_PKE_SM2_LEN_IN_BYTES;
+    td_u32 c1_index = 1;
+    td_u32 c3_index = c1_index + klen * 2; // 2 : see the start position of algorithm C3.
+    td_u32 c2_index = c1_index + klen * 3; // 3 : see the start position of algorithm C2.
+    td_u32 i = 0;
+    td_u8 k[DRV_PKE_SM2_LEN_IN_BYTES] = {0};
+    td_u8 C1x[DRV_PKE_SM2_LEN_IN_BYTES] = {0};
+    td_u8 C1y[DRV_PKE_SM2_LEN_IN_BYTES] = {0};
+    td_u8 kPBx[DRV_PKE_SM2_LEN_IN_BYTES] = {0};
+    td_u8 kPBy[DRV_PKE_SM2_LEN_IN_BYTES] = {0};
+    td_u8 *t = cipher_text->data + c2_index;
+    drv_pke_data k_data = {klen, k};
+    drv_pke_data C3_data = {klen, cipher_text->data + c3_index};
+    drv_pke_ecc_point C1_point = {C1x, C1y, klen};
+    drv_pke_ecc_point kPB_point = {kPBx, kPBy, klen};
+    drv_pke_ecc_point sm2_gpoint;
+    const drv_pke_ecc_curve *sm2 = get_ecc_curve(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(sm2 == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    sm2_gpoint = (drv_pke_ecc_point){(td_u8 *)sm2->gx, (td_u8 *)sm2->gy, klen};
+    (void)memset_s(cipher_text->data, cipher_text->length, 0, cipher_text->length);
+    // the beginning of the algorithm
+    cipher_text->data[0] = SM2_PC_UNCOMPRESS;
+
+    for (i = 0; i < ECC_TRY_CNT; i++) {
+        /* Step 1: random k */
+        ret = get_randnum(k_data.data, (td_u8 *)sm2->n, sm2->ksize);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "get_randnum failed, ret is 0x%x\n", ret);
+
+        /* Step 2: C1 = k * G */
+        ret = drv_cipher_pke_mul_dot(sm2, &k_data, &sm2_gpoint, &C1_point);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+
+        /* Step 3: kPB = k * PB */
+        ret = drv_cipher_pke_mul_dot(sm2, &k_data, pub_key, &kPB_point);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+
+        /* Step 4: t = kdf( kPBx || kPBy, plain_text->length ) */
+        ret = sm2_kdf(&kPB_point, t, plain_text->length);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "sm2_kdf failed, ret is 0x%x\n", ret);
+
+        /* Step 5: t ?= 0 */
+        if (drv_ecc_is_zero(t, plain_text->length) != TD_TRUE) {
+            break;
+        }
+    }
+    if (i == ECC_TRY_CNT) {
+        crypto_log_err("%s:%d Error! Can't gen t in %d times!\n", __FUNCTION__, __LINE__, ECC_TRY_CNT);
+        ret = PKE_COMPAT_ERRNO(ERROR_TRY_TIMES);
+        goto exit__;
+    }
+    ret = memcpy_s(cipher_text->data + c1_index, cipher_text->length - c1_index, C1_point.x, klen);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    ret = memcpy_s(cipher_text->data + c1_index + klen, cipher_text->length - c1_index - klen, C1_point.y, klen);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    for (i = 0; i < plain_text->length; i++) {
+        *(t + i) ^= *(plain_text->data + i);
+    }
+    ret = sm2_encrypt_decrypt_hash(&kPB_point, plain_text, &C3_data);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "sm2_encrypt_decrypt_hash failed, ret is 0x%x\n", ret);
+
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    return ret;
+}
+
+static td_s32 pke_sm2_private_decrypt(
+    const drv_pke_data *priv_key,
+    const drv_pke_data *cipher_text,
+    const drv_pke_data *plain_text)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = DRV_PKE_SM2_LEN_IN_BYTES;
+    td_u32 c1_index = 1;
+    td_u32 c2_index = c1_index + klen * 3; // 3 : see the start position of algorithm C2.
+    td_u32 c3_index = c1_index + klen * 2; // 2 : see the start position of algorithm C3.
+    td_u32 i = 0;
+    td_bool is_on_curve = TD_FALSE;
+    td_u8 u[DRV_PKE_SM2_LEN_IN_BYTES];
+    td_u8 C1x[DRV_PKE_SM2_LEN_IN_BYTES];
+    td_u8 C1y[DRV_PKE_SM2_LEN_IN_BYTES];
+    td_u8 x2[DRV_PKE_SM2_LEN_IN_BYTES];
+    td_u8 y2[DRV_PKE_SM2_LEN_IN_BYTES];
+    drv_pke_data u_data = {klen, u};
+    drv_pke_data plain_data;
+    const drv_pke_ecc_point C1_point = {C1x, C1y, klen};
+    const drv_pke_ecc_point dBC1_point = {x2, y2, klen};
+    const drv_pke_ecc_curve *sm2 = get_ecc_curve(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(sm2 == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    crypto_param_check(cipher_text->data[0] != SM2_PC_UNCOMPRESS);
+    plain_data = (drv_pke_data){cipher_text->length - SM2_CRYPTO_ADD_LENGTH_IN_BYTE, plain_text->data};
+
+    ret = memcpy_s(C1x, sizeof(C1x), cipher_text->data + c1_index, klen);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    ret = memcpy_s(C1y, sizeof(C1y), cipher_text->data + c1_index + klen, klen);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    /* Step 1: check C1x, C1y on curve */
+    ret = pke_check_dot_on_curve(sm2, &C1_point, &is_on_curve);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "pke_check_dot_on_curve failed, ret is 0x%x\n", ret);
+    crypto_chk_goto(is_on_curve != TD_TRUE, exit__, "pke_check_dot_on_curve failed, ret is 0x%x\n", ret);
+
+    /* Step 2: (x2, y2) = dB * C1 */
+    ret = drv_cipher_pke_mul_dot(sm2, priv_key, &C1_point, &dBC1_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+
+    /* Step 3: check x2, y2 on curve */
+    ret = pke_check_dot_on_curve(sm2, &dBC1_point, &is_on_curve);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "pke_check_dot_on_curve failed, ret is 0x%x\n", ret);
+    crypto_chk_goto(is_on_curve != TD_TRUE, exit__,
+        "pke_check_dot_on_curve failed, is_on_curve is 0x%x\n", is_on_curve);
+
+    ret = sm2_kdf(&dBC1_point, plain_data.data, plain_data.length);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "sm2_kdf failed, ret is 0x%x\n", ret);
+
+    if (drv_ecc_is_zero(plain_data.data, plain_data.length)) {
+        crypto_log_err("%s:%d Error! Can't gen t in %d times!\n", __FUNCTION__, __LINE__, ECC_TRY_CNT);
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_SM2_DECRYPT);
+        goto exit__;
+    }
+
+    for (i = 0; i < plain_data.length; i++) {
+        *(plain_data.data + i) ^= *(cipher_text->data + c2_index + i);
+    }
+
+    ret = sm2_encrypt_decrypt_hash(&dBC1_point, &plain_data, &u_data);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "sm2_encrypt_decrypt_hash failed, ret is 0x%x\n", ret);
+
+    ret = memcmp(cipher_text->data + c3_index, u, DRV_PKE_SM2_LEN_IN_BYTES);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "memcmp failed, ret is 0x%x\n", ret);
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    return ret;
+}
+
+/* Decode the private key for X25519 curve */
+static td_void decode_priv_key(td_u8 *output_key, const td_u8 *input_key, td_u32 klen)
+{
+    td_u32 i = 0;
+    /* Step 1: Do byte reverse on input_key */
+    for (i = 0; i < klen; i++) {
+        output_key[i] = input_key[klen - 1 - i];
+    }
+
+    /* Step 2: the priv_key[255], priv_key[254], priv_key[2], priv_key[1], priv_key[0] must be 0,1,0,0,0 */
+    output_key[klen - 1] = output_key[klen - 1] & 0xF8; // 0xF8 : see comment above
+    output_key[0] = output_key[0] & 0x7F; // 0x7F : see comment above
+    output_key[0] = output_key[0] | 0x40; // 0x40 : see commnet above
+    return;
+}
+
+/* Decode the public key for X25519 curve */
+static td_void decode_pub_key(td_u8 *output_key, const td_u8 *input_key, td_u32 klen)
+{
+    td_u32 i = 0;
+    /* Step 1: Do byte reverse on input_key */
+    for (i = 0; i < klen; i++) {
+        output_key[i] = input_key[klen - 1 - i];
+    }
+    /* Step 2: the pub_key[255] must be 0 */
+    output_key[0] = output_key[0] & 0x7F; // 0x7F : see comment above
+    return;
+}
+
+static td_s32 secret_expand(const td_u8 *secret, td_u8 *a, td_u8 *prefix, const td_u32 len)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    td_u8 hash[DRV_PKE_LEN_512];
+    drv_pke_data arr[1];
+    drv_pke_data hash_data = {DRV_PKE_LEN_512, hash};
+
+    arr[0].data = (td_u8 *)secret;
+    arr[0].length = len;
+    ret = drv_cipher_pke_calc_hash(arr, 1, DRV_PKE_HASH_TYPE_SHA512, &hash_data);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_calc_hash failed, ret is 0x%x\n", ret);
+
+    for (i = 0; i < DRV_PKE_LEN_256; i++) {
+        a[i] = hash[DRV_PKE_LEN_256 - 1 - i];
+    }
+    /* [255], [254], [2], [1], [0] must be 0,1,0,0,0 */
+    a[DRV_PKE_LEN_256 - 1] &= 0xF8;
+    a[0] &= 0x7F; // 0x7F : see comment above
+    a[0] |= 0x40; // 0x40 : see commnet above
+    (void)memcpy_s(prefix, DRV_PKE_LEN_256, hash + DRV_PKE_LEN_256, DRV_PKE_LEN_256);
+    return TD_SUCCESS;
+}
+
+static td_s32 point_mul_compress(const drv_pke_ecc_curve *ecc, const td_u8 *k, td_u8 *out, td_u32 len)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i;
+    td_u8 rx[DRV_PKE_LEN_256] = {0};
+    td_u8 ry[DRV_PKE_LEN_256] = {0};
+
+    const drv_pke_data k_data = {DRV_PKE_LEN_256, (td_u8 *)k};
+    const drv_pke_data ecc_p_data = {DRV_PKE_LEN_256, (td_u8 *)ecc->p};
+    const drv_pke_ecc_point ecc_gpoint = {(td_u8 *)ecc->gx, (td_u8 *)ecc->gy, DRV_PKE_LEN_256};
+    const drv_pke_ecc_point r_point = {rx, ry, DRV_PKE_LEN_256};
+
+    crypto_param_check(len != DRV_PKE_LEN_256);
+
+    /* R = k * G */
+    ret = drv_cipher_pke_ed_mul_dot(&k_data, &ecc_gpoint, &ecc_p_data, &r_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_ed_mul_dot failed, ret is 0x%x\n", ret);
+    for (i = 0; i < DRV_PKE_LEN_256; i++) {
+        out[i] = ry[DRV_PKE_LEN_256 - 1 - i];
+    }
+    /* copy the least significant bit of the x coordinate to the most significant bit of the final octet. */
+    out[DRV_PKE_LEN_256 - 1] |= (rx[DRV_PKE_LEN_256 - 1] & 0x1) << 7; /* shift 7 */
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    return ret;
+}
+
+static td_s32 ed_secret_to_public(const drv_pke_ecc_curve *ecc, const drv_pke_data *priv_key,
+    const drv_pke_ecc_point *pub_key)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 a[DRV_PKE_LEN_256] = {0};
+    td_u8 dummy[DRV_PKE_LEN_256];
+
+    /* Operation: a, prefix = secret_expand(secret) */
+    ret = secret_expand(priv_key->data, a, dummy, DRV_PKE_LEN_256);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "secret_expand failed, ret is 0x%x\n", ret);
+    /* Operation: A = point_compress(point_mul(a, G)) */
+    (void)memset_s(pub_key->y, DRV_PKE_LEN_256, 0x00, DRV_PKE_LEN_256);
+    ret = point_mul_compress(ecc, a, pub_key->y, DRV_PKE_LEN_256);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "point_mul_compress failed, ret is 0x%x\n", ret);
+
+    return TD_SUCCESS;
+}
+
+static td_s32 pke_ecc_gen_key(const drv_pke_ecc_curve *ecc, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    td_u8 key[DRV_PKE_LEN_256] = {0};
+    td_u8 montgomery_p[DRV_PKE_LEN_256] = {0};
+    td_u8 A24[DRV_PKE_LEN_256] = {0};
+    td_u8 temp_result[DRV_PKE_LEN_256] = {0};
+    const drv_pke_data key_data = {DRV_PKE_LEN_256, key};
+    const drv_pke_data montgomery_p_data = {DRV_PKE_LEN_256, montgomery_p};
+    const drv_pke_data A24_data = {DRV_PKE_LEN_256, A24};
+    const drv_pke_data temp_result_data = {DRV_PKE_LEN_256, temp_result};
+    const drv_pke_data ecc_p_data = {DRV_PKE_LEN_256, (td_u8 *)ecc->p};
+    const drv_pke_data ecc_a_data = {DRV_PKE_LEN_256, (td_u8 *)ecc->a};
+    const drv_pke_data ecc_gx_data = {DRV_PKE_LEN_256, (td_u8 *)ecc->gx};
+    const drv_pke_ecc_point ecc_gpoint = {(td_u8 *)ecc->gx, (td_u8 *)ecc->gy, ecc->ksize};
+
+    if ((input_priv_key != TD_NULL) && (input_priv_key->data != TD_NULL)) {
+        // check whether the input priv key is valid
+        if ((ecc->ecc_type != DRV_PKE_ECC_TYPE_RFC7748) && (ecc->ecc_type != DRV_PKE_ECC_TYPE_RFC8032)) {
+            /* check 1 < input_priv_key < n */
+            ret = drv_range_check(input_priv_key->data, ecc->n, ecc->ksize);
+            crypto_chk_return(ret != TD_SUCCESS, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+                "drv_range_check failed, ret is 0x%x\n", ret);
+        }
+        (void)memcpy_s(output_priv_key->data, ecc->ksize, input_priv_key->data, ecc->ksize);
+    } else {
+        if ((ecc->ecc_type == DRV_PKE_ECC_TYPE_RFC7748) || (ecc->ecc_type == DRV_PKE_ECC_TYPE_RFC8032)) {
+            /* Generate key with no limit */
+            ret = get_randnum(output_priv_key->data, TD_NULL, ecc->ksize);
+        } else { /* Generate key: 0 < key < n */
+            ret = get_randnum(output_priv_key->data, (td_u8 *)ecc->n, ecc->ksize);
+        }
+        crypto_chk_return(ret != TD_SUCCESS, ret, "get_randnum failed, ret is 0x%x\n", ret);
+    }
+    /* PA = dA * G */
+    if (ecc->ecc_type == DRV_PKE_ECC_TYPE_RFC7748) {
+        /* The private key need to be decoded */
+        ret = cal_montgomery_n(&ecc_p_data, &montgomery_p_data);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+        ret = drv_cipher_pke_mul_mod(&ecc_a_data, &montgomery_p_data, &ecc_p_data, &A24_data);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+        decode_priv_key(key, output_priv_key->data, ecc->ksize);
+        ret = drv_cipher_pke_mg_mul_dot(&key_data, &ecc_gx_data, &ecc_p_data, &A24_data, &temp_result_data);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mg_mul_dot failed, ret is 0x%x\n", ret);
+        /* The output should be byte reversed */
+        for (i = 0; i < ecc->ksize; i++) {
+            output_pub_key->x[i] = temp_result[ecc->ksize - 1 - i];
+        }
+        /* Returned priv_key[0]=.....000, priv_key[255] = 0....1.. */
+        output_priv_key->data[0] = output_priv_key->data[0] & 0xF8; // 0xF8 : see comment above
+        output_priv_key->data[ecc->ksize - 1] =
+            output_priv_key->data[ecc->ksize - 1] & 0x7F; // 0x7F : see comment above
+        output_priv_key->data[ecc->ksize - 1] =
+            output_priv_key->data[ecc->ksize - 1] | 0x40; // 0x40 : see comment above
+    } else if (ecc->ecc_type == DRV_PKE_ECC_TYPE_RFC8032) {
+        ret = ed_secret_to_public(ecc, output_priv_key, output_pub_key);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "ed_secret_to_public failed, ret is 0x%x\n", ret);
+    } else {
+        ret = drv_cipher_pke_mul_dot(ecc, output_priv_key, &ecc_gpoint, output_pub_key);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+    }
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    return ret;
+}
+
+/* z = d * p(x,y), sharekey = z(x) */
+static td_s32 pke_ecc_gen_ecdh_key(
+    const drv_pke_ecc_curve *ecc,
+    const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_shared_key)
+{
+    td_s32 ret = TD_FAILURE;
+    // for RFC7748
+    td_u32 i = 0;
+    td_u8 buffer[DRV_PKE_LEN_256 * 5] = {0}; // need buffer num is 5
+    const drv_pke_data montgomery_p_data = {DRV_PKE_LEN_256, buffer + DRV_PKE_LEN_256 * i++};
+    const drv_pke_data A24_data = {DRV_PKE_LEN_256, buffer + DRV_PKE_LEN_256 * i++};
+    const drv_pke_data priv_key_data = {DRV_PKE_LEN_256, buffer + DRV_PKE_LEN_256 * i++};
+    const drv_pke_data pub_key_data = {DRV_PKE_LEN_256, buffer + DRV_PKE_LEN_256 * i++};
+    const drv_pke_data temp_result_data = {DRV_PKE_LEN_256, buffer + DRV_PKE_LEN_256 * i++};
+    const drv_pke_data ecc_p_data = {DRV_PKE_LEN_256, (td_u8 *)ecc->p};
+    const drv_pke_data ecc_a_data = {DRV_PKE_LEN_256, (td_u8 *)ecc->a};
+    // for another curve type
+    const drv_pke_ecc_point shared_point = {output_shared_key->data, TD_NULL, ecc->ksize};
+
+    if (ecc->ecc_type == DRV_PKE_ECC_TYPE_RFC7748) {
+        /* A24 = (a * 2 ^ len_n) mod p */
+        ret = cal_montgomery_n(&ecc_p_data, &montgomery_p_data);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+        ret = drv_cipher_pke_mul_mod(&ecc_a_data, &montgomery_p_data, &ecc_p_data, &A24_data);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+         /* The private and public key need to be decoded */
+        decode_priv_key(priv_key_data.data, input_priv_key->data, DRV_PKE_LEN_256);
+        decode_pub_key(pub_key_data.data, input_pub_key->x, DRV_PKE_LEN_256);
+
+        ret = drv_cipher_pke_mg_mul_dot(&priv_key_data, &pub_key_data, &ecc_p_data, &A24_data, &temp_result_data);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mg_mul_dot failed, ret is 0x%x\n", ret);
+
+        /* The output should be byte reversed */
+        for (i = 0; i < ecc->ksize; i++) {
+            output_shared_key->data[i] = temp_result_data.data[ecc->ksize - 1 - i];
+        }
+    } else {
+        ret = drv_cipher_pke_mul_dot(ecc, input_priv_key, input_pub_key, &shared_point);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+    }
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    return ret;
+}
+
+static td_s32 sm2_sign_verify_hash(const sm2_sign_verify_hash_pack *param, const drv_pke_msg *msg, drv_pke_data *hash)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 entla[ENTLA_LEN];
+    td_u8 h[DRV_PKE_SM2_LEN_IN_BYTES];
+    drv_pke_data hh = {DRV_PKE_SM2_LEN_IN_BYTES, h};
+    drv_pke_data arr[8]; // The capacity of the array is 8.
+    drv_pke_data arr2[2]; // The capacity of the array is 2.
+    const drv_pke_ecc_curve *sm2 = get_ecc_curve(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(sm2 == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    entla[0] = (td_u8)((param->id_len * BYTE_BITS) >> BYTE_BITS);
+    entla[1] = (td_u8)((param->id_len * BYTE_BITS));
+
+    /* ENTLA */
+    arr[0].data = entla;
+    arr[0].length = ENTLA_LEN;
+    /* IDA */
+    arr[1].data = param->id;
+    arr[1].length = param->id_len;
+    /* a */
+    arr[2].data = (td_u8 *)sm2->a; // 2 is data of the 3th element
+    arr[2].length = DRV_PKE_SM2_LEN_IN_BYTES; // 2 is length of the 3th element
+    /* b */
+    arr[3].data = (td_u8 *)sm2->b; // 3 is data of the 4th element
+    arr[3].length = DRV_PKE_SM2_LEN_IN_BYTES; // 3 is length of the 4th element
+    /* xG */
+    arr[4].data = (td_u8 *)sm2->gx; // 4 is data of the 5th element
+    arr[4].length = DRV_PKE_SM2_LEN_IN_BYTES; // 4 is length of the 5th element
+    /* yG */
+    arr[5].data = (td_u8 *)sm2->gy; // 5 is data of the 6th element
+    arr[5].length = DRV_PKE_SM2_LEN_IN_BYTES; // 5 is length of the 6th element
+    /* xA */
+    arr[6].data = param->px; // 6 is data of the 7th element
+    arr[6].length = DRV_PKE_SM2_LEN_IN_BYTES; // 6 islength of the 7th element
+    /* yA */
+    arr[7].data = param->py; // 7 is data of the 8th element
+    arr[7].length = DRV_PKE_SM2_LEN_IN_BYTES; // 7 is length of the 8th element
+
+    /* ZA */
+    arr2[0].data = h;
+    arr2[0].length = DRV_PKE_SM2_LEN_IN_BYTES;
+    /* M */
+    arr2[1].data = msg->data;
+    arr2[1].length = msg->length;
+
+    /* ZA = SM3( ENTLA || IDA || a || b || xG || yG || xA || yA ) */
+    ret = drv_cipher_pke_calc_hash(arr, sizeof(arr) / sizeof(arr[0]), DRV_PKE_HASH_TYPE_SM3, &hh);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_calc_hash failed, ret is 0x%x\n", ret);
+    /* e = SM3( ZA || M ) */
+    ret = drv_cipher_pke_calc_hash(arr2, sizeof(arr2) / sizeof(arr2[0]), DRV_PKE_HASH_TYPE_SM3, hash);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_calc_hash failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+
+static td_s32 pke_sm2_sign(const drv_pke_data *priv_key, const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = DRV_PKE_SM2_LEN_IN_BYTES;
+    td_u32 i;
+    drv_pke_data var_arr[PKE_SM2_SIGN_VAR_MAX];
+    const drv_pke_ecc_curve *sm2;
+    drv_pke_ecc_point sm2_gpoint;
+    drv_pke_ecc_point r_point;
+    td_u8 *buffer;
+
+    sm2 = get_ecc_curve(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(sm2 == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    buffer = crypto_malloc(klen * SM2_SIGN_BUF_CNT);
+    if (buffer == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(buffer, klen * SM2_SIGN_BUF_CNT, 0, klen * SM2_SIGN_BUF_CNT);
+
+    for (i = 0; i < PKE_SM2_SIGN_VAR_MAX; i++) {
+        if (i <= SM2SIGN_ONE) {
+            var_arr[i].data = buffer + klen * i;
+        }
+        var_arr[i].length = klen;
+    }
+
+    var_arr[SM2SIGN_SM2_N].data = (td_u8 *)sm2->n;
+    var_arr[SM2SIGN_SIG_R].data = sig->r;
+    var_arr[SM2SIGN_SIG_S].data = sig->s;
+    var_arr[SM2SIGN_ONE].data[klen - 1] = 0x1;
+    sm2_gpoint = (drv_pke_ecc_point){(td_u8 *)sm2->gx, (td_u8 *)sm2->gy, klen};
+    r_point = (drv_pke_ecc_point){var_arr[SM2SIGN_R_X].data, var_arr[SM2SIGN_R_Y].data, klen};
+
+    // Step 1: N = r^2 mod p where N is montgomery multiplier
+    ret = cal_montgomery_n(&var_arr[SM2SIGN_SM2_N], &var_arr[SM2SIGN_MONTGOMERY_N]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+
+    for (i = 0; i < PKE_MAX_TIMES; i++) {
+        /* Step 1: random k */
+        ret = get_randnum(var_arr[SM2SIGN_K].data, (td_u8 *)sm2->n, klen);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "get_randnum failed, ret is 0x%x\n", ret);
+
+        /* Step 2: R = k * G */
+        ret = drv_cipher_pke_mul_dot(sm2, &var_arr[SM2SIGN_K], &sm2_gpoint, &r_point);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+
+        /* Step 3: E = e + 0 mod n */
+        ret = drv_cipher_pke_add_mod(hash, &var_arr[SM2SIGN_ZERO], &var_arr[SM2SIGN_SM2_N], &var_arr[SM2SIGN_E]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 4: r = E + Rx mod n */
+        ret = drv_cipher_pke_add_mod(&var_arr[SM2SIGN_E], &var_arr[SM2SIGN_R_X], &var_arr[SM2SIGN_SM2_N],
+            &var_arr[SM2SIGN_SIG_R]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 5: r = 0 ? */
+        if (drv_ecc_is_zero(var_arr[SM2SIGN_SIG_R].data, klen)) {
+            continue;
+        }
+        /* Step 6: rk = r + k mod n */
+        ret = drv_cipher_pke_add_mod(&var_arr[SM2SIGN_SIG_R], &var_arr[SM2SIGN_K], &var_arr[SM2SIGN_SM2_N],
+            &var_arr[SM2SIGN_RK]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 7: rk = 0 ? */
+        if (drv_ecc_is_zero(var_arr[SM2SIGN_RK].data, klen)) {
+            continue;
+        }
+
+        /* Step 8: random my */
+        ret = get_randnum(var_arr[SM2SIGN_MY].data, (td_u8 *)sm2->n, klen);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "get_randnum failed, ret is 0x%x\n", ret);
+
+        /* Step 9: mr = r * N mod n */
+        ret = drv_cipher_pke_mul_mod(&var_arr[SM2SIGN_SIG_R], &var_arr[SM2SIGN_MONTGOMERY_N], &var_arr[SM2SIGN_SM2_N],
+            &var_arr[SM2SIGN_MR]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 10: mk = k * N mod n */
+        ret = drv_cipher_pke_mul_mod(&var_arr[SM2SIGN_K], &var_arr[SM2SIGN_MONTGOMERY_N], &var_arr[SM2SIGN_SM2_N],
+            &var_arr[SM2SIGN_MK]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 11: mrk = mr + mk mod n */
+        ret = drv_cipher_pke_add_mod(&var_arr[SM2SIGN_MR], &var_arr[SM2SIGN_MK],
+            &var_arr[SM2SIGN_SM2_N], &var_arr[SM2SIGN_MRK]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 12: mrky = mrk * my mod n */
+        ret = drv_cipher_pke_mul_mod(&var_arr[SM2SIGN_MRK], &var_arr[SM2SIGN_MY],
+            &var_arr[SM2SIGN_SM2_N], &var_arr[SM2SIGN_MRKY]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 13: TA = dA * my mod n */
+        ret = drv_cipher_pke_mul_mod(priv_key, &var_arr[SM2SIGN_MY], &var_arr[SM2SIGN_SM2_N], &var_arr[SM2SIGN_TA]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 14: mTA = TA * N mod n */
+        ret = drv_cipher_pke_mul_mod(&var_arr[SM2SIGN_TA], &var_arr[SM2SIGN_MONTGOMERY_N], &var_arr[SM2SIGN_SM2_N],
+            &var_arr[SM2SIGN_MTA]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 15: mTy = mTA + my mod n */
+        ret = drv_cipher_pke_add_mod(&var_arr[SM2SIGN_MTA], &var_arr[SM2SIGN_MY], &var_arr[SM2SIGN_SM2_N],
+            &var_arr[SM2SIGN_MTY]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+        
+        /* Step 16: minv = mTy^-1 mod n */
+        ret = drv_cipher_pke_inv_mod(&var_arr[SM2SIGN_MTY], &var_arr[SM2SIGN_SM2_N], &var_arr[SM2SIGN_MINV]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_inv_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 20: mTz = mrky * minv mod n */
+        ret = drv_cipher_pke_mul_mod(&var_arr[SM2SIGN_MRKY], &var_arr[SM2SIGN_MINV], &var_arr[SM2SIGN_SM2_N],
+            &var_arr[SM2SIGN_MTZ]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 21: ms = mTz - mr mod n */
+        ret = drv_cipher_pke_sub_mod(&var_arr[SM2SIGN_MTZ], &var_arr[SM2SIGN_MR],
+            &var_arr[SM2SIGN_SM2_N], &var_arr[SM2SIGN_MS]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_sub_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 22: s = ms * 1 mod n */
+        ret = drv_cipher_pke_mul_mod(&var_arr[SM2SIGN_MS], &var_arr[SM2SIGN_ONE], &var_arr[SM2SIGN_SM2_N],
+            &var_arr[SM2SIGN_SIG_S]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        /* Step 23: s = 0 ? */
+        if (drv_ecc_is_zero(var_arr[SM2SIGN_SIG_S].data, klen) == TD_FALSE) {
+            break;
+        }
+    }
+
+    if (i >= PKE_MAX_TIMES) {
+        crypto_log_err("Generate rk timeout!\n");
+        ret = PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        goto exit__;
+    }
+
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, klen * SM2_SIGN_BUF_CNT, 0, klen * SM2_SIGN_BUF_CNT);
+        crypto_free(buffer);
+    }
+    return ret;
+}
+
+static td_s32 pke_sm2_verify(const drv_pke_ecc_point *pub_key, const drv_pke_data *hash,
+    const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = DRV_PKE_SM2_LEN_IN_BYTES;
+    td_u32 i;
+    drv_pke_data var_arr[PKE_SM2_VERIFY_VAR_MAX];
+    const drv_pke_ecc_curve *sm2;
+    drv_pke_ecc_point sm2_gpoint;
+    drv_pke_ecc_point sG_point;
+    drv_pke_ecc_point tPA_point;
+    drv_pke_ecc_point r_point;
+    td_u8 *buffer;
+
+    sm2 = get_ecc_curve(DRV_PKE_ECC_TYPE_SM2);
+    crypto_chk_return(sm2 == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    if (drv_range_check(sig->r, sm2->n, DRV_PKE_SM2_LEN_IN_BYTES) != TD_SUCCESS) {
+        crypto_log_err("%s:%d: sig->r check range failed!\n", __func__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    if (drv_range_check(sig->s, sm2->n, DRV_PKE_SM2_LEN_IN_BYTES) != TD_SUCCESS) {
+        crypto_log_err("%s:%d: sig->s check range failed!\n", __func__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    buffer = crypto_malloc(klen * SM2_VERIFY_BUF_CNT);
+    if (buffer == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(buffer, klen * SM2_VERIFY_BUF_CNT, 0, klen * SM2_VERIFY_BUF_CNT);
+    for (i = 0; i < PKE_SM2_VERIFY_VAR_MAX; i++) {
+        if (i <= SM2VERIFY_ZERO) {
+            var_arr[i].data = buffer + klen * i;
+        }
+        var_arr[i].length = klen;
+    }
+    var_arr[SM2VERIFY_SM2_N].data = (td_u8 *)sm2->n;
+    var_arr[SM2VERIFY_SIG_R].data = sig->r;
+    var_arr[SM2VERIFY_SIG_S].data = sig->s;
+    sm2_gpoint = (drv_pke_ecc_point){(td_u8 *)sm2->gx, (td_u8 *)sm2->gy, klen};
+    sG_point = (drv_pke_ecc_point){var_arr[SM2VERIFY_S_GX].data, var_arr[SM2VERIFY_S_GY].data, klen};
+    tPA_point = (drv_pke_ecc_point){var_arr[SM2VERIFY_T_PAX].data, var_arr[SM2VERIFY_T_PAY].data, klen};
+    r_point = (drv_pke_ecc_point){var_arr[SM2VERIFY_RX].data, var_arr[SM2VERIFY_RY].data, klen};
+    /* Step 1: t = r + s mod n */
+    ret = drv_cipher_pke_add_mod(&var_arr[SM2VERIFY_SIG_R], &var_arr[SM2VERIFY_SIG_S], &var_arr[SM2VERIFY_SM2_N],
+        &var_arr[SM2VERIFY_T]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+    /* Step 2: t = 0 ? */
+    if (drv_ecc_is_zero(var_arr[SM2VERIFY_T].data, klen)) {
+        crypto_log_err("t = 0!\n");
+        ret = TD_FAILURE;
+        goto exit__;
+    }
+    /* Step 3: sG = s * G */
+    ret = drv_cipher_pke_mul_dot(sm2, &var_arr[SM2VERIFY_SIG_S], &sm2_gpoint, &sG_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+    /* Step 4: tPA = t * PA */
+    ret = drv_cipher_pke_mul_dot(sm2, &var_arr[SM2VERIFY_T], pub_key, &tPA_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+    /* Step 5: R = sG + tPA */
+    ret = drv_cipher_pke_add_dot(sm2, &sG_point, &tPA_point, &r_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_dot failed, ret is 0x%x\n", ret);
+    /* Step 6: e = hash + 0 mod n */
+    ret = drv_cipher_pke_add_mod(hash, &var_arr[SM2VERIFY_ZERO], &var_arr[SM2VERIFY_SM2_N], &var_arr[SM2VERIFY_E]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+    /* Step 7: v = e + Rx mod n */
+    ret = drv_cipher_pke_add_mod(&var_arr[SM2VERIFY_E], &var_arr[SM2VERIFY_RX], &var_arr[SM2VERIFY_SM2_N],
+        &var_arr[SM2VERIFY_V]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+    /* Step 8: v = r ? */
+    if (memcmp(sig->r, var_arr[SM2VERIFY_V].data, klen) != 0) {
+        crypto_log_err("v != r!\n");
+        ret = TD_FAILURE;
+    }
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, klen * SM2_VERIFY_BUF_CNT, 0, klen * SM2_VERIFY_BUF_CNT);
+        crypto_free(buffer);
+    }
+    return ret;
+}
+
+static td_s32 pke_ecdsa_sign(
+    const drv_pke_ecc_curve *ecc,
+    const drv_pke_data *priv_key,
+    const drv_pke_data *hash,
+    const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = ecc->ksize;
+    td_u32 i;
+    drv_pke_data var_arr[PKE_ECDSA_SIGN_VAR_MAX];
+    drv_pke_ecc_point ecc_gpoint;
+    drv_pke_ecc_point r_point;
+    td_u8 *buffer;
+
+    if (ecc->ecc_type == DRV_PKE_ECC_TYPE_SM2) {
+        return pke_sm2_sign(priv_key, hash, sig);
+    }
+    buffer = crypto_malloc(klen * ECDSA_SIGN_BUF_CNT);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    (void)memset_s(buffer, klen * ECDSA_SIGN_BUF_CNT, 0, klen * ECDSA_SIGN_BUF_CNT);
+    for (i = 0; i < PKE_ECDSA_SIGN_VAR_MAX - 1; i++) {
+        if (i <= ECCSIGN_ONE) {
+            var_arr[i].data = buffer + klen * i;
+        }
+        var_arr[i].length = klen;
+    }
+    var_arr[ECCSIGN_ECC_N].data = (td_u8 *)ecc->n;
+    var_arr[ECCSIGN_SIG_R].data = sig->r;
+    var_arr[ECCSIGN_SIG_S].data = sig->s;
+    var_arr[ECCSIGN_HASH].data = hash->data;
+    var_arr[ECCSIGN_HASH].length = crypto_min(hash->length, ecc->ksize);
+    var_arr[ECCSIGN_ONE].data[klen - 1] = 0x1;
+    ecc_gpoint = (drv_pke_ecc_point){(td_u8 *)ecc->gx, (td_u8 *)ecc->gy, klen};
+    r_point = (drv_pke_ecc_point){var_arr[ECCSIGN_RX].data, var_arr[ECCSIGN_RY].data, klen};
+
+    // 1. N = 2 ^ 2len_n mod n where N = R ^ 2
+    ret = cal_montgomery_n(&var_arr[ECCSIGN_ECC_N], &var_arr[ECCSIGN_MONTGOMERY_N]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+
+    for (i = 0; i < ECC_TRY_CNT; i++) {
+        // 2. generate randnum k
+        ret = get_randnum(var_arr[ECCSIGN_K].data, (td_u8 *)ecc->n, klen);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "get_randnum failed, ret is 0x%x\n", ret);
+        // 3. R = k*G
+        ret = drv_cipher_pke_mul_dot(ecc, &var_arr[ECCSIGN_K], &ecc_gpoint, &r_point);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+        // 4. r= (xR + 0) mod n
+        ret = drv_cipher_pke_add_mod(&var_arr[ECCSIGN_RX], &var_arr[ECCSIGN_ZERO], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_SIG_R]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+        // 5. check r ?=0
+        if (drv_ecc_is_zero(var_arr[ECCSIGN_SIG_R].data, klen)) {
+            continue;
+        }
+
+        // 6. E = hash + 0 mod n
+        ret = drv_cipher_pke_add_mod(&var_arr[ECCSIGN_HASH], &var_arr[ECCSIGN_ZERO], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_E]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+        // 7. mE = E * N mod n
+        ret = drv_cipher_pke_mul_mod(&var_arr[ECCSIGN_E], &var_arr[ECCSIGN_MONTGOMERY_N], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_ME]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        // 8. mr = r * N mod n
+        ret = drv_cipher_pke_mul_mod(&var_arr[ECCSIGN_SIG_R], &var_arr[ECCSIGN_MONTGOMERY_N], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_MR]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        // 9. md = d * N mod n
+        ret = drv_cipher_pke_mul_mod(priv_key, &var_arr[ECCSIGN_MONTGOMERY_N], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_MD]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        // 10. mrd = md * mr mod n
+        ret = drv_cipher_pke_mul_mod(&var_arr[ECCSIGN_MD], &var_arr[ECCSIGN_MR], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_MRD]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        // 11. y = mE + mrd mod n
+        ret = drv_cipher_pke_add_mod(&var_arr[ECCSIGN_ME], &var_arr[ECCSIGN_MRD], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_Y]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+        // 12. mk = k * N mod n
+        ret = drv_cipher_pke_mul_mod(&var_arr[ECCSIGN_K], &var_arr[ECCSIGN_MONTGOMERY_N], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_MK]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        // 13. mkni = mk ^ -1 mod n
+        ret = drv_cipher_pke_inv_mod(&var_arr[ECCSIGN_MK], &var_arr[ECCSIGN_ECC_N], &var_arr[ECCSIGN_MKNI]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_inv_mod failed, ret is 0x%x\n", ret);
+
+        // 14. ms = mkni * y mod n
+        ret = drv_cipher_pke_mul_mod(&var_arr[ECCSIGN_MKNI], &var_arr[ECCSIGN_Y], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_MS]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        // 15. s = ms * 1 mod n
+        ret = drv_cipher_pke_mul_mod(&var_arr[ECCSIGN_MS], &var_arr[ECCSIGN_ONE], &var_arr[ECCSIGN_ECC_N],
+            &var_arr[ECCSIGN_SIG_S]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+        // 16. check s ?=0
+        if (drv_ecc_is_zero(var_arr[ECCSIGN_SIG_S].data, klen)) {
+            continue;
+        }
+        break;
+    }
+    if (i == ECC_TRY_CNT) {
+        crypto_log_err("Error! K is Invalid!\n");
+        ret = PKE_COMPAT_ERRNO(ERROR_TRY_TIMES);
+        goto exit__;
+    }
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, klen * ECDSA_SIGN_BUF_CNT, 0, klen * ECDSA_SIGN_BUF_CNT);
+        crypto_free(buffer);
+        buffer = TD_NULL;
+    }
+    return ret;
+}
+
+static td_s32 pke_ecdsa_verify(
+    const drv_pke_ecc_curve *ecc,
+    const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash,
+    const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = ecc->ksize;
+    td_u32 i;
+    drv_pke_data var_arr[PKE_ECDSA_VERIFY_VAR_MAX];
+    drv_pke_ecc_point ecc_gpoint;
+    drv_pke_ecc_point r_point;
+    drv_pke_ecc_point u1_point;
+    drv_pke_ecc_point u2_point;
+    td_u8 *buffer;
+
+    if (ecc->ecc_type == DRV_PKE_ECC_TYPE_SM2) {
+        return pke_sm2_verify(pub_key, hash, sig);
+    }
+    buffer = crypto_malloc(klen * ECDSA_VERIFY_BUF_CNT);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    (void)memset_s(buffer, klen * ECDSA_VERIFY_BUF_CNT, 0, klen * ECDSA_VERIFY_BUF_CNT);
+
+    for (i = 0; i < PKE_ECDSA_VERIFY_VAR_MAX - 1; i++) {
+        if (i <= ECCVERIFY_ONE) {
+            var_arr[i].data = buffer + klen * i;
+        }
+        var_arr[i].length = klen;
+    }
+    var_arr[ECCVERIFY_ECC_N].data = (td_u8 *)ecc->n;
+    var_arr[ECCVERIFY_SIG_R].data = sig->r;
+    var_arr[ECCVERIFY_SIG_S].data = sig->s;
+    var_arr[ECCVERIFY_HASH].data = hash->data;
+    var_arr[ECCVERIFY_HASH].length = crypto_min(hash->length, klen);
+    var_arr[ECCVERIFY_ONE].data[klen - 1] = 0x1;
+
+    ecc_gpoint = (drv_pke_ecc_point){(td_u8 *)ecc->gx, (td_u8 *)ecc->gy, klen};
+    r_point = (drv_pke_ecc_point){var_arr[ECCVERIFY_RX].data, var_arr[ECCVERIFY_RY].data, klen};
+    u1_point = (drv_pke_ecc_point){var_arr[ECCVERIFY_U1X].data, var_arr[ECCVERIFY_U1Y].data, klen};
+    u2_point = (drv_pke_ecc_point){var_arr[ECCVERIFY_U2X].data, var_arr[ECCVERIFY_U2Y].data, klen};
+
+    /* check 0 < r < n ? */
+    if (drv_range_check(sig->r, ecc->n, klen) != TD_SUCCESS) {
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_ECDSA_VERIFY_CHECK);
+        goto exit__;
+    }
+
+    /* check 0< s < n ? */
+    if (drv_range_check(sig->s, ecc->n, klen) != TD_SUCCESS) {
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_ECDSA_VERIFY_CHECK);
+        goto exit__;
+    }
+
+    // 1. N =2 ^ 2len_n mod n
+    ret = cal_montgomery_n(&var_arr[ECCVERIFY_ECC_N], &var_arr[ECCVERIFY_MONTGOMERY_N]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+
+    // 2. ms = s * N mod n
+    ret = drv_cipher_pke_mul_mod(&var_arr[ECCVERIFY_SIG_S], &var_arr[ECCVERIFY_MONTGOMERY_N], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_MS]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    // 3. msni = ms ^ -1 mod n
+    ret = drv_cipher_pke_inv_mod(&var_arr[ECCVERIFY_MS], &var_arr[ECCVERIFY_ECC_N], &var_arr[ECCVERIFY_MSNI]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_inv_mod failed, ret is 0x%x\n", ret);
+
+    // 4. E = hash + 0 mod n
+    ret = drv_cipher_pke_add_mod(&var_arr[ECCVERIFY_HASH], &var_arr[ECCVERIFY_ZERO], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_E]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+    // 5. mE = E * N mod n
+    ret = drv_cipher_pke_mul_mod(&var_arr[ECCVERIFY_E], &var_arr[ECCVERIFY_MONTGOMERY_N], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_ME]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    // 6. mu1 = mE * msni mod n
+    ret = drv_cipher_pke_mul_mod(&var_arr[ECCVERIFY_ME], &var_arr[ECCVERIFY_MSNI], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_MU1]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    // 7. u1 = mu1 * 1 mod n
+    ret = drv_cipher_pke_mul_mod(&var_arr[ECCVERIFY_MU1], &var_arr[ECCVERIFY_ONE], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_U1]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    // 8. mr = r * N mod n
+    ret = drv_cipher_pke_mul_mod(&var_arr[ECCVERIFY_SIG_R], &var_arr[ECCVERIFY_MONTGOMERY_N], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_MR]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    // 9. mu2 = mr * msni mod n
+    ret = drv_cipher_pke_mul_mod(&var_arr[ECCVERIFY_MR], &var_arr[ECCVERIFY_MSNI], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_MU2]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    // 10. u2 = mu2 * 1 mod n
+    ret = drv_cipher_pke_mul_mod(&var_arr[ECCVERIFY_MU2], &var_arr[ECCVERIFY_ONE], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_U2]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    // 11. u1G = u1 * G
+    ret = drv_cipher_pke_mul_dot(ecc, &var_arr[ECCVERIFY_U1], &ecc_gpoint, &u1_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+
+    // 12. u2Q = u2 * Qu
+    ret = drv_cipher_pke_mul_dot(ecc, &var_arr[ECCVERIFY_U2], pub_key, &u2_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_dot failed, ret is 0x%x\n", ret);
+
+    // 13. R = u1G + u2Q
+    ret = drv_cipher_pke_add_dot(ecc, &u1_point, &u2_point, &r_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_dot failed, ret is 0x%x\n", ret);
+
+    // 14. v= (xR + 0) mod n
+    ret = drv_cipher_pke_add_mod(&var_arr[ECCVERIFY_RX], &var_arr[ECCVERIFY_ZERO], &var_arr[ECCVERIFY_ECC_N],
+        &var_arr[ECCVERIFY_V]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+    // v = r ?
+    if (memcmp(sig->r, var_arr[ECCVERIFY_V].data, klen) != 0) {
+        crypto_log_err("Error! r != v!\n");
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_ECDSA_VERIFY_CHECK);
+    }
+
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, klen * ECDSA_VERIFY_BUF_CNT, 0, klen * ECDSA_VERIFY_BUF_CNT);
+        crypto_free(buffer);
+        buffer = TD_NULL;
+    }
+    return ret;
+}
+
+static td_s32 sha512_modq(const drv_pke_data *q, const drv_pke_data *in1, const drv_pke_data *in2,
+    const drv_pke_data *in3, const drv_pke_data *out)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 h[DRV_PKE_LEN_512];
+    td_u8 hash[DRV_PKE_LEN_512];
+    td_u32 i = 0;
+    drv_pke_data arr[ED25519_MAX_HASH_ELEMENTS];
+    drv_pke_data hash_data = {DRV_PKE_LEN_512, hash};
+    const drv_pke_data h_data = {DRV_PKE_LEN_512, h};
+
+    /* H = Hash(in1 || in2 || in3) */
+    if ((in1 != TD_NULL) && (in1->data != TD_NULL)) {
+        arr[i].data = in1->data;
+        arr[i].length = in1->length;
+        i++;
+    }
+    if ((in2 != TD_NULL) && (in2->data != TD_NULL)) {
+        arr[i].data = in2->data;
+        arr[i].length = in2->length;
+        i++;
+    }
+    if ((in3 != TD_NULL) && (in3->data != TD_NULL)) {
+        arr[i].data = in3->data;
+        arr[i].length = in3->length;
+        i++;
+    }
+    ret = drv_cipher_pke_calc_hash(arr, i, DRV_PKE_HASH_TYPE_SHA512, &hash_data);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_calc_hash failed, ret is 0x%x\n", ret);
+    for (i = 0; i < DRV_PKE_LEN_512; i++) {
+        h[i] = hash[DRV_PKE_LEN_512 - 1 - i];
+    }
+    /* For efficiency, reduce k modulo L first. L equals to ecc->n */
+    ret = drv_cipher_pke_mod(&h_data, q, out);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mod failed, ret is 0x%x\n", ret);
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    return ret;
+}
+
+/* out = in ^ k mod n */
+static td_s32 ed_exp_mod(const td_u8 *n, const td_u8 *k, const td_u8 *in, td_u8 *out)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *nn;
+    td_u8 *kk;
+    td_u8 *ii;
+    td_u8 *oo;
+    td_u32 i = 0;
+    drv_pke_data n_data;
+    drv_pke_data k_data;
+    drv_pke_data i_data;
+    drv_pke_data o_data;
+    td_u8 *buffer;
+    buffer = crypto_malloc(DRV_PKE_LEN_2048 * 4); // need buffer num is 4
+    if (buffer == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(buffer, DRV_PKE_LEN_2048 * 4, 0x00, DRV_PKE_LEN_2048 * 4); // need buffer num is 4
+
+    nn = buffer + DRV_PKE_LEN_2048 * i++;
+    kk = buffer + DRV_PKE_LEN_2048 * i++;
+    ii = buffer + DRV_PKE_LEN_2048 * i++;
+    oo = buffer + DRV_PKE_LEN_2048 * i++;
+    n_data = (drv_pke_data){DRV_PKE_LEN_2048, nn};
+    k_data = (drv_pke_data){DRV_PKE_LEN_2048, kk};
+    i_data = (drv_pke_data){DRV_PKE_LEN_2048, ii};
+    o_data = (drv_pke_data){DRV_PKE_LEN_2048, oo};
+
+    for (i = 0; i < DRV_PKE_LEN_256; i++) {
+        nn[i + DRV_PKE_LEN_2048 - DRV_PKE_LEN_256] = n[i];
+        kk[i + DRV_PKE_LEN_2048 - DRV_PKE_LEN_256] = k[i];
+        ii[i + DRV_PKE_LEN_2048 - DRV_PKE_LEN_256] = in[i];
+    }
+    ret = drv_cipher_pke_exp_mod(&n_data, &k_data, &i_data, &o_data);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_exp_mod failed, ret is 0x%x\n", ret);
+    for (i = 0; i < DRV_PKE_LEN_256; i++) {
+        out[i] = oo[i + DRV_PKE_LEN_2048 - DRV_PKE_LEN_256];
+    }
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, DRV_PKE_LEN_2048 * 4, 0x00, DRV_PKE_LEN_2048 * 4); // need free buffer num is 4
+        crypto_free(buffer);
+    }
+    return ret;
+}
+
+static td_s32 generate_x(const drv_pke_ecc_curve *ecc, const td_u8 *x2, td_u8 *x, const td_u32 klen)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i;
+    drv_pke_data var_arr[GENERATE_X_VAR_MAX];
+    td_u8 *buffer;
+
+    buffer = crypto_malloc(klen * GENERATE_X_BUF_CNT);
+    if (buffer == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(buffer, klen * GENERATE_X_BUF_CNT, 0, klen * GENERATE_X_BUF_CNT);
+
+    for (i = 0; i < GENERATE_X_VAR_MAX; i++) {
+        if (i <= GENERATEX_THREE) {
+            var_arr[i].data = buffer + klen * i;
+        }
+        var_arr[i].length = klen;
+    }
+    var_arr[GENERATEX_ECC_P].data = (td_u8 *)ecc->p;
+    var_arr[GENERATEX_X].data = x;
+    var_arr[GENERATEX_X2].data = (td_u8 *)x2;
+    var_arr[GENERATEX_ONE].data[klen - 1] = 0x1;
+    var_arr[GENERATEX_TWO].data[klen - 1] = 0x2; // 0x2 : GENERATEX_TWO
+    var_arr[GENERATEX_THREE].data[klen - 1] = 0x3; // 0x3 : GENERATEX_THREE
+
+    /* x = x2 ^ ((p + 3) // 8) mod p */
+    ret = drv_cipher_pke_add_mod(&var_arr[GENERATEX_ECC_P], &var_arr[GENERATEX_THREE], &var_arr[GENERATEX_MAX],
+        &var_arr[GENERATEX_P38]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+    for (i = DRV_PKE_LEN_256 - 1; i > 0; i--) {
+        var_arr[GENERATEX_P38].data[i] = ((var_arr[GENERATEX_P38].data[i] & 0xF8) >> 3) | /* shift 3 */
+            ((var_arr[GENERATEX_P38].data[i - 1] & 0x07) << 5); /* shift 3 5 */
+    }
+    var_arr[GENERATEX_P38].data[0] = (var_arr[GENERATEX_P38].data[0] & 0xF8) >> 3; /* shift 3 */
+    ret = ed_exp_mod(ecc->p, var_arr[GENERATEX_P38].data, x2, x);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "ed_exp_mod failed, ret is 0x%x\n", ret);
+    /* xx = x ^ 2 mod p */
+    ret = ed_exp_mod(ecc->p, var_arr[GENERATEX_TWO].data, x, var_arr[GENERATEX_XX].data);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "ed_exp_mod failed, ret is 0x%x\n", ret);
+     /* c = xx - x2 mod p */
+    ret = drv_cipher_pke_sub_mod(&var_arr[GENERATEX_XX], &var_arr[GENERATEX_X2], &var_arr[GENERATEX_ECC_P],
+        &var_arr[GENERATEX_C]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_sub_mod failed, ret is 0x%x\n", ret);
+    if (drv_ecc_is_zero(var_arr[GENERATEX_C].data, klen)) {
+        ret = TD_SUCCESS;
+        goto exit__;
+    }
+    /* c = xx + x2 mod p */
+    ret = drv_cipher_pke_add_mod(&var_arr[GENERATEX_XX], &var_arr[GENERATEX_X2], &var_arr[GENERATEX_ECC_P],
+        &var_arr[GENERATEX_C]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+    if (drv_ecc_is_zero(var_arr[GENERATEX_C].data, klen) != TD_TRUE) {
+        ret = TD_FAILURE;
+        goto exit__;
+    }
+    /* s = 2 ^ ((p - 1) / 4) mod p */
+    ret = drv_cipher_pke_sub_mod(&var_arr[GENERATEX_ECC_P], &var_arr[GENERATEX_ONE], &var_arr[GENERATEX_ECC_P],
+        &var_arr[GENERATEX_P14]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_sub_mod failed, ret is 0x%x\n", ret);
+    for (i = DRV_PKE_LEN_256 - 1; i > 0; i--) {
+        var_arr[GENERATEX_P14].data[i] = ((var_arr[GENERATEX_P14].data[i] & 0xFC) >> 2) | /* shift 2 */
+            ((var_arr[GENERATEX_P14].data[i - 1] & 0x03) << 6); /* shift 2 6 */
+    }
+    var_arr[GENERATEX_P14].data[0] = (var_arr[GENERATEX_P14].data[0] & 0xFC) >> 2; /* shift 2 */
+    ret = ed_exp_mod(ecc->p, var_arr[GENERATEX_P14].data, var_arr[GENERATEX_TWO].data, var_arr[GENERATEX_S].data);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "ed_exp_mod failed, ret is 0x%x\n", ret);
+    ret = cal_montgomery_n(&var_arr[GENERATEX_ECC_P], &var_arr[GENERATEX_MONTGOMERY_P]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+    /* x = x * sqrt mod p */
+    /* x -> mx */
+    ret = drv_cipher_pke_mul_mod(&var_arr[GENERATEX_X], &var_arr[GENERATEX_MONTGOMERY_P], &var_arr[GENERATEX_ECC_P],
+        &var_arr[GENERATEX_MX]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* s -> ms */
+    ret = drv_cipher_pke_mul_mod(&var_arr[GENERATEX_S], &var_arr[GENERATEX_MONTGOMERY_P], &var_arr[GENERATEX_ECC_P],
+        &var_arr[GENERATEX_MS]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* mxs = mx * ms mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[GENERATEX_MX], &var_arr[GENERATEX_MS], &var_arr[GENERATEX_ECC_P],
+        &var_arr[GENERATEX_MXS]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* x' = mxs * 1 mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[GENERATEX_MXS], &var_arr[GENERATEX_ONE], &var_arr[GENERATEX_ECC_P],
+        &var_arr[GENERATEX_X]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, klen * GENERATE_X_BUF_CNT, 0, klen * GENERATE_X_BUF_CNT);
+        crypto_free(buffer);
+    }
+    return ret;
+}
+
+static td_s32 point_decompress(const drv_pke_ecc_curve *ecc, const drv_pke_data *in, const drv_pke_ecc_point *out)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i;
+    td_u32 sign = 0;
+    td_u32 klen = DRV_PKE_LEN_256;
+    drv_pke_data var_arr[POINT_DECOMPRESS_VAR_MAX];
+    td_u8 *buffer;
+
+    buffer = crypto_malloc(klen * POINT_DECOMPRESS_BUF_CNT);
+    if (buffer == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(buffer, klen * POINT_DECOMPRESS_BUF_CNT, 0, klen * POINT_DECOMPRESS_BUF_CNT);
+    for (i = 0; i < POINT_DECOMPRESS_VAR_MAX; i++) {
+        if (i <= POINTDECOMPRESS_MONE) {
+            var_arr[i].data = buffer + klen * i;
+        }
+        var_arr[i].length = klen;
+    }
+    var_arr[POINTDECOMPRESS_ECC_P].data = (td_u8 *)ecc->p;
+    var_arr[POINTDECOMPRESS_ECC_A].data = (td_u8 *)ecc->a;
+    var_arr[POINTDECOMPRESS_OUTX].data = out->x;
+    var_arr[POINTDECOMPRESS_OUTY].data = out->y;
+    var_arr[POINTDECOMPRESS_ONE].data[klen - 1] = 0x1;
+
+    for (i = 0; i < klen; i++) {
+        out->y[i] = in->data[klen - 1 - i];
+    }
+    sign = out->y[0] >> 7; /* shift 7 */
+    out->y[0] &= 0x7F; /* y is recovered by clearing 255 bit */
+
+    ret = cal_montgomery_n(&var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MONTGOMERY_P]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+    /* y -> my */
+    ret = drv_cipher_pke_mul_mod(&var_arr[POINTDECOMPRESS_OUTY], &var_arr[POINTDECOMPRESS_MONTGOMERY_P],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MY]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* my2 = my * my mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[POINTDECOMPRESS_MY], &var_arr[POINTDECOMPRESS_MY],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MY2]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* 1 -> m1 */
+    ret = drv_cipher_pke_mul_mod(&var_arr[POINTDECOMPRESS_ONE], &var_arr[POINTDECOMPRESS_MONTGOMERY_P],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MONE]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* my21 = my2 - m1 mod p */
+    ret = drv_cipher_pke_sub_mod(&var_arr[POINTDECOMPRESS_MY2], &var_arr[POINTDECOMPRESS_MONE],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MY21]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* d -> md */
+    ret = drv_cipher_pke_mul_mod(&var_arr[POINTDECOMPRESS_ECC_A], &var_arr[POINTDECOMPRESS_MONTGOMERY_P],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MD]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* mdy2 = md * my2 mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[POINTDECOMPRESS_MD], &var_arr[POINTDECOMPRESS_MY2],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MDY2]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* mdy21 = mdy2 + m1 mod p */
+    ret = drv_cipher_pke_add_mod(&var_arr[POINTDECOMPRESS_MDY2], &var_arr[POINTDECOMPRESS_MONE],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MDY21]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+    /* minv = mdy21 ^ -1 mod p */
+    ret = drv_cipher_pke_inv_mod(&var_arr[POINTDECOMPRESS_MDY21], &var_arr[POINTDECOMPRESS_ECC_P],
+        &var_arr[POINTDECOMPRESS_MINV]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_inv_mod failed, ret is 0x%x\n", ret);
+    /* mx2 = my21 * minv */
+    ret = drv_cipher_pke_mul_mod(&var_arr[POINTDECOMPRESS_MY21], &var_arr[POINTDECOMPRESS_MINV],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_MX2]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    /* x2 = mx2 * 1 mod p */
+    ret = drv_cipher_pke_mul_mod(&var_arr[POINTDECOMPRESS_MX2], &var_arr[POINTDECOMPRESS_ONE],
+        &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_X2]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+    if (drv_ecc_is_zero(var_arr[POINTDECOMPRESS_X2].data, klen)) {
+        if (sign == 0) {
+            (void)memset_s(out->x, klen, 0x00, klen);
+            ret = TD_SUCCESS;
+            goto exit__;
+        } else {
+            ret = TD_FAILURE;
+            goto exit__;
+        }
+    }
+    ret = generate_x(ecc, var_arr[POINTDECOMPRESS_X2].data, var_arr[POINTDECOMPRESS_X].data, klen);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "generate_x failed, ret is 0x%x\n", ret);
+    if ((var_arr[POINTDECOMPRESS_X].data[klen - 1] & 0x1) != sign) {
+        /* x = p - x */
+        ret = drv_cipher_pke_sub_mod(&var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_X],
+            &var_arr[POINTDECOMPRESS_ECC_P], &var_arr[POINTDECOMPRESS_OUTX]);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_sub_mod failed, ret is 0x%x\n", ret);
+    } else {
+        ret = memcpy_s(out->x, out->length, var_arr[POINTDECOMPRESS_X].data, klen);
+        crypto_chk_goto(ret != TD_SUCCESS, exit__, "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, klen * POINT_DECOMPRESS_BUF_CNT, 0, klen * POINT_DECOMPRESS_BUF_CNT);
+        crypto_free(buffer);
+    }
+    return ret;
+}
+
+static td_s32 pke_eddsa_sign(const drv_pke_ecc_curve *ecc, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i;
+    td_u32 klen = DRV_PKE_LEN_256;
+    drv_pke_data var_arr[PKE_EDDSA_SIGN_VAR_MAX];
+    td_u8 *buffer;
+
+    buffer = crypto_malloc(klen * EDDSA_SIGN_BUF_CNT);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    (void)memset_s(buffer, klen * EDDSA_SIGN_BUF_CNT, 0, klen * EDDSA_SIGN_BUF_CNT);
+
+    for (i = 0; i < PKE_EDDSA_SIGN_VAR_MAX - 1; i++) {
+        if (i <= EDDSIGN_ONE) {
+            var_arr[i].data = buffer + klen * i;
+        }
+        var_arr[i].length = klen;
+    }
+    var_arr[EDDSIGN_ECC_N].data = (td_u8 *)ecc->n;
+    var_arr[EDDSIGN_MSG].data = msg->data;
+    var_arr[EDDSIGN_MSG].length = msg->length;
+    var_arr[EDDSIGN_ONE].data[klen - 1] = 0x1;
+
+    /* Operation: a, prefix = secret_expand(secret) */
+    ret = secret_expand(priv_key->data, var_arr[EDDSIGN_A].data, var_arr[EDDSIGN_PREFIX].data, klen);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "secret_expand failed, ret is 0x%x\n", ret);
+
+    /* Operation: A = point_compress(point_mul(a, G)) */
+    ret = point_mul_compress(ecc, var_arr[EDDSIGN_A].data, var_arr[EDDSIGN_PUBKEY].data, klen);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "point_mul_compress failed, ret is 0x%x\n", ret);
+
+    /* Operation: r = sha512_modq(prefix + msg) */
+    ret = sha512_modq(&var_arr[EDDSIGN_ECC_N], TD_NULL, &var_arr[EDDSIGN_PREFIX], &var_arr[EDDSIGN_MSG],
+        &var_arr[EDDSIGN_R]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "sha512_modq failed, ret is 0x%x\n", ret);
+
+    /* Operation: Rs = point_compress(point_mul(r, G)) */
+    ret = point_mul_compress(ecc, var_arr[EDDSIGN_R].data, var_arr[EDDSIGN_RS].data, klen);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "point_mul_compress failed, ret is 0x%x\n", ret);
+
+    /* Operation: h = sha512_modq(Rs + A + msg) */
+    ret = sha512_modq(&var_arr[EDDSIGN_ECC_N], &var_arr[EDDSIGN_RS], &var_arr[EDDSIGN_PUBKEY],
+        &var_arr[EDDSIGN_MSG], &var_arr[EDDSIGN_H]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "sha512_modq failed, ret is 0x%x\n", ret);
+
+    ret = cal_montgomery_n(&var_arr[EDDSIGN_ECC_N], &var_arr[EDDSIGN_MONTGOMERY_N]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "cal_montgomery_n failed, ret is 0x%x\n", ret);
+
+    /* Operation: pseudocode is s = (r + h * a) % q; h -> mh */
+    ret = drv_cipher_pke_mul_mod(&var_arr[EDDSIGN_H], &var_arr[EDDSIGN_MONTGOMERY_N], &var_arr[EDDSIGN_ECC_N],
+        &var_arr[EDDSIGN_MH]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Operation: a -> ma */
+    ret = drv_cipher_pke_mul_mod(&var_arr[EDDSIGN_A], &var_arr[EDDSIGN_MONTGOMERY_N], &var_arr[EDDSIGN_ECC_N],
+        &var_arr[EDDSIGN_MA]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Operation: mha = mh * ma mod q */
+    ret = drv_cipher_pke_mul_mod(&var_arr[EDDSIGN_MH], &var_arr[EDDSIGN_MA], &var_arr[EDDSIGN_ECC_N],
+        &var_arr[EDDSIGN_MHA]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Operation: r -> mr */
+    ret = drv_cipher_pke_mul_mod(&var_arr[EDDSIGN_R], &var_arr[EDDSIGN_MONTGOMERY_N], &var_arr[EDDSIGN_ECC_N],
+        &var_arr[EDDSIGN_MR]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Operation: ms = mr + mha mod q */
+    ret = drv_cipher_pke_add_mod(&var_arr[EDDSIGN_MHA], &var_arr[EDDSIGN_MR], &var_arr[EDDSIGN_ECC_N],
+        &var_arr[EDDSIGN_MS]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_add_mod failed, ret is 0x%x\n", ret);
+
+    /* Operation: s = ms * 1 mod q */
+    ret = drv_cipher_pke_mul_mod(&var_arr[EDDSIGN_MS], &var_arr[EDDSIGN_ONE], &var_arr[EDDSIGN_ECC_N],
+        &var_arr[EDDSIGN_S]);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_mul_mod failed, ret is 0x%x\n", ret);
+
+    /* Operation: return Rs + int.to_bytes(s, 32, "little") */
+    ret = memcpy_s(sig->r, sig->length, var_arr[EDDSIGN_RS].data, klen);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "memcpy_s failed, ret is 0x%x\n", ret);
+    for (i = 0; i < klen; i++) {
+        sig->s[i] = var_arr[EDDSIGN_S].data[klen - 1 - i];
+    }
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, klen * EDDSA_SIGN_BUF_CNT, 0, klen * EDDSA_SIGN_BUF_CNT);
+        crypto_free(buffer);
+    }
+    return ret;
+}
+
+static td_s32 pke_eddsa_verify(const drv_pke_ecc_curve *ecc, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = DRV_PKE_LEN_256;
+    td_u32 i = 0;
+    drv_pke_data h_data = {.length = klen};
+    drv_pke_data s_data = {.length = klen};
+    drv_pke_data pubkey_y_data = {klen, pub_key->y};
+    drv_pke_data sig_r_data = {klen, sig->r};
+    drv_pke_data ecc_n_data = {klen, (td_u8 *)ecc->n};
+    drv_pke_data ecc_p_data = {klen, (td_u8 *)ecc->p};
+    drv_pke_data msg_data = {msg->length, msg->data};
+    drv_pke_ecc_point ecc_a_point = {.length = klen};
+    drv_pke_ecc_point ecc_g_point = {(td_u8 *)ecc->gx, (td_u8 *)ecc->gy, klen};
+    drv_pke_ecc_point ecc_r_point = {.length = klen};
+    drv_pke_ecc_point ecc_sB_point = {.length = klen};
+    drv_pke_ecc_point ecc_hA_point = {.length = klen};
+    drv_pke_ecc_point ecc_rhA_point = {.length = klen};
+    td_u8 *buffer;
+
+    buffer = crypto_malloc(klen * EDDSA_VERIFY_BUF_CNT);
+    crypto_chk_return(buffer == TD_NULL, PKE_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    (void)memset_s(buffer, klen * EDDSA_VERIFY_BUF_CNT, 0, klen * EDDSA_VERIFY_BUF_CNT);
+
+    h_data.data = buffer + klen * i++;
+    s_data.data = buffer + klen * i++;
+    ecc_a_point.x = buffer + klen * i++;
+    ecc_a_point.y = buffer + klen * i++;
+    ecc_r_point.x = buffer + klen * i++;
+    ecc_r_point.y = buffer + klen * i++;
+    ecc_sB_point.x = buffer + klen * i++;
+    ecc_sB_point.y = buffer + klen * i++;
+    ecc_hA_point.x = buffer + klen * i++;
+    ecc_hA_point.y = buffer + klen * i++;
+    ecc_rhA_point.x = buffer + klen * i++;
+    ecc_rhA_point.y = buffer + klen * i++;
+    /* ecc_a = point_decompress(public) */
+    ret = point_decompress(ecc, &pubkey_y_data, &ecc_a_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "point_mul_compress failed, ret is 0x%x\n", ret);
+    /* ecc_rs = signature[:32] */
+    /* ecc_r = point_decompress(Rs) */
+    ret = point_decompress(ecc, &sig_r_data, &ecc_r_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "point_mul_compress failed, ret is 0x%x\n", ret);
+    /* s = int.from_bytes(signature[32:], "little") */
+    for (i = 0; i < klen; i++) {
+        s_data.data[i] = sig->s[klen - 1 - i];
+    }
+    /* h = sha512_modq(Rs + public + msg) */
+    ret = sha512_modq(&ecc_n_data, &sig_r_data, &pubkey_y_data, &msg_data, &h_data);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "sha512_modq failed, ret is 0x%x\n", ret);
+     /* ecc_sb = point_mul(ecc_s, ecc_g) */
+    ret = drv_cipher_pke_ed_mul_dot(&s_data, &ecc_g_point, &ecc_p_data, &ecc_sB_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_ed_mul_dot failed, ret is 0x%x\n", ret);
+    /* ecc_ha = point_mul(h, ecc_a) */
+    ret = drv_cipher_pke_ed_mul_dot(&h_data, &ecc_a_point, &ecc_p_data, &ecc_hA_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_ed_mul_dot failed, ret is 0x%x\n", ret);
+    /* return point_equal(ecc_sb, point_add(ecc_r, ecc_ha)) */
+    ret = drv_cipher_pke_ed_add_dot(ecc, &ecc_r_point, &ecc_hA_point, &ecc_rhA_point);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_ed_add_dot failed, ret is 0x%x\n", ret);
+
+    if ((memcmp(ecc_sB_point.x, ecc_rhA_point.x, klen) != 0) || (memcmp(ecc_sB_point.y, ecc_rhA_point.y, klen) != 0)) {
+        ret = TD_FAILURE;
+        goto exit__;
+    }
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    if (buffer != TD_NULL) {
+        (void)memset_s(buffer, klen * EDDSA_VERIFY_BUF_CNT, 0, klen * EDDSA_VERIFY_BUF_CNT);
+        crypto_free(buffer);
+    }
+    return ret;
+}
+
+/* expose layer, do param check here */
+td_s32 drv_cipher_pke_ecc_gen_key(
+    drv_pke_ecc_curve_type curve_type,
+    const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key,
+    const drv_pke_ecc_point *output_pub_key)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    const drv_pke_ecc_curve *ecc_curve = get_ecc_curve(curve_type);
+    crypto_chk_return(ecc_curve == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    /* check ptr. */
+    if (input_priv_key != TD_NULL) {
+        pke_null_ptr_chk(input_priv_key->data);
+    }
+    pke_null_ptr_chk(output_priv_key);
+    pke_null_ptr_chk(output_priv_key->data);
+    pke_null_ptr_chk(output_pub_key);
+    if (curve_type != DRV_PKE_ECC_TYPE_RFC8032) {
+        pke_null_ptr_chk(output_pub_key->x);
+    }
+    if (curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        pke_null_ptr_chk(output_pub_key->y);
+    }
+
+    /* check length. */
+    klen = ecc_curve->ksize;
+    if (input_priv_key != TD_NULL) {
+        crypto_chk_return(input_priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "input_priv_key->length is Invalid\n");
+    }
+    crypto_chk_return(output_priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "output_priv_key->length is Invalid\n");
+    crypto_chk_return(output_pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "output_pub_key->length is Invalid\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_ecc_gen_key(ecc_curve, input_priv_key, output_priv_key, output_pub_key);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_ecc_gen_ecdh_key(
+    drv_pke_ecc_curve_type curve_type,
+    const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_shared_key)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    const drv_pke_ecc_curve *ecc_curve = get_ecc_curve(curve_type);
+    crypto_chk_return(ecc_curve == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    /* check ptr. */
+    pke_null_ptr_chk(input_pub_key);
+    pke_null_ptr_chk(input_pub_key->x);
+    if (curve_type != DRV_PKE_ECC_TYPE_RFC7748) {
+        pke_null_ptr_chk(input_pub_key->y);
+    }
+    pke_null_ptr_chk(input_priv_key);
+    pke_null_ptr_chk(input_priv_key->data);
+    pke_null_ptr_chk(output_shared_key);
+    pke_null_ptr_chk(output_shared_key->data);
+
+    /* check curve_type. */
+    crypto_chk_return(curve_type == DRV_PKE_ECC_TYPE_RFC8032, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "curve_type is Invalid\n");
+
+    /* check length. */
+    klen = ecc_curve->ksize;
+    crypto_chk_return(input_pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "input_pub_key->length is Invalid\n");
+    crypto_chk_return(input_priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "input_priv_key->length is Invalid\n");
+    crypto_chk_return(output_shared_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "output_shared_key->length is Invalid\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_ecc_gen_ecdh_key(ecc_curve, input_pub_key, input_priv_key, output_shared_key);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_ecdsa_sign(
+    drv_pke_ecc_curve_type curve_type,
+    const drv_pke_data *priv_key,
+    const drv_pke_data *hash,
+    const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    const drv_pke_ecc_curve *ecc_curve = get_ecc_curve(curve_type);
+    crypto_chk_return(ecc_curve == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    /* check ptr. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->data);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(hash->data);
+    pke_null_ptr_chk(sig);
+    pke_null_ptr_chk(sig->r);
+    pke_null_ptr_chk(sig->s);
+
+    /* check curve_type. */
+    crypto_chk_return(curve_type == DRV_PKE_ECC_TYPE_RFC8032 ||curve_type == DRV_PKE_ECC_TYPE_RFC7748,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "curve_type is Invalid\n");
+
+    /* check length. */
+    klen = ecc_curve->ksize;
+    hash_len = hash->length;
+    if ((priv_key->length != klen) ||
+        (hash_len != DRV_PKE_LEN_256 && hash_len != DRV_PKE_LEN_384 && hash_len != DRV_PKE_LEN_512)) {
+        ret = PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        crypto_log_err("priv_key->length or hash_len is Invaild!\n");
+        return ret;
+    }
+    crypto_chk_return(sig->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "sig->length is Invalid\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_ecdsa_sign(ecc_curve, priv_key, hash, sig);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_ecdsa_verify(
+    drv_pke_ecc_curve_type curve_type,
+    const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash,
+    const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    const drv_pke_ecc_curve *ecc_curve = get_ecc_curve(curve_type);
+    crypto_chk_return(ecc_curve == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    /* check ptr. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(hash->data);
+    pke_null_ptr_chk(sig);
+    pke_null_ptr_chk(sig->r);
+    pke_null_ptr_chk(sig->s);
+
+    /* check curve_type. */
+    crypto_chk_return(curve_type == DRV_PKE_ECC_TYPE_RFC8032 ||curve_type == DRV_PKE_ECC_TYPE_RFC7748,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "curve_type is Invalid\n");
+
+    /* check length. */
+    klen = ecc_curve->ksize;
+    hash_len = hash->length;
+    if ((pub_key->length != klen) ||
+        (hash_len != DRV_PKE_LEN_256 && hash_len != DRV_PKE_LEN_384 && hash_len != DRV_PKE_LEN_512)) {
+        ret = PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        crypto_log_err("pub_key->length or hash_len is Invaild!\n");
+        return ret;
+    }
+    crypto_chk_return(sig->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "sig->length is Invalid\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_ecdsa_verify(ecc_curve, pub_key, hash, sig);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_eddsa_sign(
+    drv_pke_ecc_curve_type curve_type,
+    const drv_pke_data *priv_key,
+    const drv_pke_msg *msg,
+    const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    const drv_pke_ecc_curve *ecc_curve = get_ecc_curve(curve_type);
+    crypto_chk_return(ecc_curve == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    /* check ptr. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->data);
+    pke_null_ptr_chk(msg);
+    pke_null_ptr_chk(msg->data);
+    pke_null_ptr_chk(sig);
+    pke_null_ptr_chk(sig->r);
+    pke_null_ptr_chk(sig->s);
+
+    /* check curve_type. */
+    crypto_chk_return(curve_type != DRV_PKE_ECC_TYPE_RFC8032, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "curve_type is Invalid\n");
+
+    /* check length. */
+    klen = ecc_curve->ksize;
+    crypto_chk_return(priv_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "priv_key->length is Invalid\n");
+    crypto_chk_return(sig->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "sig->length is Invalid\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_eddsa_sign(ecc_curve, priv_key, msg, sig);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_eddsa_verify(
+    drv_pke_ecc_curve_type curve_type,
+    const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg,
+    const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    const drv_pke_ecc_curve *ecc_curve = get_ecc_curve(curve_type);
+    crypto_chk_return(ecc_curve == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    /* check ptr. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(msg);
+    pke_null_ptr_chk(msg->data);
+    pke_null_ptr_chk(sig);
+    pke_null_ptr_chk(sig->r);
+    pke_null_ptr_chk(sig->s);
+
+    /* check curve_type. */
+    crypto_chk_return(curve_type != DRV_PKE_ECC_TYPE_RFC8032, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "curve_type is Invalid\n");
+
+    /* check length. */
+    klen = ecc_curve->ksize;
+    crypto_chk_return(pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is Invalid\n");
+    crypto_chk_return(sig->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "sig->length is Invalid\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_eddsa_verify(ecc_curve, pub_key, msg, sig);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_sm2_public_encrypt(
+    const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 plain_text_len = 0;
+    td_u32 cipher_text_len = 0;
+
+    /* check ptr. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(plain_text);
+    pke_null_ptr_chk(plain_text->data);
+    pke_null_ptr_chk(cipher_text);
+    pke_null_ptr_chk(cipher_text->data);
+
+    /* check length. */
+    plain_text_len = plain_text->length;
+    cipher_text_len = cipher_text->length;
+    crypto_chk_return(pub_key->length != DRV_PKE_LEN_256, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is Invalid\n");
+    /* For SM2 Crypto, the cipher_text is 97 longer than plain_text. */
+    crypto_chk_return(cipher_text_len < plain_text_len + SM2_CRYPTO_ADD_LENGTH_IN_BYTE,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "cipher_text_len is not enough\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_sm2_public_encrypt(pub_key, plain_text, cipher_text);
+    if (ret == TD_SUCCESS) {
+        cipher_text->length = plain_text->length + SM2_CRYPTO_ADD_LENGTH_IN_BYTE;
+    }
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_sm2_private_decrypt(
+    const drv_pke_data *priv_key,
+    const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 plain_text_len = 0;
+    td_u32 cipher_text_len = 0;
+
+    /* check ptr. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->data);
+    pke_null_ptr_chk(cipher_text);
+    pke_null_ptr_chk(cipher_text->data);
+    pke_null_ptr_chk(plain_text);
+    pke_null_ptr_chk(plain_text->data);
+
+    /* check length. */
+    plain_text_len = plain_text->length;
+    cipher_text_len = cipher_text->length;
+    crypto_chk_return(priv_key->length != DRV_PKE_LEN_256, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "priv_key->length is Invalid\n");
+    crypto_chk_return(cipher_text_len <= SM2_CRYPTO_ADD_LENGTH_IN_BYTE, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "cipher_text_len is not enough\n");
+    /* For SM2 Crypto, the cipher_text is 97 longer than plain_text. */
+    crypto_chk_return(plain_text_len > CRYPTO_PKE_SM2_PLAIN_TEXT_MAX_SIZE ||
+        plain_text_len + SM2_CRYPTO_ADD_LENGTH_IN_BYTE < cipher_text_len,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "plain_text_len is not enough\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_sm2_private_decrypt(priv_key, cipher_text, plain_text);
+    if (ret == TD_SUCCESS) {
+        plain_text->length = cipher_text_len - SM2_CRYPTO_ADD_LENGTH_IN_BYTE;
+    }
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    const drv_pke_ecc_curve *ecc_curve = get_ecc_curve(curve_type);
+    crypto_chk_return(ecc_curve == TD_NULL, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT), "unsupport alg\n");
+
+    /* check ptr. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(is_on_curve);
+
+    /* check curve_type. */
+    crypto_chk_return(curve_type == DRV_PKE_ECC_TYPE_RFC7748 || curve_type == DRV_PKE_ECC_TYPE_RFC8032,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "curve_type is Invalid\n");
+
+    /* check length. */
+    klen = ecc_curve->ksize;
+    crypto_chk_return(pub_key->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is Invalid\n");
+
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_check_dot_on_curve(ecc_curve, pub_key, is_on_curve);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash)
+{
+    td_s32 ret = TD_FAILURE;
+    sm2_sign_verify_hash_pack hash_param;
+    drv_pke_data hash_data;
+
+    /* check ptr. */
+    pke_null_ptr_chk(sm2_id);
+    pke_null_ptr_chk(sm2_id->data);
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->x);
+    pke_null_ptr_chk(pub_key->y);
+    pke_null_ptr_chk(msg);
+    pke_null_ptr_chk(msg->data);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(hash->data);
+
+    /* check length. */
+    crypto_chk_return(pub_key->length != DRV_PKE_SM2_LEN_IN_BYTES, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "pub_key->length is Invalid\n");
+    crypto_chk_return(hash->length != DRV_PKE_SM2_LEN_IN_BYTES, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "hash_len is Invalid\n");
+    crypto_chk_return(sm2_id->length > PKE_U16_MAX / BYTE_BITS, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "sm2_id_len is Invalid\n");
+
+    hash_param.px = pub_key->x;
+    hash_param.py = pub_key->y;
+    hash_param.id = sm2_id->data;
+    hash_param.id_len = sm2_id->length;
+    hash_data.data = hash->data;
+    hash_data.length = hash->length;
+
+    /* e = Hash */
+    ret = sm2_sign_verify_hash(&hash_param, msg, &hash_data);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "sm2_sign_verify_hash failed, ret is 0x%x\n", ret);
+    return TD_SUCCESS;
+}
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_ecc_curve.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_ecc_curve.c
new file mode 100644
index 0000000..5c9c805
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_ecc_curve.c
@@ -0,0 +1,628 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "crypto_hash_struct.h"
+#include "drv_pke_v4.h"
+#include "crypto_drv_common.h"
+#include "crypto_pke_struct.h"
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP256R
+static const td_u8 ecc_brainpool_256_p[] = {
+    0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+    0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x72,
+    0x6E, 0x3B, 0xF6, 0x23, 0xD5, 0x26, 0x20, 0x28,
+    0x20, 0x13, 0x48, 0x1D, 0x1F, 0x6E, 0x53, 0x77
+};
+static const td_u8 ecc_brainpool_256_a[] = {
+    0x7D, 0x5A, 0x09, 0x75, 0xFC, 0x2C, 0x30, 0x57,
+    0xEE, 0xF6, 0x75, 0x30, 0x41, 0x7A, 0xFF, 0xE7,
+    0xFB, 0x80, 0x55, 0xC1, 0x26, 0xDC, 0x5C, 0x6C,
+    0xE9, 0x4A, 0x4B, 0x44, 0xF3, 0x30, 0xB5, 0xD9
+};
+static const td_u8 ecc_brainpool_256_b[] = {
+    0x26, 0xDC, 0x5C, 0x6C, 0xE9, 0x4A, 0x4B, 0x44,
+    0xF3, 0x30, 0xB5, 0xD9, 0xBB, 0xD7, 0x7C, 0xBF,
+    0x95, 0x84, 0x16, 0x29, 0x5C, 0xF7, 0xE1, 0xCE,
+    0x6B, 0xCC, 0xDC, 0x18, 0xFF, 0x8C, 0x07, 0xB6
+};
+static const td_u8 ecc_brainpool_256_gx[] = {
+    0x8B, 0xD2, 0xAE, 0xB9, 0xCB, 0x7E, 0x57, 0xCB,
+    0x2C, 0x4B, 0x48, 0x2F, 0xFC, 0x81, 0xB7, 0xAF,
+    0xB9, 0xDE, 0x27, 0xE1, 0xE3, 0xBD, 0x23, 0xC2,
+    0x3A, 0x44, 0x53, 0xBD, 0x9A, 0xCE, 0x32, 0x62
+};
+static const td_u8 ecc_brainpool_256_gy[] = {
+    0x54, 0x7E, 0xF8, 0x35, 0xC3, 0xDA, 0xC4, 0xFD,
+    0x97, 0xF8, 0x46, 0x1A, 0x14, 0x61, 0x1D, 0xC9,
+    0xC2, 0x77, 0x45, 0x13, 0x2D, 0xED, 0x8E, 0x54,
+    0x5C, 0x1D, 0x54, 0xC7, 0x2F, 0x04, 0x69, 0x97
+};
+static const td_u8 ecc_brainpool_256_n[] = {
+    0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+    0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x71,
+    0x8C, 0x39, 0x7A, 0xA3, 0xB5, 0x61, 0xA6, 0xF7,
+    0x90, 0x1E, 0x0E, 0x82, 0x97, 0x48, 0x56, 0xA7
+};
+
+static const drv_pke_ecc_curve g_brainpool_p256_curve = {
+    .p = ecc_brainpool_256_p,
+    .a = ecc_brainpool_256_a,
+    .b = ecc_brainpool_256_b,
+    .gx = ecc_brainpool_256_gx,
+    .gy = ecc_brainpool_256_gy,
+    .n = ecc_brainpool_256_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_RFC5639_P256
+};
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP384R
+static const td_u8 ecc_brainpool_384_p[] = {
+    0x8C, 0xB9, 0x1E, 0x82, 0xA3, 0x38, 0x6D, 0x28,
+    0x0F, 0x5D, 0x6F, 0x7E, 0x50, 0xE6, 0x41, 0xDF,
+    0x15, 0x2F, 0x71, 0x09, 0xED, 0x54, 0x56, 0xB4,
+    0x12, 0xB1, 0xDA, 0x19, 0x7F, 0xB7, 0x11, 0x23,
+    0xAC, 0xD3, 0xA7, 0x29, 0x90, 0x1D, 0x1A, 0x71,
+    0x87, 0x47, 0x00, 0x13, 0x31, 0x07, 0xEC, 0x53
+};
+static const td_u8 ecc_brainpool_384_a[] = {
+    0x7B, 0xC3, 0x82, 0xC6, 0x3D, 0x8C, 0x15, 0x0C,
+    0x3C, 0x72, 0x08, 0x0A, 0xCE, 0x05, 0xAF, 0xA0,
+    0xC2, 0xBE, 0xA2, 0x8E, 0x4F, 0xB2, 0x27, 0x87,
+    0x13, 0x91, 0x65, 0xEF, 0xBA, 0x91, 0xF9, 0x0F,
+    0x8A, 0xA5, 0x81, 0x4A, 0x50, 0x3A, 0xD4, 0xEB,
+    0x04, 0xA8, 0xC7, 0xDD, 0x22, 0xCE, 0x28, 0x26
+};
+static const td_u8 ecc_brainpool_384_b[] = {
+    0x04, 0xA8, 0xC7, 0xDD, 0x22, 0xCE, 0x28, 0x26,
+    0x8B, 0x39, 0xB5, 0x54, 0x16, 0xF0, 0x44, 0x7C,
+    0x2F, 0xB7, 0x7D, 0xE1, 0x07, 0xDC, 0xD2, 0xA6,
+    0x2E, 0x88, 0x0E, 0xA5, 0x3E, 0xEB, 0x62, 0xD5,
+    0x7C, 0xB4, 0x39, 0x02, 0x95, 0xDB, 0xC9, 0x94,
+    0x3A, 0xB7, 0x86, 0x96, 0xFA, 0x50, 0x4C, 0x11
+};
+static const td_u8 ecc_brainpool_384_gx[] = {
+    0x1D, 0x1C, 0x64, 0xF0, 0x68, 0xCF, 0x45, 0xFF,
+    0xA2, 0xA6, 0x3A, 0x81, 0xB7, 0xC1, 0x3F, 0x6B,
+    0x88, 0x47, 0xA3, 0xE7, 0x7E, 0xF1, 0x4F, 0xE3,
+    0xDB, 0x7F, 0xCA, 0xFE, 0x0C, 0xBD, 0x10, 0xE8,
+    0xE8, 0x26, 0xE0, 0x34, 0x36, 0xD6, 0x46, 0xAA,
+    0xEF, 0x87, 0xB2, 0xE2, 0x47, 0xD4, 0xAF, 0x1E
+};
+static const td_u8 ecc_brainpool_384_gy[] = {
+    0x8A, 0xBE, 0x1D, 0x75, 0x20, 0xF9, 0xC2, 0xA4,
+    0x5C, 0xB1, 0xEB, 0x8E, 0x95, 0xCF, 0xD5, 0x52,
+    0x62, 0xB7, 0x0B, 0x29, 0xFE, 0xEC, 0x58, 0x64,
+    0xE1, 0x9C, 0x05, 0x4F, 0xF9, 0x91, 0x29, 0x28,
+    0x0E, 0x46, 0x46, 0x21, 0x77, 0x91, 0x81, 0x11,
+    0x42, 0x82, 0x03, 0x41, 0x26, 0x3C, 0x53, 0x15
+};
+static const td_u8 ecc_brainpool_384_n[] = {
+    0x8C, 0xB9, 0x1E, 0x82, 0xA3, 0x38, 0x6D, 0x28,
+    0x0F, 0x5D, 0x6F, 0x7E, 0x50, 0xE6, 0x41, 0xDF,
+    0x15, 0x2F, 0x71, 0x09, 0xED, 0x54, 0x56, 0xB3,
+    0x1F, 0x16, 0x6E, 0x6C, 0xAC, 0x04, 0x25, 0xA7,
+    0xCF, 0x3A, 0xB6, 0xAF, 0x6B, 0x7F, 0xC3, 0x10,
+    0x3B, 0x88, 0x32, 0x02, 0xE9, 0x04, 0x65, 0x65
+};
+
+static const drv_pke_ecc_curve g_brainpool_p384_curve = {
+    .p = ecc_brainpool_384_p,
+    .a = ecc_brainpool_384_a,
+    .b = ecc_brainpool_384_b,
+    .gx = ecc_brainpool_384_gx,
+    .gy = ecc_brainpool_384_gy,
+    .n = ecc_brainpool_384_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_384,
+    .ecc_type = DRV_PKE_ECC_TYPE_RFC5639_P384
+};
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP512R
+static const td_u8 ecc_brainpool_512_p[] = {
+    0xAA, 0xDD, 0x9D, 0xB8, 0xDB, 0xE9, 0xC4, 0x8B,
+    0x3F, 0xD4, 0xE6, 0xAE, 0x33, 0xC9, 0xFC, 0x07,
+    0xCB, 0x30, 0x8D, 0xB3, 0xB3, 0xC9, 0xD2, 0x0E,
+    0xD6, 0x63, 0x9C, 0xCA, 0x70, 0x33, 0x08, 0x71,
+    0x7D, 0x4D, 0x9B, 0x00, 0x9B, 0xC6, 0x68, 0x42,
+    0xAE, 0xCD, 0xA1, 0x2A, 0xE6, 0xA3, 0x80, 0xE6,
+    0x28, 0x81, 0xFF, 0x2F, 0x2D, 0x82, 0xC6, 0x85,
+    0x28, 0xAA, 0x60, 0x56, 0x58, 0x3A, 0x48, 0xF3
+};
+static const td_u8 ecc_brainpool_512_a[] = {
+    0x78, 0x30, 0xA3, 0x31, 0x8B, 0x60, 0x3B, 0x89,
+    0xE2, 0x32, 0x71, 0x45, 0xAC, 0x23, 0x4C, 0xC5,
+    0x94, 0xCB, 0xDD, 0x8D, 0x3D, 0xF9, 0x16, 0x10,
+    0xA8, 0x34, 0x41, 0xCA, 0xEA, 0x98, 0x63, 0xBC,
+    0x2D, 0xED, 0x5D, 0x5A, 0xA8, 0x25, 0x3A, 0xA1,
+    0x0A, 0x2E, 0xF1, 0xC9, 0x8B, 0x9A, 0xC8, 0xB5,
+    0x7F, 0x11, 0x17, 0xA7, 0x2B, 0xF2, 0xC7, 0xB9,
+    0xE7, 0xC1, 0xAC, 0x4D, 0x77, 0xFC, 0x94, 0xCA
+};
+static const td_u8 ecc_brainpool_512_b[] = {
+    0x3D, 0xF9, 0x16, 0x10, 0xA8, 0x34, 0x41, 0xCA,
+    0xEA, 0x98, 0x63, 0xBC, 0x2D, 0xED, 0x5D, 0x5A,
+    0xA8, 0x25, 0x3A, 0xA1, 0x0A, 0x2E, 0xF1, 0xC9,
+    0x8B, 0x9A, 0xC8, 0xB5, 0x7F, 0x11, 0x17, 0xA7,
+    0x2B, 0xF2, 0xC7, 0xB9, 0xE7, 0xC1, 0xAC, 0x4D,
+    0x77, 0xFC, 0x94, 0xCA, 0xDC, 0x08, 0x3E, 0x67,
+    0x98, 0x40, 0x50, 0xB7, 0x5E, 0xBA, 0xE5, 0xDD,
+    0x28, 0x09, 0xBD, 0x63, 0x80, 0x16, 0xF7, 0x23
+};
+static const td_u8 ecc_brainpool_512_gx[] = {
+    0x81, 0xAE, 0xE4, 0xBD, 0xD8, 0x2E, 0xD9, 0x64,
+    0x5A, 0x21, 0x32, 0x2E, 0x9C, 0x4C, 0x6A, 0x93,
+    0x85, 0xED, 0x9F, 0x70, 0xB5, 0xD9, 0x16, 0xC1,
+    0xB4, 0x3B, 0x62, 0xEE, 0xF4, 0xD0, 0x09, 0x8E,
+    0xFF, 0x3B, 0x1F, 0x78, 0xE2, 0xD0, 0xD4, 0x8D,
+    0x50, 0xD1, 0x68, 0x7B, 0x93, 0xB9, 0x7D, 0x5F,
+    0x7C, 0x6D, 0x50, 0x47, 0x40, 0x6A, 0x5E, 0x68,
+    0x8B, 0x35, 0x22, 0x09, 0xBC, 0xB9, 0xF8, 0x22
+};
+static const td_u8 ecc_brainpool_512_gy[] = {
+    0x7D, 0xDE, 0x38, 0x5D, 0x56, 0x63, 0x32, 0xEC,
+    0xC0, 0xEA, 0xBF, 0xA9, 0xCF, 0x78, 0x22, 0xFD,
+    0xF2, 0x09, 0xF7, 0x00, 0x24, 0xA5, 0x7B, 0x1A,
+    0xA0, 0x00, 0xC5, 0x5B, 0x88, 0x1F, 0x81, 0x11,
+    0xB2, 0xDC, 0xDE, 0x49, 0x4A, 0x5F, 0x48, 0x5E,
+    0x5B, 0xCA, 0x4B, 0xD8, 0x8A, 0x27, 0x63, 0xAE,
+    0xD1, 0xCA, 0x2B, 0x2F, 0xA8, 0xF0, 0x54, 0x06,
+    0x78, 0xCD, 0x1E, 0x0F, 0x3A, 0xD8, 0x08, 0x92
+};
+static const td_u8 ecc_brainpool_512_n[] = {
+    0xAA, 0xDD, 0x9D, 0xB8, 0xDB, 0xE9, 0xC4, 0x8B,
+    0x3F, 0xD4, 0xE6, 0xAE, 0x33, 0xC9, 0xFC, 0x07,
+    0xCB, 0x30, 0x8D, 0xB3, 0xB3, 0xC9, 0xD2, 0x0E,
+    0xD6, 0x63, 0x9C, 0xCA, 0x70, 0x33, 0x08, 0x70,
+    0x55, 0x3E, 0x5C, 0x41, 0x4C, 0xA9, 0x26, 0x19,
+    0x41, 0x86, 0x61, 0x19, 0x7F, 0xAC, 0x10, 0x47,
+    0x1D, 0xB1, 0xD3, 0x81, 0x08, 0x5D, 0xDA, 0xDD,
+    0xB5, 0x87, 0x96, 0x82, 0x9C, 0xA9, 0x00, 0x69
+};
+
+static const drv_pke_ecc_curve g_brainpool_p512_curve = {
+    .p = ecc_brainpool_512_p,
+    .a = ecc_brainpool_512_a,
+    .b = ecc_brainpool_512_b,
+    .gx = ecc_brainpool_512_gx,
+    .gy = ecc_brainpool_512_gy,
+    .n = ecc_brainpool_512_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_512,
+    .ecc_type = DRV_PKE_ECC_TYPE_RFC5639_P512
+};
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P256K
+static const td_u8 ecc_fp_256k_p[] = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F
+};
+static const td_u8 ecc_fp_256k_a[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const td_u8 ecc_fp_256k_b[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07
+};
+static const td_u8 ecc_fp_256k_gx[] = {
+    0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC,
+    0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07,
+    0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9,
+    0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98
+};
+static const td_u8 ecc_fp_256k_gy[] = {
+    0x48, 0x3A, 0xDA, 0x77, 0x26, 0xA3, 0xC4, 0x65,
+    0x5D, 0xA4, 0xFB, 0xFC, 0x0E, 0x11, 0x08, 0xA8,
+    0xFD, 0x17, 0xB4, 0x48, 0xA6, 0x85, 0x54, 0x19,
+    0x9C, 0x47, 0xD0, 0x8F, 0xFB, 0x10, 0xD4, 0xB8
+};
+static const td_u8 ecc_fp_256k_n[] = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
+    0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,
+    0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41
+};
+
+static const drv_pke_ecc_curve g_fips_256k_curve = {
+    .p = ecc_fp_256k_p,
+    .a = ecc_fp_256k_a,
+    .b = ecc_fp_256k_b,
+    .gx = ecc_fp_256k_gx,
+    .gy = ecc_fp_256k_gy,
+    .n = ecc_fp_256k_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_FIPS_P256K
+};
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P256R
+static const td_u8 ecc_fp_256r_p[] = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+static const td_u8 ecc_fp_256r_a[] = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC
+};
+static const td_u8 ecc_fp_256r_b[] = {
+    0x5A, 0xC6, 0x35, 0xD8, 0xAA, 0x3A, 0x93, 0xE7,
+    0xB3, 0xEB, 0xBD, 0x55, 0x76, 0x98, 0x86, 0xBC,
+    0x65, 0x1D, 0x06, 0xB0, 0xCC, 0x53, 0xB0, 0xF6,
+    0x3B, 0xCE, 0x3C, 0x3E, 0x27, 0xD2, 0x60, 0x4B
+};
+static const td_u8 ecc_fp_256r_gx[] = {
+    0x6B, 0x17, 0xD1, 0xF2, 0xE1, 0x2C, 0x42, 0x47,
+    0xF8, 0xBC, 0xE6, 0xE5, 0x63, 0xA4, 0x40, 0xF2,
+    0x77, 0x03, 0x7D, 0x81, 0x2D, 0xEB, 0x33, 0xA0,
+    0xF4, 0xA1, 0x39, 0x45, 0xD8, 0x98, 0xC2, 0x96
+};
+static const td_u8 ecc_fp_256r_gy[] = {
+    0x4F, 0xE3, 0x42, 0xE2, 0xFE, 0x1A, 0x7F, 0x9B,
+    0x8E, 0xE7, 0xEB, 0x4A, 0x7C, 0x0F, 0x9E, 0x16,
+    0x2B, 0xCE, 0x33, 0x57, 0x6B, 0x31, 0x5E, 0xCE,
+    0xCB, 0xB6, 0x40, 0x68, 0x37, 0xBF, 0x51, 0xF5
+};
+static const td_u8 ecc_fp_256r_n[] = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xBC, 0xE6, 0xFA, 0xAD, 0xA7, 0x17, 0x9E, 0x84,
+    0xF3, 0xB9, 0xCA, 0xC2, 0xFC, 0x63, 0x25, 0x51
+};
+
+static const drv_pke_ecc_curve g_fips_256r_curve = {
+    .p = ecc_fp_256r_p,
+    .a = ecc_fp_256r_a,
+    .b = ecc_fp_256r_b,
+    .gx = ecc_fp_256r_gx,
+    .gy = ecc_fp_256r_gy,
+    .n = ecc_fp_256r_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_FIPS_P256R
+};
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P384R
+static const td_u8 ecc_fp_384r_p[] = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF
+};
+static const td_u8 ecc_fp_384r_a[] = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFC
+};
+static const td_u8 ecc_fp_384r_b[] = {
+    0xB3, 0x31, 0x2F, 0xA7, 0xE2, 0x3E, 0xE7, 0xE4,
+    0x98, 0x8E, 0x05, 0x6B, 0xE3, 0xF8, 0x2D, 0x19,
+    0x18, 0x1D, 0x9C, 0x6E, 0xFE, 0x81, 0x41, 0x12,
+    0x03, 0x14, 0x08, 0x8F, 0x50, 0x13, 0x87, 0x5A,
+    0xC6, 0x56, 0x39, 0x8D, 0x8A, 0x2E, 0xD1, 0x9D,
+    0x2A, 0x85, 0xC8, 0xED, 0xD3, 0xEC, 0x2A, 0xEF
+};
+static const td_u8 ecc_fp_384r_gx[] = {
+    0xAA, 0x87, 0xCA, 0x22, 0xBE, 0x8B, 0x05, 0x37,
+    0x8E, 0xB1, 0xC7, 0x1E, 0xF3, 0x20, 0xAD, 0x74,
+    0x6E, 0x1D, 0x3B, 0x62, 0x8B, 0xA7, 0x9B, 0x98,
+    0x59, 0xF7, 0x41, 0xE0, 0x82, 0x54, 0x2A, 0x38,
+    0x55, 0x02, 0xF2, 0x5D, 0xBF, 0x55, 0x29, 0x6C,
+    0x3A, 0x54, 0x5E, 0x38, 0x72, 0x76, 0x0A, 0xB7
+};
+static const td_u8 ecc_fp_384r_gy[] = {
+    0x36, 0x17, 0xDE, 0x4A, 0x96, 0x26, 0x2C, 0x6F,
+    0x5D, 0x9E, 0x98, 0xBF, 0x92, 0x92, 0xDC, 0x29,
+    0xF8, 0xF4, 0x1D, 0xBD, 0x28, 0x9A, 0x14, 0x7C,
+    0xE9, 0xDA, 0x31, 0x13, 0xB5, 0xF0, 0xB8, 0xC0,
+    0x0A, 0x60, 0xB1, 0xCE, 0x1D, 0x7E, 0x81, 0x9D,
+    0x7A, 0x43, 0x1D, 0x7C, 0x90, 0xEA, 0x0E, 0x5F
+};
+static const td_u8 ecc_fp_384r_n[] = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xC7, 0x63, 0x4D, 0x81, 0xF4, 0x37, 0x2D, 0xDF,
+    0x58, 0x1A, 0x0D, 0xB2, 0x48, 0xB0, 0xA7, 0x7A,
+    0xEC, 0xEC, 0x19, 0x6A, 0xCC, 0xC5, 0x29, 0x73
+};
+
+static const drv_pke_ecc_curve g_fips_384r_curve = {
+    .p = ecc_fp_384r_p,
+    .a = ecc_fp_384r_a,
+    .b = ecc_fp_384r_b,
+    .gx = ecc_fp_384r_gx,
+    .gy = ecc_fp_384r_gy,
+    .n = ecc_fp_384r_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_384,
+    .ecc_type = DRV_PKE_ECC_TYPE_FIPS_P384R
+};
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P521R
+static const td_u8 ecc_fp_521r_p[] = {
+    0x00, 0x00, 0x01, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+static const td_u8 ecc_fp_521r_a[] = {
+    0x00, 0x00, 0x01, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC
+};
+static const td_u8 ecc_fp_521r_b[] = {
+    0x00, 0x00, 0x00, 0x51,
+    0x95, 0x3E, 0xB9, 0x61, 0x8E, 0x1C, 0x9A, 0x1F,
+    0x92, 0x9A, 0x21, 0xA0, 0xB6, 0x85, 0x40, 0xEE,
+    0xA2, 0xDA, 0x72, 0x5B, 0x99, 0xB3, 0x15, 0xF3,
+    0xB8, 0xB4, 0x89, 0x91, 0x8E, 0xF1, 0x09, 0xE1,
+    0x56, 0x19, 0x39, 0x51, 0xEC, 0x7E, 0x93, 0x7B,
+    0x16, 0x52, 0xC0, 0xBD, 0x3B, 0xB1, 0xBF, 0x07,
+    0x35, 0x73, 0xDF, 0x88, 0x3D, 0x2C, 0x34, 0xF1,
+    0xEF, 0x45, 0x1F, 0xD4, 0x6B, 0x50, 0x3F, 0x00
+};
+static const td_u8 ecc_fp_521r_gx[] = {
+    0x00, 0x00, 0x00, 0xC6,
+    0x85, 0x8E, 0x06, 0xB7, 0x04, 0x04, 0xE9, 0xCD,
+    0x9E, 0x3E, 0xCB, 0x66, 0x23, 0x95, 0xB4, 0x42,
+    0x9C, 0x64, 0x81, 0x39, 0x05, 0x3F, 0xB5, 0x21,
+    0xF8, 0x28, 0xAF, 0x60, 0x6B, 0x4D, 0x3D, 0xBA,
+    0xA1, 0x4B, 0x5E, 0x77, 0xEF, 0xE7, 0x59, 0x28,
+    0xFE, 0x1D, 0xC1, 0x27, 0xA2, 0xFF, 0xA8, 0xDE,
+    0x33, 0x48, 0xB3, 0xC1, 0x85, 0x6A, 0x42, 0x9B,
+    0xF9, 0x7E, 0x7E, 0x31, 0xC2, 0xE5, 0xBD, 0x66
+};
+static const td_u8 ecc_fp_521r_gy[] = {
+    0x00, 0x00, 0x01, 0x18,
+    0x39, 0x29, 0x6A, 0x78, 0x9A, 0x3B, 0xC0, 0x04,
+    0x5C, 0x8A, 0x5F, 0xB4, 0x2C, 0x7D, 0x1B, 0xD9,
+    0x98, 0xF5, 0x44, 0x49, 0x57, 0x9B, 0x44, 0x68,
+    0x17, 0xAF, 0xBD, 0x17, 0x27, 0x3E, 0x66, 0x2C,
+    0x97, 0xEE, 0x72, 0x99, 0x5E, 0xF4, 0x26, 0x40,
+    0xC5, 0x50, 0xB9, 0x01, 0x3F, 0xAD, 0x07, 0x61,
+    0x35, 0x3C, 0x70, 0x86, 0xA2, 0x72, 0xC2, 0x40,
+    0x88, 0xBE, 0x94, 0x76, 0x9F, 0xD1, 0x66, 0x50
+};
+static const td_u8 ecc_fp_521r_n[] = {
+    0x00, 0x00, 0x01, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFA,
+    0x51, 0x86, 0x87, 0x83, 0xBF, 0x2F, 0x96, 0x6B,
+    0x7F, 0xCC, 0x01, 0x48, 0xF7, 0x09, 0xA5, 0xD0,
+    0x3B, 0xB5, 0xC9, 0xB8, 0x89, 0x9C, 0x47, 0xAE,
+    0xBB, 0x6F, 0xB7, 0x1E, 0x91, 0x38, 0x64, 0x09
+};
+
+static const drv_pke_ecc_curve g_fips_521r_curve = {
+    .p = ecc_fp_521r_p,
+    .a = ecc_fp_521r_a,
+    .b = ecc_fp_521r_b,
+    .gx = ecc_fp_521r_gx,
+    .gy = ecc_fp_521r_gy,
+    .n = ecc_fp_521r_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_521,
+    .ecc_type = DRV_PKE_ECC_TYPE_FIPS_P521R
+};
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_CURVE_25519
+static const td_u8 ecc_rfc_7748_p[] = {
+    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xED
+};
+static const td_u8 ecc_rfc_7748_a[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xDB, 0x41
+};
+static const td_u8 ecc_rfc_7748_n[] = {
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x14, 0xDE, 0xF9, 0xDE, 0xA2, 0xF7, 0x9C, 0xD6,
+    0x58, 0x12, 0x63, 0x1A, 0x5C, 0xF5, 0xD3, 0xED
+};
+static const td_u8 ecc_rfc_7748_gx[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09
+};
+
+static const drv_pke_ecc_curve g_rfc7748_curve = {
+    .p = ecc_rfc_7748_p,
+    .a = ecc_rfc_7748_a,
+    .gx = ecc_rfc_7748_gx,
+    .n = ecc_rfc_7748_n,
+    .h = 0x8,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_RFC7748
+};
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_ECC_ED25519
+static const td_u8 ecc_rfc_8032_p[] = {
+    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xED
+};
+
+static const td_u8 ecc_rfc_8032_d[] = {
+    0x52, 0x03, 0x6c, 0xee, 0x2b, 0x6f, 0xfe, 0x73,
+    0x8c, 0xc7, 0x40, 0x79, 0x77, 0x79, 0xe8, 0x98,
+    0x00, 0x70, 0x0a, 0x4d, 0x41, 0x41, 0xd8, 0xab,
+    0x75, 0xeb, 0x4d, 0xca, 0x13, 0x59, 0x78, 0xa3
+};
+
+static const td_u8 ecc_rfc_8032_n[] = {
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x14, 0xDE, 0xF9, 0xDE, 0xA2, 0xF7, 0x9C, 0xD6,
+    0x58, 0x12, 0x63, 0x1A, 0x5C, 0xF5, 0xD3, 0xED
+};
+
+static const td_u8 ecc_rfc_8032_gx[] = {
+    0x21, 0x69, 0x36, 0xd3, 0xcd, 0x6e, 0x53, 0xfe,
+    0xc0, 0xa4, 0xe2, 0x31, 0xfd, 0xd6, 0xdc, 0x5c,
+    0x69, 0x2c, 0xc7, 0x60, 0x95, 0x25, 0xa7, 0xb2,
+    0xc9, 0x56, 0x2d, 0x60, 0x8f, 0x25, 0xd5, 0x1a
+};
+
+static const td_u8 ecc_rfc_8032_gy[] = {
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x58
+};
+
+static const drv_pke_ecc_curve g_rfc8032_curve = {
+    .p = ecc_rfc_8032_p,
+    .a = ecc_rfc_8032_d,
+    .gx = ecc_rfc_8032_gx,
+    .gy = ecc_rfc_8032_gy,
+    .n = ecc_rfc_8032_n,
+    .h = 0x8,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_RFC8032
+};
+#endif
+
+#if defined(CONFIG_PKE_SUPPORT_SM2)
+static const td_u8 ecc_sm2_p[] = {
+    0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+
+static const td_u8 ecc_sm2_a[] = {
+    0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
+};
+
+static const td_u8 ecc_sm2_b[] = {
+    0x28, 0xE9, 0xFA, 0x9E, 0x9D, 0x9F, 0x5E, 0x34,
+    0x4D, 0x5A, 0x9E, 0x4B, 0xCF, 0x65, 0x09, 0xA7,
+    0xF3, 0x97, 0x89, 0xF5, 0x15, 0xAB, 0x8F, 0x92,
+    0xDD, 0xBC, 0xBD, 0x41, 0x4D, 0x94, 0x0E, 0x93,
+};
+
+static const td_u8 ecc_sm2_n[] = {
+    0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0x72, 0x03, 0xDF, 0x6B, 0x21, 0xC6, 0x05, 0x2B,
+    0x53, 0xBB, 0xF4, 0x09, 0x39, 0xD5, 0x41, 0x23,
+};
+
+static const td_u8 ecc_sm2_gx[] = {
+    0x32, 0xC4, 0xAE, 0x2C, 0x1F, 0x19, 0x81, 0x19,
+    0x5F, 0x99, 0x04, 0x46, 0x6A, 0x39, 0xC9, 0x94,
+    0x8F, 0xE3, 0x0B, 0xBF, 0xF2, 0x66, 0x0B, 0xE1,
+    0x71, 0x5A, 0x45, 0x89, 0x33, 0x4C, 0x74, 0xC7,
+};
+
+static const td_u8 ecc_sm2_gy[] = {
+    0xBC, 0x37, 0x36, 0xA2, 0xF4, 0xF6, 0x77, 0x9C,
+    0x59, 0xBD, 0xCE, 0xE3, 0x6B, 0x69, 0x21, 0x53,
+    0xD0, 0xA9, 0x87, 0x7C, 0xC6, 0x2A, 0x47, 0x40,
+    0x02, 0xDF, 0x32, 0xE5, 0x21, 0x39, 0xF0, 0xA0,
+};
+
+static const drv_pke_ecc_curve g_sm2_curve = {
+    .p = ecc_sm2_p,
+    .a = ecc_sm2_a,
+    .b = ecc_sm2_b,
+    .gx = ecc_sm2_gx,
+    .gy = ecc_sm2_gy,
+    .n = ecc_sm2_n,
+    .h = 0x1,
+    .ksize = DRV_PKE_LEN_256,
+    .ecc_type = DRV_PKE_ECC_TYPE_SM2
+};
+#endif
+
+static const drv_pke_ecc_curve * const g_ecc_curve_list[] = {
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP256R
+    &g_brainpool_p256_curve,
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP384R
+    &g_brainpool_p384_curve,
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_BP512R
+    &g_brainpool_p512_curve,
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P256K
+    &g_fips_256k_curve,
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P256R
+    &g_fips_256r_curve,
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P384R
+    &g_fips_384r_curve,
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_FIPS_P521R
+    &g_fips_521r_curve,
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_CURVE_25519
+    &g_rfc7748_curve,
+#endif
+#ifdef CONFIG_PKE_SUPPORT_ECC_ED25519
+    &g_rfc8032_curve,
+#endif
+#if defined(CONFIG_PKE_SUPPORT_SM2)
+    &g_sm2_curve,
+#endif
+};
+
+const drv_pke_ecc_curve *get_ecc_curve(drv_pke_ecc_curve_type curve_type)
+{
+    td_u32 i;
+    for (i = 0; i < crypto_array_size(g_ecc_curve_list); i++) {
+        if (curve_type == g_ecc_curve_list[i]->ecc_type) {
+            return g_ecc_curve_list[i];
+        }
+    }
+    return TD_NULL;
+}
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_inner_v4.h b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_inner_v4.h
new file mode 100644
index 0000000..64c796a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_inner_v4.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef DRV_INNER_H
+#define DRV_INNER_H
+
+#include "crypto_hash_struct.h"
+#include "crypto_kdf_struct.h"
+#include "crypto_symc_struct.h"
+#include "crypto_pke_struct.h"
+
+typedef struct {
+    td_u8 mac[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 mac_length;
+    td_u8 tail[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 tail_length;
+} crypto_symc_mac_ctx;
+
+typedef struct {
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    td_u32 chn_num;
+    td_phys_addr_t aad_phys;
+    td_u8 *aad_virt;
+    td_u32 aad_len;
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    td_u32 last_pattern_len;
+    union {
+        crypto_symc_config_aes_ccm_gcm ccm_config;
+    } param;
+    /*
+     * For CBC_MAC, store data copy;
+     * For CCM, store N + ccm_header + ccm_padding
+     * For GCM, store aad_padding + clen
+     */
+    td_u8 *dma_addr;
+    td_u32 dma_size;
+    td_u32 data_len;        /* For CCM/GCM. */
+    td_u32 processed_len;   /* For CCM/GCM. */
+    td_u8 tail[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u32 tail_length;
+    td_bool is_create_keyslot;
+    td_handle keyslot_handle;
+    td_bool is_open;
+    td_bool is_config;
+    td_bool is_attached;
+    td_u32 iv_change_flag;
+#if defined(CRYPTO_CTR_NON_ALIGN_SUPPORT)
+    td_u32 ctr_offset;
+    td_u32 ctr_used;
+    td_u8 ctr_last_block[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+#endif
+} drv_symc_context_t;
+
+
+td_s32 drv_cipher_pke_clean_ram(void);
+
+td_s32 drv_cipher_pke_add_mod(const drv_pke_data *a, const drv_pke_data *b,
+    const drv_pke_data *p, const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_sub_mod(const drv_pke_data *a, const drv_pke_data *b,
+    const drv_pke_data *p, const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_mul_dot(const drv_pke_ecc_curve *ecc, const drv_pke_data *k, const drv_pke_ecc_point *p,
+    const drv_pke_ecc_point *r);
+
+td_s32 drv_cipher_pke_mul_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data  *p,
+    const drv_pke_data  *c);
+
+td_s32 drv_cipher_pke_inv_mod(const drv_pke_data *a, const drv_pke_data *p, drv_pke_data *c);
+
+td_s32 drv_cipher_pke_add_dot(const drv_pke_ecc_curve *ecc, const drv_pke_ecc_point *s, const drv_pke_ecc_point *r,
+    const drv_pke_ecc_point *c);
+
+td_s32 drv_cipher_pke_mg_mul_dot(const drv_pke_data *k, const drv_pke_data *U, const drv_pke_data *p,
+    const drv_pke_data *a24, const drv_pke_data *rx);
+
+td_s32 drv_cipher_pke_ed_mul_dot(const drv_pke_data *k, const drv_pke_ecc_point *U, const drv_pke_data *p,
+    const drv_pke_ecc_point *r);
+
+td_s32 drv_cipher_pke_ed_add_dot(const drv_pke_ecc_curve *ecc, const drv_pke_ecc_point *s,
+    const drv_pke_ecc_point *r, const drv_pke_ecc_point *c);
+
+td_s32 drv_cipher_pke_calc_hash(const drv_pke_data* arr, td_u32 arr_len, const drv_pke_hash_type hash_type,
+    drv_pke_data *hash);
+
+drv_symc_context_t *inner_get_symc_ctx(td_handle symc_handle);
+
+td_s32 inner_hash_drv_handle_chk(td_handle hash_handle);
+
+td_s32 inner_hash_start_param_chk(td_handle *drv_hash_handle, const crypto_hash_attr *hash_attr);
+
+td_s32 inner_drv_symc_crypto_chk(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 inner_symc_drv_handle_chk(td_handle symc_handle);
+
+td_s32 inner_drv_get_mac_ctx(td_handle symc_handle, crypto_symc_mac_ctx *mac_ctx);
+
+td_s32 inner_drv_set_mac_ctx(td_handle symc_handle, const crypto_symc_mac_ctx *mac_ctx);
+
+td_s32 inner_symc_cfg_param_check(const crypto_symc_ctrl_t *symc_ctrl);
+
+typedef struct {
+    td_u8 *iv0;
+    td_u32 iv0_length;
+    td_u8 *iv_mac;
+    td_u32 iv_mac_length;
+    td_u32 data_length;
+    td_u32 processed_length;
+    td_u32 aad_len;
+} drv_symc_ex_context_t;
+
+td_s32 inner_drv_symc_get_iv0(td_handle symc_handle, td_u8 *iv0, td_u32 iv0_length);
+
+td_s32 inner_drv_symc_get_iv_mac(td_handle symc_handle, td_u8 *iv_mac, td_u32 iv_mac_length);
+
+td_s32 inner_drv_symc_ex_restore(td_handle symc_handle, const drv_symc_ex_context_t *symc_ex_ctx);
+
+td_s32 inner_drv_symc_set_ctr_block(td_handle symc_handle, const td_u8 *block, td_u32 block_size, td_u32 ctr_offset);
+
+td_s32 inner_drv_symc_get_ctr_block(td_handle symc_handle, td_u8 *block, td_u32 block_size, td_u32 *ctr_offset);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_rsa.c b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_rsa.c
new file mode 100644
index 0000000..ad0a45a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_rsa.c
@@ -0,0 +1,1202 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "hal_pke_v4.h"
+#include "drv_pke_v4.h"
+#include "drv_pke_inner_v4.h"
+#include "crypto_hash_struct.h"
+#include "securec.h"
+#include "drv_hash.h"
+#include "drv_trng.h"
+#include "crypto_drv_common.h"
+
+#define RANDOM_TRY_TIME                 100
+#define RSA_GEN_KEY_WAIT_TIMES          10
+#define RSA_GEN_KEY_TRY_TIMES           10
+#define BYTE_MAX                        0xFF
+#define PKE_COMPAT_ERRNO(err_code)      DISPATCH_COMPAT_ERRNO(ERROR_MODULE_PKE, err_code)
+
+// hash ASN.1
+static const td_u8 g_asn1_sha1[] = {
+    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e,
+    0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14,
+};
+
+static const td_u8 g_asn1_sha256[] = {
+    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
+    0x00, 0x04, 0x20,
+};
+
+static const td_u8 g_asn1_sha384[] = {
+    0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05,
+    0x00, 0x04, 0x30,
+};
+
+static const td_u8 g_asn1_sha512[] = {
+    0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
+    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
+    0x00, 0x04, 0x40,
+};
+
+static const td_u8 g_empty_l_sha1[] = {
+    0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d,
+    0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90,
+    0xaf, 0xd8, 0x07, 0x09,
+};
+
+static const td_u8 g_empty_l_sha256[] = {
+    0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,
+    0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,
+    0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,
+    0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55,
+};
+
+static const td_u8 g_empty_l_sha384[] = {
+    0x38, 0xb0, 0x60, 0xa7, 0x51, 0xac, 0x96, 0x38,
+    0x4c, 0xd9, 0x32, 0x7e, 0xb1, 0xb1, 0xe3, 0x6a,
+    0x21, 0xfd, 0xb7, 0x11, 0x14, 0xbe, 0x07, 0x43,
+    0x4c, 0x0c, 0xc7, 0xbf, 0x63, 0xf6, 0xe1, 0xda,
+    0x27, 0x4e, 0xde, 0xbf, 0xe7, 0x6f, 0x65, 0xfb,
+    0xd5, 0x1a, 0xd2, 0xf1, 0x48, 0x98, 0xb9, 0x5b,
+};
+
+static const td_u8 g_empty_l_sha512[] = {
+    0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd,
+    0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07,
+    0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc,
+    0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce,
+    0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0,
+    0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f,
+    0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81,
+    0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e,
+};
+
+static const td_s8 g_bits[] = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4};
+
+static td_u8 g_l_hash[HASH_SIZE_SHA_512] = {0x0};
+
+static const pke_hash_properties_type g_pke_hash_properties[] = {
+    {DRV_PKE_HASH_TYPE_SHA1, SHA1_BLOCK_LENGTH, SHA1_RESULT_LENGTH},
+    {DRV_PKE_HASH_TYPE_SHA224, SHA224_BLOCK_LENGTH, SHA224_RESULT_LENGTH},
+    {DRV_PKE_HASH_TYPE_SHA256, SHA256_BLOCK_LENGTH, SHA256_RESULT_LENGTH},
+    {DRV_PKE_HASH_TYPE_SHA384, SHA384_BLOCK_LENGTH, SHA384_RESULT_LENGTH},
+    {DRV_PKE_HASH_TYPE_SHA512, SHA512_BLOCK_LENGTH, SHA512_RESULT_LENGTH},
+    {DRV_PKE_HASH_TYPE_SM3, SM3_BLOCK_LENGTH, SM3_RESULT_LENGTH}
+};
+
+static td_s32 drv_get_hash_len(const drv_pke_hash_type hash_type)
+{
+    td_u32 i = 0;
+
+    for (i = 0; i < sizeof(g_pke_hash_properties) / sizeof(pke_hash_properties_type); i++) {
+        if (g_pke_hash_properties[i].hash_type == hash_type) {
+            return g_pke_hash_properties[i].result_len;
+        }
+    }
+    return 0;
+}
+
+static td_s32 rsa_exp_mod(const td_u8 *n, const td_u8 *k, const td_u32 klen,
+    const drv_pke_data *in, const drv_pke_data *out)
+{
+    td_s32 ret = TD_FAILURE;
+    drv_pke_data n_data = {klen, (td_u8 *)n};
+    drv_pke_data k_data = {klen, (td_u8 *)k};
+
+    ret = drv_cipher_pke_exp_mod(&n_data, &k_data, in, out);
+    crypto_chk_goto(ret != TD_SUCCESS, exit__, "drv_cipher_pke_exp_mod failed, ret is 0x%x\n", ret);
+exit__:
+    (void)drv_cipher_pke_clean_ram();
+    return ret;
+}
+
+static td_s32 get_random(td_u8 *rand, const td_u32 size)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 k = 0;
+    td_u32 i = 0;
+    td_u32 randnum = 0;
+
+    ret = drv_cipher_trng_get_multi_random(size, rand);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_multi_random failed, ret is 0x%x\n", ret);
+
+    k = 0;
+    while (k < size) { // It's almost impossible to randomize 100 times and not get a non-zero value.
+        if (rand[k] != 0x00) {
+            i = 0;
+            k++;
+            continue;
+        }
+        crypto_chk_return(i == RANDOM_TRY_TIME, PKE_COMPAT_ERRNO(ERROR_TRY_TIMES),
+            "drv_cipher_trng_get_random failed!\n");
+        i++;
+        ret = drv_cipher_trng_get_random(&randnum);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_trng_get_random failed, ret is 0x%x\n", ret);
+        rand[k] = (td_u8)(randnum & BYTE_MAX);
+    }
+    return ret;
+}
+
+static td_u32 rsa_get_bit_num(const td_u8 *big_num, td_u32 num_len)
+{
+    td_u32 i = 0;
+    td_s8 num = 0;
+
+    for (i = 0; i < num_len; i++) {
+        if (big_num[i] == 0x00) {
+            continue;
+        }
+        num = g_bits[(big_num[i] & (MAX_LOW_8BITS - MAX_LOW_4BITS)) >> SHIFT_4BITS];
+        if (num > 0) {
+            return (num_len - i - BOUND_VALUE_1) * BYTE_BITS + num + DRV_WORD_WIDTH;
+        }
+
+        num = g_bits[big_num[i] & MAX_LOW_4BITS];
+        if (num > 0) {
+            return (num_len - i - BOUND_VALUE_1) * BYTE_BITS + num;
+        }
+    }
+    return 0;
+}
+
+static td_s32 pkcs1_mgf(const rsa_pkcs1_hash_info *hash_info, const td_u8 *seed, const td_u32 seed_len,
+    td_u8 *mask, const td_u32 mask_len)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    td_u32 j = 0;
+    td_u32 out_len = 0;
+    td_u8 cnt[DRV_WORD_WIDTH];
+    td_u8 md[HASH_SIZE_SHA_MAX];
+    drv_pke_data hash = {0};
+    td_u8 seed_buf[DRV_PKE_LEN_4096];
+    drv_pke_data arr[2];
+
+    (void)memset_s(cnt, DRV_WORD_WIDTH, 0x00, DRV_WORD_WIDTH);
+    (void)memset_s(md, HASH_SIZE_SHA_MAX, 0x00, HASH_SIZE_SHA_MAX);
+    ret = memcpy_s(seed_buf, DRV_PKE_LEN_4096, seed, seed_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    hash.length = HASH_SIZE_SHA_MAX;
+    hash.data = md;
+
+    arr[0].data = seed_buf;
+    arr[0].length = seed_len;
+    arr[1].data = cnt;
+    arr[1].length = (uintptr_t)sizeof(cnt);
+
+    for (i = 0; out_len < mask_len; i++) {
+        cnt[WORD_INDEX_0] = (td_u8)((i >> SHIFT_24BITS) & MAX_LOW_8BITS);
+        cnt[WORD_INDEX_1] = (td_u8)((i >> SHIFT_16BITS) & MAX_LOW_8BITS);
+        cnt[WORD_INDEX_2] = (td_u8)((i >> SHIFT_8BITS)) & MAX_LOW_8BITS;
+        cnt[WORD_INDEX_3] = (td_u8)(i & MAX_LOW_8BITS);
+
+        /* H = Hash(seedbuf || cnt) */
+        ret = drv_cipher_pke_calc_hash(arr, sizeof(arr) / sizeof(arr[0]), hash_info->hash_type, &hash);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_calc_hash failed, ret is 0x%x\n", ret);
+
+        for (j = 0; (j < hash_info->hash_len) && (out_len < mask_len); j++) {
+            mask[out_len++] ^= md[j];
+        }
+    }
+    return ret;
+}
+
+static td_s32 pkcs1_get_hash(const drv_pke_hash_type hash_type, const drv_pke_data *label,
+    rsa_pkcs1_hash_info *hash_info)
+{
+    td_s32 ret = TD_FAILURE;
+    drv_pke_data h_hash = {0};
+    switch (hash_type) {
+        case DRV_PKE_HASH_TYPE_SHA1:
+            hash_info->hash_type = DRV_PKE_HASH_TYPE_SHA1;
+            hash_info->hash_len = HASH_SIZE_SHA_1;
+            hash_info->asn1_data = (td_u8 *)g_asn1_sha1;
+            hash_info->asn1_len = sizeof(g_asn1_sha1);
+            hash_info->lhash_data = (td_u8 *)g_empty_l_sha1;
+            break;
+        case DRV_PKE_HASH_TYPE_SHA256:
+            hash_info->hash_type = DRV_PKE_HASH_TYPE_SHA256;
+            hash_info->hash_len = HASH_SIZE_SHA_256;
+            hash_info->asn1_data = (td_u8 *)g_asn1_sha256;
+            hash_info->asn1_len = sizeof(g_asn1_sha256);
+            hash_info->lhash_data = (td_u8 *)g_empty_l_sha256;
+            break;
+        case DRV_PKE_HASH_TYPE_SHA384:
+            hash_info->hash_type = DRV_PKE_HASH_TYPE_SHA384;
+            hash_info->hash_len = HASH_SIZE_SHA_384;
+            hash_info->asn1_data = (td_u8 *)g_asn1_sha384;
+            hash_info->asn1_len = sizeof(g_asn1_sha384);
+            hash_info->lhash_data = (td_u8 *)g_empty_l_sha384;
+            break;
+        case DRV_PKE_HASH_TYPE_SHA512:
+            hash_info->hash_type = DRV_PKE_HASH_TYPE_SHA512;
+            hash_info->hash_len = HASH_SIZE_SHA_512;
+            hash_info->asn1_data = (td_u8 *)g_asn1_sha512;
+            hash_info->asn1_len = sizeof(g_asn1_sha512);
+            hash_info->lhash_data = (td_u8 *)g_empty_l_sha512;
+            break;
+        default:
+            crypto_log_err("unsupport hash type\n");
+            return PKE_COMPAT_ERRNO(ERROR_UNSUPPORT);
+    }
+
+    if (label != TD_NULL && label->data != TD_NULL && label->length != 0) {
+        hash_info->lhash_data = g_l_hash;
+        h_hash.data = hash_info->lhash_data;
+        h_hash.length = hash_info->hash_len;
+
+        ret = drv_cipher_pke_calc_hash(label, 1, hash_info->hash_type, &h_hash);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_calc_hash failed, ret is 0x%x\n", ret);
+    }
+
+    return TD_SUCCESS;
+}
+
+/* H = Hash( M' ) = Hash( Padding1 || mHash || salt ) */
+static td_s32 pkcs1_pss_hash(const rsa_pkcs1_hash_info *hash_info, const td_u8 *m_hash, td_u32 klen,
+    const drv_pke_data *salt, drv_pke_data *hash)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 ps[RSA_PADLEN_8] = {0};
+    drv_pke_data arr[3]; // The capacity of the array is 3.
+
+    /* H = Hash(PS || MHash || SALT) */
+    arr[0].data = ps; // 0 th element is ps
+    arr[0].length = RSA_PADLEN_8; // 0 element is PS
+    arr[1].data = (td_u8 *)m_hash; // 1 element is MHash
+    arr[1].length = klen; // 1 element is MHash
+    arr[2].data = (td_u8 *)salt->data; // 2 element is SALT
+    arr[2].length = salt->length; // 2 element is SALT
+    ret = drv_cipher_pke_calc_hash(arr, sizeof(arr) / sizeof(arr[0]), hash_info->hash_type, hash);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_calc_hash failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+/* EM = 00 || 01 || PS || 00 || T */
+static td_s32 pkcs1_v15_sign(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 *p = TD_NULL;
+    td_u32 idx = 0;
+
+    ret = pkcs1_get_hash(hash_type, TD_NULL, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    p = pack->em;
+    p[idx++] = 0x00;
+    p[idx++] = 0x01;
+
+    /* PS */
+    while (idx < (pack->em_len - hash_info.hash_len - hash_info.asn1_len - 1)) {
+        p[idx++] = BYTE_MAX;
+    }
+
+    p[idx++] = 0x00;
+
+    /* T */
+    ret = memcpy_s(&p[idx], pack->em_len - idx, hash_info.asn1_data, hash_info.asn1_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    idx += hash_info.asn1_len;
+    ret = memcpy_s(&p[idx], pack->em_len - idx, pack->hash, hash_info.hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+
+/* check EM = 00 || 01 || PS || 00 || T */
+static td_s32 pkcs1_v15_verify(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 *p = TD_NULL;
+    td_u32 idx = 0;
+
+    ret = pkcs1_get_hash(hash_type, TD_NULL, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    p = pack->em;
+    if (p[idx++] != 0x00) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+    if (p[idx++] != 0x01) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+
+    /* PS */
+    while (idx < (pack->em_len - hash_info.hash_len - hash_info.asn1_len - 1)) {
+        if (p[idx++] != BYTE_MAX) {
+            return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+        }
+    }
+    if (p[idx++] != 0x00) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+
+    /* T */
+    if (memcmp(&p[idx], hash_info.asn1_data, hash_info.asn1_len) != 0) {
+        crypto_log_err("check v15 asn1 failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+
+    idx += hash_info.asn1_len;
+    if (memcmp(&p[idx], pack->hash, hash_info.hash_len) != 0) {
+        crypto_log_err("check v15 hash failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_V15_CHECK);
+    }
+
+    return ret;
+}
+#endif
+
+static td_s32 pkcs1_pss_sign(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 salt_data[HASH_SIZE_SHA_MAX];
+    td_u32 salt_len = 0;
+    td_u32 tmp_len = 0;
+    td_u32 ms_bits = 0;
+    td_u8 *masked_db = TD_NULL;
+    td_u32 masked_db_len = pack->em_len - pack->hash_len - 1; /* 1 byte for bound. */
+    drv_pke_data masked_seed;
+    drv_pke_data salt = {0};
+
+    ret = pkcs1_get_hash(hash_type, TD_NULL, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    salt_len = hash_info.hash_len;
+
+    /* em_bit is the number of bits of key n. */
+    ms_bits = (pack->em_bit - BOUND_VALUE_1) & MAX_LOW_3BITS;
+
+    ret = get_random((td_u8 *)salt_data, salt_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get_random failed, ret is 0x%x\n", ret);
+
+    /* EM = masked_db || masked_seed || 0xbc */
+    masked_db = pack->em;
+    masked_seed.data = pack->em + masked_db_len;
+    masked_seed.length = pack->hash_len;
+
+    salt.data = salt_data;
+    salt.length = salt_len;
+    ret = pkcs1_pss_hash(&hash_info, pack->hash, pack->hash_len, &salt, &masked_seed);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_pss_hash failed, ret is 0x%x\n", ret);
+
+    /* DB = PS || 0x01 || salt */
+    /* set PS, here tmp_len means the length of PS */
+    tmp_len = pack->em_len - pack->hash_len - salt_len - RSA_PADLEN_2; /* padding2.length - 1 */
+    (void)memset_s(masked_db, tmp_len, 0x00, tmp_len);
+
+    /* set 0x01 after PS */
+    masked_db[tmp_len++] = 0x01;
+
+    /* set salt */
+    ret = memcpy_s(masked_db + tmp_len, pack->em_len - tmp_len, salt_data, salt_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    ret = pkcs1_mgf(&hash_info, masked_seed.data, pack->hash_len, masked_db, masked_db_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    pack->em[0] &= MAX_LOW_8BITS >> (BYTE_BITS - ms_bits);
+    pack->em[pack->em_len - 1] = RSA_PAD_XBC; /* 1 byte for bound. */
+    return ret;
+}
+
+static td_s32 pkcs1_pss_verify(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 em[DRV_PKE_LEN_4096];
+    td_u8 hash[HASH_SIZE_SHA_MAX];
+    td_u32 salt_len = 0;
+    td_u32 ms_bits = 0;
+    td_u8 *masked_db = TD_NULL;
+    td_u32 masked_db_len = pack->em_len - pack->hash_len - 1; /* 1 byte for bound. */
+    td_u8 *masked_seed = TD_NULL;
+    drv_pke_data hash_data = { .data = hash, .length = sizeof(hash) };
+    drv_pke_data salt = {0};
+
+    ret = pkcs1_get_hash(hash_type, TD_NULL, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    if (pack->em[pack->em_len - 1] != RSA_PAD_XBC) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_PSS_CHECK);
+    }
+
+    ms_bits = (pack->em_bit - BOUND_VALUE_1) & MAX_LOW_3BITS;
+    if ((pack->em[0] & (MAX_LOW_8BITS << ms_bits))) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_PSS_CHECK);
+    }
+
+    ret = memcpy_s(em, DRV_PKE_LEN_4096, pack->em, pack->em_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+
+    masked_db = em;
+    masked_seed = em + masked_db_len;
+    ret = pkcs1_mgf(&hash_info, masked_seed, pack->hash_len, masked_db, masked_db_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    em[0] &= MAX_LOW_8BITS >> (BYTE_BITS - ms_bits);
+
+    while (masked_db < masked_seed - 1 && *masked_db == 0) {
+        masked_db++;
+    }
+
+    if (*masked_db++ != 0x01) {
+        crypto_log_err("pss padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_PSS_CHECK);
+    }
+
+    salt_len = masked_seed - masked_db;
+    salt.length = salt_len;
+    salt.data = masked_db;
+
+    ret = pkcs1_pss_hash(&hash_info, pack->hash, pack->hash_len, &salt, &hash_data);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_pss_hash failed, ret is 0x%x\n", ret);
+
+    if (memcmp(masked_seed, hash, hash_info.hash_len) != 0) {
+        crypto_log_err("pss hash check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_VERIFY_PSS_CHECK);
+    }
+
+    return ret;
+}
+
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+/* EM = 00 || 02 || PS || 00 || M */
+static td_s32 pkcs1_v15_encrypt(const rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *p = TD_NULL;
+    td_u32 idx = 0;
+    td_u32 ps_len = pack->em_len - pack->data_len - RSA_PADLEN_3;
+
+    p = pack->em;
+    p[idx++] = 0x00;
+    p[idx++] = 0x02; // 0x02 see comment above func
+
+    /* PS */
+    ret = get_random(&p[idx], ps_len);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("get random ps failed!\n");
+        return ret;
+    }
+    idx += ps_len;
+
+    p[idx++] = 0x00;
+    /* M */
+    if (pack->data_len != 0) {
+        ret = memcpy_s(&p[idx], pack->em_len - idx, pack->data, pack->data_len);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+
+    return ret;
+}
+
+/* check EM = 00 || 02 || PS || 00 || M */
+static td_s32 pkcs1_v15_decrypt(rsa_pkcs1_pack *pack)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *p = TD_NULL;
+    td_u32 idx = 0;
+    td_u32 len = 0;
+
+    p = pack->em;
+    if (p[idx++] != 0x00) {
+        crypto_log_err("padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_V15_CHECK);
+    }
+
+    if (p[idx++] != 0x02) { // 0x02 see comment above func
+        crypto_log_err("padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_V15_CHECK);
+    }
+
+    /* PS */
+    while ((idx < (pack->em_len - RSA_PADLEN_1)) && p[idx] != 0x00) {
+        idx++;
+    }
+
+    if (p[idx++] != 0x00) {
+        crypto_log_err("padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_V15_CHECK);
+    }
+
+    len = pack->em_len - idx;
+    if (len > pack->em_len - RSA_PADLEN_11) {
+        crypto_log_err("padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_V15_CHECK);
+    }
+
+    /* M */
+    if (len != 0) {
+        ret = memcpy_s(pack->data, pack->data_len, &p[idx], len);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+    pack->data_len = len; // record length of plain text for return
+
+    return TD_SUCCESS;
+}
+#endif
+
+static td_s32 pkcs1_oaep_encrypt(const drv_pke_hash_type hash_type, const rsa_pkcs1_pack *pack,
+    const drv_pke_data *label)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u8 *p = TD_NULL;
+    td_u8 *db = TD_NULL;
+    td_u8 *seed = TD_NULL;
+    td_u32 idx = 0;
+    td_u32 hash_len = 0;
+    td_u32 tmp_len = 0;
+
+    ret = pkcs1_get_hash(hash_type, label, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+    hash_len = hash_info.hash_len;
+
+    p = pack->em;
+    seed = p + 1;
+    db = p + hash_len + 1;
+
+    /* 1. set data[0] = 0 */
+    p[idx++] = 0x00;
+
+    /* 2. set data[1, hash_len + 1] = random */
+    ret = get_random(&p[idx], hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get_random failed, ret is 0x%x\n", ret);
+    idx += hash_len;
+
+    /* 3. set data[hash_len + 1, 2hash_len + 1] = lHash */
+    ret = memcpy_s(p + idx, pack->em_len - idx, hash_info.lhash_data, hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    idx += hash_len;
+
+    /* 4. set PS with 0x00 */
+    tmp_len = pack->klen - pack->data_len - 2 * hash_len - 2; /* 2 */
+    (void)memset_s(p + idx, tmp_len, 0x00, tmp_len);
+    idx += tmp_len;
+
+    /* 5. set 0x01 after PS */
+    p[idx++] = 0x01;
+
+    /* 6. set M */
+    if (pack->data_len != 0) {
+        ret = memcpy_s(p + idx, pack->em_len - idx, pack->data, pack->data_len);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+    /* 7. MGF: seed -> db */
+    tmp_len = pack->klen - hash_len - 1;
+    ret = pkcs1_mgf(&hash_info, seed, hash_len, db, tmp_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    /* 8. MGF: db -> seed */
+    ret = pkcs1_mgf(&hash_info, db, tmp_len, seed, hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+
+static td_s32 pkcs1_oaep_decrypt(const drv_pke_hash_type hash_type, rsa_pkcs1_pack *pack,
+    const drv_pke_data *label)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_hash_info hash_info = {0};
+    td_u32 idx = 0;
+    td_u32 hash_len = 0;
+    td_u32 tmp_len = 0;
+    td_u8 *p = TD_NULL;
+    td_u8 *db = TD_NULL;
+    td_u8 *seed = TD_NULL;
+
+    ret = pkcs1_get_hash(hash_type, label, &hash_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_get_hash failed, ret is 0x%x\n", ret);
+
+    hash_len = hash_info.hash_len;
+
+    p = pack->em;
+    seed = p + 1;
+    db = p + hash_len + 1;
+
+    /* 1. check data[0] = 0 */
+    if (p[idx++] != 0x00) {
+        crypto_log_err("oaep padding check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    /* 2. MGF: db -> seed */
+    tmp_len = pack->klen - hash_len - 1;
+    ret = pkcs1_mgf(&hash_info, db, tmp_len, seed, hash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    /* 3. MGF: seed -> db */
+    ret = pkcs1_mgf(&hash_info, seed, hash_len, db, tmp_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_mgf failed, ret is 0x%x\n", ret);
+
+    /* 4. check data[hash + 1, 2hash + 1] */
+    idx += hash_len;
+    if (memcmp(p + idx, hash_info.lhash_data, hash_len) != 0) {
+        crypto_log_err("oaep lhash check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    /* 5. remove PS */
+    idx += hash_len;
+    for (; idx < pack->klen - 1; idx++) {
+        if (p[idx] != 0x00) {
+            break;
+        }
+    }
+
+    /* 6. check 0x01 */
+    if (p[idx++] != 0x01) {
+        crypto_log_err("oaep check failed!\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    /* 7. check data length */
+    tmp_len = pack->klen - idx;
+    if (tmp_len > pack->klen - 2 * hash_len - 2) { /* 2 */
+        crypto_log_err("PS error.\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    if (tmp_len > pack->data_len) {
+        crypto_log_err("Input buffer too small.\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_CRYPTO_OAEP_CHECK);
+    }
+
+    if (tmp_len != 0) {
+        ret = memcpy_s(pack->data, pack->data_len, p + idx, tmp_len);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+    pack->data_len = tmp_len; // record length of plain text for return
+
+    return ret;
+}
+
+static td_s32 rsa_sign(
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    td_u8 *em,
+    td_u32 klen,
+    td_u32 em_bit,
+    const drv_pke_data *msg)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_pack sg_pack = {
+        .klen = klen,
+        .em_bit = em_bit,
+        .em = em,
+        .em_len = klen,
+        .hash = msg->data,
+        .hash_len = msg->length,
+        .data = TD_NULL,
+        .data_len = 0
+    };
+
+    switch (scheme) {
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V15: {
+            ret = pkcs1_v15_sign(hash_type, &sg_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_v15_sign failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+        case DRV_PKE_RSA_SCHEME_PKCS1_V21: {
+            ret = pkcs1_pss_sign(hash_type, &sg_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_pss_sign failed, ret is 0x%x\n", ret);
+            break;
+        }
+        default:
+            crypto_log_err("Invalid rsa sign padding type.\n");
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return ret;
+}
+
+static td_s32 rsa_verify(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    td_u8 *em,
+    const td_u32 klen,
+    const td_u32 em_bit,
+    const drv_pke_data *msg)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_pack vf_pack = {
+        .klen = klen,
+        .em_bit = em_bit,
+        .em = em,
+        .em_len = klen,
+        .hash = msg->data,
+        .hash_len = msg->length,
+        .data = TD_NULL,
+        .data_len = 0
+    };
+
+    switch (scheme) {
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V15: {
+            ret = pkcs1_v15_verify(hash_type, &vf_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_v15_verify failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+        case DRV_PKE_RSA_SCHEME_PKCS1_V21: {
+            ret = pkcs1_pss_verify(hash_type, &vf_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_pss_verify failed, ret is 0x%x\n", ret);
+            break;
+        }
+        default:
+            crypto_log_err("Invalid rsa verify padding type.\n");
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return ret;
+}
+
+static td_s32 rsa_encrypt(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    td_u8 *em,
+    const td_u32 klen,
+    const drv_pke_data *msg,
+    const drv_pke_data *label)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_pack en_pack = {
+        .klen = klen,
+        .em_bit = 0,
+        .em = em,
+        .em_len = klen,
+        .hash = TD_NULL,
+        .hash_len = 0,
+        .data = msg->data,
+        .data_len = msg->length
+    };
+
+    switch (scheme) {
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V15: {
+            ret = pkcs1_v15_encrypt(&en_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_v15_encrypt failed, ret is 0x%x\n", ret);
+            break;
+        }
+#endif
+        case DRV_PKE_RSA_SCHEME_PKCS1_V21: {
+            ret = pkcs1_oaep_encrypt(hash_type, &en_pack, label);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_oaep_encrypt failed, ret is 0x%x\n", ret);
+            break;
+        }
+        default:
+            crypto_log_err("Invalid rsa encrypt padding type.\n");
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return ret;
+}
+
+static td_s32 rsa_decrypt(const drv_pke_rsa_scheme scheme, const drv_pke_hash_type hash_type, td_u8 *em,
+    const td_u32 klen, const drv_pke_data *label, drv_pke_data *msg)
+{
+    td_s32 ret = TD_FAILURE;
+    rsa_pkcs1_pack de_pack = {
+        .klen = klen,
+        .em_bit = 0,
+        .em = em,
+        .em_len = klen,
+        .hash = TD_NULL,
+        .hash_len = 0,
+        .data = msg->data,
+        .data_len = msg->length
+    };
+
+    switch (scheme) {
+#if defined(CONFIG_PKE_RSA_V15_SUPPORT)
+        case DRV_PKE_RSA_SCHEME_PKCS1_V15: {
+            ret = pkcs1_v15_decrypt(&de_pack);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_v15_decrypt failed, ret is 0x%x\n", ret);
+            msg->length = de_pack.data_len; // record length of plain text for return
+            break;
+        }
+#endif
+        case DRV_PKE_RSA_SCHEME_PKCS1_V21: {
+            ret = pkcs1_oaep_decrypt(hash_type, &de_pack, label);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "pkcs1_oaep_decrypt failed, ret is 0x%x\n", ret);
+            msg->length = de_pack.data_len; // record length of plain text for return
+            break;
+        }
+        default:
+            crypto_log_err("Invalid rsa decrypt padding type.\n");
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return ret;
+}
+
+static td_s32 pke_rsa_sign(
+    const drv_pke_rsa_priv_key *priv_key,
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    drv_pke_data *sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *em;
+    td_u32 klen = priv_key->n_len;
+    td_u32 em_bit = 0;
+    drv_pke_data in = {0};
+
+    em = crypto_malloc(DRV_PKE_LEN_4096);
+    if (em == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(em, DRV_PKE_LEN_4096, 0x00, DRV_PKE_LEN_4096);
+
+    em_bit = rsa_get_bit_num((const td_u8 *)priv_key->n, priv_key->n_len);
+    ret = rsa_sign(scheme, hash_type, em, klen, em_bit, input_hash);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit__, ret, "rsa_sign failed, ret is 0x%x\n", ret);
+
+    in = (drv_pke_data) {.length = klen, .data = em};
+    ret = rsa_exp_mod(priv_key->n, priv_key->d, priv_key->n_len, &in, sign);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit__, ret, "rsa_exp_mod failed, ret is 0x%x\n", ret);
+
+    if (memcmp(input_hash->data, sign->data, input_hash->length) == 0) {
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_RSA_SAME_DATA);
+    }
+
+exit__:
+    if (em != TD_NULL) {
+        (void)memset_s(em, DRV_PKE_LEN_4096, 0, DRV_PKE_LEN_4096);
+        crypto_free(em);
+    }
+    return ret;
+}
+
+static td_s32 pke_rsa_verify(
+    const drv_pke_rsa_pub_key *pub_key,
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    const drv_pke_data *sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 *em;
+    td_u8 *pem;
+    td_u32 klen = pub_key->len;
+    td_u32 em_bit = 0;
+    drv_pke_data out = {0};
+
+    em = crypto_malloc(DRV_PKE_LEN_4096);
+    if (em == TD_NULL) {
+        crypto_log_err("%s:%d Error! Malloc memory failed!\n", __FUNCTION__, __LINE__);
+        return PKE_COMPAT_ERRNO(ERROR_MALLOC);
+    }
+    (void)memset_s(em, DRV_PKE_LEN_4096, 0x00, DRV_PKE_LEN_4096);
+    pem = em;
+
+    out = (drv_pke_data) {.length = klen, .data = em};
+    ret = rsa_exp_mod(pub_key->n, pub_key->e, pub_key->len, sign, &out);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit__, ret, "rsa_exp_mod failed, ret is 0x%x\n", ret);
+
+    if (memcmp(sign->data, pem, pub_key->len) == 0) {
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_RSA_SAME_DATA);
+        goto exit__;
+    }
+
+    em_bit = rsa_get_bit_num((const td_u8 *)pub_key->n, pub_key->len);
+    ret = rsa_verify(scheme, hash_type, em, klen, em_bit, input_hash);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit__, ret, "rsa_verify failed, ret is 0x%x\n", ret);
+
+exit__:
+    if (em != TD_NULL) {
+        (void)memset_s(em, DRV_PKE_LEN_4096, 0, DRV_PKE_LEN_4096);
+        crypto_free(em);
+    }
+    return ret;
+}
+
+static td_s32 pke_rsa_encrypt(
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    const drv_pke_data *output)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 em[DRV_PKE_LEN_4096];
+    td_u32 klen = pub_key->len;
+    td_u8 *n = pub_key->n;
+    td_u8 *key = pub_key->e;
+    drv_pke_data data_in = {0};
+
+    (void)memset_s(em, sizeof(em), 0x00, sizeof(em));
+    ret = rsa_encrypt(scheme, hash_type, em, klen, input, label);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "rsa_encrypt failed, ret is 0x%x\n", ret);
+    data_in = (drv_pke_data) {.length = klen, .data = em};
+    ret = rsa_exp_mod(n, key, klen, &data_in, output);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "rsa_exp_mod failed, ret is 0x%x\n", ret);
+    if (memcmp(input->data, output->data, input->length) == 0) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_SAME_DATA);
+    }
+
+    return ret;
+}
+
+static td_s32 pke_rsa_decrypt(
+    drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 em[DRV_PKE_LEN_4096];
+    td_u32 klen = priv_key->n_len;
+    td_u8 *n = priv_key->n;
+    td_u8 *key = priv_key->d;
+    drv_pke_data data_out = {0};
+
+    (void)memset_s(em, sizeof(em), 0x00, sizeof(em));
+
+    data_out = (drv_pke_data) {.length = klen, .data = em};
+    ret = rsa_exp_mod(n, key, klen, input, &data_out);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "rsa_exp_mod failed, ret is 0x%x\n", ret);
+    ret = rsa_decrypt(scheme, hash_type, em, klen, label, output);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "rsa_decrypt failed, ret is 0x%x\n", ret);
+    if (memcmp(input->data, output->data, output->length) == 0) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_RSA_SAME_DATA);
+    }
+    return ret;
+}
+
+// expose layer
+td_s32 drv_cipher_pke_rsa_sign(
+    const drv_pke_rsa_priv_key *priv_key,
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    drv_pke_data *sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    /* check ptr. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->n);
+    pke_null_ptr_chk(priv_key->d);
+    pke_null_ptr_chk(input_hash);
+    pke_null_ptr_chk(input_hash->data);
+    pke_null_ptr_chk(sign);
+    pke_null_ptr_chk(sign->data);
+
+    /* check enum. */
+    crypto_chk_return(scheme >= DRV_PKE_RSA_SCHEME_MAX, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "scheme is Invalid\n");
+    crypto_chk_return(hash_type < DRV_PKE_HASH_TYPE_SHA256 || hash_type > DRV_PKE_HASH_TYPE_SHA512,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    /* check length. */
+    klen = priv_key->n_len;
+    hash_len = drv_get_hash_len(hash_type);
+    crypto_chk_return(input_hash->length != hash_len, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "input_hash->length is Invalid\n");
+
+    crypto_chk_return(klen != DRV_PKE_LEN_2048 && klen != DRV_PKE_LEN_3072 && klen != DRV_PKE_LEN_4096,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "n_len is Invalid\n");
+    if ((priv_key->d_len != klen)) {
+        ret = PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        crypto_log_err("d_len is Invalid!\n");
+        return ret;
+    }
+    crypto_chk_return(sign->length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "sign_len is Invalid\n");
+    crypto_chk_return(crypto_rsa_support(klen, scheme) == TD_FALSE, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_rsa_sign(priv_key, scheme, hash_type, input_hash, sign);
+    if (ret == TD_SUCCESS) {
+        sign->length = klen;
+    }
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_rsa_verify(
+    const drv_pke_rsa_pub_key *pub_key,
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_data *input_hash,
+    const drv_pke_data *sign)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 hash_len;
+    /* check ptr. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->n);
+    pke_null_ptr_chk(pub_key->e);
+    pke_null_ptr_chk(input_hash);
+    pke_null_ptr_chk(input_hash->data);
+    pke_null_ptr_chk(sign);
+    pke_null_ptr_chk(sign->data);
+
+    /* check enum. */
+    crypto_chk_return(scheme >= DRV_PKE_RSA_SCHEME_MAX, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "scheme is Invalid\n");
+    crypto_chk_return(hash_type < DRV_PKE_HASH_TYPE_SHA1 || hash_type > DRV_PKE_HASH_TYPE_SHA512,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    /* check length. */
+    hash_len = drv_get_hash_len(hash_type);
+    crypto_chk_return(input_hash->length != hash_len, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "input_hash->length is Invalid\n");
+
+    klen = pub_key->len;
+    if ((klen != DRV_PKE_LEN_2048 && klen != DRV_PKE_LEN_3072 && klen != DRV_PKE_LEN_4096)) {
+        ret = PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        crypto_log_err("k_len is Invalid!\n");
+        return ret;
+    }
+    crypto_chk_return(sign->length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "sign_len is Invalid\n");
+    crypto_chk_return(crypto_rsa_support(klen, scheme) == TD_FALSE, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_rsa_verify(pub_key, scheme, hash_type, input_hash, sign);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_rsa_public_encrypt(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    td_u32 input_len = 0;
+    /* check ptr. */
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(pub_key->n);
+    pke_null_ptr_chk(pub_key->e);
+    pke_null_ptr_chk(input);
+    pke_null_ptr_chk(input->data);
+    pke_null_ptr_chk(output);
+    pke_null_ptr_chk(output->data);
+    if (label != TD_NULL) {
+        pke_null_ptr_chk(label->data);
+    }
+
+    /* check enum. */
+    crypto_chk_return(scheme >= DRV_PKE_RSA_SCHEME_MAX, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "scheme is Invalid\n");
+    crypto_chk_return(hash_type < DRV_PKE_HASH_TYPE_SHA256 || hash_type > DRV_PKE_HASH_TYPE_SHA512,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    /* check length. */
+    klen = pub_key->len;
+    input_len = input->length;
+    hash_len = drv_get_hash_len(hash_type);
+    crypto_chk_return(hash_len == 0, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    crypto_chk_return(klen != DRV_PKE_LEN_2048 && klen != DRV_PKE_LEN_3072 && klen != DRV_PKE_LEN_4096,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "n_len is Invalid\n");
+    /*
+     * For V15, the plain_text's max length is klen - 11.
+     * For OAEP, the plain_text's max length is klen - 2 * hash_len - 2.
+     */
+    if (scheme == DRV_PKE_RSA_SCHEME_PKCS1_V15) {
+        crypto_chk_return(input_len > klen - RSA_PADLEN_11, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "input_len is too long for V15\n");
+    } else {
+        crypto_chk_return(input_len > klen - 2 * hash_len - 2,  // 2: refer to comment.
+            PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "input_len is too long for V21\n");
+    }
+    crypto_chk_return(input_len == 0, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "input_len is zero\n");
+    crypto_chk_return(output->length < klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "output_len is Invalid\n");
+    crypto_chk_return(crypto_rsa_support(klen, scheme) == TD_FALSE, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_rsa_encrypt(scheme, hash_type, pub_key, input, label, output);
+    if (ret == TD_SUCCESS) {
+        output->length = klen;
+    }
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
+
+td_s32 drv_cipher_pke_rsa_private_decrypt(
+    const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key,
+    const drv_pke_data *input,
+    const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_FAILURE;
+
+    td_u32 klen = 0;
+    td_u32 hash_len = 0;
+    td_u32 output_len = 0;
+    /* check ptr. */
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(priv_key->n);
+    pke_null_ptr_chk(priv_key->d);
+    pke_null_ptr_chk(input);
+    pke_null_ptr_chk(input->data);
+    pke_null_ptr_chk(output);
+    pke_null_ptr_chk(output->data);
+    if (label != TD_NULL) {
+        pke_null_ptr_chk(label->data);
+    }
+
+    /* check enum. */
+    crypto_chk_return(scheme >= DRV_PKE_RSA_SCHEME_MAX, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "scheme is Invalid\n");
+    crypto_chk_return(hash_type < DRV_PKE_HASH_TYPE_SHA256 || hash_type > DRV_PKE_HASH_TYPE_SHA512,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    /* check length. */
+    klen = priv_key->n_len;
+    output_len = output->length;
+    hash_len = drv_get_hash_len(hash_type);
+    crypto_chk_return(hash_len == 0, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash_type is Invalid\n");
+
+    crypto_chk_return(klen != DRV_PKE_LEN_2048 && klen != DRV_PKE_LEN_3072 && klen != DRV_PKE_LEN_4096,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "n_len is Invalid\n");
+    crypto_chk_return(priv_key->d_len != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "d_len is Invalid\n");
+    crypto_chk_return(input->length != klen, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "input_len is Invalid\n");
+
+    /*
+     * For V15, the plain_text's max length is klen - 11.
+     * For OAEP, the plain_text's max length is klen - 2 * hash_len - 2.
+     */
+    if (scheme == DRV_PKE_RSA_SCHEME_PKCS1_V15) {
+        crypto_chk_return(output_len < klen - RSA_PADLEN_11, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "output_len is not enough for V15\n");
+    } else {
+        crypto_chk_return(output_len < klen - 2 * hash_len - 2,  // 2: refer to comment.
+            PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "input_len is not enough for V21\n");
+    }
+    crypto_chk_return(crypto_rsa_support(klen, scheme) == TD_FALSE, PKE_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "alg is unsupport\n");
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+    ret = pke_rsa_decrypt(scheme, hash_type, priv_key, input, label, output);
+    (void)drv_cipher_pke_unlock_secure();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_v4.h b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_v4.h
new file mode 100644
index 0000000..ebd3ab0
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/pke/v4/drv_pke_v4.h
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef DRV_PKE_H
+#define DRV_PKE_H
+
+#include "crypto_pke_struct.h"
+
+/* Define ECC-HASH related data & types */
+#define SHA1_BLOCK_LENGTH                          64
+#define SHA224_BLOCK_LENGTH                        64
+#define SHA256_BLOCK_LENGTH                        64
+#define SHA384_BLOCK_LENGTH                        128
+#define SHA512_BLOCK_LENGTH                        128
+#define SM3_BLOCK_LENGTH                           64
+
+#define SHA1_RESULT_LENGTH                         20
+#define SHA224_RESULT_LENGTH                       28
+#define SHA256_RESULT_LENGTH                       32
+#define SHA384_RESULT_LENGTH                       48
+#define SHA512_RESULT_LENGTH                       64
+#define SM3_RESULT_LENGTH                          32
+
+/* result size */
+#define HASH_SIZE_SHA_1                            20
+#define HASH_SIZE_SHA_224                          28
+#define HASH_SIZE_SHA_256                          32
+#define HASH_SIZE_SHA_384                          48
+#define HASH_SIZE_SHA_512                          64
+#define HASH_SIZE_SHA_MAX                          64
+
+#define DRV_PKE_SM2_LEN_IN_BYTES                   32
+
+#define PKE_MAX_TIMES              3000
+
+#define WORD_INDEX_0               0
+#define WORD_INDEX_1               1
+#define WORD_INDEX_2               2
+#define WORD_INDEX_3               3
+
+#define MAX_LOW_2BITS              3
+#define MAX_LOW_3BITS              7
+#define MAX_LOW_4BITS              0xF
+#define MAX_LOW_8BITS              0xFF
+
+#define SHIFT_4BITS                4
+#define SHIFT_8BITS                8
+#define SHIFT_16BITS               16
+#define SHIFT_24BITS               24
+
+#define BOUND_VALUE_1              1
+
+#define REGISTER_WIDTH             8
+#define DRV_WORD_WIDTH             4
+#define BYTE_BITS                  8
+
+#define RSA_PUBLIC                 0x5A /* public key operation */
+#define RSA_PRIVATE                0xA5 /* private key operation */
+
+#define RSA_PADLEN_1               1
+#define RSA_PADLEN_2               2
+#define RSA_PADLEN_3               3
+#define RSA_PADLEN_8               8
+#define RSA_PADLEN_11              11
+#define RSA_PADLEN_19              19
+#define RSA_PADLEN_51              51
+#define RSA_PAD_X12                0x12
+#define RSA_PAD_X55                0x55
+#define RSA_PAD_XBC                0xBC
+
+#define RSA_MIN_KEY_LEN            32
+#define RSA_MAX_KEY_LEN            512
+#define HASH_SIZE_SHA_MAX          64
+
+#define ECC_TRY_CNT                8
+
+#define ECC_KEY_LEN_IN_WORD        0x12
+#define ECC_KEY_LEN_IN_BYTE        (ECC_KEY_LEN_IN_WORD * 4)
+#define ECC_KEY_LEN_IN_BYTE_X2     (ECC_KEY_LEN_IN_BYTE * 2) // 2: x2 is for security enhancement
+
+
+#define SM2_PC_UNCOMPRESS          0x04
+#define SM2_TRY_CNT                8
+#define ENTLA_LEN                  2
+#define PKE_U16_MAX             0xFFFF
+
+typedef struct {
+    td_u32 klen;
+    td_u32 em_bit;
+    td_u8 *em;
+    td_u32 em_len;
+    td_u8 *hash;
+    td_u32 hash_len;
+    td_u8 *data;
+    td_u32 data_len;
+} rsa_pkcs1_pack;
+
+typedef struct {
+    drv_pke_hash_type hash_type;
+    td_u32 hash_len;
+    td_u8 *lhash_data;
+    td_u8 *asn1_data;
+    td_u32 asn1_len;
+} rsa_pkcs1_hash_info;
+
+typedef struct {
+    drv_pke_hash_type hash_type;
+    td_u32 block_len;
+    td_u32 result_len;
+} pke_hash_properties_type;
+
+typedef struct {
+    td_u8 *px;
+    td_u8 *py;
+    td_u8 *id;
+    td_u16 id_len;
+} sm2_sign_verify_hash_pack;
+
+td_s32 drv_cipher_pke_init(void);
+
+td_s32 drv_cipher_pke_deinit(void);
+
+td_s32 drv_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k,
+    const drv_pke_data *in, const drv_pke_data *out);
+
+td_s32 drv_cipher_pke_lock_secure(void);
+
+td_s32 drv_cipher_pke_unlock_secure(void);
+
+td_s32 drv_cipher_pke_rsa_sign(const drv_pke_rsa_priv_key *priv_key, const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign);
+
+td_s32 drv_cipher_pke_rsa_verify(const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type, const drv_pke_data *input_hash, const drv_pke_data *sign);
+
+td_s32 drv_cipher_pke_rsa_public_encrypt(const drv_pke_rsa_scheme scheme, const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+td_s32 drv_cipher_pke_rsa_private_decrypt(const drv_pke_rsa_scheme scheme, const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+td_s32 drv_cipher_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve);
+
+td_s32 drv_cipher_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key);
+
+td_s32 drv_cipher_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key);
+
+td_s32 drv_cipher_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 drv_cipher_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 drv_cipher_pke_eddsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 drv_cipher_pke_eddsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 drv_cipher_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash);
+
+td_s32 drv_cipher_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text);
+
+td_s32 drv_cipher_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc.c b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc.c
new file mode 100644
index 0000000..75f6a77
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc.c
@@ -0,0 +1,531 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_symc. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+#include "drv_symc.h"
+#include "drv_symc_inner.h"
+#include "hal_symc.h"
+#include "crypto_drv_common.h"
+
+static drv_symc_context_t g_drv_symc_ctx_list[CONFIG_SYMC_HARD_CHN_CNT];
+
+td_s32 inner_symc_drv_handle_chk(td_handle symc_handle)
+{
+    td_u32 chn_num = (td_u32)symc_handle;
+    if (chn_num >= CONFIG_SYMC_HARD_CHN_CNT) {
+        return SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE);
+    }
+    if (((1 << chn_num) & CONFIG_SYMC_HARD_CHANNEL_MASK) == 0) {
+        return SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE);
+    }
+    return TD_SUCCESS;
+}
+
+drv_symc_context_t *inner_get_symc_ctx(td_handle symc_handle)
+{
+    td_s32 ret;
+    td_u32 chn_num = (td_u32)symc_handle;
+    ret = inner_symc_drv_handle_chk(symc_handle);
+    if (ret != TD_SUCCESS) {
+        return TD_NULL;
+    }
+    return &g_drv_symc_ctx_list[chn_num];
+}
+
+td_s32 drv_cipher_symc_init(td_void)
+{
+    td_s32 ret;
+    crypto_drv_func_enter();
+    ret = hal_cipher_symc_init();
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("hal_cipher_symc_init failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_symc_deinit(td_void)
+{
+    crypto_drv_func_enter();
+    hal_cipher_symc_deinit();
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 drv_cipher_symc_create(td_handle *symc_handle, const crypto_symc_attr *symc_attr)
+{
+    td_u32 i;
+    td_s32 ret = CRYPTO_SUCCESS;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_drv_func_enter();
+
+    symc_null_ptr_chk(symc_handle);
+    symc_null_ptr_chk(symc_attr);
+
+    for (i = 0; i < CONFIG_SYMC_HARD_CHN_CNT; i++) {
+        symc_ctx = &g_drv_symc_ctx_list[i];
+        if (symc_ctx->is_open == TD_TRUE) {
+            continue;
+        }
+        ret = hal_cipher_symc_lock_chn(i);
+        if (ret == CRYPTO_SUCCESS) {
+            break;
+        }
+    }
+    if (i >= CONFIG_SYMC_HARD_CHN_CNT) {
+        crypto_log_err("All SYMC Channels are busy!\n");
+        return SYMC_COMPAT_ERRNO(ERROR_CHN_BUSY);
+    }
+    symc_ctx = &g_drv_symc_ctx_list[i];
+    (td_void)memset_s(symc_ctx, sizeof(drv_symc_context_t), 0, sizeof(drv_symc_context_t));
+
+    symc_ctx->chn_num = i;
+    symc_ctx->is_open = TD_TRUE;
+    *symc_handle = i;
+
+    crypto_drv_func_exit();
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 drv_cipher_symc_destroy(td_handle symc_handle)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    td_u32 chn_num = (td_u32)symc_handle;
+    crypto_drv_func_enter();
+
+    ret = inner_symc_drv_handle_chk(symc_handle);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("Invalid Handle\n");
+        return ret;
+    }
+    symc_ctx = &g_drv_symc_ctx_list[chn_num];
+
+#if defined(CONFIG_CRYPTO_SOFT_CENC_SUPPORT)
+    cenc_ddr_release();
+    cenc_ddr_unmap_input(chn_num);
+#endif
+    (td_void)memset_s(symc_ctx, sizeof(drv_symc_context_t), 0, sizeof(drv_symc_context_t));
+    ret = hal_cipher_symc_unlock_chn(chn_num);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("hal_cipher_symc_unlock_chn failed, ret is 0x%x\n", ret);
+    }
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 inner_symc_cfg_param_check(const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_bool is_support = TD_FALSE;
+    crypto_symc_alg symc_alg = symc_ctrl->symc_alg;
+    crypto_symc_work_mode mode = symc_ctrl->work_mode;
+    crypto_symc_key_length key_length = symc_ctrl->symc_key_length;
+    crypto_symc_bit_width bit_width = symc_ctrl->symc_bit_width;
+    crypto_symc_iv_change_type iv_change_flag = symc_ctrl->iv_change_flag;
+    td_u32 iv_length = symc_ctrl->iv_length;
+
+    /* Check Common Params. */
+    crypto_chk_return(symc_alg != CRYPTO_SYMC_ALG_AES && symc_alg != CRYPTO_SYMC_ALG_SM4,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "symc_alg is invalid\n");
+    crypto_chk_return(symc_alg == CRYPTO_SYMC_ALG_AES && mode > CRYPTO_SYMC_WORK_MODE_GCM,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "aes mode is invalid\n");
+    crypto_chk_return(symc_alg == CRYPTO_SYMC_ALG_SM4 && mode > CRYPTO_SYMC_WORK_MODE_CFB,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "sm4 mode is invalid\n");
+    crypto_chk_return(key_length < CRYPTO_SYMC_KEY_128BIT || key_length > CRYPTO_SYMC_KEY_256BIT,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "key_length is invalid\n");
+    crypto_chk_return(bit_width >= CRYPTO_SYMC_BIT_WIDTH_MAX,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "bit_width is invalid\n");
+    crypto_chk_return(iv_change_flag >= CRYPTO_SYMC_IV_CHANGE_MAX, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "iv_change_flag is invalid\n");
+
+    /* Check Mode. && Check key_length. */
+    if (symc_alg == CRYPTO_SYMC_ALG_SM4) {
+        /* SM4 only support ECB/CBC/CTR. */
+#if !defined(CONFIG_SYMC_SM4_CFB_OFB_SUPPORT)
+        crypto_chk_return(mode != CRYPTO_SYMC_WORK_MODE_ECB && mode != CRYPTO_SYMC_WORK_MODE_CBC &&
+            mode != CRYPTO_SYMC_WORK_MODE_CTR, SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT), "sm4 unsupport this mode\n");
+#endif
+        /* SM4's keylength must be 128. */
+        crypto_chk_return(key_length != CRYPTO_SYMC_KEY_128BIT, SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT),
+            "sm4's key_len only support 128-bit\n");
+    }
+
+    /* Check bit_width. */
+    if (mode == CRYPTO_SYMC_WORK_MODE_CFB) {
+        crypto_chk_return(bit_width == CRYPTO_SYMC_BIT_WIDTH_64BIT, SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT),
+            "CFB's bit-width don't support 64-bit\n");
+    } else {
+        crypto_chk_return(bit_width != CRYPTO_SYMC_BIT_WIDTH_128BIT, SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT),
+            "bit-width only support 128-bit\n");
+    }
+
+    /* Check iv_change_flag. */
+
+    /* Check iv_length. */
+    if (mode != CRYPTO_SYMC_WORK_MODE_ECB) {
+        crypto_chk_return(iv_length != CRYPTO_IV_LEN_IN_BYTES, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "iv_length is invalid\n");
+    }
+
+    is_support = crypto_symc_support(symc_ctrl->symc_alg, symc_ctrl->work_mode,
+        symc_ctrl->symc_key_length, symc_ctrl->symc_bit_width);
+    crypto_chk_return(is_support == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT), "alg is unsupport\n");
+    if (symc_ctrl->symc_alg == CRYPTO_SYMC_ALG_SM4) {
+        is_support = crypto_sm4_support();
+    }
+    crypto_chk_return(is_support == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT), "alg is unsupport\n");
+
+    return TD_SUCCESS;
+}
+
+static td_s32 drv_cipher_symc_normal_set_config(drv_symc_context_t *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    hal_symc_config_t hal_symc_config = {0};
+
+    ret = inner_symc_cfg_param_check(symc_ctrl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_symc_cfg_param_check failed, ret is 0x%x\n", ret);
+
+    symc_ctx->iv_change_flag = symc_ctrl->iv_change_flag;
+    ret = memcpy_s(symc_ctx->iv, sizeof(symc_ctx->iv), symc_ctrl->iv, sizeof(symc_ctx->iv));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = hal_cipher_symc_set_iv(symc_ctx->chn_num, symc_ctx->iv, symc_ctrl->iv_length);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed, ret is 0x%x\n", ret);
+
+    hal_symc_config.symc_alg = symc_ctrl->symc_alg;
+    hal_symc_config.work_mode = symc_ctrl->work_mode;
+    hal_symc_config.symc_bit_width = symc_ctrl->symc_bit_width;
+    hal_symc_config.symc_key_length = symc_ctrl->symc_key_length;
+    hal_symc_config.iv_change_flag = symc_ctrl->iv_change_flag;
+    ret = hal_cipher_symc_config(symc_ctx->chn_num, &hal_symc_config);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_config failed, ret is 0x%x\n", ret);
+
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+    symc_ctx->ctr_offset = 0;
+#endif
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_symc_set_config(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    td_u32 chn_num = symc_handle;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_drv_func_enter();
+
+    ret = inner_symc_drv_handle_chk(symc_handle);
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+    symc_null_ptr_chk(symc_ctrl);
+    symc_ctx = &g_drv_symc_ctx_list[chn_num];
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    symc_ctx->work_mode = symc_ctrl->work_mode;
+    symc_ctx->iv_change_flag = symc_ctrl->iv_change_flag;
+    switch (symc_ctrl->work_mode) {
+        case CRYPTO_SYMC_WORK_MODE_CCM:
+#if defined(CONFIG_SYMC_CCM_SUPPORT)
+            ret = drv_cipher_symc_ccm_set_config(symc_ctx, symc_ctrl);
+            break;
+#else
+            crypto_log_err("ccm unsupport\n");
+            return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+#endif
+        case CRYPTO_SYMC_WORK_MODE_GCM:
+#if defined(CONFIG_SYMC_GCM_SUPPORT)
+            ret = drv_cipher_symc_gcm_set_config(symc_ctx, symc_ctrl);
+            break;
+#else
+            crypto_log_err("gcm unsupport\n");
+            return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+#endif
+        default:
+            ret = drv_cipher_symc_normal_set_config(symc_ctx, symc_ctrl);
+            break;
+    }
+
+    symc_ctx->is_config = TD_TRUE;
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_symc_attach(td_handle symc_handle, td_handle keyslot_handle)
+{
+    td_s32 ret;
+    td_u32 symc_chn_num = symc_handle;
+    td_u32 keyslot_chn_num = keyslot_handle;
+    drv_symc_context_t *drv_symc_ctx = TD_NULL;
+
+    crypto_drv_func_enter();
+    ret = inner_symc_drv_handle_chk(symc_handle);
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    drv_symc_ctx = &g_drv_symc_ctx_list[symc_chn_num];
+    crypto_chk_return(drv_symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(drv_symc_ctx->is_create_keyslot == TD_TRUE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED),
+        "has been create\n");
+
+    ret = hal_cipher_symc_attach(symc_chn_num, keyslot_chn_num);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("hal_cipher_symc_attach failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    drv_symc_ctx->keyslot_handle = keyslot_handle;
+    drv_symc_ctx->is_attached = TD_TRUE;
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+int32_t inner_drv_symc_common_process(drv_symc_context_t *symc_ctx, td_u64 src_phys_addr, td_u64 dst_phys_addr,
+    td_u32 length, td_u32 node_type)
+{
+    td_s32 ret;
+    td_u32 chn_num = symc_ctx->chn_num;
+
+#if defined(CONFIG_SYMC_TRACE_ENABLE)
+    crypto_dump_data("set iv", symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_dump_phys_addr("src_buf", src_phys_addr, length);
+#endif
+
+    ret = hal_cipher_symc_set_iv(chn_num, symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_get_iv failed\n");
+
+    ret = hal_cipher_symc_add_in_node(chn_num, src_phys_addr, length, node_type);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_cipher_symc_add_in_node failed\n");
+
+    ret = hal_cipher_symc_add_out_node(chn_num, dst_phys_addr, length);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_cipher_symc_add_out_node failed\n");
+
+    ret = hal_cipher_symc_start(chn_num);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_start failed\n");
+
+    ret = hal_cipher_symc_wait_done(chn_num, TD_TRUE);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_wait_done failed\n");
+
+    ret = hal_cipher_symc_get_iv(chn_num, symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_get_iv failed\n");
+
+#if defined(CONFIG_SYMC_TRACE_ENABLE)
+    crypto_dump_data("get iv", symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_dump_phys_addr("dst_buf", dst_phys_addr, length);
+#endif
+
+    return ret;
+}
+
+static td_s32 inner_drv_cipher_symc_crypto(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length, td_bool is_decrypt)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    td_u32 chn_num = (td_u32)symc_handle;
+    crypto_drv_func_enter();
+
+    ret = inner_drv_symc_crypto_chk(symc_handle, src_buf, dst_buf, length);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_crypto_chk failed\n");
+
+    symc_ctx = &g_drv_symc_ctx_list[chn_num];
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(symc_ctx->is_config == TD_FALSE,
+        SYMC_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG), "call set_config first\n");
+    crypto_chk_return(symc_ctx->is_attached == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_ATTACHED), "call attach first\n");
+
+    symc_ctx->is_decrypt = is_decrypt;
+
+    (td_void)hal_cipher_set_chn_secure(chn_num, dst_buf->buf_sec == CRYPTO_BUF_SECURE,
+        src_buf->buf_sec == CRYPTO_BUF_SECURE);
+
+    (void)hal_cipher_symc_set_flag(chn_num, is_decrypt);
+
+    switch (symc_ctx->work_mode) {
+        case CRYPTO_SYMC_WORK_MODE_CCM:
+#if defined(CONFIG_SYMC_CCM_SUPPORT)
+            ret = inner_drv_cipher_symc_ccm_process(symc_ctx, src_buf->phys_addr, dst_buf->phys_addr, length);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_cipher_symc_ccm_process failed\n");
+            break;
+#else
+            crypto_log_err("ccm unsupport\n");
+            return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+#endif
+        case CRYPTO_SYMC_WORK_MODE_GCM:
+#if defined(CONFIG_SYMC_GCM_SUPPORT)
+            ret = inner_drv_cipher_symc_gcm_process(symc_ctx, src_buf->phys_addr, dst_buf->phys_addr, length);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_cipher_symc_gcm_process failed\n");
+            break;
+#else
+            crypto_log_err("gcm unsupport\n");
+            return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+#endif
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+        case CRYPTO_SYMC_WORK_MODE_CTR:
+            ret = inner_drv_cipher_symc_ctr_process_non_align(symc_ctx, src_buf->phys_addr,
+                dst_buf->phys_addr, length);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_cipher_symc_ctr_process_non_align failed\n");
+            break;
+#endif
+        default:
+            ret = inner_drv_symc_common_process(symc_ctx, src_buf->phys_addr, dst_buf->phys_addr, length,
+                IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_common_process failed\n");
+            break;
+    }
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_symc_encrypt(td_handle symc_handle, const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf,
+    td_u32 length)
+{
+    td_s32 ret;
+    crypto_drv_func_enter();
+
+    ret = inner_drv_cipher_symc_crypto(symc_handle, src_buf, dst_buf, length, TD_FALSE);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("inner_drv_cipher_symc_crypto failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_symc_decrypt(td_handle symc_handle, const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf,
+    td_u32 length)
+{
+    td_s32 ret;
+    crypto_drv_func_enter();
+
+    ret = inner_drv_cipher_symc_crypto(symc_handle, src_buf, dst_buf, length, TD_TRUE);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("inner_drv_cipher_symc_crypto failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_symc_get_tag(td_handle symc_handle, td_u8 *tag, td_u32 tag_length)
+{
+    td_s32 ret;
+    td_u32 chn_num;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_drv_func_enter();
+    ret = inner_symc_drv_handle_chk(symc_handle);
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+    symc_null_ptr_chk(tag);
+    crypto_chk_return(tag_length == 0 || tag_length > CRYPTO_AES_MAX_TAG_SIZE,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "tag_length is invalid\n");
+    chn_num = symc_handle;
+    symc_ctx = &g_drv_symc_ctx_list[chn_num];
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(symc_ctx->is_config == TD_FALSE,
+        SYMC_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG), "call set_config first\n");
+    crypto_chk_return(symc_ctx->is_attached == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_ATTACHED), "call attach first\n");
+
+    switch (symc_ctx->work_mode) {
+        case CRYPTO_SYMC_WORK_MODE_CCM:
+#if defined(CONFIG_SYMC_CCM_SUPPORT)
+            ret = inner_drv_cipher_symc_ccm_get_tag(symc_ctx, tag, tag_length);
+            break;
+#else
+            crypto_log_err("unsupport ccm\n");
+            return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+#endif
+        case CRYPTO_SYMC_WORK_MODE_GCM:
+#if defined(CONFIG_SYMC_GCM_SUPPORT)
+            ret = inner_drv_cipher_symc_gcm_get_tag(symc_ctx, tag, tag_length);
+            break;
+#else
+            crypto_log_err("unsupport gcm\n");
+            return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+#endif
+        default:
+            crypto_log_err("invalid work_mode\n");
+            return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+    }
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 inner_drv_symc_crypto_chk(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_symc_work_mode mode;
+
+    ret = inner_symc_drv_handle_chk(symc_handle);
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+    symc_ctx = &g_drv_symc_ctx_list[symc_handle];
+
+    symc_null_ptr_chk(src_buf);
+    symc_null_ptr_chk(dst_buf);
+    crypto_chk_return(src_buf->phys_addr == 0, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "src_buf's phys_addr is invalid\n");
+    crypto_chk_return(dst_buf->phys_addr == 0, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "dst_buf's phys_addr is invalid\n");
+    crypto_chk_return(src_buf->buf_sec != CRYPTO_BUF_SECURE && src_buf->buf_sec != CRYPTO_BUF_NONSECURE,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "src_buf's buf_sec is invalid\n");
+    crypto_chk_return(dst_buf->buf_sec != CRYPTO_BUF_SECURE && dst_buf->buf_sec != CRYPTO_BUF_NONSECURE,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "dst_buf's buf_sec is invalid\n");
+
+    crypto_chk_return(length == 0, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "length is zero!\n");
+    mode = symc_ctx->work_mode;
+    if (mode == CRYPTO_SYMC_WORK_MODE_CBC || mode == CRYPTO_SYMC_WORK_MODE_ECB) {
+        crypto_chk_return((length % CRYPTO_AES_BLOCK_SIZE_IN_BYTES) != 0, SYMC_COMPAT_ERRNO(ERROR_SYMC_LEN_NOT_ALIGNED),
+            "length must be aligned to 16-Byte\n");
+    }
+    return TD_SUCCESS;
+}
+
+td_s32 inner_drv_symc_set_iv(td_handle symc_handle, const td_u8 *iv, td_u32 iv_len)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    ret = memcpy_s(symc_ctx->iv, sizeof(symc_ctx->iv), iv, iv_len);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return TD_SUCCESS;
+}
+
+td_s32 inner_drv_symc_get_iv(td_handle symc_handle, td_u8 *iv, td_u32 iv_len)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    ret = memcpy_s(iv, iv_len, symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return TD_SUCCESS;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_ccm.c b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_ccm.c
new file mode 100644
index 0000000..4f1217c
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_ccm.c
@@ -0,0 +1,510 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_symc gcm. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+#include "drv_symc.h"
+#include "drv_symc_inner.h"
+#include "drv_symc_outer.h"
+#include "hal_symc.h"
+#include "crypto_drv_common.h"
+#if defined(CONFIG_SYMC_CCM_SUPPORT)
+
+static td_s32 inner_symc_ccm_process_N(drv_symc_context_t *symc_ctx);
+static td_s32 inner_symc_ccm_process_aad(drv_symc_context_t *symc_ctx, td_u64 aad_phys_addr, td_u32 aad_len);
+
+static td_s32 inner_symc_ccm_cfg_param_check(const crypto_symc_ctrl_t *symc_ctrl)
+{
+    crypto_symc_config_aes_ccm_gcm *ccm_gcm_param = (crypto_symc_config_aes_ccm_gcm *)symc_ctrl->param;
+    td_u32 iv_length = symc_ctrl->iv_length;
+    td_u32 tag_len;
+    td_u32 data_len;
+    td_u32 diff = 0;
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_START) {
+        crypto_chk_return(ccm_gcm_param == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "param is NULL\n");
+        tag_len = ccm_gcm_param->tag_len;
+        data_len = ccm_gcm_param->data_len;
+        /* IV lenght for CCM, which should be 7~13. */
+        crypto_chk_return(iv_length > 13 || iv_length < 7,      // 7: min iv_len for ccm, 13: max iv_len for ccm.
+            SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "iv_len must be 7~13 for CCM\n");
+        /* Tag length for CCM should be 4,6,8,10,12,14,16. */
+        crypto_chk_return(
+            tag_len % 2 != 0 || tag_len < 4 || tag_len > 16,  // 4: min tag_len, 16: max tag_len, 2: judge if even.
+            SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "tag_len must be 4,6,8,10,12,14,16 for CCM\n");
+        diff = CRYPTO_IV_LEN_IN_BYTES - iv_length - 1;
+        if (diff == 2) {    // 2: 2 * 8 bits to represent data_len.
+            crypto_chk_return(data_len > 0xFFFF, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), // 0xFFFF: 2^16 - 1
+                "data_len is too long\n");
+        }
+        if (diff == 3) {    // 3: 3 * 8 bits to represent data_len.
+            crypto_chk_return(data_len > 0xFFFFFF, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), // 0xFFFFFF: 2^24 - 1
+                "data_len is too long\n");
+        }
+    }
+
+    return TD_SUCCESS;
+}
+
+static td_s32 inner_format_ccm_iv(const td_u8 *iv, td_u32 iv_length, td_u8 *ccm_iv, td_u32 *ccm_iv_length)
+{
+    td_s32 ret;
+
+    ccm_iv[0] = CRYPTO_AES_CCM_NQ_LEN - iv_length;
+    ret = memcpy_s(&ccm_iv[1], *ccm_iv_length - 1, iv, iv_length);
+    if (ret != EOK) {
+        crypto_log_err("memcpy_s failed\n");
+        return TD_FAILURE;
+    }
+    *ccm_iv_length = iv_length + 1;
+    return TD_SUCCESS;
+}
+
+static td_void inner_format_ccm_header(td_u32 aad_len, td_u8 *ccm_header, td_u32 *ccm_header_len)
+{
+    td_u32 idx = 0;
+    ccm_header[idx++] = (td_u8)(aad_len >> 8);  /* 8: bits 15-8 */
+    ccm_header[idx++] = (td_u8)(aad_len);
+    *ccm_header_len = idx;
+}
+
+static void inner_ccm_iv_plus_one(uint8_t *iv, uint32_t iv_len)
+{
+    uint32_t value = CRYPTO_BYTE_MAX + 1;
+    int32_t i = iv_len - 1;
+
+    while (value > CRYPTO_BYTE_MAX && i >= 0) {
+        value = iv[i] + 1;
+        iv[i] = value % CRYPTO_BYTE_MAX;
+        iv--;
+    }
+}
+
+td_s32 drv_cipher_symc_ccm_set_config(drv_symc_context_t *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    hal_symc_config_t hal_symc_config = {0};
+    crypto_symc_config_aes_ccm_gcm *ccm_gcm_config = TD_NULL;
+
+    crypto_assert_neq(symc_ctx, TD_NULL);
+    crypto_assert_neq(symc_ctrl, TD_NULL);
+
+    ret = inner_symc_ccm_cfg_param_check(symc_ctrl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_symc_ccm_cfg_param_check failed\n");
+
+    hal_symc_config.symc_alg = symc_ctrl->symc_alg;
+    hal_symc_config.work_mode = symc_ctrl->work_mode;
+    hal_symc_config.symc_bit_width = symc_ctrl->symc_bit_width;
+    hal_symc_config.symc_key_length = symc_ctrl->symc_key_length;
+    hal_symc_config.iv_change_flag = symc_ctrl->iv_change_flag;
+    ret = hal_cipher_symc_config(symc_ctx->chn_num, &hal_symc_config);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_config failed, ret is 0x%x\n", ret);
+
+    symc_ctx->symc_alg = symc_ctrl->symc_alg;
+    symc_ctx->work_mode = symc_ctrl->work_mode;
+    symc_ctx->symc_bit_width = symc_ctrl->symc_bit_width;
+    symc_ctx->symc_key_length = symc_ctrl->symc_key_length;
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_FINISH) {
+        ret = hal_cipher_symc_set_iv(symc_ctx->chn_num, symc_ctrl->iv, sizeof(symc_ctrl->iv));
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed, ret is 0x%x\n", ret);
+        symc_ctx->is_config = TD_TRUE;
+        return CRYPTO_SUCCESS;
+    }
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_START) {
+        ccm_gcm_config = (crypto_symc_config_aes_ccm_gcm *)symc_ctrl->param;
+        symc_ctx->total_aad_len = ccm_gcm_config->total_aad_len;
+        symc_ctx->data_len = ccm_gcm_config->data_len;
+        symc_ctx->tag_len = ccm_gcm_config->tag_len;
+        symc_ctx->processed_len = 0;
+        (void)memset_s(symc_ctx->iv, sizeof(symc_ctx->iv), 0, sizeof(symc_ctx->iv));
+        (void)memset_s(symc_ctx->ctr0, sizeof(symc_ctx->ctr0), 0, sizeof(symc_ctx->ctr0));
+        symc_ctx->iv_length = sizeof(symc_ctx->iv);
+        ret = inner_format_ccm_iv(symc_ctrl->iv, symc_ctrl->iv_length, symc_ctx->iv, &(symc_ctx->iv_length));
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_format_ccm_iv failed, ret is 0x%x\n", ret);
+
+        ret = memcpy_s(symc_ctx->ctr0, sizeof(symc_ctx->ctr0), symc_ctx->iv, symc_ctx->iv_length);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+#if defined(CONFIG_SYMC_CCM_TRACE_ENABLE)
+        crypto_dump_data("ccm_iv", symc_ctx->iv, sizeof(symc_ctx->iv));
+#endif
+        /* ccm cmac N. */
+        ret = inner_symc_ccm_process_N(symc_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_symc_ccm_process_N failed, ret is 0x%x\n", ret);
+
+        inner_ccm_iv_plus_one(symc_ctx->iv, sizeof(symc_ctx->iv));
+        ret = hal_cipher_symc_set_iv(symc_ctx->chn_num, symc_ctx->iv, sizeof(symc_ctx->iv));
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed, ret is 0x%x\n", ret);
+    }
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_START ||
+        symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_UPDATE) {
+        ccm_gcm_config = (crypto_symc_config_aes_ccm_gcm *)symc_ctrl->param;
+        /* ccm cmac aad. */
+        if (ccm_gcm_config->aad_len != 0) {
+            ret = inner_symc_ccm_process_aad(symc_ctx, ccm_gcm_config->aad_buf.phys_addr, ccm_gcm_config->aad_len);
+            crypto_chk_return(ret != TD_SUCCESS, ret, "inner_symc_ccm_process_aad failed, ret is 0x%x\n", ret);
+        }
+    }
+    symc_ctx->is_config = TD_TRUE;
+
+    return TD_SUCCESS;
+}
+
+static td_s32 inner_symc_ccm_process_N(drv_symc_context_t *symc_ctx)
+{
+    td_s32 ret;
+    td_u32 data_len = symc_ctx->data_len;
+    td_u32 idx = 0;
+    td_u32 q;
+    td_u32 N_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    td_u8 *N = crypto_malloc_coherent(N_len, "ccm_N");
+    crypto_chk_return(N == NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    /* CCM ADD N. */
+    (td_void)memset_s(N, N_len, 0, N_len);
+    /* First byte of N. */
+    N[idx] = (symc_ctx->total_aad_len > 0 ? 1 : 0) << CRYPTO_BIT_6;
+    N[idx] |= ((symc_ctx->tag_len - 2) / 2) << CRYPTO_BIT_3;  /* 2: ccm require */
+    N[idx] |= (CRYPTO_AES_BLOCK_SIZE_IN_BYTES - 1 - symc_ctx->iv_length);
+    idx++;
+    /* copy ccm_iv[1..] to N[1..] */
+    ret = memcpy_s(&N[idx], N_len - idx, &(symc_ctx->iv[1]), symc_ctx->iv_length - 1);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    idx += symc_ctx->iv_length - 1;
+
+    q = N_len - idx;
+    if (q >= CRYPTO_SYMC_CCM_Q_LEN_4B) {
+        idx = CRYPTO_AES_BLOCK_SIZE_IN_BYTES - CRYPTO_SYMC_CCM_Q_LEN_4B;
+        N[idx++] = (td_u8)(data_len >> 24);     /* 24: bits 31-24 */
+        N[idx++] = (td_u8)(data_len >> 16);     /* 16: bits 23-16 */
+        N[idx++] = (td_u8)(data_len >> 8);      /* 8: bits 15-8 */
+        N[idx++] = (td_u8)(data_len);
+    } else if (q == CRYPTO_SYMC_CCM_Q_LEN_3B) {
+        N[idx++] = (td_u8)(data_len >> 16);     /* 16: bits 23-16 */
+        N[idx++] = (td_u8)(data_len >> 8);      /* 8: bits 15-8 */
+        N[idx++] = (td_u8)(data_len);
+    } else if (q == CRYPTO_SYMC_CCM_Q_LEN_2B) {
+        N[idx++] = (td_u8)(data_len >> 8);      /* 8: bits 15-8 */
+        N[idx++] = (td_u8)(data_len);
+    } else {
+        crypto_log_err("Invalid iv_len\n");
+        ret = SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        goto exit_free;
+    }
+#ifdef CONFIG_SYMC_CCM_TRACE_ENABLE
+    crypto_dump_data("N", N, CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+#endif
+    ret = inner_drv_cipher_symc_ccm_cmac_start(symc_ctx);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit_free, ret, "inner_drv_cipher_symc_ccm_cmac_start failed\n");
+
+    ret = inner_drv_cipher_symc_ccm_cmac_update(symc_ctx, crypto_get_phys_addr(N), N_len);
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_free, ret,
+        "inner_drv_cipher_symc_ccm_cmac_update failed\n");
+
+exit_free:
+    (void)memset_s(N, N_len, 0, N_len);
+    crypto_free_coherent(N);
+    return ret;
+}
+
+static td_s32 inner_symc_ccm_process_aad(drv_symc_context_t *symc_ctx, td_u64 aad_phys_addr, td_u32 aad_len)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 ccm_header_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    td_u32 ccm_padding_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    td_u8 *ccm_header = NULL;
+    td_u8 *ccm_padding = NULL;
+    td_u8 *ccm_buf = crypto_malloc_coherent(ccm_header_len + ccm_padding_len, "ccm_buf");
+    crypto_chk_return(ccm_buf == NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    ccm_header = ccm_buf;
+    ccm_padding = ccm_buf + ccm_header_len;
+
+    if (symc_ctx->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_START) {
+        symc_ctx->processed_aad_len = 0;
+        /* AAD Header. */
+        inner_format_ccm_header(symc_ctx->total_aad_len, ccm_header, &ccm_header_len);
+#ifdef CONFIG_SYMC_CCM_TRACE_ENABLE
+        crypto_dump_data("ccm_header", ccm_header, ccm_header_len);
+#endif
+        ret = inner_drv_cipher_symc_ccm_cmac_update(symc_ctx, crypto_get_phys_addr(ccm_header), ccm_header_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "inner_drv_cipher_symc_ccm_cmac_update failed\n");
+    }
+
+    if (aad_len != 0) {
+        /* AAD Body. */
+#ifdef CONFIG_SYMC_CCM_TRACE_ENABLE
+        crypto_dump_phys_addr("aad", aad_phys_addr, aad_len);
+#endif
+        ret = inner_drv_cipher_symc_ccm_cmac_update(symc_ctx, aad_phys_addr, aad_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "inner_drv_cipher_symc_ccm_cmac_update failed\n");
+
+        symc_ctx->processed_aad_len += aad_len;
+    }
+
+    /* AAD Padding. */
+    if (symc_ctx->processed_aad_len == symc_ctx->total_aad_len) {
+        ccm_padding_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES -
+            (CRYPTO_SYMC_CCM_HEADER_LEN + symc_ctx->total_aad_len) % CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+        /* AAD Padding. */
+        if (ccm_padding_len != CRYPTO_AES_BLOCK_SIZE_IN_BYTES) {
+            (td_void)memset_s(ccm_padding, ccm_padding_len, 0, ccm_padding_len);
+#ifdef CONFIG_SYMC_CCM_TRACE_ENABLE
+            crypto_dump_data("ccm_padding", ccm_padding, ccm_padding_len);
+#endif
+            ret = inner_drv_cipher_symc_ccm_cmac_update(symc_ctx, crypto_get_phys_addr(ccm_padding), ccm_padding_len);
+            crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "inner_drv_cipher_symc_ccm_cmac_update failed\n");
+        }
+    }
+
+exit_free:
+    crypto_free_coherent(ccm_buf);
+    return ret;
+}
+
+td_s32 inner_drv_cipher_symc_ccm_process(drv_symc_context_t *symc_ctx, td_ulong src_phys_addr,
+    td_ulong dst_phys_addr, td_u32 length)
+{
+    td_s32 ret;
+    td_u32 ccm_p_node_type = 0;
+    hal_symc_config_t symc_config = {0};
+
+    symc_null_ptr_chk(symc_ctx);
+    if (length == 0) {
+        return CRYPTO_SUCCESS;
+    }
+
+    /* CCM ADD P. */
+    crypto_log_dbg("ccm start process P\n");
+    if (symc_ctx->is_decrypt == TD_FALSE) { /* Encrypt, cmac update the plain text. */
+        ret = inner_drv_cipher_symc_ccm_cmac_update(symc_ctx, src_phys_addr, length);
+        crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_cipher_symc_ccm_cmac_update failed\n");
+    }
+
+    ccm_p_node_type = IN_NODE_TYPE_CCM_P | IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST;
+    if (symc_ctx->processed_len + length == symc_ctx->data_len) {
+        ccm_p_node_type |= IN_NODE_TYPE_CCM_LAST;
+    }
+
+    symc_config.symc_alg = symc_ctx->symc_alg;
+    symc_config.work_mode = symc_ctx->work_mode;
+    symc_config.symc_key_length = symc_ctx->symc_key_length;
+    symc_config.symc_bit_width = symc_ctx->symc_bit_width;
+
+    ret = hal_cipher_symc_config(symc_ctx->chn_num, &symc_config);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_config failed\n");
+
+    ret = inner_drv_symc_common_process(symc_ctx, src_phys_addr, dst_phys_addr, length, ccm_p_node_type);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_common_process failed\n");
+
+    if (symc_ctx->is_decrypt == TD_TRUE) { /* Decrypt, cmac update the plain text. */
+        ret = inner_drv_cipher_symc_ccm_cmac_update(symc_ctx, dst_phys_addr, length);
+        crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_cipher_symc_ccm_cmac_update failed\n");
+    }
+
+    symc_ctx->processed_len += length;
+    return ret;
+}
+
+td_s32 inner_drv_cipher_symc_ccm_get_tag(drv_symc_context_t *symc_ctx, td_u8 *tag, td_u32 tag_length)
+{
+    uint32_t i;
+    td_s32 ret;
+    td_u8 s0[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+#if defined(CONFIG_SYMC_CCM_TRACE_ENABLE)
+    crypto_dump_data("ccm ctr0", symc_ctx->ctr0, sizeof(symc_ctx->ctr0));
+#endif
+    ret = hal_cipher_ccm_compute_s0(symc_ctx->chn_num, symc_ctx->ctr0, sizeof(symc_ctx->ctr0), s0, sizeof(s0));
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_cipher_ccm_compute_s0");
+
+    ret = inner_drv_cipher_symc_ccm_cmac_finish(symc_ctx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_cipher_symc_ccm_cmac_finish");
+
+    for (i = 0; i < tag_length; i++) {
+        tag[i] = symc_ctx->ccm_cmac[i] ^ s0[i];
+    }
+
+#if defined(CONFIG_SYMC_CCM_TRACE_ENABLE)
+    crypto_dump_data("ccm s0", s0, sizeof(s0));
+    crypto_dump_data("ccm cmac", symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac));
+    crypto_dump_data("ccm tag", tag, tag_length);
+#endif
+    return ret;
+}
+
+int32_t inner_drv_cipher_symc_ccm_cmac_start(drv_symc_context_t *symc_ctx)
+{
+    symc_ctx->cmac_tail_len = 0;
+    (void)memset_s(symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac), 0, sizeof(symc_ctx->ccm_cmac));
+    return CRYPTO_SUCCESS;
+}
+
+int32_t inner_drv_cipher_symc_ccm_cmac_update(drv_symc_context_t *symc_ctx,
+    uint64_t data_phys_addr, uint32_t data_len)
+{
+    int32_t ret;
+    uint32_t left = data_len;
+    uint32_t processed_len = 0;
+    uint32_t processing_len = 0;
+    uint32_t tail_len = symc_ctx->cmac_tail_len;
+    uint32_t tail_buf_len = sizeof(symc_ctx->cmac_tail);
+    uint8_t *ccm_tail_buf = TD_NULL;
+
+    ccm_tail_buf = crypto_malloc_coherent(tail_buf_len, "ccm_tail_buf");
+    crypto_chk_return(ccm_tail_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+#if defined(CONFIG_SYMC_CCM_TRACE_ENABLE)
+    crypto_dump_data("cmac before", symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac));
+    crypto_dump_data("cmac_tail before", symc_ctx->cmac_tail, tail_len);
+    crypto_dump_phys_addr("cmac data", data_phys_addr, data_len);
+#endif
+
+    processing_len = crypto_min(tail_buf_len - tail_len, data_len);
+    ret = crypto_copy_from_phys_addr(symc_ctx->cmac_tail + tail_len, tail_buf_len - tail_len,
+        data_phys_addr, processing_len);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "crypto_copy_from_phys_addr failed\n");
+
+    symc_ctx->cmac_tail_len += processing_len;
+
+    /* process one block. */
+    if (symc_ctx->cmac_tail_len == tail_buf_len) {
+        (void)memcpy_s(ccm_tail_buf, tail_buf_len, symc_ctx->cmac_tail, tail_buf_len);
+        ret = hal_cipher_ccm_cmac_update(symc_ctx->chn_num, crypto_get_phys_addr(ccm_tail_buf),
+            tail_buf_len, symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac));
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "hal_cipher_ccm_cmac_update failed\n");
+        symc_ctx->cmac_tail_len = 0;
+    }
+
+    left -= processing_len;
+    processed_len += processing_len;
+    if (left == 0) {
+#if defined(CONFIG_SYMC_CCM_TRACE_ENABLE)
+        crypto_dump_data("cmac after", symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac));
+#endif
+        ret = CRYPTO_SUCCESS;
+        goto exit_free;
+    }
+    /* process blocks. */
+    while (left >= tail_buf_len) {
+        ret = crypto_copy_from_phys_addr(ccm_tail_buf, tail_buf_len, data_phys_addr + processed_len, tail_buf_len);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free, "crypto_copy_from_phys_addr failed\n");
+        ret = hal_cipher_ccm_cmac_update(symc_ctx->chn_num, crypto_get_phys_addr(ccm_tail_buf), tail_buf_len,
+            symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac));
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "hal_cipher_ccm_cmac_update failed\n");
+        left -= tail_buf_len;
+        processed_len += tail_buf_len;
+    }
+    if (left != 0) {
+        ret = crypto_copy_from_phys_addr(symc_ctx->cmac_tail, tail_buf_len, data_phys_addr + processed_len, left);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free, "crypto_copy_from_phys_addr failed\n");
+    }
+    symc_ctx->cmac_tail_len = left;
+
+#if defined(CONFIG_SYMC_CCM_TRACE_ENABLE)
+    crypto_dump_data("cmac after", symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac));
+#endif
+    ret = TD_SUCCESS;
+exit_free:
+    crypto_free_coherent(ccm_tail_buf);
+    return ret;
+}
+
+int32_t inner_drv_cipher_symc_ccm_cmac_finish(drv_symc_context_t *symc_ctx)
+{
+    int32_t ret;
+    uint32_t tail_len = symc_ctx->cmac_tail_len;
+    uint32_t tail_buf_len = sizeof(symc_ctx->cmac_tail);
+    uint8_t *ccm_tail_buf = TD_NULL;
+
+    if (symc_ctx->cmac_tail_len != 0) {
+        (void)memset_s(symc_ctx->cmac_tail + tail_len, tail_buf_len - tail_len, 0, tail_buf_len - tail_len);
+
+        ccm_tail_buf = crypto_malloc_coherent(tail_buf_len, "ccm_tail_buf");
+        crypto_chk_return(ccm_tail_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+        (void)memcpy_s(ccm_tail_buf, tail_buf_len, symc_ctx->cmac_tail, tail_buf_len);
+        ret = hal_cipher_ccm_cmac_update(symc_ctx->chn_num, crypto_get_phys_addr(ccm_tail_buf), tail_buf_len,
+            symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac));
+        crypto_free_coherent(ccm_tail_buf);
+
+        crypto_chk_return(ret != CRYPTO_SUCCESS, CRYPTO_FAILURE, "hal_cipher_ccm_cmac_update failed\n");
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 inner_drv_symc_ccm_set_ctx(td_handle symc_handle, const drv_symc_ccm_ctx *ccm_ctx)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = NULL;
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    symc_ctx->data_len = ccm_ctx->data_len;
+    symc_ctx->processed_aad_len = ccm_ctx->processed_aad_len;
+    symc_ctx->total_aad_len = ccm_ctx->total_aad_len;
+
+    symc_ctx->tag_len = ccm_ctx->tag_len;
+    symc_ctx->cmac_tail_len = ccm_ctx->cmac_tail_len;
+    ret = memcpy_s(symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac), ccm_ctx->ccm_cmac, sizeof(ccm_ctx->ccm_cmac));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = memcpy_s(symc_ctx->ctr0, sizeof(symc_ctx->ctr0), ccm_ctx->ctr0, sizeof(ccm_ctx->ctr0));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = memcpy_s(symc_ctx->cmac_tail, sizeof(symc_ctx->cmac_tail), ccm_ctx->cmac_tail, sizeof(ccm_ctx->cmac_tail));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 inner_drv_symc_ccm_get_ctx(td_handle symc_handle, drv_symc_ccm_ctx *ccm_ctx)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = NULL;
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    ccm_ctx->data_len = symc_ctx->data_len;
+    ccm_ctx->processed_aad_len = symc_ctx->processed_aad_len;
+    ccm_ctx->total_aad_len = symc_ctx->total_aad_len;
+
+    ccm_ctx->tag_len = symc_ctx->tag_len;
+    ccm_ctx->cmac_tail_len = symc_ctx->cmac_tail_len;
+    ret = memcpy_s(ccm_ctx->ccm_cmac, sizeof(ccm_ctx->ccm_cmac), symc_ctx->ccm_cmac, sizeof(symc_ctx->ccm_cmac));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = memcpy_s(ccm_ctx->ctr0, sizeof(ccm_ctx->ctr0), symc_ctx->ctr0, sizeof(symc_ctx->ctr0));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = memcpy_s(ccm_ctx->cmac_tail, sizeof(ccm_ctx->cmac_tail), symc_ctx->cmac_tail, sizeof(symc_ctx->cmac_tail));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return CRYPTO_SUCCESS;
+}
+#else
+td_s32 inner_drv_symc_ccm_set_ctx(td_handle symc_handle, const drv_symc_ccm_ctx *ccm_ctx)
+{
+    crypto_unused(symc_handle);
+    crypto_unused(ccm_ctx);
+
+    return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+
+td_s32 inner_drv_symc_ccm_get_ctx(td_handle symc_handle, drv_symc_ccm_ctx *ccm_ctx)
+{
+    crypto_unused(symc_handle);
+    crypto_unused(ccm_ctx);
+
+    return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_ctr_non_align.c b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_ctr_non_align.c
new file mode 100644
index 0000000..d0638bd
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_ctr_non_align.c
@@ -0,0 +1,143 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_symc ctr non align. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+
+#include "drv_symc.h"
+#include "drv_symc_inner.h"
+#include "hal_symc.h"
+#include "crypto_drv_common.h"
+
+#if defined(CONFIG_SYMC_SET_CTR_BLOCK)
+td_s32 inner_drv_symc_set_ctr_block(td_handle symc_handle, const td_u8 *block, td_u32 block_size, td_u32 ctr_offset)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = NULL;
+    drv_symc_param_trace("symc_handle is 0x%x\n", symc_handle);
+    drv_symc_param_dump_trace("block", block, block_size);
+    drv_symc_param_trace("block_size is 0x%x\n", block_size);
+    drv_symc_param_trace("ctr_offset is 0x%x\n", ctr_offset);
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    symc_null_ptr_chk(block);
+    crypto_chk_return(block_size != CRYPTO_AES_BLOCK_SIZE_IN_BYTES, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "block_size is invalid\n");
+
+    ret = memcpy_s(symc_ctx->ctr_last_block, sizeof(symc_ctx->ctr_last_block), block, block_size);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    symc_ctx->ctr_offset = ctr_offset;
+    return TD_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_SYMC_GET_CTR_BLOCK)
+td_s32 inner_drv_symc_get_ctr_block(td_handle symc_handle, td_u8 *block, td_u32 block_size, td_u32 *ctr_offset)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = NULL;
+    drv_symc_param_trace("symc_handle is 0x%x\n", symc_handle);
+    drv_symc_param_trace("block_size is 0x%x\n", block_size);
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    symc_null_ptr_chk(block);
+    symc_null_ptr_chk(ctr_offset);
+    crypto_chk_return(block_size != CRYPTO_AES_BLOCK_SIZE_IN_BYTES, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "block_size is invalid\n");
+
+    ret = memcpy_s(block, block_size, symc_ctx->ctr_last_block, sizeof(symc_ctx->ctr_last_block));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    *ctr_offset = symc_ctx->ctr_offset;
+
+    drv_symc_param_dump_trace("get block", block, block_size);
+    drv_symc_param_trace("get ctr_offset is 0x%x\n", *ctr_offset);
+    return TD_SUCCESS;
+}
+#endif
+
+static td_s32 inner_drv_cipher_ctr_process_one_zero_block(td_u32 chn_num, drv_symc_context_t *symc_ctx)
+{
+    td_u32 ret;
+    td_u8 *zero_block = crypto_malloc_coherent(CRYPTO_AES_BLOCK_SIZE_IN_BYTES, "zero_block");
+    crypto_chk_return(zero_block == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    (td_void)memset_s(zero_block, CRYPTO_AES_BLOCK_SIZE_IN_BYTES, 0, CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+#if defined(CRYPTO_CTR_TRACE_ENABLE)
+    crypto_dump_data("zero_block_before_iv", symc_ctx->iv, sizeof(symc_ctx->iv));
+#endif
+    ret = hal_cipher_symc_set_iv(chn_num, symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_set_iv failed\n");
+
+    ret = inner_drv_symc_common_process(symc_ctx, crypto_get_phys_addr(zero_block), crypto_get_phys_addr(zero_block),
+        CRYPTO_AES_BLOCK_SIZE_IN_BYTES, IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "inner_drv_symc_common_process failed\n");
+
+    ret = memcpy_s(symc_ctx->ctr_last_block, sizeof(symc_ctx->ctr_last_block),
+        zero_block, CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+#if defined(CRYPTO_CTR_TRACE_ENABLE)
+    crypto_dump_data("zero_block_after_iv", symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_dump_data("zero_block_after", zero_block, CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+#endif
+exit_free:
+    crypto_free_coherent(zero_block);
+    return ret;
+}
+
+td_s32 inner_drv_cipher_symc_ctr_process_non_align(drv_symc_context_t *symc_ctx,
+    td_u64 src_phys_addr, td_u64 dst_phys_addr, td_u32 length)
+{
+    td_s32 ret;
+    td_u32 processing_length = length;
+    td_u32 chn_num = symc_ctx->chn_num;
+    if (symc_ctx->ctr_offset != 0) {
+        symc_ctx->ctr_used = crypto_min(CRYPTO_AES_BLOCK_SIZE_IN_BYTES - symc_ctx->ctr_offset, length);
+        ret = crypto_virt_xor_phys_copy_to_phys(dst_phys_addr, symc_ctx->ctr_last_block + symc_ctx->ctr_offset,
+            src_phys_addr, symc_ctx->ctr_used);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_virt_xor_copy_to_phys failed\n");
+        src_phys_addr += symc_ctx->ctr_used;
+        dst_phys_addr += symc_ctx->ctr_used;
+        crypto_log_dbg("ctr skip %d bytes\n", symc_ctx->ctr_used);
+        if (length == symc_ctx->ctr_used) {
+            symc_ctx->ctr_offset = (symc_ctx->ctr_offset + symc_ctx->ctr_used) % CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+            return TD_SUCCESS;
+        }
+        processing_length -= symc_ctx->ctr_used;
+    }
+
+    symc_ctx->ctr_offset = processing_length % CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    processing_length -= symc_ctx->ctr_offset;
+    ret = hal_cipher_symc_set_iv(chn_num, symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed\n");
+
+    if (processing_length != 0) {
+        ret = inner_drv_symc_common_process(symc_ctx, src_phys_addr, dst_phys_addr, processing_length,
+            IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_common_process failed\n");
+    }
+
+    if (symc_ctx->ctr_offset != 0) {
+        ret = inner_drv_cipher_ctr_process_one_zero_block(chn_num, symc_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_cipher_ctr_process_one_zero_block failed\n");
+
+        crypto_log_dbg("ctr xor %d bytes, processing_length is %d, ctr_used is %d\n",
+            symc_ctx->ctr_offset, processing_length, symc_ctx->ctr_used);
+        ret = crypto_virt_xor_phys_copy_to_phys(dst_phys_addr + processing_length,
+            symc_ctx->ctr_last_block, src_phys_addr + processing_length, symc_ctx->ctr_offset);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_virt_xor_copy_to_phys failed\n");
+    }
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_gcm.c b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_gcm.c
new file mode 100644
index 0000000..ecee280
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_gcm.c
@@ -0,0 +1,520 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_symc gcm. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#include "drv_symc.h"
+#include "drv_symc_inner.h"
+#include "drv_symc_outer.h"
+#include "hal_symc.h"
+#include "crypto_drv_common.h"
+
+#if defined(CONFIG_SYMC_GCM_SUPPORT)
+
+static td_s32 inner_drv_symc_gcm_process_aad(drv_symc_context_t *symc_ctx, td_u64 aad_phys_addr, td_u32 aad_len);
+
+static int32_t inner_drv_cipher_symc_gcm_ghash_start(drv_symc_context_t *symc_ctx)
+{
+    symc_ctx->ghash_tail_len = 0;
+    (void)memset_s(symc_ctx->ghash, sizeof(symc_ctx->ghash), 0, sizeof(symc_ctx->ghash));
+    return CRYPTO_SUCCESS;
+}
+
+static int32_t inner_drv_cipher_symc_gcm_ghash_update(drv_symc_context_t *symc_ctx,
+    uint64_t data_phys_addr, uint32_t data_len)
+{
+    int32_t ret;
+    uint32_t left = data_len;
+    uint32_t processed_len = 0;
+    uint32_t processing_len = 0;
+    uint32_t tail_len = symc_ctx->ghash_tail_len;
+    uint32_t tail_buf_len = sizeof(symc_ctx->ghash_tail);
+    uint8_t *ghash = symc_ctx->ghash;
+    uint32_t ghash_len = sizeof(symc_ctx->ghash);
+    uint8_t *ghash_buf = NULL;
+    uint32_t ghash_buf_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+
+    if (data_len == 0) {
+        return CRYPTO_SUCCESS;
+    }
+
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_data("ghash before", ghash, ghash_len);
+    crypto_dump_phys_addr("ghash data", data_phys_addr, data_len);
+#endif
+
+    ghash_buf = crypto_malloc_coherent(ghash_buf_len, "ghash_buf");
+    crypto_chk_return(ghash_buf == NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    processing_len = crypto_min(tail_buf_len - tail_len, data_len);
+    ret = crypto_copy_from_phys_addr(symc_ctx->ghash_tail + tail_len, tail_buf_len - tail_len,
+        data_phys_addr, processing_len);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "crypto_copy_from_phys_addr failed\n");
+    symc_ctx->ghash_tail_len += processing_len;
+
+    /* process one block. */
+    if (symc_ctx->ghash_tail_len == tail_buf_len) {
+        ret = memcpy_s(ghash_buf, ghash_buf_len, symc_ctx->ghash_tail, tail_buf_len);
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = hal_cipher_gcm_ghash_update(symc_ctx->chn_num, crypto_get_phys_addr(ghash_buf),
+            tail_buf_len, ghash, ghash_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "hal_cipher_gcm_ghash_update failed\n");
+        symc_ctx->ghash_tail_len = 0;
+    }
+
+    left -= processing_len;
+    processed_len += processing_len;
+    if (left == 0) {
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+        crypto_dump_data("ghash after", ghash, ghash_len);
+#endif
+        ret = CRYPTO_SUCCESS;
+        goto exit_free;
+    }
+    /* process blocks. */
+    while (left >= tail_buf_len) {
+        ret = crypto_copy_from_phys_addr(ghash_buf, ghash_buf_len, data_phys_addr + processed_len, tail_buf_len);
+        crypto_chk_goto(ret != EOK, exit_free, "crypto_copy_from_phys_addr failed\n");
+
+        ret = hal_cipher_gcm_ghash_update(symc_ctx->chn_num, crypto_get_phys_addr(ghash_buf), tail_buf_len,
+            ghash, ghash_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "hal_cipher_gcm_ghash_update failed\n");
+        left -= tail_buf_len;
+        processed_len += tail_buf_len;
+    }
+    if (left != 0) {
+        ret = crypto_copy_from_phys_addr(symc_ctx->ghash_tail, tail_buf_len, data_phys_addr + processed_len, left);
+        crypto_chk_goto(ret != EOK, exit_free, "crypto_copy_from_phys_addr failed\n");
+    }
+    symc_ctx->ghash_tail_len = left;
+
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_data("ghash after", ghash, ghash_len);
+#endif
+
+    ret = TD_SUCCESS;
+exit_free:
+    crypto_free_coherent(ghash_buf);
+    return ret;
+}
+
+static int32_t inner_drv_cipher_symc_gcm_ghash_finish(drv_symc_context_t *symc_ctx,
+    uint8_t *ghash, uint32_t ghash_len)
+{
+    int32_t ret;
+    if (symc_ctx->ghash_tail_len != 0) {
+        crypto_log_err("ghash data is not aligned to 16-Byte\n");
+        return CRYPTO_FAILURE;
+    }
+    ret = memcpy_s(ghash, ghash_len, symc_ctx->ghash, sizeof(symc_ctx->ghash));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return CRYPTO_SUCCESS;
+}
+
+static int32_t inner_drv_cipher_symc_gcm_compute_j0(drv_symc_context_t *symc_ctx,
+    const uint8_t *gcm_iv, uint32_t gcm_iv_len)
+{
+    int32_t ret;
+    uint8_t iv_padding[CRYPTO_AES_BLOCK_SIZE_IN_BYTES * 2];
+    uint8_t iv_padding_len = sizeof(iv_padding);
+    uint32_t iv_len_in_bit = gcm_iv_len * CRYPTO_BITS_IN_BYTE;
+    uint8_t *gcm_j0_buf = TD_NULL;
+    uint8_t buf_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES * 2;
+    crypto_hal_func_enter();
+
+    gcm_j0_buf = crypto_malloc_coherent(buf_len, "gcm_j0_buf");
+    crypto_chk_return(gcm_j0_buf == NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    iv_len_in_bit = crypto_cpu_to_be32(iv_len_in_bit);
+
+    (void)memset_s(symc_ctx->j0, sizeof(symc_ctx->j0), 0, sizeof(symc_ctx->j0));
+    /* If the IV length is 12 bytes, J0 = IV || 00000000 00000000 00000000 00000001 */
+    if (gcm_iv_len == CRYPTO_GCM_SPECIAL_IV_BYTES) { // for 96 bits, J0 = IV || 00000001
+        ret = memcpy_s(symc_ctx->j0, sizeof(symc_ctx->j0), gcm_iv, gcm_iv_len);
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+        symc_ctx->j0[sizeof(symc_ctx->j0) - 1] = 0x01;  // j0[15] = 0x01
+    } else { /* If the IV length is not 12 bytes, J0 = GHASH{IV || [00..00] || len(IV)} */
+        iv_padding_len = iv_padding_len - gcm_iv_len % CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+        (void)memset_s(iv_padding, sizeof(iv_padding), 0, sizeof(iv_padding));
+        ret = memcpy_s(iv_padding + iv_padding_len - sizeof(td_u32), sizeof(td_u32), &iv_len_in_bit, sizeof(td_u32));
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = inner_drv_cipher_symc_gcm_ghash_start(symc_ctx);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "inner_drv_cipher_symc_gcm_ghash_start failed\n");
+
+        ret = memcpy_s(gcm_j0_buf, buf_len, gcm_iv, gcm_iv_len);
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, crypto_get_phys_addr(gcm_j0_buf), gcm_iv_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "inner_drv_cipher_symc_gcm_ghash_update failed\n");
+
+        ret = memcpy_s(gcm_j0_buf, buf_len, iv_padding, iv_padding_len);
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, crypto_get_phys_addr(gcm_j0_buf), iv_padding_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "inner_drv_cipher_symc_gcm_ghash_update failed\n");
+        ret = inner_drv_cipher_symc_gcm_ghash_finish(symc_ctx, symc_ctx->j0, sizeof(symc_ctx->j0));
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "inner_drv_cipher_symc_gcm_ghash_finish failed\n");
+    }
+
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_data("gcm j0", symc_ctx->j0, sizeof(symc_ctx->j0));
+#endif
+    ret = TD_SUCCESS;
+exit_free:
+    crypto_free_coherent(gcm_j0_buf);
+    crypto_hal_func_exit();
+    return ret;
+}
+
+static td_s32 inner_symc_gcm_cfg_param_check(const crypto_symc_ctrl_t *symc_ctrl)
+{
+    crypto_symc_work_mode mode = symc_ctrl->work_mode;
+    crypto_symc_config_aes_ccm_gcm *ccm_gcm_param = (crypto_symc_config_aes_ccm_gcm *)symc_ctrl->param;
+    td_u32 iv_length = symc_ctrl->iv_length;
+    td_u32 tag_len;
+
+    /* Check for GCM. */
+    if (mode == CRYPTO_SYMC_WORK_MODE_GCM && symc_ctrl->iv_change_flag == CRYPTO_SYMC_GCM_IV_CHANGE_START) {
+        crypto_chk_return(ccm_gcm_param == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "param is NULL\n");
+        tag_len = ccm_gcm_param->tag_len;
+        /* IV lenght for GCM, which should be 1~16. */
+        crypto_chk_return(iv_length == 0 || iv_length > CRYPTO_IV_LEN_IN_BYTES, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "iv_len must be 1~16 for GCM.\n");
+        /* Tag length for GCM should be 1~16.. */
+        crypto_chk_return(tag_len == 0 || tag_len > CRYPTO_AES_MAX_TAG_SIZE, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "tag_len must be 1~16 for GCM.\n");
+    }
+    return TD_SUCCESS;
+}
+
+static void inner_gcm_j0_plus_one(uint8_t *j0, uint32_t j0_len)
+{
+    uint32_t value = CRYPTO_BYTE_MAX + 1;
+    int32_t i = j0_len - 1;
+
+    while (value > CRYPTO_BYTE_MAX && i >= 0) {
+        value = j0[i] + 1;
+        j0[i] = value % CRYPTO_BYTE_MAX;
+        j0--;
+    }
+}
+
+td_s32 drv_cipher_symc_gcm_set_config(drv_symc_context_t *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    hal_symc_config_t hal_symc_config = {0};
+    crypto_symc_config_aes_ccm_gcm *gcm_config = TD_NULL;
+
+    symc_null_ptr_chk(symc_ctx);
+    symc_null_ptr_chk(symc_ctrl);
+
+    ret = inner_symc_gcm_cfg_param_check(symc_ctrl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_symc_gcm_cfg_param_check failed\n");
+
+    hal_symc_config.symc_alg = symc_ctrl->symc_alg;
+    hal_symc_config.work_mode = symc_ctrl->work_mode;
+    hal_symc_config.symc_bit_width = symc_ctrl->symc_bit_width;
+    hal_symc_config.symc_key_length = symc_ctrl->symc_key_length;
+    hal_symc_config.iv_change_flag = symc_ctrl->iv_change_flag;
+    ret = hal_cipher_symc_config(symc_ctx->chn_num, &hal_symc_config);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_config failed, ret is 0x%x\n", ret);
+
+    symc_ctx->symc_alg = symc_ctrl->symc_alg;
+    symc_ctx->work_mode = symc_ctrl->work_mode;
+    symc_ctx->symc_bit_width = symc_ctrl->symc_bit_width;
+    symc_ctx->symc_key_length = symc_ctrl->symc_key_length;
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_GCM_IV_CHANGE_FINISH) {
+        ret = hal_cipher_symc_set_iv(symc_ctx->chn_num, symc_ctrl->iv, sizeof(symc_ctrl->iv));
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed, ret is 0x%x\n", ret);
+        symc_ctx->is_config = TD_TRUE;
+        return CRYPTO_SUCCESS;
+    }
+
+    gcm_config = (crypto_symc_config_aes_ccm_gcm *)symc_ctrl->param;
+    crypto_chk_return(gcm_config == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "gcm_config is NULL\n");
+    crypto_chk_return(gcm_config->aad_len > CRYPTO_SYMC_AAD_MAX_SIZE, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "aad_len is too long\n");
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_GCM_IV_CHANGE_START) {
+        symc_ctx->total_aad_len = gcm_config->total_aad_len;
+        symc_ctx->data_len = gcm_config->data_len;
+        symc_ctx->processed_aad_len = 0;
+        symc_ctx->processed_len = 0;
+
+        /* compute gcm j0 and iv. */
+        ret = inner_drv_cipher_symc_gcm_compute_j0(symc_ctx, symc_ctrl->iv, symc_ctrl->iv_length);
+        crypto_chk_return(ret != EOK, ret, "inner_drv_cipher_symc_gcm_compute_j0 failed, ret is 0x%x\n", ret);
+
+        ret = memcpy_s(symc_ctx->iv, sizeof(symc_ctx->iv), symc_ctx->j0, sizeof(symc_ctx->j0));
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed, ret is 0x%x\n", ret);
+
+        inner_gcm_j0_plus_one(symc_ctx->iv, sizeof(symc_ctx->iv));
+    }
+    /* GCM ADD AAD. */
+    crypto_log_dbg("gcm start process aad\n");
+    ret = inner_drv_symc_gcm_process_aad(symc_ctx, gcm_config->aad_buf.phys_addr, gcm_config->aad_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_gcm_process_aad failed, ret is 0x%x\n", ret);
+
+    symc_ctx->is_config = TD_TRUE;
+    return TD_SUCCESS;
+}
+
+static td_s32 inner_drv_symc_gcm_process_aad(drv_symc_context_t *symc_ctx, td_u64 aad_phys_addr, td_u32 aad_len)
+{
+    td_s32 ret = TD_SUCCESS;
+    uint32_t aad_padding_len = 0;
+    uint8_t *aad_padding = NULL;
+
+    aad_padding = crypto_malloc_coherent(CRYPTO_AES_BLOCK_SIZE_IN_BYTES, "aad_padding_buf");
+    crypto_chk_return(aad_padding == NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    if (symc_ctx->processed_aad_len == 0) {
+        ret = inner_drv_cipher_symc_gcm_ghash_start(symc_ctx);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free,
+            "inner_drv_cipher_symc_gcm_ghash_start failed, ret is 0x%x\n", ret);
+    }
+
+    /* GCM ADD AAD. */
+    if (aad_len != 0) {
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+        crypto_dump_phys_addr("gcm aad", aad_phys_addr, aad_len);
+#endif
+        ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, aad_phys_addr, aad_len);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free,
+            "inner_drv_cipher_symc_gcm_ghash_update failed, ret is 0x%x\n", ret);
+    }
+    if (symc_ctx->processed_aad_len + aad_len == symc_ctx->total_aad_len) {
+        aad_padding_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES - symc_ctx->total_aad_len % CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+        if (aad_padding_len != CRYPTO_AES_BLOCK_SIZE_IN_BYTES) {
+            /* padding must be zeros. */
+            (td_void)memset_s(aad_padding, aad_padding_len, 0, aad_padding_len);
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+            crypto_dump_data("gcm aad_padding", aad_padding, aad_padding_len);
+#endif
+            ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, crypto_get_phys_addr(aad_padding), aad_padding_len);
+            crypto_chk_goto(ret != TD_SUCCESS, exit_free,
+                "inner_drv_cipher_symc_gcm_ghash_update failed, ret is 0x%x\n", ret);
+        }
+    }
+    symc_ctx->processed_aad_len += aad_len;
+
+exit_free:
+    crypto_free_coherent(aad_padding);
+    return ret;
+}
+
+static td_s32 inner_drv_symc_gcm_process_P(drv_symc_context_t *symc_ctx,
+    td_ulong src_phys_addr, td_ulong dst_phys_addr, td_u32 length)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 gcm_p_node_type = 0;
+
+    /* GCM ADD P. */
+    if (length != 0) {
+        gcm_p_node_type = IN_NODE_TYPE_GCM_P | IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST;
+        if (symc_ctx->total_aad_len == 0) {
+            gcm_p_node_type |= IN_NODE_TYPE_GCM_FIRST;
+        }
+        ret = inner_drv_symc_common_process(symc_ctx, src_phys_addr, dst_phys_addr, length, gcm_p_node_type);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_common_process failed, ret is 0x%x\n", ret);
+    }
+    symc_ctx->processed_len += length;
+    return ret;
+}
+
+static td_s32 inner_drv_symc_gcm_process_clen(drv_symc_context_t *symc_ctx)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 aad_len_in_bit = 0;
+    td_u32 data_len_in_bit = 0;
+    td_u8 *clen_buf = TD_NULL;
+    td_u32 clen_buf_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+
+    clen_buf = crypto_malloc_coherent(clen_buf_len, "clen_buf");
+    crypto_chk_return(clen_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    /* GCM ADD LEN. */
+    aad_len_in_bit = crypto_cpu_to_be32(symc_ctx->processed_aad_len * CRYPTO_BITS_IN_BYTE);
+    data_len_in_bit = crypto_cpu_to_be32(symc_ctx->processed_len * CRYPTO_BITS_IN_BYTE);
+    (td_void)memset_s(clen_buf, clen_buf_len, 0x00, clen_buf_len);
+    (td_void)memcpy_s(clen_buf + 8 - sizeof(td_u32),        /* 8: bit15~8 for aad_len. */
+        sizeof(td_u32), &aad_len_in_bit, sizeof(td_u32));
+    (td_void)memcpy_s(clen_buf + 16 - sizeof(td_u32), sizeof(td_u32),   /* 16: bit7~0 for data_len. */
+        &data_len_in_bit, sizeof(td_u32));
+
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_data("gcm_clen_buf", clen_buf, clen_buf_len);
+#endif
+    ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, crypto_get_phys_addr(clen_buf), clen_buf_len);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "inner_drv_cipher_symc_gcm_ghash_update failed, ret is 0x%x\n", ret);
+
+exit_free:
+    crypto_free_coherent(clen_buf);
+    return ret;
+}
+
+td_s32 inner_drv_cipher_symc_gcm_process(drv_symc_context_t *symc_ctx, td_ulong src_phys_addr,
+    td_ulong dst_phys_addr, td_u32 length)
+{
+    td_s32 ret;
+    td_u8 p_padding_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    td_u8 *p_padding = NULL;
+    td_u8 *gcm_buf = NULL;
+    hal_symc_config_t symc_config = {0};
+
+    symc_null_ptr_chk(symc_ctx);
+    gcm_buf = crypto_malloc_coherent(p_padding_len, "gcm_buf");
+    crypto_chk_return(gcm_buf == NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+    p_padding = gcm_buf;
+
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_phys_addr("gcm_buf", crypto_get_phys_addr(gcm_buf), p_padding_len);
+    crypto_dump_phys_addr("p_padding", crypto_get_phys_addr(p_padding), p_padding_len);
+#endif
+    (void)memset_s(p_padding, CRYPTO_AES_BLOCK_SIZE_IN_BYTES, 0, CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+    if (length % CRYPTO_AES_BLOCK_SIZE_IN_BYTES == 0) {
+        p_padding_len = 0;
+    } else {
+        p_padding_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES - length % CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    }
+    if (symc_ctx->is_decrypt == TD_TRUE) { /* Decrypt, ghash update the cipher text. */
+        ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, src_phys_addr, length);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free,
+            "inner_drv_cipher_symc_gcm_ghash_update failed, ret is 0x%x\n", ret);
+
+        ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, crypto_get_phys_addr(p_padding), p_padding_len);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free,
+            "inner_drv_cipher_symc_gcm_ghash_update failed, ret is 0x%x\n", ret);
+    }
+
+    symc_config.symc_alg = symc_ctx->symc_alg;
+    symc_config.work_mode = symc_ctx->work_mode;
+    symc_config.symc_key_length = symc_ctx->symc_key_length;
+    symc_config.symc_bit_width = symc_ctx->symc_bit_width;
+
+    ret = hal_cipher_symc_config(symc_ctx->chn_num, &symc_config);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_config failed\n");
+
+    /* GCM ADD P. */
+    crypto_log_dbg("gcm start process p\n");
+    ret = inner_drv_symc_gcm_process_P(symc_ctx, src_phys_addr, dst_phys_addr, length);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "inner_drv_symc_gcm_process_P failed, ret is 0x%x\n", ret);
+
+    if (symc_ctx->is_decrypt == TD_FALSE) { /* Encrypt, ghash update the cipher text. */
+        ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, dst_phys_addr, length);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free,
+            "inner_drv_cipher_symc_gcm_ghash_update failed, ret is 0x%x\n", ret);
+
+        ret = inner_drv_cipher_symc_gcm_ghash_update(symc_ctx, crypto_get_phys_addr(p_padding), p_padding_len);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_free,
+            "inner_drv_cipher_symc_gcm_ghash_update failed, ret is 0x%x\n", ret);
+    }
+
+exit_free:
+    crypto_free_coherent(gcm_buf);
+    return ret;
+}
+
+td_s32 inner_drv_cipher_symc_gcm_get_tag(drv_symc_context_t *symc_ctx, td_u8 *tag, td_u32 tag_length)
+{
+    td_s32 ret;
+
+    /* GCM ADD LEN. */
+    crypto_log_dbg("gcm start process clen\n");
+    ret = inner_drv_symc_gcm_process_clen(symc_ctx);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_gcm_process_clen failed, ret is 0x%x\n", ret);
+
+    /* Calculate ghash. */
+    ret = inner_drv_cipher_symc_gcm_ghash_finish(symc_ctx, symc_ctx->ghash, sizeof(symc_ctx->ghash));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_cipher_symc_gcm_ghash_finish failed, ret is 0x%x\n", ret);
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_data("gcm ghash finish", symc_ctx->ghash, sizeof(symc_ctx->ghash));
+#endif
+    ret = hal_cipher_gcm_compute_tag(symc_ctx->chn_num, symc_ctx->ghash, sizeof(symc_ctx->ghash),
+        symc_ctx->j0, sizeof(symc_ctx->j0), tag, tag_length);
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_data("gcm tag", tag, tag_length);
+#endif
+    return ret;
+}
+
+td_s32 inner_drv_symc_gcm_set_ctx(td_handle symc_handle, const drv_symc_gcm_ctx *gcm_ctx)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = NULL;
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    symc_ctx->data_len = gcm_ctx->data_len;
+    symc_ctx->processed_aad_len = gcm_ctx->processed_aad_len;
+    symc_ctx->total_aad_len = gcm_ctx->total_aad_len;
+    symc_ctx->processed_len = gcm_ctx->processed_len;
+
+    symc_ctx->ghash_tail_len = gcm_ctx->ghash_tail_len;
+    ret = memcpy_s(symc_ctx->ghash_tail, sizeof(symc_ctx->ghash_tail),
+        gcm_ctx->ghash_tail, sizeof(gcm_ctx->ghash_tail));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = memcpy_s(symc_ctx->ghash, sizeof(symc_ctx->ghash), gcm_ctx->ghash, sizeof(gcm_ctx->ghash));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = memcpy_s(symc_ctx->j0, sizeof(symc_ctx->j0), gcm_ctx->j0, sizeof(gcm_ctx->j0));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 inner_drv_symc_gcm_get_ctx(td_handle symc_handle, drv_symc_gcm_ctx *gcm_ctx)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = NULL;
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    gcm_ctx->data_len = symc_ctx->data_len;
+    gcm_ctx->processed_aad_len = symc_ctx->processed_aad_len;
+    gcm_ctx->total_aad_len = symc_ctx->total_aad_len;
+    gcm_ctx->processed_len = symc_ctx->processed_len;
+
+    gcm_ctx->ghash_tail_len = symc_ctx->ghash_tail_len;
+    ret = memcpy_s(gcm_ctx->ghash_tail, sizeof(gcm_ctx->ghash_tail),
+        symc_ctx->ghash_tail, sizeof(symc_ctx->ghash_tail));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = memcpy_s(gcm_ctx->ghash, sizeof(gcm_ctx->ghash), symc_ctx->ghash, sizeof(symc_ctx->ghash));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = memcpy_s(gcm_ctx->j0, sizeof(gcm_ctx->j0), symc_ctx->j0, sizeof(symc_ctx->j0));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return CRYPTO_SUCCESS;
+}
+#else
+td_s32 inner_drv_symc_gcm_set_ctx(td_handle symc_handle, const drv_symc_gcm_ctx *gcm_ctx)
+{
+    crypto_unused(symc_handle);
+    crypto_unused(gcm_ctx);
+
+    return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+
+td_s32 inner_drv_symc_gcm_get_ctx(td_handle symc_handle, drv_symc_gcm_ctx *gcm_ctx)
+{
+    crypto_unused(symc_handle);
+    crypto_unused(gcm_ctx);
+
+    return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_get_config.c b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_get_config.c
new file mode 100644
index 0000000..2f16b07
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_get_config.c
@@ -0,0 +1,44 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_symc get config. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+#include "drv_symc.h"
+#include "drv_symc_inner.h"
+#include "hal_symc.h"
+#include "crypto_drv_common.h"
+
+td_s32 drv_cipher_symc_get_config(td_handle symc_handle, crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    td_u32 chn_num;
+    hal_symc_config_t hal_symc_config = {0};
+    drv_symc_context_t *symc_ctx = TD_NULL;
+
+    crypto_drv_func_enter();
+    ret = inner_symc_drv_handle_chk(symc_handle);
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+    symc_null_ptr_chk(symc_ctrl);
+
+    chn_num = symc_handle;
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid handle\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(symc_ctx->is_config == TD_FALSE,
+        SYMC_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG), "call set_config first\n");
+
+    ret = hal_cipher_symc_get_config(chn_num, &hal_symc_config);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_unlock_chn failed, ret is 0x%x\n", ret);
+
+    ret = memcpy_s(symc_ctrl->iv, sizeof(symc_ctx->iv), symc_ctx->iv, sizeof(symc_ctx->iv));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed, ret is 0x%x\n", ret);
+
+    crypto_drv_func_exit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_inner.h b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_inner.h
new file mode 100755
index 0000000..30f9e60
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_inner.h
@@ -0,0 +1,115 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver common header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef DRV_SYMC_INNER_H
+#define DRV_SYMC_INNER_H
+
+#include "crypto_symc_struct.h"
+
+#define SYMC_COMPAT_ERRNO(err_code)     DRV_COMPAT_ERRNO(ERROR_MODULE_SYMC, err_code)
+#if defined(CONFIG_DRV_SYMC_PARAM_TRACE_ENABLE)
+#define drv_symc_param_trace            crypto_param_trace
+#define drv_symc_param_dump_trace       crypto_param_dump_trace
+#else
+#define drv_symc_param_trace(...)
+#define drv_symc_param_dump_trace(...)
+#endif
+
+typedef struct {
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    td_u32 chn_num;
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    crypto_symc_bit_width symc_bit_width;
+    td_u32 last_pattern_len;
+    td_handle keyslot_handle;
+    td_u32 iv_change_flag;
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+    td_u32 ctr_offset;
+    td_u32 ctr_used;
+    td_u8 ctr_last_block[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+#endif
+#if defined(CONFIG_SYMC_CCM_SUPPORT) || defined(CONFIG_SYMC_GCM_SUPPORT)
+    td_u32 data_len;        /* For CCM/GCM. */
+    td_u32 processed_aad_len;
+    td_u32 total_aad_len;
+    td_u32 processed_len;   /* For CCM/GCM. */
+#endif
+#if defined(CONFIG_SYMC_GCM_SUPPORT)
+    td_u8 ghash_tail_len;
+    td_u8 ghash_tail[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u8 ghash[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u8 j0[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+#endif
+#if defined(CONFIG_SYMC_CCM_SUPPORT)
+    td_u32 tag_len;
+    td_u8 ccm_cmac[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u8 ctr0[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    /* CCM CMAC. */
+    td_u8 cmac_tail_len;
+    td_u8 cmac_tail[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+#endif
+#if defined(CONFIG_SYMC_CBC_MAC_SUPPORT)
+    td_u8 mac[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    crypto_cmac_ctx cmac_ctx;
+#endif
+    td_u32 is_decrypt           : 1;
+    td_u32 is_create_keyslot    : 1;
+    td_u32 is_open              : 1;
+    td_u32 is_config            : 1;
+    td_u32 is_attached          : 1;
+} drv_symc_context_t;
+
+td_s32 inner_drv_symc_set_iv(td_handle symc_handle, const td_u8 *iv, td_u32 iv_len);
+
+drv_symc_context_t *inner_get_symc_ctx(td_handle symc_handle);
+
+td_s32 inner_drv_symc_crypto_chk(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 inner_symc_drv_handle_chk(td_handle symc_handle);
+
+int32_t inner_drv_symc_common_process(drv_symc_context_t *symc_ctx, td_u64 src_phys_addr, td_u64 dst_phys_addr,
+    td_u32 length, td_u32 node_type);
+
+/* CCM. */
+td_s32 drv_cipher_symc_ccm_set_config(drv_symc_context_t *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 inner_drv_cipher_symc_ccm_process(drv_symc_context_t *symc_ctx, td_ulong src_phys_addr,
+    td_ulong dst_phys_addr, td_u32 length);
+
+td_s32 inner_drv_cipher_symc_ccm_get_tag(drv_symc_context_t *symc_ctx, td_u8 *tag, td_u32 tag_length);
+
+int32_t inner_drv_cipher_symc_ccm_cmac_start(drv_symc_context_t *symc_ctx);
+
+int32_t inner_drv_cipher_symc_ccm_cmac_update(drv_symc_context_t *symc_ctx,
+    uint64_t data_phys_addr, uint32_t data_len);
+
+int32_t inner_drv_cipher_symc_ccm_cmac_finish(drv_symc_context_t *symc_ctx);
+
+/* GCM. */
+td_s32 drv_cipher_symc_gcm_set_config(drv_symc_context_t *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 inner_drv_cipher_symc_gcm_process(drv_symc_context_t *symc_ctx, td_ulong src_phys_addr,
+    td_ulong dst_phys_addr, td_u32 length);
+
+td_s32 inner_drv_cipher_symc_gcm_get_tag(drv_symc_context_t *symc_ctx, td_u8 *tag, td_u32 tag_length);
+
+/* For CTR non align. */
+td_s32 inner_drv_cipher_symc_ctr_process_non_align(drv_symc_context_t *symc_ctx,
+    td_u64 src_phys_addr, td_u64 dst_phys_addr, td_u32 length);
+
+/* Only for CENC. */
+td_void cenc_ddr_unmap_input(td_u32 chn_num);
+
+td_void cenc_ddr_unmap_output(td_u32 chn_num);
+
+td_void cenc_ddr_release(td_void);
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_mac.c b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_mac.c
new file mode 100755
index 0000000..56bc4a4
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_mac.c
@@ -0,0 +1,189 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_symc mac. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_SYMC_CMAC_SUPPORT) || defined(CONFIG_SYMC_CBC_MAC_SUPPORT)
+
+#include "drv_symc.h"
+#include "drv_symc_inner.h"
+#include "drv_symc_outer.h"
+#include "hal_symc.h"
+#include "crypto_drv_common.h"
+
+td_s32 drv_cipher_mac_start(td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr)
+{
+    td_s32 ret;
+    crypto_symc_attr symc_attr = {0};
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    td_u32 chn_num;
+    hal_symc_config_t symc_config = {0};
+    crypto_drv_func_enter();
+    symc_null_ptr_chk(symc_handle);
+    symc_null_ptr_chk(mac_attr);
+
+#if !defined(CONFIG_SYMC_SM4_MAC_SUPPORT)
+    crypto_chk_return(mac_attr->symc_alg != CRYPTO_SYMC_ALG_AES, SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT),
+        "MAC only support AES\n");
+#endif
+    ret = drv_cipher_symc_create(symc_handle, &symc_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_symc_create failed\n");
+
+    symc_ctx = inner_get_symc_ctx(*symc_handle);
+    crypto_chk_goto_with_ret(ret, symc_ctx == TD_NULL, error_symc_destroy,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "symc_handle is invalid\n");
+    crypto_chk_goto_with_ret(ret, symc_ctx->is_open == TD_FALSE, error_symc_destroy,
+        SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    chn_num = *symc_handle;
+    symc_config.symc_alg = mac_attr->symc_alg;
+    /* For Both CBC_MAC and CMAC, the first work_mdoe is CBC_MAC. */
+    symc_config.work_mode = CRYPTO_SYMC_WORK_MODE_CBC_MAC;
+    symc_config.symc_bit_width = CRYPTO_SYMC_BIT_WIDTH_128BIT;
+    symc_config.symc_key_length = mac_attr->symc_key_length;
+
+    ret = hal_cipher_symc_config(chn_num, &symc_config);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "hal_cipher_symc_config failed\n");
+
+    ret = hal_cipher_symc_attach(chn_num, mac_attr->keyslot_chn);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "hal_cipher_symc_config failed\n");
+
+    (void)memset_s(symc_ctx->mac, sizeof(symc_ctx->mac), 0, sizeof(symc_ctx->mac));
+    ret = hal_cipher_symc_set_iv(chn_num, symc_ctx->mac, sizeof(symc_ctx->mac));
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "hal_cipher_symc_set_iv failed\n");
+
+    symc_ctx->work_mode = mac_attr->work_mode;
+    return TD_SUCCESS;
+error_symc_destroy:
+    drv_cipher_symc_destroy(*symc_handle);
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_mac_update(td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length)
+{
+    td_s32 ret;
+    td_u32 chn_num;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_drv_func_enter();
+
+    symc_null_ptr_chk(src_buf);
+    crypto_chk_return(length == 0 || length > CRYPTO_SYMC_MAC_UPDATE_MAX_LEN,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "length is Invalid\n");
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "symc_handle is invalid\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    chn_num = symc_handle;
+
+    ret = hal_cipher_symc_set_iv(chn_num, symc_ctx->mac, sizeof(symc_ctx->mac));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed\n");
+
+    if (symc_ctx->work_mode == CRYPTO_SYMC_WORK_MODE_CMAC) {
+        ret = hal_cipher_symc_cmac_update(chn_num, crypto_get_phys_addr(src_buf->virt_addr), length,
+            &symc_ctx->cmac_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_cmac_update failed, ret is 0x%x\n", ret);
+    } else {
+        ret = hal_cipher_symc_cbc_mac_update(chn_num, crypto_get_phys_addr(src_buf->virt_addr), length,
+            symc_ctx->cmac_ctx.mac, sizeof(symc_ctx->cmac_ctx.mac));
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_cbc_mac_update failed, ret is 0x%x\n", ret);
+    }
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 drv_cipher_mac_finish(td_handle symc_handle, td_u8 *mac, td_u32 *mac_length)
+{
+    td_s32 ret;
+    td_u32 chn_num;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_drv_func_enter();
+
+    symc_null_ptr_chk(mac);
+    symc_null_ptr_chk(mac_length);
+    crypto_chk_return(*mac_length < CRYPTO_AES_BLOCK_SIZE_IN_BYTES, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "mac_length is not enough\n");
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "symc_handle is invalid\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    chn_num = symc_handle;
+
+    if (symc_ctx->work_mode == CRYPTO_SYMC_WORK_MODE_CMAC) {
+        ret = hal_cipher_symc_cmac_finish(chn_num, &symc_ctx->cmac_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_cmac_finish failed, ret is 0x%x\n", ret);
+
+        ret = memcpy_s(mac, *mac_length, symc_ctx->cmac_ctx.mac, sizeof(symc_ctx->cmac_ctx.mac));
+        crypto_chk_return(ret != TD_SUCCESS, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed, ret is 0x%x\n", ret);
+    } else {
+        ret = memcpy_s(mac, *mac_length, symc_ctx->cmac_ctx.mac, sizeof(symc_ctx->cmac_ctx.mac));
+        crypto_chk_return(ret != TD_SUCCESS, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed, ret is 0x%x\n", ret);
+    }
+
+#if defined(CONFIG_SYMC_MAC_TRACE_ENABLE)
+    crypto_dump_data("mac_out_mac", mac, *mac_length);
+#endif
+    *mac_length = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+
+    (td_void)drv_cipher_symc_destroy(symc_handle);
+    crypto_drv_func_exit();
+    return 0;
+}
+
+td_s32 inner_drv_symc_cbc_mac_set_ctx(td_handle symc_handle, const td_u8 *mac, uint32_t mac_len)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_drv_func_enter();
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "symc_handle is invalid\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    ret = memcpy_s(symc_ctx->mac, sizeof(symc_ctx->mac), mac, mac_len);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+int32_t inner_drv_mac_set_ctx(td_handle symc_handle, const crypto_cmac_ctx *mac_ctx)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_drv_func_enter();
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "symc_handle is invalid\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    ret = memcpy_s(&symc_ctx->cmac_ctx, sizeof(crypto_cmac_ctx), mac_ctx, sizeof(crypto_cmac_ctx));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+int32_t inner_drv_mac_get_ctx(td_handle symc_handle, crypto_cmac_ctx *mac_ctx)
+{
+    td_s32 ret;
+    drv_symc_context_t *symc_ctx = TD_NULL;
+    crypto_drv_func_enter();
+
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "symc_handle is invalid\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    ret = memcpy_s(mac_ctx, sizeof(crypto_cmac_ctx), &symc_ctx->cmac_ctx, sizeof(crypto_cmac_ctx));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_outer.h b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_outer.h
new file mode 100644
index 0000000..562e5f4
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_outer.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef DRV_SYMC_OUTER_H
+#define DRV_SYMC_OUTER_H
+
+#include "crypto_hash_struct.h"
+#include "crypto_symc_struct.h"
+
+typedef struct {
+    td_u8 mac[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 mac_length;
+    td_u8 tail[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 tail_length;
+} crypto_symc_mac_ctx;
+
+td_s32 inner_symc_drv_handle_chk(td_handle symc_handle);
+
+td_s32 inner_drv_get_mac_ctx(td_handle symc_handle, crypto_symc_mac_ctx *mac_ctx);
+
+td_s32 inner_drv_set_mac_ctx(td_handle symc_handle, const crypto_symc_mac_ctx *mac_ctx);
+
+td_s32 inner_symc_cfg_param_check(const crypto_symc_ctrl_t *symc_ctrl);
+
+typedef struct {
+    td_u8 *iv0;
+    td_u32 iv0_length;
+    td_u8 *iv_mac;
+    td_u32 iv_mac_length;
+    td_u32 data_length;
+    td_u32 processed_length;
+    td_u32 aad_len;
+} drv_symc_ex_context_t;
+
+td_s32 inner_drv_symc_get_iv0(td_handle symc_handle, td_u8 *iv0, td_u32 iv0_length);
+
+td_s32 inner_drv_symc_get_iv_mac(td_handle symc_handle, td_u8 *iv_mac, td_u32 iv_mac_length);
+
+td_s32 inner_drv_symc_ex_restore(td_handle symc_handle, const drv_symc_ex_context_t *symc_ex_ctx);
+
+td_s32 inner_drv_symc_set_ctr_block(td_handle symc_handle, const td_u8 *block, td_u32 block_size, td_u32 ctr_offset);
+
+td_s32 inner_drv_symc_get_ctr_block(td_handle symc_handle, td_u8 *block, td_u32 block_size, td_u32 *ctr_offset);
+
+td_s32 inner_drv_symc_set_iv(td_handle symc_handle, const td_u8 *iv, td_u32 iv_len);
+
+td_s32 inner_drv_symc_get_iv(td_handle symc_handle, td_u8 *iv, td_u32 iv_len);
+
+typedef struct {
+    td_u32 data_len;        /* For CCM/GCM. */
+    td_u32 processed_aad_len;
+    td_u32 total_aad_len;
+    td_u32 tag_len;
+    td_u8 ccm_cmac[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u8 ctr0[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    /* CCM CMAC. */
+    td_u8 cmac_tail_len;
+    td_u8 cmac_tail[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+} drv_symc_ccm_ctx;
+
+typedef struct {
+    td_u32 data_len;        /* For CCM/GCM. */
+    td_u32 processed_aad_len;
+    td_u32 total_aad_len;
+    td_u32 processed_len;   /* For CCM/GCM. */
+    td_u8 ghash_tail_len;
+    td_u8 ghash_tail[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u8 ghash[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u8 j0[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+} drv_symc_gcm_ctx;
+
+td_s32 inner_drv_symc_set_iv(td_handle symc_handle, const td_u8 *iv, td_u32 iv_len);
+
+td_s32 inner_drv_symc_get_iv(td_handle symc_handle, td_u8 *iv, td_u32 iv_len);
+
+/* CCM. */
+td_s32 inner_drv_symc_ccm_set_ctx(td_handle symc_handle, const drv_symc_ccm_ctx *ccm_ctx);
+
+td_s32 inner_drv_symc_ccm_get_ctx(td_handle symc_handle, drv_symc_ccm_ctx *ccm_ctx);
+
+/* GCM. */
+td_s32 inner_drv_symc_gcm_set_ctx(td_handle symc_handle, const drv_symc_gcm_ctx *gcm_ctx);
+
+td_s32 inner_drv_symc_gcm_get_ctx(td_handle symc_handle, drv_symc_gcm_ctx *gcm_ctx);
+
+/* CMAC&CBC_MAC. */
+int32_t inner_drv_mac_set_ctx(td_handle symc_handle, const crypto_cmac_ctx *mac_ctx);
+
+int32_t inner_drv_mac_get_ctx(td_handle symc_handle, crypto_cmac_ctx *mac_ctx);
+
+/* CBC_MAC. */
+td_s32 inner_drv_symc_cbc_mac_set_ctx(td_handle symc_handle, const td_u8 *mac, uint32_t mac_len);
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_proc.c b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_proc.c
new file mode 100644
index 0000000..1b0418a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/symc/drv_symc_proc.c
@@ -0,0 +1,57 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides drv_symc proc. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+
+#include "drv_symc.h"
+#include "drv_symc_inner.h"
+#include "hal_symc.h"
+#include "crypto_drv_common.h"
+#if defined(CONFIG_SYMC_PROC_SUPPORT)
+
+td_s32 drv_cipher_symc_get_proc_info(td_handle symc_handle, crypto_symc_proc_info *proc_symc_info)
+{
+    td_s32 ret;
+    td_u32 chn_num;
+    drv_symc_context_t *drv_symc_ctx = TD_NULL;
+
+    crypto_drv_func_enter();
+    symc_null_ptr_chk(proc_symc_info);
+
+    drv_symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(drv_symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed\n");
+
+    chn_num = drv_symc_ctx->chn_num;
+    proc_symc_info->chn_id = chn_num;
+    proc_symc_info->open = drv_symc_ctx->is_open;
+
+    if (drv_symc_ctx->is_open == TD_FALSE) {
+        return SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+
+    if (drv_symc_ctx->is_config == TD_FALSE) {
+        return SYMC_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG);
+    }
+
+    ret = hal_cipher_symc_get_proc_info(chn_num, proc_symc_info);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_get_proc_info, ret is 0x%x\n", ret);
+
+    ret = hal_cipher_symc_get_iv(chn_num, proc_symc_info->iv, sizeof(proc_symc_info->iv));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_get_iv failed, ret is 0x%x\n", ret);
+
+    crypto_drv_func_exit();
+    return ret;
+}
+#else
+td_s32 drv_cipher_symc_get_proc_info(td_handle symc_handle, crypto_symc_proc_info *proc_symc_info)
+{
+    crypto_unused(symc_handle);
+    crypto_unused(proc_symc_info);
+
+    return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/drv_code/trng/drv_trng.c b/bsp/security_subsys/security_subsys_common/drv_code/trng/drv_trng.c
new file mode 100644
index 0000000..56f1cd1
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/drv_code/trng/drv_trng.c
@@ -0,0 +1,85 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver trng. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#include "drv_trng.h"
+
+#include "hal_trng.h"
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#define TRNG_COMPAT_ERRNO(err_code)     DRV_COMPAT_ERRNO(ERROR_MODULE_TRNG, err_code)
+#define TRNG_ONCE_WIDTH_IN_BYTE         4
+
+static td_bool g_drv_trng_init_flag = TD_FALSE;
+
+td_s32 drv_cipher_trng_init(td_void)
+{
+    td_s32 ret;
+    if (g_drv_trng_init_flag == TD_TRUE) {
+        return TD_SUCCESS;
+    }
+    ret = hal_cipher_trng_init();
+    g_drv_trng_init_flag = TD_TRUE;
+
+    return ret;
+}
+
+/* times try to read rang */
+#define RANG_READ_TRY_TIME 0x40
+
+td_s32 drv_cipher_trng_get_random(td_u32 *randnum)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 i;
+    crypto_chk_return(g_drv_trng_init_flag == TD_FALSE, TRNG_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(randnum == TD_NULL, TRNG_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "randnum is NULL\n");
+
+    for (i = 0; i < RANG_READ_TRY_TIME; i++) {
+        ret = hal_cipher_trng_get_random(randnum);
+        if (ret == TD_SUCCESS) {
+            return ret;
+        }
+    }
+
+    return TD_FAILURE;
+}
+
+td_s32 drv_cipher_trng_get_multi_random(td_u32 size, td_u8 *randnum)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 cnt;
+    td_u32 i;
+    td_u32 randnum_once = 0;
+    td_u32 tail = 0;
+    crypto_chk_return(g_drv_trng_init_flag == TD_FALSE, TRNG_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(randnum == TD_NULL, TRNG_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "randnum is NULL\n");
+    cnt = size / TRNG_ONCE_WIDTH_IN_BYTE;
+    for (i = 0; i < cnt; i++) {
+        ret = drv_cipher_trng_get_random(&randnum_once);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "ERROR! drv_cipher_trng_get_random failed!\n");
+        (void)memcpy_s(randnum, TRNG_ONCE_WIDTH_IN_BYTE, &randnum_once, TRNG_ONCE_WIDTH_IN_BYTE);
+        randnum += TRNG_ONCE_WIDTH_IN_BYTE;
+    }
+    /* less then 4 byte */
+    tail = size - cnt * TRNG_ONCE_WIDTH_IN_BYTE;
+    if (tail != 0) {
+        ret = drv_cipher_trng_get_random(&randnum_once);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "ERROR! drv_cipher_trng_get_random failed!\n");
+        memcpy_s(randnum, tail, &randnum_once, tail);
+    }
+    return ret;
+}
+
+td_s32 drv_cipher_trng_deinit(td_void)
+{
+    if (g_drv_trng_init_flag == TD_FALSE) {
+        return TD_SUCCESS;
+    }
+    g_drv_trng_init_flag = TD_FALSE;
+    return hal_cipher_trng_deinit();
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_hard.c b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_hard.c
new file mode 100644
index 0000000..73cc970
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_hard.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+#if defined(CONFIG_KM_KEYSLOT_HARD_SUPPORT)
+#include "hal_keyslot.h"
+#include "hal_keyslot_reg.h"
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#define KEYSLOT_TYPE_MCIPHER    0
+#define KEYSLOT_TYPE_HMAC       1
+
+#define KM_COMPAT_ERRNO(err_code)     HAL_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+static td_bool inner_kslot_chn_is_locked(td_u32 keyslot_num, td_u32 keyslot_type_reg_value, td_u32 *locked_cpu)
+{
+    kc_rd_slot_num slot = {0};
+    kc_rd_lock_status stat = {0};
+
+    slot.u32 = km_reg_read(KC_RD_SLOT_NUM);
+    slot.bits.slot_cfg_type = keyslot_type_reg_value; /* sym or hash */
+    slot.bits.slot_num_cfg = keyslot_num;
+    km_reg_write(KC_RD_SLOT_NUM, slot.u32);
+
+    stat.u32 = km_reg_read(KC_RD_LOCK_STATUS);
+    if (locked_cpu != TD_NULL) {
+        *locked_cpu = stat.bits.rd_lock_status;
+    }
+    if (stat.bits.rd_lock_status) {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+static td_bool inner_kslot_is_busy(td_void)
+{
+    kc_flush_busy kc_busy = {0};
+    crypto_cpu_type cpu_type = crypto_get_cpu_type();
+    switch (cpu_type) {
+        case CRYPTO_CPU_TYPE_ACPU:
+            kc_busy.u32 = km_reg_read(KC_REECPU_FLUSH_BUSY);
+            break;
+        case CRYPTO_CPU_TYPE_SCPU:
+            kc_busy.u32 = km_reg_read(KC_TEECPU_FLUSH_BUSY);
+            break;
+        default:
+            crypto_log_err("invalid cpu type\n");
+            return TD_TRUE;
+    }
+    if (kc_busy.bits.flush_busy) {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+static td_bool inner_kslot_is_unlock_failed(td_void)
+{
+    kc_flush_busy kc_busy = {0};
+    crypto_cpu_type cpu_type = crypto_get_cpu_type();
+    switch (cpu_type) {
+        case CRYPTO_CPU_TYPE_ACPU:
+            kc_busy.u32 = km_reg_read(KC_REECPU_FLUSH_BUSY);
+            break;
+        case CRYPTO_CPU_TYPE_SCPU:
+            kc_busy.u32 = km_reg_read(KC_TEECPU_FLUSH_BUSY);
+            break;
+        default:
+            crypto_log_err("invalid cpu type\n");
+            return TD_TRUE;
+    }
+    if (kc_busy.bits.flush_unlock_fail) {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+#define KSLOT_TIMEOUT           1000000
+static td_s32 inner_kslot_wait_idle(void)
+{
+    td_u32 time_out = KSLOT_TIMEOUT;
+
+    while (time_out) {
+        if (inner_kslot_is_busy() == TD_FALSE) {
+            break;
+        }
+        crypto_udelay(1);
+        --time_out;
+    }
+    if (time_out == 0) {
+        return KM_COMPAT_ERRNO(ERROR_KEYSLOT_TIMEOUT);
+    }
+
+    return TD_SUCCESS;
+}
+
+#define KS_STAT_UN_LOCK     0x0
+#define KS_STAT_REE_LOCK    0x1
+#define KS_STAT_TEE_LOCK    0x2
+
+#define KS_CPU_LOCK         1
+#define KS_CPU_UNLOCK       0
+td_s32 hal_keyslot_lock(td_u32 keyslot_num, crypto_keyslot_type keyslot_type)
+{
+    td_u32 keyslot_type_reg_value = 0;
+    crypto_cpu_type cpu_type = crypto_get_cpu_type();
+    td_u32 cpu_reg_addr = KC_REECPU_LOCK_CMD;       /* default is ree cpu. */
+    td_u32 lock_state_expected = KS_STAT_REE_LOCK;  /* default is ree cpu. */
+    td_u32 lock_state = 0;
+    kc_cpu_lock_cmd lock_cmd = {0};
+
+    switch (keyslot_type) {
+        case CRYPTO_KEYSLOT_TYPE_MCIPHER:
+            keyslot_type_reg_value = KEYSLOT_TYPE_MCIPHER;
+            break;
+        case CRYPTO_KEYSLOT_TYPE_HMAC:
+            keyslot_type_reg_value = KEYSLOT_TYPE_HMAC;
+            break;
+        default:
+            crypto_log_err("invalid keyslot_type\n");
+            return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    if (inner_kslot_chn_is_locked(keyslot_num, keyslot_type_reg_value, TD_NULL)) {
+        return KM_COMPAT_ERRNO(ERROR_KEYSLOT_LOCK);
+    }
+
+    if (inner_kslot_is_busy()) {
+        return KM_COMPAT_ERRNO(ERROR_CHN_BUSY);
+    }
+
+    if (cpu_type == CRYPTO_CPU_TYPE_SCPU) {
+        lock_state_expected = KS_STAT_TEE_LOCK;
+        cpu_reg_addr = KC_TEECPU_LOCK_CMD;
+    }
+
+    lock_cmd.u32 = km_reg_read(cpu_reg_addr);
+    lock_cmd.bits.flush_hmac_kslot_ind = keyslot_type_reg_value;
+    lock_cmd.bits.key_slot_num = keyslot_num;
+    lock_cmd.bits.lock_cmd = KS_CPU_LOCK;         /* start lock and unlock */
+    km_reg_write(cpu_reg_addr, lock_cmd.u32);
+
+    if (inner_kslot_chn_is_locked(keyslot_num, keyslot_type_reg_value, &lock_state) == TD_FALSE) {
+        crypto_log_err("lock failed\n");
+        return KM_COMPAT_ERRNO(ERROR_KEYSLOT_LOCK);
+    }
+    if (lock_state != lock_state_expected) {
+        crypto_log_err("lock failed\n");
+        return KM_COMPAT_ERRNO(ERROR_KEYSLOT_LOCK);
+    }
+    return TD_SUCCESS;
+}
+
+td_s32 hal_keyslot_unlock(td_u32 keyslot_num, crypto_keyslot_type keyslot_type)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 keyslot_type_reg_value = 0;
+    crypto_cpu_type cpu_type = crypto_get_cpu_type();
+    td_u32 cpu_reg_addr = 0;
+    kc_cpu_lock_cmd lock_cmd = {0};
+
+    switch (keyslot_type) {
+        case CRYPTO_KEYSLOT_TYPE_MCIPHER:
+            keyslot_type_reg_value = KEYSLOT_TYPE_MCIPHER;
+            break;
+        case CRYPTO_KEYSLOT_TYPE_HMAC:
+            keyslot_type_reg_value = KEYSLOT_TYPE_HMAC;
+            break;
+        default:
+            crypto_log_err("invalid keyslot_type\n");
+            return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    if (inner_kslot_is_busy()) {
+        return KM_COMPAT_ERRNO(ERROR_CHN_BUSY);
+    }
+    if (inner_kslot_chn_is_locked(keyslot_num, keyslot_type_reg_value, TD_NULL) == TD_FALSE) {
+        return TD_SUCCESS;
+    }
+
+    switch (cpu_type) {
+        case CRYPTO_CPU_TYPE_SCPU:
+            cpu_reg_addr = KC_TEECPU_LOCK_CMD;
+            break;
+        case CRYPTO_CPU_TYPE_ACPU:
+            cpu_reg_addr = KC_REECPU_LOCK_CMD;
+            break;
+        default:
+            crypto_log_err("invalid cpu type\n");
+            return KM_COMPAT_ERRNO(ERROR_INVALID_CPU_TYPE);
+    }
+
+    lock_cmd.u32 = km_reg_read(cpu_reg_addr);
+    lock_cmd.bits.flush_hmac_kslot_ind = keyslot_type_reg_value;
+    lock_cmd.bits.key_slot_num = keyslot_num;
+    lock_cmd.bits.lock_cmd = KS_CPU_UNLOCK;         /* start lock and unlock */
+    km_reg_write(cpu_reg_addr, lock_cmd.u32);
+
+    ret = inner_kslot_wait_idle();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_kslot_wait_idle failed\n");
+
+    if (inner_kslot_is_unlock_failed() == TD_TRUE) {
+        crypto_log_err("kslot unlock failed\n");
+        return KM_COMPAT_ERRNO(ERROR_KEYSLOT_LOCK);
+    }
+    return TD_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_reg.h b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_reg.h
new file mode 100644
index 0000000..cbeb718
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_reg.h
@@ -0,0 +1,158 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal keyslot register header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef HAL_KEYSLOT_REG_H
+#define HAL_KEYSLOT_REG_H
+
+#define KS_CPU_LOCK   1
+#define KS_CPU_UNLOCK 0
+
+#define KCTRL_REG_OFFSET          (0x00001000)
+
+#define KC_TEECPU_LOCK_CMD      (KCTRL_REG_OFFSET + 0xB00)
+#define KC_REECPU_LOCK_CMD      (KCTRL_REG_OFFSET + 0xB04)
+#define KC_PCPU_LOCK_CMD        (KCTRL_REG_OFFSET + 0xB08)
+#define KC_AIDSP_LOCK_CMD       (KCTRL_REG_OFFSET + 0xB0c)
+#define KC_TEECPU_FLUSH_BUSY    (KCTRL_REG_OFFSET + 0xB10)
+#define KC_REECPU_FLUSH_BUSY    (KCTRL_REG_OFFSET + 0xB14)
+#define KC_PCPU_FLUSH_BUSY      (KCTRL_REG_OFFSET + 0xB18)
+#define KC_AIDSP_FLUSH_BUSY     (KCTRL_REG_OFFSET + 0xB1c)
+#define KC_RD_SLOT_NUM          (KCTRL_REG_OFFSET + 0xB30)
+#define KC_RD_LOCK_STATUS       (KCTRL_REG_OFFSET + 0xB34)
+
+typedef enum {
+    KS_STAT_UN_LOCK     = 0x0,
+    KS_STAT_REE_LOCK    = 0x1,
+    KS_STAT_TEE_LOCK    = 0x2,
+    KS_STAT_PCPU_LOCK   = 0x4,
+    KS_STAT_AIDSP_LOCK  = 0x6,
+    KS_STAT_MAX
+} ks_slot_stat;
+
+/* define the union u_kc_cpu_lock_cmd */
+typedef union {
+    struct {
+        unsigned int    key_slot_num                : 10; /* [9..0]  */
+        unsigned int    reserved_0                  : 5; /* [14..10]  */
+        unsigned int    flush_hmac_kslot_ind        : 1; /* [15]  */
+        unsigned int    tscipher_ind                : 1; /* [16] */
+        unsigned int    reserved_1                  : 3; /* [19..17]  */
+        unsigned int    lock_cmd                    : 1; /* [20]  */
+        unsigned int    reserved_2                    : 11; /* [31..21]  */
+    } bits;
+    unsigned int    u32;
+} kc_cpu_lock_cmd;
+
+/* define the union u_kc_teecpu_lock_cmd */
+typedef union {
+    struct {
+        unsigned int    tee_key_slot_num              : 10; /* [9..0]  */
+        unsigned int    reserved_0                    : 5; /* [14..10]  */
+        unsigned int    tee_flush_hmac_kslot_ind      : 1; /* [15]  */
+        unsigned int    tee_tscipher_ind              : 1; /* [16] */
+        unsigned int    reserved_1                    : 3; /* [19..17]  */
+        unsigned int    tee_lock_cmd                  : 1; /* [20]  */
+        unsigned int    reserved_2                    : 11; /* [31..21]  */
+    } bits;
+    unsigned int    u32;
+} kc_tee_lock_cmd;
+
+/* define the union u_kc_reecpu_lock_cmd */
+typedef union {
+    struct {
+        unsigned int    ree_key_slot_num              : 10; /* [9..0]  */
+        unsigned int    reserved_0                    : 5; /* [14..10]  */
+        unsigned int    ree_flush_hmac_kslot_ind      : 1; /* [15]  */
+        unsigned int    ree_tscipher_ind              : 1; /* [16] */
+        unsigned int    reserved_1                    : 3; /* [19..17]  */
+        unsigned int    ree_lock_cmd                  : 1; /* [20]  */
+        unsigned int    reserved_2                    : 11; /* [31..21]  */
+    } bits;
+    unsigned int    u32;
+} kc_ree_lock_cmd;
+
+/* define the union u_kc_pcpu_lock_cmd */
+typedef union {
+    struct {
+        unsigned int    pcpu_key_slot_num              : 10; /* [9..0]  */
+        unsigned int    reserved_0                     : 5; /* [14..10]  */
+        unsigned int    pcpu_flush_hmac_kslot_ind      : 1; /* [15]  */
+        unsigned int    pcpu_tscipher_ind              : 1; /* [16] */
+        unsigned int    reserved_1                     : 3; /* [19..17]  */
+        unsigned int    pcpu_lock_cmd                  : 1; /* [20]  */
+        unsigned int    reserved_2                     : 11; /* [31..21]  */
+    } bits;
+    unsigned int    u32;
+} kc_pcpu_lock_cmd;
+
+/* define the union u_kc_aidsp_lock_cmd */
+typedef union {
+    struct {
+        unsigned int    aidsp_key_slot_num              : 10; /* [9..0]  */
+        unsigned int    reserved_0                      : 5; /* [14..10]  */
+        unsigned int    aidsp_flush_hmac_kslot_ind      : 1; /* [15]  */
+        unsigned int    aidsp_tscipher_ind              : 1; /* [16] */
+        unsigned int    reserved_1                      : 3; /* [19..17]  */
+        unsigned int    aidsp_lock_cmd                  : 1; /* [20]  */
+        unsigned int    reserved_2                      : 11; /* [31..21]  */
+    } bits;
+    unsigned int    u32;
+} kc_aidsp_lock_cmd;
+
+/* define the union kc_flush_busy */
+typedef union {
+    struct {
+        unsigned int    flush_busy        : 1; /* [0]  */
+        unsigned int    flush_unlock_fail : 1; /* [1]  */
+        unsigned int    flush_timeout_err : 1; /* [2]  */
+        unsigned int    reserved_0            : 29; /* [31..3]  */
+    } bits;
+    unsigned int    u32;
+} kc_flush_busy;
+
+/* define the union kc_send_dbg */
+typedef union {
+    struct {
+        unsigned int    main_fsm_cur          : 8; /* [7..0]  */
+        unsigned int    reserved_1            : 24; /* [31..8]  */
+    } bits;
+    unsigned int    u32;
+} kc_send_dbg;
+
+/* define the union kc_rob_alarm */
+typedef union {
+    struct {
+        unsigned int    kc_rob_alarm          : 4; /* [3..0]  */
+        unsigned int    reserved_0            : 28; /* [31..4]  */
+    } bits;
+    unsigned int    u32;
+} kc_rob_alarm;
+
+/* define the union kc_rd_slot_num */
+typedef union {
+    struct {
+        unsigned int    slot_num_cfg          : 10; /* [9..0]  */
+        unsigned int    reserved_0            : 5; /* [14..10]  */
+        unsigned int    slot_cfg_type         : 1; /* [15]  */
+        unsigned int    tscipher_slot_ind     : 1; /* [16]  */
+        unsigned int    reserved_1            : 15; /* [31..17]  */
+    } bits;
+    unsigned int    u32;
+} kc_rd_slot_num;
+
+/* define the union kc_rd_lock_status */
+typedef union {
+    struct {
+        unsigned int    rd_lock_status        : 3;  /* [2..0]  */
+        unsigned int    reserved_0            : 29; /* [31..3]  */
+    } bits;
+    unsigned int    u32;
+} kc_rd_lock_status;
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_soft.c b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_soft.c
new file mode 100644
index 0000000..d37dfce
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_keyslot_soft.c
@@ -0,0 +1,61 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal keyslot soft. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-5, Create file. \n
+ */
+#if defined(CONFIG_KM_KEYSLOT_SOFT_SUPPORT)
+#include "hal_keyslot.h"
+
+#define KEYSLOT_MCIPHER_KEYSLOT_CNT     8
+#define KEYSLOT_HMAC_KEYSLOT_CNT        2
+
+static td_s32 keyslot_mcipher_channel[KEYSLOT_MCIPHER_KEYSLOT_CNT] = {0};
+static td_s32 keyslot_hmac_channel[KEYSLOT_HMAC_KEYSLOT_CNT] = {0};
+
+td_s32 hal_keyslot_lock(td_u32 keyslot_num, crypto_keyslot_type keyslot_type)
+{
+    switch (keyslot_type) {
+        case CRYPTO_KEYSLOT_TYPE_MCIPHER:
+                if (keyslot_num >= KEYSLOT_MCIPHER_KEYSLOT_CNT || keyslot_mcipher_channel[keyslot_num] == 1) {
+                    return TD_FAILURE;
+                }
+                keyslot_mcipher_channel[keyslot_num] = 1;
+                break;
+        case CRYPTO_KEYSLOT_TYPE_HMAC:
+                if (keyslot_num >= KEYSLOT_HMAC_KEYSLOT_CNT || keyslot_hmac_channel[keyslot_num] == 1) {
+                    return TD_FAILURE;
+                }
+                keyslot_hmac_channel[keyslot_num] = 1;
+                break;
+        default:
+            return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 hal_keyslot_unlock(td_u32 keyslot_num, crypto_keyslot_type keyslot_type)
+{
+    switch (keyslot_type) {
+        case CRYPTO_KEYSLOT_TYPE_MCIPHER:
+                if (keyslot_num >= KEYSLOT_MCIPHER_KEYSLOT_CNT) {
+                    return TD_FAILURE;
+                }
+                keyslot_mcipher_channel[keyslot_num] = 0;
+                break;
+        case CRYPTO_KEYSLOT_TYPE_HMAC:
+                if (keyslot_num >= KEYSLOT_HMAC_KEYSLOT_CNT) {
+                    return TD_FAILURE;
+                }
+                keyslot_hmac_channel[keyslot_num] = 0;
+                break;
+        default:
+            return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad.c b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad.c
new file mode 100644
index 0000000..c3d49f4
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad.c
@@ -0,0 +1,670 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal klad. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "hal_klad.h"
+#include "hal_klad_reg.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#define CRYPTO_U8_TO_U32_BIT_SHIFT(data) \
+    ((td_u32)(data)[i]  | ((td_u32)(data)[i+1] << 8) | ((td_u32)(data)[i+2] << 16) | ((td_u32)(data)[i+3]<< 24))
+
+#define HKL_COM_LOCK_STAT_TEE_LOCK      0xa5
+#define HKL_COM_LOCK_STAT_REE_LOCK      0xaa
+
+#define KM_COMPAT_ERRNO(err_code)     HAL_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+static td_s32 inner_klad_to_be_lock(td_void)
+{
+    td_u32 lock_stat_expected = 0;
+    hkl_lock_ctrl lock_ctl = {0};
+    hkl_com_lock_info lock_info = {0};
+    hkl_com_lock_status lock_status = {0};
+    crypto_cpu_type cpu_type = crypto_get_cpu_type();
+
+    switch (cpu_type) {
+        case CRYPTO_CPU_TYPE_ACPU:
+            lock_stat_expected = HKL_COM_LOCK_STAT_REE_LOCK;
+            break;
+        case CRYPTO_CPU_TYPE_SCPU:
+            lock_stat_expected = HKL_COM_LOCK_STAT_TEE_LOCK;
+            break;
+        default:
+            crypto_log_err("invalid cpu_type\n");
+            return KM_COMPAT_ERRNO(ERROR_INVALID_CPU_TYPE);
+    }
+
+    lock_ctl.bits.kl_lock = 0x1;
+    km_reg_write(KL_LOCK_CTRL, lock_ctl.u32);
+
+    lock_info.u32 = km_reg_read(KL_COM_LOCK_INFO);
+    if (lock_info.bits.kl_com_lock_fail == 0x1) {
+        return KM_COMPAT_ERRNO(ERROR_KLAD_LOCK);
+    }
+
+    lock_status.u32 = km_reg_read(KL_COM_LOCK_STATUS);
+    if (lock_status.bits.kl_com_lock_stat != lock_stat_expected) {
+        return KM_COMPAT_ERRNO(ERROR_KLAD_LOCK);
+    }
+
+    return TD_SUCCESS;
+}
+
+#define HKL_LOCK_TIMEOUT        10000
+td_s32 hal_klad_lock(td_void)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    for (i = 0; i < HKL_LOCK_TIMEOUT; i++) {
+        ret = inner_klad_to_be_lock();
+        if (ret == TD_SUCCESS) {
+            break;
+        }
+
+        crypto_udelay(1);
+    }
+
+    if (i >= HKL_LOCK_TIMEOUT) {
+        crypto_log_err("klad is busy, lock failed\n");
+        return KM_COMPAT_ERRNO(ERROR_KLAD_TIMEOUT);
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 hal_klad_unlock(td_void)
+{
+    hkl_unlock_ctrl unlock_ctl = {0};
+    hkl_com_lock_info lock_info = {0};
+    hkl_com_lock_status lock_status = {0};
+    td_u32 lock_stat_expected = 0;
+
+    crypto_cpu_type cpu_type = crypto_get_cpu_type();
+    switch (cpu_type) {
+        case CRYPTO_CPU_TYPE_ACPU:
+            lock_stat_expected = HKL_COM_LOCK_STAT_REE_LOCK;
+            break;
+        case CRYPTO_CPU_TYPE_SCPU:
+            lock_stat_expected = HKL_COM_LOCK_STAT_TEE_LOCK;
+            break;
+        default:
+            crypto_log_err("invalid cpu_type\n");
+            return KM_COMPAT_ERRNO(ERROR_INVALID_CPU_TYPE);
+    }
+
+    lock_status.u32 = km_reg_read(KL_COM_LOCK_STATUS);
+    if (lock_status.bits.kl_com_lock_stat != lock_stat_expected || lock_status.bits.kl_com_lock_stat == 0) {
+        return TD_SUCCESS;
+    }
+
+    unlock_ctl.bits.kl_unlock = 0x1;
+    km_reg_write(KL_UNLOCK_CTRL, unlock_ctl.u32);
+
+    lock_info.u32 = km_reg_read(KL_COM_LOCK_INFO);
+    if (lock_info.bits.kl_com_unlock_fail == 0x1) {
+        return KM_COMPAT_ERRNO(ERROR_KLAD_LOCK);
+    }
+
+    return TD_SUCCESS;
+}
+
+#define HKL_ENGINE_AES          0x20
+#define HKL_ENGINE_SM4          0x50
+#define HKL_ENGINE_SHA1_HMAC    0xa0
+#define HKL_ENGINE_SHA2_HMAC    0xa1
+#define HKL_ENGINE_SM3_HMAC     0xa2
+
+td_s32 hal_klad_set_key_crypto_cfg(td_bool encrypt_support, td_bool decrypt_support, crypto_klad_engine engine)
+{
+    hkl_key_cfg key_cfg = {0};
+    td_u32 alg_engine_reg_value = 0;
+
+    switch (engine) {
+        case CRYPTO_KLAD_ENGINE_AES:
+            alg_engine_reg_value = HKL_ENGINE_AES;
+            break;
+        case CRYPTO_KLAD_ENGINE_SM4:
+            alg_engine_reg_value = HKL_ENGINE_SM4;
+            break;
+        case CRYPTO_KLAD_ENGINE_SHA1_HMAC:
+            alg_engine_reg_value = HKL_ENGINE_SHA1_HMAC;
+            break;
+        case CRYPTO_KLAD_ENGINE_SHA2_HMAC:
+            alg_engine_reg_value = HKL_ENGINE_SHA2_HMAC;
+            break;
+        case CRYPTO_KLAD_ENGINE_SM3_HMAC:
+            alg_engine_reg_value = HKL_ENGINE_SM3_HMAC;
+            break;
+        default:
+            crypto_log_err("invalid engine\n");
+            return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    key_cfg.u32 = km_reg_read(KL_KEY_CFG);
+    key_cfg.bits.key_dec = decrypt_support;
+    key_cfg.bits.key_enc = encrypt_support;
+    key_cfg.bits.dsc_code = alg_engine_reg_value;
+
+    km_reg_write(KL_KEY_CFG, key_cfg.u32);
+
+    return TD_SUCCESS;
+}
+
+#define HKL_PORT_SEL_MCIPHER        0x1
+#define HKL_PORT_SEL_HMAC           0x1 /* the sample as MCIPHER. */
+#define HKL_PORT_SEL_NPU            0x5
+#define HKL_PORT_SEL_FLASH          0x7
+
+#define HKL_FLASH_SEL_REE_DEC       0
+
+td_s32 hal_klad_set_key_dest_cfg(crypto_klad_dest dest, crypto_klad_flash_key_type flash_key_type)
+{
+    hkl_key_cfg key_cfg = {0};
+    td_u32 port_sel_reg_val = 0;
+    td_u32 flash_sel_reg_val = 0;
+
+    switch (dest) {
+        case CRYPTO_KLAD_DEST_MCIPHER:
+            port_sel_reg_val = HKL_PORT_SEL_MCIPHER;
+            break;
+        case CRYPTO_KLAD_DEST_HMAC:
+            port_sel_reg_val = HKL_PORT_SEL_HMAC;
+            break;
+        case CRYPTO_KLAD_DEST_FLASH:
+            port_sel_reg_val = HKL_PORT_SEL_FLASH;
+            break;
+        case CRYPTO_KLAD_DEST_NPU:
+            port_sel_reg_val = HKL_PORT_SEL_NPU;
+            break;
+        default:
+            crypto_log_err("invalid dest\n");
+            return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    if (dest == CRYPTO_KLAD_DEST_FLASH) {
+        switch (flash_key_type) {
+            case CRYPTO_KLAD_FLASH_KEY_TYPE_REE_DEC:
+                flash_sel_reg_val = HKL_FLASH_SEL_REE_DEC;
+                break;
+            default:
+                crypto_log_err("invalid flash_key_type\n");
+                return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        }
+    }
+
+    key_cfg.u32 = km_reg_read(KL_KEY_CFG);
+    key_cfg.bits.port_sel = port_sel_reg_val;
+    if (dest == CRYPTO_KLAD_DEST_FLASH) {
+        key_cfg.bits.kl_flash_sel = flash_sel_reg_val;
+    }
+    km_reg_write(KL_KEY_CFG, key_cfg.u32);
+
+    return TD_SUCCESS;
+}
+
+td_s32 hal_klad_set_key_secure_cfg(const crypto_klad_key_secure_config *secure_cfg)
+{
+    hkl_key_sec_cfg sec_cfg = {0};
+
+    km_null_ptr_chk(secure_cfg);
+
+    sec_cfg.u32 = km_reg_read(KL_KEY_SEC_CFG);
+    sec_cfg.bits.master_only = secure_cfg->master_only_enable;
+    sec_cfg.bits.dest_sec = secure_cfg->dest_buf_sec_support;
+    sec_cfg.bits.dest_nsec = secure_cfg->dest_buf_non_sec_support;
+    sec_cfg.bits.src_sec = secure_cfg->src_buf_sec_support;
+    sec_cfg.bits.src_nsec = secure_cfg->src_buf_non_sec_support;
+    sec_cfg.bits.key_sec = secure_cfg->key_sec;
+    km_reg_write(KL_KEY_SEC_CFG, sec_cfg.u32);
+
+    return TD_SUCCESS;
+}
+
+td_s32 hal_klad_set_key_addr(crypto_klad_dest klad_dest, td_u32 keyslot_chn)
+{
+    hkl_key_addr key_addr = {0};
+
+    if (klad_dest == CRYPTO_KLAD_DEST_MCIPHER) {    /* symc */
+        key_addr.u32 = km_reg_read(KL_KEY_ADDR);
+        key_addr.bits.key_addr = (keyslot_chn << 1);
+        km_reg_write(KL_KEY_ADDR, key_addr.u32);
+    } else if (klad_dest == CRYPTO_KLAD_DEST_HMAC || klad_dest == CRYPTO_KLAD_DEST_NPU) { /* hmac & NPU */
+        key_addr.u32 = km_reg_read(KL_KEY_ADDR);
+        key_addr.bits.key_addr = keyslot_chn;
+        km_reg_write(KL_KEY_ADDR, key_addr.u32);
+    } else {
+        crypto_log_err("invalid klad_dest\n");
+        return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    return TD_SUCCESS;
+}
+
+td_void hal_klad_clear_data(td_void)
+{
+    td_u32 i = 0;
+    td_u32 clear_key_val = 0;
+
+    for (i = 0; i < HKL_KEY_LEN / CRYPTO_WORD_WIDTH; i += CRYPTO_WORD_WIDTH) {
+        km_reg_write(KL_DATA_IN_0 + i, clear_key_val);
+    }
+}
+
+td_s32 hal_klad_set_data(const td_u8 *data, td_u32 data_length)
+{
+    td_u32 i = 0;
+    td_u32 data_word = 0;
+    if (data_length == 0) { /* do nothing. */
+        return TD_SUCCESS;
+    }
+
+    km_null_ptr_chk(data);
+    crypto_chk_return(data_length > HKL_KEY_LEN, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "invalid data_length\n");
+    crypto_chk_return((data_length % CRYPTO_WORD_WIDTH) != 0, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "data_length must be aligned to 4-byte\n");
+    for (i = 0; i < HKL_KEY_LEN; i += CRYPTO_WORD_WIDTH) {
+        if (i < data_length) {
+            data_word = CRYPTO_U8_TO_U32_BIT_SHIFT(data);
+            km_reg_write(KL_DATA_IN_0 + i, data_word);
+        } else {
+            km_reg_write(KL_DATA_IN_0 + i, 0);      /* padding with zero. */
+        }
+    }
+    return TD_SUCCESS;
+}
+
+td_void hal_klad_set_key_odd(td_bool odd)
+{
+    hkl_key_addr key_addr = {0};
+    key_addr.u32 = km_reg_read(KL_KEY_ADDR);
+    if (odd) {
+        key_addr.u32 |= 0x1;    /* set bit0. */
+    } else {
+        key_addr.u32 &= ~(0x1); /* clear bit0. */
+    }
+    km_reg_write(KL_KEY_ADDR, key_addr.u32);
+}
+
+td_s32 inner_klad_error_check(td_void)
+{
+    td_u32 klad_err = 0;
+    td_u32 kctrl_err = 0;
+
+    klad_err = km_reg_read(KL_ERROR);
+    if (klad_err) {
+        crypto_log_err("klad_err is 0x%x\n", klad_err);
+    }
+    kctrl_err = km_reg_read(KC_ERROR);
+    if (kctrl_err) {
+        crypto_log_err("kctrl_err is 0x%x\n", kctrl_err);
+    }
+    if (klad_err | kctrl_err) {
+        return KM_COMPAT_ERRNO(ERROR_KM_LOGIC);
+    }
+    return TD_SUCCESS;
+}
+
+#define KLAD_COM_ROUTE_TIMEOUT          1000000
+td_s32 hal_klad_wait_com_route_done(td_void)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    kl_com_ctrl com_ctrl = { 0 };
+    kl_int_raw int_raw = {0};
+    kl_com_status com_status = {0};
+    td_u32 i = 0;
+
+    for (i = 0; i < KLAD_COM_ROUTE_TIMEOUT; ++i) {
+        com_ctrl.u32 = km_reg_read(KL_COM_CTRL);
+        if (com_ctrl.bits.kl_com_start == 0) {
+            int_raw.u32 = km_reg_read(KL_INT_RAW);
+            int_raw.bits.com_kl_int_raw = 0x1;
+            km_reg_write(KL_INT_RAW, int_raw.u32);
+            break;
+        }
+        crypto_udelay(1);
+    }
+    if (i < KLAD_COM_ROUTE_TIMEOUT) {
+        ret = TD_SUCCESS;
+    }
+
+    com_status.u32 = km_reg_read(KL_COM_STATUS);
+    if (com_status.bits.kl_com_rk_rdy == 0) {
+        crypto_log_err("root key is not ready!\n");
+    }
+#if defined(CONFIG_KM_CONTENT_KEY_SUPPORT)
+    if (com_status.bits.kl_com_lv1_rdy == 0) {
+        crypto_log_err("level 1 is not ready!\n");
+    }
+#endif
+    ret = inner_klad_error_check();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_klad_error_check failed\n");
+
+    return ret;
+}
+
+#define HKL_COM_KEY_SIZE_128            0x1
+#define HKL_COM_KEY_SIZE_192            0x2
+#define HKL_COM_KEY_SIZE_256            0x3
+static const crypto_table_item g_klad_key_size_table[] = {
+    {
+        .index = CRYPTO_KLAD_KEY_SIZE_128BIT, .value = HKL_COM_KEY_SIZE_128
+    },
+#if defined(CONFIG_KM_KEY_LEN_192_SUPPORT)
+    {
+        .index = CRYPTO_KLAD_KEY_SIZE_192BIT, .value = HKL_COM_KEY_SIZE_192
+    },
+#endif
+#if defined(CONFIG_KM_KEY_LEN_256_SUPPORT)
+    {
+        .index = CRYPTO_KLAD_KEY_SIZE_256BIT, .value = HKL_COM_KEY_SIZE_256
+    },
+#endif
+};
+
+#define HKL_COM_RK_CHOOSE_ODRK0         0x5
+#define HKL_COM_RK_CHOOSE_OARK0         0x6
+#define HKL_COM_RK_CHOOSE_ODRK1         0x7
+#define HKL_COM_RK_CHOOSE_ABRK_REE      0x15
+#define HKL_COM_RK_CHOOSE_RDRK_REE      0x17
+
+#define HKL_COM_RK_CHOOSE_SBRK0         0x0
+#define HKL_COM_RK_CHOOSE_SBRK1         0x1
+#define HKL_COM_RK_CHOOSE_ABRK0         0x2
+#define HKL_COM_RK_CHOOSE_ABRK1         0x3
+#define HKL_COM_RK_CHOOSE_DRK0          0xc
+#define HKL_COM_RK_CHOOSE_DRK1          0xd
+#define HKL_COM_RK_CHOOSE_RDRK0         0xe
+#define HKL_COM_RK_CHOOSE_RDRK1         0xf
+#define HKL_COM_RK_CHOOSE_SBRK2         0x10
+#define HKL_COM_RK_CHOOSE_ABRK2         0x11
+#define HKL_COM_RK_CHOOSE_MDRK0         0x8
+#define HKL_COM_RK_CHOOSE_MDRK1         0x9
+#define HKL_COM_RK_CHOOSE_MDRK2         0xa
+#define HKL_COM_RK_CHOOSE_MDRK3         0xb
+#define HKL_COM_RK_CHOOSE_PSK           0x12
+#define HKL_COM_RK_CHOOSE_ERK_TEE          6
+#define HKL_COM_RK_CHOOSE_ERK_REE          7
+#define HKL_COM_RK_CHOOSE_ERK1_REE          16
+#define HKL_COM_RK_CHOOSE_ERK2_REE          17
+
+static const crypto_table_item g_klad_rk_table[] = {
+#if defined(CONFIG_KM_ODRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ODRK0, .value = HKL_COM_RK_CHOOSE_ODRK0
+    },
+#endif
+#if defined(CONFIG_KM_OARK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_OARK0, .value = HKL_COM_RK_CHOOSE_OARK0
+    },
+#endif
+#if defined(CONFIG_KM_ODRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ODRK1, .value = HKL_COM_RK_CHOOSE_ODRK1
+    },
+#endif
+#if defined(CONFIG_KM_ABRK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK_REE, .value = HKL_COM_RK_CHOOSE_ABRK_REE
+    },
+#endif
+#if defined(CONFIG_KM_RDRK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_RDRK_REE, .value = HKL_COM_RK_CHOOSE_RDRK_REE
+    },
+#endif
+#if defined(CONFIG_KM_ABRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK0, .value = HKL_COM_RK_CHOOSE_ABRK0
+    },
+#endif
+#if defined(CONFIG_KM_ABRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK1, .value = HKL_COM_RK_CHOOSE_ABRK1
+    },
+#endif
+#if defined(CONFIG_KM_ABRK2_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK2, .value = HKL_COM_RK_CHOOSE_ABRK2
+    },
+#endif
+#if defined(CONFIG_KM_SBRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_SBRK0, .value = HKL_COM_RK_CHOOSE_SBRK0
+    },
+#endif
+#if defined(CONFIG_KM_SBRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_SBRK1, .value = HKL_COM_RK_CHOOSE_SBRK1
+    },
+#endif
+#if defined(CONFIG_KM_SBRK2_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_SBRK2, .value = HKL_COM_RK_CHOOSE_SBRK2
+    },
+#endif
+#if defined(CONFIG_KM_DRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_DRK0, .value = HKL_COM_RK_CHOOSE_DRK0
+    },
+#endif
+#if defined(CONFIG_KM_DRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_DRK1, .value = HKL_COM_RK_CHOOSE_DRK1
+    },
+#endif
+#if defined(CONFIG_KM_RDRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_RDRK0, .value = HKL_COM_RK_CHOOSE_RDRK0
+    },
+#endif
+#if defined(CONFIG_KM_RDRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_RDRK1, .value = HKL_COM_RK_CHOOSE_RDRK1
+    },
+#endif
+#if defined(CONFIG_KM_MDRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_MDRK0, .value = HKL_COM_RK_CHOOSE_MDRK0
+    },
+#endif
+#if defined(CONFIG_KM_MDRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_MDRK1, .value = HKL_COM_RK_CHOOSE_MDRK1
+    },
+#endif
+#if defined(CONFIG_KM_MDRK2_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_MDRK2, .value = HKL_COM_RK_CHOOSE_MDRK2
+    },
+#endif
+#if defined(CONFIG_KM_MDRK3_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_MDRK3, .value = HKL_COM_RK_CHOOSE_MDRK3
+    },
+#endif
+#if defined(CONFIG_KM_PSK_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_PSK, .value = HKL_COM_RK_CHOOSE_PSK
+    },
+#endif
+#if defined(CONFIG_KM_ERK_TEE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK_TEE, .value = HKL_COM_RK_CHOOSE_ERK_TEE
+    },
+#endif
+#if defined(CONFIG_KM_ERK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK_REE, .value = HKL_COM_RK_CHOOSE_ERK_REE
+    },
+#endif
+#if defined(CONFIG_KM_ERK1_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK1_REE, .value = HKL_COM_RK_CHOOSE_ERK1_REE
+    },
+#endif
+#if defined(CONFIG_KM_ERK2_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK2_REE, .value = HKL_COM_RK_CHOOSE_ERK2_REE
+    }
+#endif
+};
+
+#define HKL_COM_ALG_TDES_SEL_VAL    (0x0)
+#define HKL_COM_ALG_AES_SEL_VAL     (0x1)
+#define HKL_COM_ALG_SM4_SEL_VAL     (0x2)
+static const crypto_table_item g_klad_alg_sel_table[] = {
+#if defined(CONFIG_KM_TDES_SUPPORT)
+    {
+        .index = CRYPTO_KLAD_ALG_SEL_TDES, .value = HKL_COM_ALG_TDES_SEL_VAL
+    },
+#endif
+    {
+        .index = CRYPTO_KLAD_ALG_SEL_AES, .value = HKL_COM_ALG_AES_SEL_VAL
+    },
+#if defined(CONFIG_KM_SM4_SUPPORT)
+    {
+        .index = CRYPTO_KLAD_ALG_SEL_SM4, .value = HKL_COM_ALG_SM4_SEL_VAL
+    },
+#endif
+};
+
+#if defined(CONFIG_KM_CONTENT_KEY_SUPPORT)
+td_s32 hal_klad_com_start(crypto_klad_level_sel level, crypto_klad_alg_sel alg, crypto_klad_key_size key_size,
+    crypto_kdf_hard_key_type rk_type)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    kl_com_ctrl com_ctrl = {0};
+    td_u32 key_size_reg_val = 0;
+    td_u32 alg_sel_reg_val = 0;
+    td_u32 rk_choose_reg_val = 0;
+
+    ret = crypto_get_value_by_index(g_klad_key_size_table, crypto_array_size(g_klad_key_size_table),
+        key_size, &key_size_reg_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get key_size failed\n");
+
+    ret = crypto_get_value_by_index(g_klad_alg_sel_table, crypto_array_size(g_klad_alg_sel_table),
+        alg, &alg_sel_reg_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get alg_sel failed\n");
+
+    ret = crypto_get_value_by_index(g_klad_rk_table, crypto_array_size(g_klad_rk_table),
+        rk_type, &rk_choose_reg_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get rootkey failed\n");
+
+    com_ctrl.u32 = km_reg_read(KL_COM_CTRL);
+    com_ctrl.bits.kl_com_key_size = key_size_reg_val; /* size */
+    com_ctrl.bits.kl_com_alg_sel = alg_sel_reg_val;       /* alg */
+    com_ctrl.bits.kl_com_level_sel = level;   /* level */
+    com_ctrl.bits.rk_choose = rk_choose_reg_val;        /* rk_choose. */
+    com_ctrl.bits.kl_com_start = 1;   /* start calculation */
+    km_reg_write(KL_COM_CTRL, com_ctrl.u32);
+
+    return TD_SUCCESS;
+}
+#endif
+
+td_s32 hal_klad_start_com_route(crypto_kdf_hard_key_type rk_type, const crypto_klad_effective_key *content_key,
+    crypto_klad_dest klad_dest)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_bool key_parity = TD_FALSE;
+    td_u32 key_size_reg_val = 0;
+    td_u32 rk_choose_reg_val = 0;
+    kl_com_ctrl com_ctrl = {0};
+
+    crypto_chk_return(content_key == TD_NULL, TD_FAILURE, "content_key is NULL\n");
+    crypto_chk_return(content_key->salt == TD_NULL, TD_FAILURE, "content_key->salt is NULL\n");
+
+    ret = crypto_get_value_by_index(g_klad_rk_table, crypto_array_size(g_klad_rk_table),
+        rk_type, &rk_choose_reg_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get rootkey failed\n");
+
+    ret = crypto_get_value_by_index(g_klad_key_size_table, crypto_array_size(g_klad_key_size_table),
+        content_key->key_size, &key_size_reg_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get key_size failed\n");
+    /*
+     * If key_length is 16, the key_parity is passed by caller;
+     * If key_length is 24/32, the high 128bit's key_parity is even,
+        the low 128bit's(padding 0 for 192bit) key_parity is odd.
+     */
+    if (content_key->key_size == CRYPTO_KLAD_KEY_SIZE_128BIT) {
+        key_parity = content_key->key_parity;
+    }
+    /* config the high 128bit  */
+    if (klad_dest == CRYPTO_KLAD_DEST_MCIPHER) {
+        hal_klad_set_key_odd(key_parity);
+    }
+
+    /* config com_ctrl */
+    com_ctrl.bits.kl_com_key_size = key_size_reg_val; /* size */
+    com_ctrl.bits.kl_com_start = 0x1;   /* start calculation */
+    com_ctrl.bits.rk_choose = rk_choose_reg_val; /* klad config rootkey type */
+    km_reg_write(KL_COM_CTRL, com_ctrl.u32);
+
+    ret = hal_klad_wait_com_route_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_wait_com_route_done failed\n");
+
+    /* config the low 64bit/128bit */
+    if (content_key->key_size != CRYPTO_KLAD_KEY_SIZE_128BIT) {
+        if (klad_dest == CRYPTO_KLAD_DEST_MCIPHER) {
+            hal_klad_set_key_odd(TD_TRUE);
+        }
+        /* config com_ctrl */
+        com_ctrl.bits.kl_com_key_size = key_size_reg_val; /* size */
+        com_ctrl.bits.rk_choose = rk_choose_reg_val; /* klad config rootkey type */
+        com_ctrl.bits.kl_com_start = 0x1;   /* start calculation */
+        km_reg_write(KL_COM_CTRL, com_ctrl.u32);
+
+        ret = hal_klad_wait_com_route_done();
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_klad_wait_com_route_done failed\n");
+    }
+
+    return ret;
+}
+
+#if defined(CONFIG_KLAD_DEBUG_ENABLE)
+const reg_item_t g_hkl_reg_table[] = {
+    { "KL_DATA_IN_0",       KL_DATA_IN_0 },
+    { "KL_DATA_IN_1",       KL_DATA_IN_1 },
+    { "KL_DATA_IN_2",       KL_DATA_IN_2 },
+    { "KL_DATA_IN_3",       KL_DATA_IN_3 },
+    { "KL_KEY_ADDR",       KL_KEY_ADDR },
+    { "KL_KEY_CFG",       KL_KEY_CFG },
+    { "KL_KEY_SEC_CFG",       KL_KEY_SEC_CFG },
+    { "KL_STATE",       KL_STATE },
+    { "KL_CRC",       KL_CRC },
+    { "KL_ERROR",       KL_ERROR },
+    { "KC_ERROR",       KC_ERROR },
+    { "KL_INT_EN",       KL_INT_EN },
+    { "KL_INT_RAW",       KL_INT_RAW },
+    { "KL_INT",       KL_INT },
+    { "SBRK_DISABLE",       SBRK_DISABLE },
+    { "ABRK_DISABLE",       ABRK_DISABLE },
+    { "KL_RK_GEN_STATUS",       KL_RK_GEN_STATUS },
+    { "KL_LOCK_CTRL",       KL_LOCK_CTRL },
+    { "KL_UNLOCK_CTRL",       KL_UNLOCK_CTRL },
+    { "KL_COM_LOCK_INFO",       KL_COM_LOCK_INFO },
+    { "KL_COM_LOCK_STATUS",       KL_COM_LOCK_STATUS },
+    { "KL_COM_CTRL",       KL_COM_CTRL },
+    { "KL_COM_STATUS",       KL_COM_STATUS },
+    { "KL_CLR_CTRL",       KL_CLR_CTRL },
+    { "KL_ALARM_INFO",       KL_ALARM_INFO },
+};
+
+static td_u32 inner_km_reg_reg(td_u32 offset)
+{
+    return km_reg_read(offset);
+}
+
+td_void hal_klad_debug(td_void)
+{
+    crypto_reg_item_dump("HKL", (const reg_item_t *)&g_hkl_reg_table,
+        crypto_array_size(g_hkl_reg_table), inner_km_reg_reg);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad_clear_key.c b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad_clear_key.c
new file mode 100644
index 0000000..2dc7765
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad_clear_key.c
@@ -0,0 +1,175 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal klad. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "hal_klad.h"
+#include "hal_klad_reg.h"
+#include "hal_km_inner.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#define KM_COMPAT_ERRNO(err_code)     HAL_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+#define KLAD_CLR_ROUTE_TIMEOUT          1000000
+static td_s32 inner_klad_wait_clr_route_done(td_void)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    kl_clr_ctrl clr_ctrl = { 0 };
+    kl_int_raw int_raw = {0};
+    td_u32 i = 0;
+
+    for (i = 0; i < KLAD_CLR_ROUTE_TIMEOUT; ++i) {
+        clr_ctrl.u32 = km_reg_read(KL_CLR_CTRL);
+        if (clr_ctrl.bits.kl_clr_start == 0) {
+            int_raw.u32 = km_reg_read(KL_INT_RAW);
+            int_raw.bits.clr_kl_int_raw = 0x1;
+            km_reg_write(KL_INT_RAW, int_raw.u32);
+            break;
+        }
+        crypto_udelay(1);
+    }
+    if (i >= KLAD_CLR_ROUTE_TIMEOUT) {
+        return KM_COMPAT_ERRNO(ERROR_KLAD_TIMEOUT);
+    }
+
+    ret = inner_klad_error_check();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_klad_error_check failed\n");
+
+    return ret;
+}
+
+#define HKL_CLR_KEY_SIZE_128            0x1
+#define HKL_CLR_KEY_SIZE_192            0x2
+#define HKL_CLR_KEY_SIZE_256            0x3
+static td_s32 inner_klad_symc_start_clr_route(const td_u8 *key, td_u32 key_length, td_bool odd)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_bool key_parity = TD_FALSE;
+    td_u32 key_size_reg_val = 0;
+    kl_clr_ctrl clr_ctrl = {0};
+
+    switch (key_length) {
+        case CRYPTO_128_KEY_LEN:
+            key_size_reg_val = HKL_CLR_KEY_SIZE_128;
+            break;
+        case CRYPTO_192_KEY_LEN:
+            key_size_reg_val = HKL_CLR_KEY_SIZE_192;
+            break;
+        case CRYPTO_256_KEY_LEN:
+            key_size_reg_val = HKL_CLR_KEY_SIZE_256;
+            break;
+        default:
+            crypto_log_err("invalid key_length\n");
+            return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    /*
+     * If key_length is 16, the key_parity is passed by caller;
+     * If key_length is 24/32, the high 128bit's key_parity is even,
+        the low 128bit's(padding 0 for 192bit) key_parity is odd.
+     */
+    if (key_length == HKL_KEY_LEN) {
+        key_parity = odd;
+    }
+    /* config the high 128bit  */
+    hal_klad_set_key_odd(key_parity);
+    ret = hal_klad_set_data(key, HKL_KEY_LEN);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_set_data failed\n");
+
+    /* config clr_ctrl */
+    clr_ctrl.u32 = km_reg_read(KL_CLR_CTRL);
+    clr_ctrl.bits.kl_clr_key_size = key_size_reg_val;   /* symc key need to config */
+    clr_ctrl.bits.kl_clr_start = 0x1;                   /* start calculation */
+    km_reg_write(KL_CLR_CTRL, clr_ctrl.u32);
+
+    ret = inner_klad_wait_clr_route_done();
+    crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "inner_klad_wait_clr_route_done failed\n");
+
+    /* config the low 64bit/128bit */
+    if (key_length != HKL_KEY_LEN) {
+        hal_klad_set_key_odd(TD_TRUE);
+        ret = hal_klad_set_data(key + HKL_KEY_LEN, key_length - HKL_KEY_LEN);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_set_data failed\n");
+
+        /* config clr_ctrl */
+        clr_ctrl.u32 = km_reg_read(KL_CLR_CTRL);
+        clr_ctrl.bits.kl_clr_key_size = key_size_reg_val;   /* symc key need to config */
+        clr_ctrl.bits.kl_clr_start = 0x1;                   /* start calculation */
+        km_reg_write(KL_CLR_CTRL, clr_ctrl.u32);
+
+        ret = inner_klad_wait_clr_route_done();
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "inner_klad_wait_clr_route_done failed\n");
+    }
+
+exit_clean:
+    hal_klad_clear_data();
+    return ret;
+}
+
+#define HMAC_KEY_BLOCK_SIZE_512     64
+#define HMAC_KEY_BLOCK_SIZE_1024    128
+#define HMAC_KEY_CAL_CNT_512        4
+#define HMAC_KEY_CAL_CNT_1024       8
+#define HKL_HMAC_KEY_MAX_SIZE       128
+static td_s32 inner_klad_hmac_start_clr_route(const td_u8 *key, td_u32 key_length, crypto_klad_hmac_type hmac_type)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 hmac_cal_cnt = HMAC_KEY_CAL_CNT_512;
+    td_u32 i;
+    kl_clr_ctrl clr_ctrl = {0};
+    td_u8 key_padding[128] = {0};
+
+    km_null_ptr_chk(key);
+    crypto_chk_return(hmac_type != CRYPTO_KLAD_HMAC_TYPE_SHA1 && hmac_type != CRYPTO_KLAD_HMAC_TYPE_SHA224 &&
+        hmac_type != CRYPTO_KLAD_HMAC_TYPE_SHA256 && hmac_type != CRYPTO_KLAD_HMAC_TYPE_SHA384 &&
+        hmac_type != CRYPTO_KLAD_HMAC_TYPE_SHA512 && hmac_type != CRYPTO_KLAD_HMAC_TYPE_SM3,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "invalid hmac_type\n");
+
+    ret = memcpy_s(key_padding, sizeof(key_padding), key, key_length);
+    crypto_chk_return(ret != EOK, KM_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    if (hmac_type == CRYPTO_KLAD_HMAC_TYPE_SHA384 || hmac_type == CRYPTO_KLAD_HMAC_TYPE_SHA512) {
+        hmac_cal_cnt = HMAC_KEY_CAL_CNT_1024;
+    }
+
+    for (i = 0; i < hmac_cal_cnt; i++) {
+        ret = hal_klad_set_data(key_padding + HKL_KEY_LEN * i, HKL_KEY_LEN);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "hal_klad_set_data failed\n");
+
+        clr_ctrl.bits.kl_clr_key_cnt = i;       /* only software Hmac mode need to config */
+        clr_ctrl.bits.kl_clr_start = 0x1;       /* start calculation */
+        km_reg_write(KL_CLR_CTRL, clr_ctrl.u32);
+
+        ret = inner_klad_wait_clr_route_done();
+        crypto_chk_goto(ret != TD_SUCCESS, exit_clean, "inner_klad_wait_clr_route_done failed\n");
+    }
+
+exit_clean:
+    hal_klad_clear_data();
+    return ret;
+}
+
+td_s32 hal_klad_start_clr_route(crypto_klad_dest klad_dest, const crypto_klad_clear_key *clear_key)
+{
+    volatile td_s32 ret = TD_FAILURE;
+
+    km_null_ptr_chk(clear_key);
+    km_null_ptr_chk(clear_key->key);
+
+    if (klad_dest == CRYPTO_KLAD_DEST_MCIPHER || klad_dest == CRYPTO_KLAD_DEST_FLASH) {
+        ret = inner_klad_symc_start_clr_route(clear_key->key, clear_key->key_length, clear_key->key_parity);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_klad_symc_start_clr_route failed\n");
+    } else if (klad_dest == CRYPTO_KLAD_DEST_HMAC) {
+        ret = inner_klad_hmac_start_clr_route(clear_key->key, clear_key->key_length, clear_key->hmac_type);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_klad_hmac_start_clr_route failed\n");
+    } else {
+        crypto_log_err("invalid klad_dest\n");
+        return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad_reg.h b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad_reg.h
new file mode 100644
index 0000000..95ca3f8
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_klad_reg.h
@@ -0,0 +1,640 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal klad register header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_KLAD_REG_H
+#define HAL_KLAD_REG_H
+
+#define KEY_SIZE_64_BIT    8
+#define KEY_SIZE_128_BIT   16
+#define KEY_SIZE_192_BIT   24
+#define KEY_SIZE_256_BIT   32
+#define SBRK_DISABLE_VAL   0x5
+#define ABRK_DISABLE_VAL   0x5
+
+#define KEY_SIZE_64_BIT_REG_VAL    0x0
+#define KEY_SIZE_128_BIT_REG_VAL   0x1
+#define KEY_SIZE_192_BIT_REG_VAL   0x2
+#define KEY_SIZE_256_BIT_REG_VAL   0x3
+#define KLAD_LOCK_REG_CONFIG_VALUE   1
+#define KLAD_UNLOCK_REG_CONFIG_VALUE 1
+#define KLAD_INVALID_HANDLE_INDEX    (-1)
+
+/*
+ * keyload
+ */
+#define KLAD_REG_OFFSET              (0x00001000)
+
+#define KL_DATA_IN_0        (KLAD_REG_OFFSET + 0x000)
+#define KL_DATA_IN_1        (KLAD_REG_OFFSET + 0x004)
+#define KL_DATA_IN_2        (KLAD_REG_OFFSET + 0x008)
+#define KL_DATA_IN_3        (KLAD_REG_OFFSET + 0x00c)
+#define KL_DATA_IN(n)       (KLAD_REG_OFFSET + 0x000 + ((n) * 0x4))  /* n 0~3 */
+#define KL_KEY_ADDR         (KLAD_REG_OFFSET + 0x010)
+#define KL_KEY_CFG          (KLAD_REG_OFFSET + 0x014)
+#define KL_KEY_SEC_CFG      (KLAD_REG_OFFSET + 0x018)
+#define KL_STATE            (KLAD_REG_OFFSET + 0x030)
+#define KL_CRC              (KLAD_REG_OFFSET + 0x034)
+#define KL_ERROR            (KLAD_REG_OFFSET + 0x038)
+#define KC_ERROR            (KLAD_REG_OFFSET + 0x03c)
+#define KL_INT_EN           (KLAD_REG_OFFSET + 0x040)
+#define KL_INT_RAW          (KLAD_REG_OFFSET + 0x044)
+#define KL_INT              (KLAD_REG_OFFSET + 0x048)
+#define SBRK_DISABLE        (KLAD_REG_OFFSET + 0x060)
+#define ABRK_DISABLE        (KLAD_REG_OFFSET + 0x064)
+#define KL_RK_GEN_STATUS    (KLAD_REG_OFFSET + 0x070)
+#define KL_LOCK_CTRL        (KLAD_REG_OFFSET + 0x074)
+#define KL_UNLOCK_CTRL      (KLAD_REG_OFFSET + 0x078)
+#define KL_COM_LOCK_INFO    (KLAD_REG_OFFSET + 0x07c)
+#define KL_COM_LOCK_STATUS  (KLAD_REG_OFFSET + 0x080)
+#define KL_COM_CTRL         (KLAD_REG_OFFSET + 0x084)
+#define KL_COM_STATUS       (KLAD_REG_OFFSET + 0x088)
+#define KL_CLR_CTRL         (KLAD_REG_OFFSET + 0x438)
+#define KL_ALARM_INFO       (KLAD_REG_OFFSET + 0x600)
+
+/*
+    klad attach kslot type
+*/
+#define ATTACH_FLASH    2
+#define ATTACH_MCIPHER  3
+#define ATTACH_HMAC     4
+
+/*
+    klad data in reg num
+*/
+#define KALD_DATA_IN_REG_NUM  4
+
+/*
+    pbkdf2_key_config
+*/
+#define KDF_SW_GEN      3
+#define KDF_USD         4
+#define KDF_SBRK        5
+#define KDF_ABRK        6
+#define KDF_ODRK0       7
+#define KDF_ODRK1       8
+#define KDF_RDRK        9
+#define KDF_MDRK0       10
+#define KDF_FDRK        11
+#define KDF_MDRK1       12
+#define KDF_DRK         13
+#define KDF_MDRK2       14
+#define KDF_MDRK3       15
+#define KDF_SBRK2       16
+#define KDF_ABRK2       17
+#define KDF_PSK         18
+#define KDF_ABRK_REE    20
+#define KDF_RDRK_REE    22
+
+#define KLAD_KEY_TYPE_SBRK0  0x0
+#define KLAD_KEY_TYPE_SBRK1  0x1
+#define KLAD_KEY_TYPE_SBRK2  0x10
+#define KLAD_KEY_TYPE_ABRK0  0x2
+#define KLAD_KEY_TYPE_ABRK1  0x3
+#define KLAD_KEY_TYPE_ABRK2  0x11
+#define KLAD_KEY_TYPE_DRK0   0xc
+#define KLAD_KEY_TYPE_DRK1   0xd
+#define KLAD_KEY_TYPE_RDRK0  0xe
+#define KLAD_KEY_TYPE_RDRK1  0xf
+#define KLAD_KEY_TYPE_PSK    0x12
+#define KLAD_KEY_TYPE_FDRK0  0x4
+#define KLAD_KEY_TYPE_ODRK0  0x5
+#define KLAD_KEY_TYPE_OARK0  0x6
+#define KLAD_KEY_TYPE_ODRK1  0x7
+#define KLAD_KEY_TYPE_MDRK0  0x8
+#define KLAD_KEY_TYPE_ABRK_REE 0x15
+#define KLAD_KEY_TYPE_RDRK_REE 0x17
+
+#define KDF_FUNC_JTAG   0x13
+#define KDF_TEE_JTAG    0x14
+#define KDF_DFT_JTAG    0x15
+
+#define KLAD_DEST_TYPE_INVALID    0
+#define KLAD_DEST_TYPE_MCIPHER    1
+#define KLAD_DEST_TYPE_AI_AUDIO   4
+#define KLAD_DEST_TYPE_AI_NPU     5
+#define KLAD_DEST_TYPE_FLASH      7
+#define KLAD_UNLOCK_STATUS        0x0
+
+#define KLAD_DEST_TYPE_INVALID_KSLOT     0xffffffff
+#define KLAD_CLEAR_KEY_INVALID_HMAC      0xff
+
+#define CLEAR_HMAC_KEY_BLOCK_SIZE_512    64
+#define CLEAR_HMAC_KEY_BLOCK_SIZE_1024   128
+#define CLEAR_HMAC_KEY_CAL_CNT_512       4
+#define CLEAR_HMAC_KEY_CAL_CNT_1024      8
+#define BYTE_TO_BITS                     8
+#define HKL_KEY_LEN                      16
+#define HKL_KEY_LEN_32                   32
+
+#define KLAD_CHANNEL_MAX_SUPPORT         1
+
+/* define the union hkl_lock_ctrl */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_lock               : 1; /* [0]  */
+        unsigned int    reserved_0            : 3; /* [3..1]  */
+        unsigned int    kl_lock_num           : 3; /* [6..4]  */
+        unsigned int    reserved_1            : 25; /* [31..7]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_lock_ctrl;
+
+/* define the union hkl_com_lock_info */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_com_lock_busy      : 2; /* [1..0]  */
+        unsigned int    kl_com_lock_fail      : 2; /* [3..2]  */
+        unsigned int    kl_com_unlock_fail    : 2; /* [5..4]  */
+        unsigned int    reserved_0            : 2; /* [7..6]  */
+        unsigned int    kl_com_lock_num       : 3; /* [10..8]  */
+        unsigned int    reserved_1            : 21; /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_com_lock_info;
+
+/* Define the union U_KL_COM_LOCK_STATUS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    kl_com_lock_stat      : 8; /* [7..0]  */
+        unsigned int    reserved_0            : 24; /* [31..8]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} hkl_com_lock_status;
+
+/* define the union hkl_unlock_ctrl */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_unlock             : 1; /* [0]  */
+        unsigned int    reserved_0            : 3; /* [3..1]  */
+        unsigned int    kl_unlock_num         : 3; /* [6..4]  */
+        unsigned int    reserved_1            : 1; /* [7]  */
+        unsigned int    kl_com_unlock_num     : 3; /* [10..8]  */
+        unsigned int    reserved_2            : 21; /* [31..11]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_unlock_ctrl;
+
+/* Define the union KL_COM_CTRL */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    kl_com_start          : 1; /* [0]  */
+        unsigned int    kl_com_level_sel      : 3; /* [3..1]  */
+        unsigned int    kl_com_alg_sel        : 2; /* [5..4]  */
+        unsigned int    kl_com_key_size       : 2; /* [7..6]  */
+        unsigned int    rk_choose             : 5; /* [12..8]  */
+        unsigned int    reserved_1            : 19; /* [31..13]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} kl_com_ctrl;
+
+/* Define the union U_KL_COM_STATUS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    kl_com_rk_rdy         : 1; /* [0]  */
+        unsigned int    kl_com_lv1_rdy        : 1; /* [1]  */
+        unsigned int    reserved_0            : 30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} kl_com_status;
+
+/* define the union hkl_key_sec_cfg */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    key_sec               : 1; /* [0]  */
+        unsigned int    src_nsec              : 1; /* [1]  */
+        unsigned int    src_sec               : 1; /* [2]  */
+        unsigned int    dest_nsec             : 1; /* [3]  */
+        unsigned int    dest_sec              : 1; /* [4]  */
+        unsigned int    master_only           : 1; /* [5]  */
+        unsigned int    reserved_0            : 26; /* [31..6]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_key_sec_cfg;
+
+/* define the union u_kl_key_addr */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    key_addr              : 10; /* [9..0]  */
+        unsigned int    reserved_0            : 22; /* [31..10]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_key_addr;
+
+/* define the union hkl_key_cfg */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    port_sel              : 3; /* [2..0]  */
+        unsigned int    reserved_0            : 1; /* [3]  */
+        unsigned int    dsc_code              : 8; /* [11..4]  */
+        unsigned int    reserved_1            : 4; /* [15..12]  */
+        unsigned int    key_enc               : 1; /* [16]  */
+        unsigned int    key_dec               : 1; /* [17]  */
+        unsigned int    kl_flash_sel          : 2; /* [19..18]  */
+        unsigned int    reserved_2            : 12; /* [31..20]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_key_cfg;
+
+/* Define the union U_KL_CLR_CTRL */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    kl_clr_start          : 1; /* [0]  */
+        unsigned int    reserved_0            : 1; /* [1]  */
+        unsigned int    kl_clr_key_size       : 2; /* [3..2]  */
+        unsigned int    reserved_1            : 9; /* [12..4]  */
+        unsigned int    kl_clr_key_cnt        : 3; /* [15..13]  */
+        unsigned int    reserved_2            : 16; /* [31..16]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} kl_clr_ctrl;
+
+/* define the union hkl_nonce_ctrl */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_nonce_start        : 1; /* [0]  */
+        unsigned int    reserved_0            : 3; /* [3..1]  */
+        unsigned int    kl_nonce_alg_sel      : 2; /* [5..4]  */
+        unsigned int    reserved_1            : 26; /* [31..6]  */
+    } bits;
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_nonce_ctrl;
+
+/* define the union hkl_nonce_status */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_nonce_rk_rdy       : 1; /* [0]  */
+        unsigned int    kl_nonce_lvl1_rdy     : 1; /* [1]  */
+        unsigned int    kl_nonce_lvl2_rdy     : 1; /* [2]  */
+        unsigned int    reserved_0            : 29; /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_nonce_status;
+
+/* define the union hkl_clr_lock_info */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_clr_lock_busy      : 2; /* [1..0]  */
+        unsigned int    kl_clr_lock_fail      : 2; /* [3..2]  */
+        unsigned int    kl_clr_unlock_fail    : 2; /* [5..4]  */
+        unsigned int    reserved_0            : 26; /* [31..6]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_clr_lock_info;
+
+/* define the union hkl_clr_lock_status */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_clr_lock_stat      : 8; /* [7..0]  */
+        unsigned int    reserved_0            : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_clr_lock_status;
+
+/* define the union hkl_clr_ctrl */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_clr_start          : 1; /* [0]  */
+        unsigned int    kl_clr_iv_sel         : 1; /* [1]  */
+        unsigned int    kl_clr_key_size       : 2; /* [3..2]  */
+        unsigned int    reserved_0            : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_clr_ctrl;
+
+/* define the union hkl_fp_lock_info */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_fp_lock_busy       : 2; /* [1..0]  */
+        unsigned int    kl_fp_lock_fail       : 2; /* [3..2]  */
+        unsigned int    kl_fp_unlock_fail     : 2; /* [5..4]  */
+        unsigned int    reserved_0            : 26; /* [31..6]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_fp_lock_info;
+
+/* define the union hkl_fp_lock_status */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_fp_lock_stat       : 8; /* [7..0]  */
+        unsigned int    reserved_0            : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_fp_lock_status;
+
+/* define the union hkl_fp_rk_sel */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_fp_rk_sel          : 3; /* [2..0]  */
+        unsigned int    reserved_0            : 29; /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_fp_rk_sel;
+
+/* define the union hkl_fp_ctrl */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_fp_start           : 1; /* [0]  */
+        unsigned int    kl_fp_level_sel       : 1; /* [1]  */
+        unsigned int    reserved_0            : 4; /* [5..2]  */
+        unsigned int    kl_fp_dec_sel         : 1; /* [6]  */
+        unsigned int    reserved_1            : 25; /* [31..7]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_fp_ctrl;
+
+/* define the union hkl_fp_status */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_fp_rk_rdy          : 1; /* [0]  */
+        unsigned int    kl_fp_lv1_enc_rdy     : 1; /* [1]  */
+        unsigned int    kl_fp_lv1_dec_rdy     : 1; /* [2]  */
+        unsigned int    reserved_0            : 29; /* [31..3]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_fp_status;
+
+/* define the union hkl_fp_dec_ctrl */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_fp_dec_rd_dis      : 4; /* [3..0]  */
+        unsigned int    kl_fp_dec_route_dis   : 4; /* [7..4]  */
+        unsigned int    reserved_0            : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_fp_dec_ctrl;
+
+/* define the union hkl_ta_lock_info */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_ta_lock_busy       : 2; /* [1..0]  */
+        unsigned int    kl_ta_lock_fail       : 2; /* [3..2]  */
+        unsigned int    kl_ta_unlock_fail     : 2; /* [5..4]  */
+        unsigned int    reserved_0            : 26; /* [31..6]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_ta_lock_info;
+
+/* define the union hkl_ta_lock_status */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_ta_lock_stat       : 8; /* [7..0]  */
+        unsigned int    reserved_0            : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_ta_lock_status;
+
+/* define the union hkl_ta_ctrl */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_ta_start           : 1; /* [0]  */
+        unsigned int    kl_ta_level_sel       : 2; /* [2..1]  */
+        unsigned int    reserved_0            : 2; /* [4..3]  */
+        unsigned int    kl_ta_cur_128bit_cnt  : 6; /* [10..5]  */
+        unsigned int    kl_ta_last_time       : 1; /* [11]  */
+        unsigned int    kl_ta_lut_alg_sel     : 1; /* [12]  */
+        unsigned int    reserved_1            : 19; /* [31..13]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_ta_ctrl;
+
+/* define the union hkl_ta_status */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_ta_rk_rdy          : 1; /* [0]  */
+        unsigned int    kl_ta_lvl1_rdy        : 1; /* [1]  */
+        unsigned int    kl_ta_lvl2_rdy        : 1; /* [2]  */
+        unsigned int    kl_ta_lvl3_rdy        : 1; /* [3]  */
+        unsigned int    kl_ta_f_lut_rdy       : 1; /* [4]  */
+        unsigned int    kl_ta_f_m_rdy         : 1; /* [5]  */
+        unsigned int    kl_ta_f_bc_rdy        : 1; /* [6]  */
+        unsigned int    reserved_0            : 25; /* [31..7]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_ta_status;
+
+/* define the union hkl_csgk2_lock_info */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_csgk2_lock_busy    : 2; /* [1..0]  */
+        unsigned int    kl_csgk2_lock_fail    : 2; /* [3..2]  */
+        unsigned int    kl_csgk2_unlock_fail  : 2; /* [5..4]  */
+        unsigned int    reserved_0            : 26; /* [31..6]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_csgk2_lock_info;
+
+/* define the union hkl_csgk2_lock_status */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_csgk2_lock_stat    : 8; /* [7..0]  */
+        unsigned int    reserved_0            : 24; /* [31..8]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_csgk2_lock_status;
+
+/* define the union hkl_csgk2_ctrl */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_csgk2_start        : 1; /* [0]  */
+        unsigned int    reserved_0            : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_csgk2_ctrl;
+
+/* define the union hkl_csgk2_disable */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_csgk2_dis          : 4; /* [3..0]  */
+        unsigned int    reserved_0            : 28; /* [31..4]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_csgk2_disable;
+
+/* define the union hkl_csgk2_disable_lock */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    kl_csgk2_dis_lock     : 1; /* [0]  */
+        unsigned int    reserved_0            : 31; /* [31..1]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_csgk2_disable_lock;
+
+/* define the union hkl_alarm_info */
+typedef union {
+    /* define the struct bits */
+    struct {
+        unsigned int    rng_crc4_alarm        : 1; /* [0]  */
+        unsigned int    kl_cfg_sig_alarm      : 1; /* [1]  */
+        unsigned int    kl_rk_tag_sig_alarm   : 1; /* [2]  */
+        unsigned int    kl_rk_tag_crc16_alarm : 1; /* [3]  */
+        unsigned int    kl_rk_info_crc4_alarm : 1; /* [4]  */
+        unsigned int    kl_sel_sig_alarm      : 1; /* [5]  */
+        unsigned int    kl_com_crc16_alarm    : 1; /* [6]  */
+        unsigned int    kl_nonce_crc16_alarm  : 1; /* [7]  */
+        unsigned int    kl_fp_crc16_alarm     : 1; /* [8]  */
+        unsigned int    kl_ta_crc16_alarm     : 1; /* [9]  */
+        unsigned int    kl_ta_fsm_alarm       : 1; /* [10]  */
+        unsigned int    reserved_0            : 13; /* [23..11]  */
+        unsigned int    cm_core_alarm         : 1; /* [24]  */
+        unsigned int    reserved_1            : 7; /* [31..25]  */
+    } bits;
+
+    /* define an unsigned member */
+    unsigned int    u32;
+} hkl_alarm_info;
+
+/* Define the union sbrk_disable */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    sbrk0_disable                : 4; /* [3..0]  */
+        unsigned int    sbrk1_disable                : 4; /* [7..4]  */
+        unsigned int    reserved                     : 24; /* [31..8]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} sbrk_disable;
+
+/* Define the union sbrk_disable */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    abrk0_disable                : 4; /* [3..0]  */
+        unsigned int    reserved                     : 28; /* [31..4]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} abrk_disable;
+
+/* Define the union kl_int_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    kl_int_en                    : 1; /* [0]  */
+        unsigned int    reserved                     : 31; /* [31..1]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} kl_int_cfg;
+
+/* Define the union kl_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    kl_int                       : 1; /* [0]  */
+        unsigned int    reserved                     : 31; /* [31..1]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} kl_int_status;
+
+/* Define the union kl_int_raw */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    com_kl_int_raw               : 1; /* [0]  */
+        unsigned int    reserved0                    : 3; /* [3..1]  */
+        unsigned int    kl_int_num                   : 5; /* [8..4]  */
+        unsigned int    reserved1                    : 5; /* [13..9]  */
+        unsigned int    clr_kl_int_raw               : 1; /* [14]  */
+        unsigned int    reserved2                    : 18; /* [31..15]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} kl_int_raw;
+
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_km_inner.h b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_km_inner.h
new file mode 100644
index 0000000..8826f3a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_km_inner.h
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal rkp register header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_KM_INNER_H
+#define HAL_KM_INNER_H
+
+#include "crypto_type.h"
+
+td_s32 inner_klad_error_check(td_void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_rkp.c b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_rkp.c
new file mode 100644
index 0000000..c548ef8
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_rkp.c
@@ -0,0 +1,475 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal rkp. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "hal_rkp.h"
+#include "hal_rkp_reg.h"
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+#define CRYPTO_U8_TO_U32_BIT_SHIFT(data, i) \
+    ((td_u32)(data)[(i)*4]  | ((td_u32)(data)[(i)*4+1] << 8) | ((td_u32)(data)[(i)*4+2] << 16) | \
+    ((td_u32)(data)[(i)*4+3]<< 24))
+
+#define KM_COMPAT_ERRNO(err_code)     HAL_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+#define RKP_LOCK_TIMEOUT_IN_US      1000000
+td_s32 hal_rkp_lock(td_void)
+{
+    td_u32 i = 0;
+    rkp_lock lock_val = {0};
+    td_u32 rkp_config_val = RKP_LOCK_CPU_REE;
+    crypto_cpu_type cpu_type = crypto_get_cpu_type();
+    if (cpu_type == CRYPTO_CPU_TYPE_SCPU) {
+        rkp_config_val = RKP_LOCK_CPU_TEE;
+    }
+
+    for (i = 0; i < RKP_LOCK_TIMEOUT_IN_US; i++) {
+        km_reg_write(RKP_LOCK, rkp_config_val);
+        lock_val.u32 = km_reg_read(RKP_LOCK);
+        if (lock_val.bits.km_lock_status == rkp_config_val) {
+            break;
+        }
+        crypto_udelay(1);
+    }
+
+    if (i >= RKP_LOCK_TIMEOUT_IN_US) {
+        crypto_log_err("drv_rkp_lock busy.\n");
+        return KM_COMPAT_ERRNO(ERROR_RKP_LOCK_TIMEOUT);
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 hal_rkp_unlock(void)
+{
+    km_reg_write(RKP_LOCK, RKP_LOCK_CPU_IDLE);
+    return TD_SUCCESS;
+}
+
+#define DEOB_UPDATE_KEY_SEL_MRK1        0
+#define DEOB_UPDATE_KEY_SEL_USK         1
+#define DEOB_UPDATE_KEY_SEL_RUSK        2
+
+#define DEOB_UPDATE_ALG_SEL_AES         0
+#define DEOB_UPDATE_ALG_SEL_SM4         1
+
+#define RKP_DEOB_UPDATE_TIMEOUT_IN_US      1000000
+#define KDF_MAX_VAL_LENGTH      64
+#define KDF_PADDING_VAL_LEN         64
+#define KDF_PADDING_SALT_LEN         128
+#define KDF_PADDING_KEY_LEN         128
+
+/*
+    pbkdf2_key_config
+*/
+#define KDF_SW_GEN              3
+
+#define PBKDF2_ALG_SEL_SHA1     1
+#define PBKDF2_ALG_SEL_SHA256   0
+#define PBKDF2_ALG_SEL_SHA384   3
+#define PBKDF2_ALG_SEL_SHA512   4
+#define PBKDF2_ALG_SEL_SM3      5
+
+#define RKP_WAIT_TIMEOUT_IN_US          1000000
+td_s32 hal_rkp_kdf_wait_done(td_void)
+{
+    td_u32 i;
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 kdf_err = 0;
+    rkp_cmd_cfg cmd_cfg = { 0 };
+
+    for (i = 0; i < RKP_WAIT_TIMEOUT_IN_US; ++i) {
+        cmd_cfg.u32 = km_reg_read(RKP_CMD_CFG);
+        if (cmd_cfg.bits.sw_calc_req == 0x0) {
+            km_reg_write(RKP_RAW_INT, 0x1);
+            break;
+        }
+        crypto_udelay(1);
+    }
+    if (i >= RKP_WAIT_TIMEOUT_IN_US) {
+        ret = KM_COMPAT_ERRNO(ERROR_RKP_CALC_TIMEOUT);
+    } else {
+        ret = TD_SUCCESS;
+    }
+
+    /* check kdf err. */
+    kdf_err = km_reg_read(KDF_ERROR);
+    if (kdf_err != 0) {
+        crypto_log_err("kdf_err is 0x%x\n", kdf_err);
+        ret = KM_COMPAT_ERRNO(ERROR_KM_LOGIC);
+    }
+
+    return ret;
+}
+
+#define PBKDF2_KEY_SEL_ABRK_REE     20
+#define PBKDF2_KEY_SEL_RDRK_REE     22
+
+#define PBKDF2_KEY_SEL_SBRK1        5
+#define PBKDF2_KEY_SEL_SBRK2        16
+#define PBKDF2_KEY_SEL_ABRK1        6
+#define PBKDF2_KEY_SEL_ABRK2        17
+#define PBKDF2_KEY_SEL_ODRK0        7
+#define PBKDF2_KEY_SEL_ODRK1        8
+#define PBKDF2_KEY_SEL_RDRK         9
+#define PBKDF2_KEY_SEL_MDRK0        10
+#define PBKDF2_KEY_SEL_FDRK         11
+#define PBKDF2_KEY_SEL_MDRK1        12
+#define PBKDF2_KEY_SEL_DRK          13
+#define PBKDF2_KEY_SEL_MDRK2        14
+#define PBKDF2_KEY_SEL_MDRK3        15
+#define PBKDF2_KEY_SEL_SBRK2        16
+#define PBKDF2_KEY_SEL_ABRK2        17
+#define PBKDF2_KEY_SEL_PSK          18
+
+#define PBKDF2_KEY_ERK_TEE          6
+#define PBKDF2_KEY_ERK_REE          7
+#define PBKDF2_KEY_ERK1_REE          16
+#define PBKDF2_KEY_ERK2_REE          17
+static const crypto_table_item g_rkp_key_sel_table[] = {
+#if defined(CONFIG_KM_ODRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ODRK0, .value = PBKDF2_KEY_SEL_ODRK0
+    },
+#endif
+#if defined(CONFIG_KM_OARK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_OARK0, .value = PBKDF2_KEY_SEL_ODRK0
+    },
+#endif
+#if defined(CONFIG_KM_ODRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ODRK1, .value = PBKDF2_KEY_SEL_ODRK1
+    },
+#endif
+#if defined(CONFIG_KM_ABRK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK_REE, .value = PBKDF2_KEY_SEL_ABRK_REE
+    },
+#endif
+#if defined(CONFIG_KM_RDRK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_RDRK_REE, .value = PBKDF2_KEY_SEL_RDRK_REE
+    },
+#endif
+#if defined(CONFIG_KM_SBRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_SBRK0, .value = PBKDF2_KEY_SEL_SBRK1
+    },
+#endif
+#if defined(CONFIG_KM_SBRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_SBRK1, .value = PBKDF2_KEY_SEL_SBRK1
+    },
+#endif
+#if defined(CONFIG_KM_SBRK2_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_SBRK2, .value = PBKDF2_KEY_SEL_SBRK2
+    },
+#endif
+#if defined(CONFIG_KM_ABRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK0, .value = PBKDF2_KEY_SEL_ABRK1
+    },
+#endif
+#if defined(CONFIG_KM_ABRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK1, .value = PBKDF2_KEY_SEL_ABRK1
+    },
+#endif
+#if defined(CONFIG_KM_ABRK2_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK2, .value = PBKDF2_KEY_SEL_ABRK2
+    },
+#endif
+#if defined(CONFIG_KM_DRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_DRK0, .value = PBKDF2_KEY_SEL_DRK
+    },
+#endif
+#if defined(CONFIG_KM_DRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_DRK1, .value = PBKDF2_KEY_SEL_DRK
+    },
+#endif
+#if defined(CONFIG_KM_RDRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_RDRK0, .value = PBKDF2_KEY_SEL_RDRK
+    },
+#endif
+#if defined(CONFIG_KM_RDRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_RDRK1, .value = PBKDF2_KEY_SEL_RDRK
+    },
+#endif
+#if defined(CONFIG_KM_MDRK0_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_MDRK0, .value = PBKDF2_KEY_SEL_MDRK0
+    },
+#endif
+#if defined(CONFIG_KM_MDRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_MDRK1, .value = PBKDF2_KEY_SEL_MDRK1
+    },
+#endif
+#if defined(CONFIG_KM_MDRK2_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_MDRK2, .value = PBKDF2_KEY_SEL_MDRK2
+    },
+#endif
+#if defined(CONFIG_KM_MDRK3_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_MDRK3, .value = PBKDF2_KEY_SEL_MDRK3
+    },
+#endif
+#if defined(CONFIG_KM_PSK_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_PSK, .value = PBKDF2_KEY_SEL_PSK
+    },
+#endif
+#if defined(CONFIG_KM_ERK_TEE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK_TEE, .value = PBKDF2_KEY_ERK_TEE
+    },
+#endif
+#if defined(CONFIG_KM_ERK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK_REE, .value = PBKDF2_KEY_ERK_REE
+    },
+#endif
+#if defined(CONFIG_KM_ERK1_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK1_REE, .value = PBKDF2_KEY_ERK1_REE
+    },
+#endif
+#if defined(CONFIG_KM_ERK2_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK2_REE, .value = PBKDF2_KEY_ERK2_REE
+    }
+#endif
+};
+
+#define PBKDF2_KEY_LEN_192BIT       0
+#define PBKDF2_KEY_LEN_128BIT       1
+#define PBKDF2_KEY_LEN_256BIT       2
+static const crypto_table_item g_rkp_key_len_table[] = {
+    {
+        .index = CRYPTO_KDF_HARD_KEY_SIZE_128BIT, .value = PBKDF2_KEY_LEN_128BIT
+    },
+#if defined(CONFIG_KM_KEY_LEN_192_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_SIZE_192BIT, .value = PBKDF2_KEY_LEN_192BIT
+    },
+#endif
+#if defined(CONFIG_KM_KEY_LEN_256_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_SIZE_256BIT, .value = PBKDF2_KEY_LEN_256BIT
+    },
+#endif
+};
+
+#define PBKDF2_RDRK_REE_ONEWAY_OFFSET   0
+#define PBKDF2_ABRK_REE_ONEWAY_OFFSET   1
+#define PBKDF2_ODRK1_ONEWAY_OFFSET      2
+#define PBKDF2_ERK_REE_ONEWAY_OFFSET    0
+#define PBKDF2_ERK_TEE_ONEWAY_OFFSET    1
+#define PBKDF2_ERK1_REE_ONEWAY_OFFSET    0
+#define PBKDF2_ERK2_REE_ONEWAY_OFFSET    0
+
+#if defined(CRYPTO_IOT_V200)
+static const crypto_table_item g_rkp_oneway_offset_table[] = {
+#if defined(CONFIG_KM_RDRK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_RDRK_REE, .value = PBKDF2_RDRK_REE_ONEWAY_OFFSET
+    },
+#endif
+#if defined(CONFIG_KM_ABRK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ABRK_REE, .value = PBKDF2_ABRK_REE_ONEWAY_OFFSET
+    },
+#endif
+#if defined(CONFIG_KM_ODRK1_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ODRK1, .value = PBKDF2_ODRK1_ONEWAY_OFFSET
+    },
+#endif
+#if defined(CONFIG_KM_ERK_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK_REE, .value = PBKDF2_ERK_REE_ONEWAY_OFFSET
+    },
+#endif
+#if defined(CONFIG_KM_ERK_TEE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK_TEE, .value = PBKDF2_ERK_TEE_ONEWAY_OFFSET
+    },
+#endif
+#if defined(CONFIG_KM_ERK1_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK1_REE, .value = PBKDF2_ERK1_REE_ONEWAY_OFFSET
+    },
+#endif
+#if defined(CONFIG_KM_ERK2_REE_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_KEY_TYPE_ERK2_REE, .value = PBKDF2_ERK2_REE_ONEWAY_OFFSET
+    }
+#endif
+};
+#endif
+
+static const crypto_table_item g_rkp_hard_alg_sel_table[] = {
+    {
+        .index = CRYPTO_KDF_HARD_ALG_SHA256, .value = PBKDF2_ALG_SEL_SHA256
+    },
+#if defined(CONFIG_KM_KDF_SM3_SUPPORT)
+    {
+        .index = CRYPTO_KDF_HARD_ALG_SM3, .value = PBKDF2_ALG_SEL_SM3
+    },
+#endif
+};
+
+#define KDF_HARD_SALT_LEN           28
+td_s32 hal_rkp_kdf_hard_calculation(const crypto_kdf_hard_calc_param *param)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 i;
+    td_u32 key_sel_reg_val = 0;
+    td_u32 alg_reg_val = 0;
+    td_u32 key_len_reg_val = 0;
+#if defined(CRYPTO_IOT_V200)
+    rkp_oneway_ree onewayval = {0};
+    td_u32 oneway_offset = 0;
+#endif
+    rkp_cmd_cfg cfgval = {0};
+    td_u32 salt_word = 0;
+
+    km_null_ptr_chk(param);
+    if (param->salt != TD_NULL) {
+        crypto_chk_return(param->salt_length != KDF_HARD_SALT_LEN, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "invalid param->salt_length\n");
+    }
+    crypto_chk_return(param->hard_alg != CRYPTO_KDF_HARD_ALG_SHA256 && param->hard_alg != CRYPTO_KDF_HARD_ALG_SM3,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "invalid param->hard->alg\n");
+
+    /* get key_sel. */
+    ret = crypto_get_value_by_index(g_rkp_key_sel_table, crypto_array_size(g_rkp_key_sel_table),
+        param->hard_key_type, &key_sel_reg_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get key_sel failed\n");
+
+    /* get alg_sel. */
+    ret = crypto_get_value_by_index(g_rkp_hard_alg_sel_table, crypto_array_size(g_rkp_hard_alg_sel_table),
+        param->hard_alg, &alg_reg_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get alg_sel failed\n");
+
+    /* get key_len. */
+    ret = crypto_get_value_by_index(g_rkp_key_len_table, crypto_array_size(g_rkp_key_len_table),
+        param->hard_key_size, &key_len_reg_val);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get key_len failed\n");
+
+#if defined(CRYPTO_IOT_V200)
+    /* get oneway_offset. */
+    ret = crypto_get_value_by_index(g_rkp_oneway_offset_table, crypto_array_size(g_rkp_oneway_offset_table),
+        param->hard_key_type, &oneway_offset);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "get oneway_offset failed\n");
+
+    /* config oneway. */
+    if (param->hard_key_type == CRYPTO_KDF_HARD_KEY_TYPE_ERK1_REE) {
+        onewayval.u32 |= (param->is_oneway << oneway_offset);
+        km_reg_write(RKP_ERK1_ONEWAY, onewayval.u32);
+    } else if (param->hard_key_type == CRYPTO_KDF_HARD_KEY_TYPE_ERK2_REE) {
+        onewayval.u32 |= (param->is_oneway << oneway_offset);
+        km_reg_write(RKP_ERK2_ONEWAY, onewayval.u32);
+    } else {
+        onewayval.u32 |= (param->is_oneway << oneway_offset);
+        km_reg_write(RKP_ONEWAY, onewayval.u32);
+    }
+#endif
+    /* config salt. */
+    if (param->salt != TD_NULL) {
+        for (i = 0; i < param->salt_length / CRYPTO_WORD_WIDTH; i++) {
+            salt_word = CRYPTO_U8_TO_U32_BIT_SHIFT(param->salt, i);
+#if defined(CONFIG_KM_CONTENT_KEY_SUPPORT)
+            km_reg_write(RKP_SALT(i), salt_word);
+#else
+            km_reg_write(RKP_PBKDF2_DATA(i), salt_word);
+#endif
+        }
+    }
+    /* config sw_cfg for MDRK0 MDRK1 MDRK2 MDRK3 */
+    if (param->hard_key_type == CRYPTO_KDF_HARD_KEY_TYPE_MDRK0 ||
+        param->hard_key_type == CRYPTO_KDF_HARD_KEY_TYPE_MDRK1 ||
+        param->hard_key_type == CRYPTO_KDF_HARD_KEY_TYPE_MDRK2 ||
+        param->hard_key_type == CRYPTO_KDF_HARD_KEY_TYPE_MDRK3) {
+            km_reg_write(SW_CFG, param->rkp_sw_cfg);
+        }
+    /* config rkp_cmd_cfg. */
+    cfgval.u32 = km_reg_read(RKP_CMD_CFG);
+    cfgval.bits.pbkdf2_key_len = key_len_reg_val;
+    cfgval.bits.pbkdf2_alg_sel_cfg = alg_reg_val;
+    cfgval.bits.pbkdf2_key_sel_cfg = key_sel_reg_val;
+    cfgval.bits.master_key_sel = 0x2;
+
+    cfgval.bits.sw_calc_req = 0x1;         /* start kdf calculation */
+    km_reg_write(RKP_CMD_CFG, cfgval.u32);
+
+    ret = hal_rkp_kdf_wait_done();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_rkp_kdf_wait_done failed\n");
+
+    return ret;
+}
+
+#if defined(CONFIG_RKP_DEBUG_ENABLE)
+td_void hal_rkp_debug(td_void)
+{
+    td_u32 i;
+    td_u32 reg_value = 0;
+    rkp_cmd_cfg cmd_cfg;
+
+    crypto_unused(cmd_cfg);
+    /* RKP_LOCK. */
+    reg_value = km_reg_read(RKP_LOCK);
+    if (reg_value == RKP_LOCK_CPU_REE) {
+        crypto_print("RKP locked by REE CPU!\r\n");
+    } else if (reg_value == RKP_LOCK_CPU_TEE) {
+        crypto_print("RKP locked by TEE CPU!\r\n");
+    }
+
+    /* RKP_CMD_CFG. */
+    cmd_cfg.u32 = km_reg_read(RKP_CMD_CFG);
+    crypto_print("RKP_CMD_CFG: sw_calc_req is 0x%x\r\n", cmd_cfg.bits.sw_calc_req);
+    crypto_print("RKP_CMD_CFG: pbkdf2_alg_sel_cfg is 0x%x\r\n", cmd_cfg.bits.pbkdf2_alg_sel_cfg);
+    crypto_print("RKP_CMD_CFG: pbkdf2_key_sel_cfg is 0x%x\r\n", cmd_cfg.bits.pbkdf2_key_sel_cfg);
+    crypto_print("RKP_CMD_CFG: pbkdf2_key_len is 0x%x\r\n", cmd_cfg.bits.pbkdf2_key_len);
+    crypto_print("RKP_CMD_CFG: rkp_pbkdf_calc_time is 0x%x\r\n", cmd_cfg.bits.rkp_pbkdf_calc_time);
+
+    /* KDF_ERROR. */
+    crypto_print("KDF_ERROR is 0x%x\r\n", km_reg_read(KDF_ERROR));
+    /* RKP_RAW_INT */
+    crypto_print("RKP_RAW_INT is 0x%x\r\n", km_reg_read(RKP_RAW_INT));
+    /* RKP_INT_ENABLE */
+    crypto_print("RKP_INT_ENABLE is 0x%x\r\n", km_reg_read(RKP_INT_ENABLE));
+    /* RKP_INT */
+    crypto_print("RKP_INT is 0x%x\r\n", km_reg_read(RKP_INT));
+    /* RKP_DEOB_CFG */
+    crypto_print("RKP_DEOB_CFG is 0x%x\r\n", km_reg_read(RKP_DEOB_CFG));
+    /* DEOB_ERROR */
+    crypto_print("DEOB_ERROR is 0x%x\r\n", km_reg_read(DEOB_ERROR));
+    /* RK_RDY */
+    crypto_print("RK_RDY is 0x%x\r\n", km_reg_read(RK_RDY));
+    /* RKP_SALT */
+    for (i = 0; i < KDF_HARD_SALT_LEN / CRYPTO_WORD_WIDTH; i++) {
+        crypto_print("RKP_PBKDF2_DATA is 0x%x\r\n", km_reg_read(RKP_PBKDF2_DATA(i)));
+    }
+    /* RKP_ONEWAY */
+    crypto_print("RKP_ONEWAY is 0x%x\r\n", km_reg_read(RKP_ONEWAY));
+    crypto_print("RKP_ERK1_ONEWAY is 0x%x\r\n", km_reg_read(RKP_ERK1_ONEWAY));
+    crypto_print("RKP_ERK2_ONEWAY is 0x%x\r\n", km_reg_read(RKP_ERK2_ONEWAY));
+
+    crypto_print("RKP_PBKDF2_RSLT_CRC is 0x%x\n", km_reg_read(RKP_PBKDF2_RSLT_CRC));
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_rkp_reg.h b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_rkp_reg.h
new file mode 100644
index 0000000..b571751
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/km_v4/hal_rkp_reg.h
@@ -0,0 +1,156 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal rkp register header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef HAL_RKP_REG_H
+#define HAL_RKP_REG_H
+
+#define RKP_LOCK_CPU_IDLE  0
+#define RKP_LOCK_CPU_REE   1
+#define RKP_LOCK_CPU_TEE   2
+#define RKP_LOCK_CPU_PCPU  4
+#define RKP_LOCK_CPU_AIDSP 5
+
+/* Current CPU ID Status .
+8'h35: AIDSP;
+8'h6a: PCPU;
+8'ha5: TEE;
+8'haa: ACPU.
+*/
+#define PCPU_STAT     0x6a
+#define AIDSP_STAT    0x35
+#define TEE_STAT      0xa5
+#define ACPU_STAT     0xaa
+
+#define PBKDF2_ALG_HMAC_SHA1       1
+#define PBKDF2_ALG_HMAC_SHA256     0
+#define PBKDF2_ALG_HMAC_SHA384     3
+#define PBKDF2_ALG_HMAC_SHA512     4
+#define PBKDF2_ALG_HMAC_SM3        5
+
+#define HMAC_SHA1_OUTPUT_LEN       20
+#define HMAC_SHA256_OUTPUT_LEN     32
+#define HMAC_SHA384_OUTPUT_LEN     48
+#define HMAC_SHA512_OUTPUT_LEN     64
+#define HMAC_SM3_OUTPUT_LEN        32
+
+#define KDF_KEY_BLOCK_SIZE_512     64
+#define KDF_KEY_BLOCK_SIZE_1024    128
+#define KDF_KEY_CONFIG_LEN         32
+#define KDF_SALT_CONFIG_LEN        32
+#define KDF_VAL_CONFIG_LEN         16
+#define KDF_ALG_TYPE               5
+#define DRV_KDF_OTP_KEY_MRK1       0
+#define DRV_KDF_OTP_KEY_USK        1
+#define DRV_KDF_OTP_KEY_RUSK       2
+#define DRV_KDF_DEOB_ALG_AES       0
+#define DRV_KDF_DEOB_ALG_SM4       1
+
+/*
+ * rkp
+ */
+#define RKP_LOCK                (0x000)
+#define RKP_CMD_CFG             (0x004)
+#define KDF_ERROR               (0x008)
+#define RKP_DEOB_CFG            (0x020)
+#define DEOB_ERROR              (0x028)
+#define RK_RDY                  (0x050)
+#define RKP_USD_DIS             (0x054)
+#define RKP_LOW_POWER           (0x058)
+#define RKP_INIT                (0x05C)
+#define SW_CFG                  (0x060)
+#define RKP_RAW_INT             (0x010)
+#define RKP_INT_ENABLE          (0x014)
+#define RKP_INT                 (0x018)
+#define RKP_PBKDF2_DATA(a)      (0x100 + 4 * (a)) /* a 0~31 */
+#define RKP_PBKDF2_KEY(a)       (0x180 + 4 * (a)) /* a 0~31 */
+#define RKP_PBKDF2_VAL(b)       (0x200 + 4 * (b)) /* b 0~16 */
+#define RKP_USD(c)              (0x300 + 4 * (c)) /* c 0~8 */
+#define RKP_SALT(e)             (0x340 + 4 * (e)) /* e 0~6 */
+#define RKP_ONEWAY              (0x360)
+#define RKP_ERK1_ONEWAY         (0x368)
+#define RKP_ERK2_ONEWAY         (0x36C)
+#define RKP_ALARM               (0x400)
+#define RKP_PBKDF2_RSLT_CRC     (0x060)
+
+/* Define the union U_RKP_RKP_LOCK */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    km_lock_status            : 3; /* [2..0]  */
+        unsigned int    reserved                  : 29; /* [31..3]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} rkp_lock;
+
+/* Define the union U_RKP_CMD_CFG */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    sw_calc_req               : 1; /* [0]  */
+        unsigned int    pbkdf2_alg_sel_cfg        : 3; /* [3..1]  */
+        unsigned int    pbkdf2_key_sel_cfg        : 5; /* [8..4]  */
+        unsigned int    reserved                  : 3; /* [11..9]  */
+        unsigned int    master_key_sel            : 2; /* [13..12]  */
+        unsigned int    pbkdf2_key_len            : 2; /* [15..14]  */
+        unsigned int    rkp_pbkdf_calc_time       : 16; /* [31..16]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} rkp_cmd_cfg;
+
+/* Define the union rkp_oneway_ree */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    pbkdf2_rdrk_oneway          : 1; /* [0]  */
+        unsigned int    pbkdf2_abrk_oneway          : 1; /* [1]  */
+        unsigned int    pbkdf2_odrk1_oneway         : 1; /* [2]  */
+        unsigned int    reserved                    : 29; /* [31..3]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} rkp_oneway_ree;
+
+/* Define the union rkp_deob_cfg */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    deob_update_req            : 1; /* [0]  */
+        unsigned int    deob_update_sel            : 2; /* [2..1]  */
+        unsigned int    deob_update_alg_sel        : 1; /* [3]  */
+        unsigned int    reserved                  : 29; /* [31..4]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} rkp_deob_cfg;
+
+/* Define the union rkp_int_enable */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    rkp_int_enable            : 1; /* [0]  */
+        unsigned int    reserved                  : 31; /* [31..1]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} rkp_int_cfg;
+
+/* Define the union rkp_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    rkp_int                   : 1; /* [0]  */
+        unsigned int    reserved                  : 31; /* [31..1]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} rkp_int_status;
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/calc_hash.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/calc_hash.c
new file mode 100644
index 0000000..6bd4024
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/calc_hash.c
@@ -0,0 +1,100 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg calc_hash. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#if defined(CONFIG_PKE_CAL_HASH_SUPPORT)
+
+#include "hal_pke_alg.h"
+#include "drv_pke_inner.h"
+#include "drv_hash.h"
+
+#include "crypto_drv_common.h"
+#include "crypto_hash_common.h"
+
+static crypto_hash_type drv_pke_get_hash_type(drv_pke_hash_type hash_type)
+{
+    switch (hash_type) {
+        case DRV_PKE_HASH_TYPE_SHA1:
+            return CRYPTO_HASH_TYPE_SHA1;
+        case DRV_PKE_HASH_TYPE_SHA224:
+            return CRYPTO_HASH_TYPE_SHA224;
+        case DRV_PKE_HASH_TYPE_SHA256:
+            return CRYPTO_HASH_TYPE_SHA256;
+        case DRV_PKE_HASH_TYPE_SHA384:
+            return CRYPTO_HASH_TYPE_SHA384;
+        case DRV_PKE_HASH_TYPE_SHA512:
+            return CRYPTO_HASH_TYPE_SHA512;
+        case DRV_PKE_HASH_TYPE_SM3:
+            return CRYPTO_HASH_TYPE_SM3;
+        default:
+            crypto_log_err("Invalid hash_type\n");
+            return CRYPTO_HASH_TYPE_INVALID;
+    }
+}
+
+static int inner_hash_update(td_handle hash_handle, unsigned char *buf, unsigned int buf_len)
+{
+    int ret;
+    crypto_buf_attr src_buf;
+    unsigned char *data_buf = NULL;
+
+    data_buf = crypto_malloc_coherent(buf_len, "calc_hash_buf");
+    crypto_chk_return(data_buf == NULL, ERROR_MALLOC, "crypto_malloc_coherent failed\n");
+
+    ret = memcpy_s(data_buf, buf_len, buf, buf_len);
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_free, ERROR_MEMCPY_S, "drv_cipher_hash_update failed\n");
+
+    src_buf.virt_addr = data_buf;
+    ret = drv_cipher_hash_update(hash_handle, &src_buf, buf_len);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "drv_cipher_hash_update failed\n");
+
+exit_free:
+    (void)memset_s(data_buf, buf_len, 0, buf_len);
+    crypto_free_coherent(data_buf);
+    return ret;
+}
+
+#define INVALID_HANDLE  0xFFFF0000
+td_s32 hal_pke_alg_calc_hash(const drv_pke_data *arr, td_u32 arr_len,
+    const drv_pke_hash_type hash_type, drv_pke_data *hash)
+{
+    td_s32 ret = TD_FAILURE;
+    td_handle h_handle = INVALID_HANDLE;
+    td_u32 i;
+    crypto_hash_type hash_alg;
+    crypto_hash_attr hash_attr;
+    crypto_param_check(arr == TD_NULL);
+    crypto_param_check(hash == TD_NULL);
+    crypto_param_check(hash->data == TD_NULL);
+
+    hash_common_lock();
+    hash_alg = drv_pke_get_hash_type(hash_type);
+    crypto_chk_goto_with_ret(ret, hash_alg == CRYPTO_HASH_TYPE_INVALID, exit_free,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hash type invalid\n");
+    hash_attr = (crypto_hash_attr){.hash_type = hash_alg};
+
+    ret = drv_cipher_hash_start(&h_handle, &hash_attr);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "drv_cipher_hash_start failed\n");
+
+    for (i = 0;i < arr_len; i++) {
+        ret = inner_hash_update(h_handle, arr[i].data, arr[i].length);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, hash_destroy, "inner_hash_update failed\n");
+    }
+    ret = drv_cipher_hash_finish(h_handle, hash->data, &(hash->length));
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, hash_destroy, "drv_cipher_hash_finish failed\n");
+    h_handle = INVALID_HANDLE;
+
+hash_destroy:
+    if (h_handle != INVALID_HANDLE) {
+        drv_cipher_hash_destroy(h_handle);
+    }
+exit_free:
+    hash_common_unlock();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_check_dot_on_curve.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_check_dot_on_curve.c
new file mode 100644
index 0000000..7835671
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_check_dot_on_curve.c
@@ -0,0 +1,84 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_check_dot_on_curve. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_CHECK_DOT_ON_CURVE_SUPPORT) || defined(CONFIG_PKE_ECC_SM2_PRIV_DEC_SUPPORT)
+
+#include "hal_pke_alg.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+
+#include "drv_pke_inner.h"
+
+#include "crypto_drv_common.h"
+
+static td_s32 inner_ecfp_demontgomery_data_jac_z(const drv_pke_data *z, td_u32 work_len)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_drv_func_enter();
+
+    /* Step 1: start calculate. */
+    ret = inner_batch_instr_process(&instr_ecfp_demont_cz_3, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* Step 2: get data from PKE DRAM */
+    if (z != TD_NULL && z->data != TD_NULL) {
+        hal_pke_get_ram(sec_arg_add_cs(ecc_addr_cz, z->data, z->length));
+    }
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+static td_s32 inner_ecc_ecfp_point_valid_standard(const drv_pke_ecc_curve *curve, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 z[DRV_PKE_LEN_576] = {0};
+    drv_pke_data check_z = { .data = z, .length = curve->ksize };
+    drv_pke_data mod_p = { .data = (td_u8 *)curve->p, .length = curve->ksize };
+    drv_pke_data kk = { .data = (td_u8 *)curve->n, .length = curve->ksize };
+    crypto_drv_func_enter();
+
+    /* Step 1: montgomerize the pub_key point */
+    ret = inner_ecfp_montgomery_data_aff(pub_key, &mod_p, TD_NULL);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_montgomery_data_aff failed\n");
+
+    /* Step 2: trans Affine coordinate system to Jacobin coordinate system */
+    ret = inner_ecfp_aff_to_jac(TD_NULL, &mod_p, TD_NULL);
+    crypto_chk_func_return(inner_ecfp_aff_to_jac, ret);
+
+    /* Step 3: calculate [n] * P */
+    ret = inner_ecfp_mul_naf_cal(curve->ksize / ALIGNED_TO_WORK_LEN_IN_BYTE, &kk);
+    crypto_chk_func_return(inner_ecfp_mul_naf_cal, ret);
+
+    /* Step 4: no need to trans result data from jacobin coordinate system to affine coordinate system. */
+
+    /* Step 5: demontgomery data of point.z. */
+    ret = inner_ecfp_demontgomery_data_jac_z(&check_z, curve->ksize / ALIGNED_TO_WORK_LEN_IN_BYTE);
+    crypto_chk_func_return(inner_ecfp_demontgomery_data_jac_z, ret);
+
+    *is_on_curve = TD_FALSE;
+    if (inner_drv_is_zero(check_z.data, check_z.length) == TD_TRUE) {
+        *is_on_curve = TD_TRUE;
+    };
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+int hal_pke_alg_ecc_check_dot_on_curve(const drv_pke_ecc_point *point, td_bool *is_on_curve)
+{
+    const drv_pke_ecc_curve *curve = TD_NULL;
+    hal_pke_alg_ecc_init_check();
+
+    curve = hal_pke_alg_ecc_get_curve();
+    crypto_chk_return(curve == TD_NULL, CRYPTO_FAILURE, "hal_pke_alg_ecc_get_curve failed\n");
+
+    return inner_ecc_ecfp_point_valid_standard(curve, point, is_on_curve);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_common.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_common.c
new file mode 100644
index 0000000..b6ff5d1
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_common.c
@@ -0,0 +1,93 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_common. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#include "hal_pke_alg.h"
+
+#include "crypto_pke_common.h"
+#include "hal_pke_v5.h"
+#include "drv_pke_inner.h"
+#include "pke_alg_inner.h"
+
+/* ECC Curve Parameters. */
+static const drv_pke_ecc_curve *g_ecc_curve = NULL;
+static const pke_ecc_init_param *g_init_param = NULL;
+static td_bool g_ecc_init_flag = TD_FALSE;
+
+int hal_pke_alg_ecc_init(drv_pke_ecc_curve_type curve_type)
+{
+    int ret = CRYPTO_FAILURE;
+    if (g_ecc_init_flag == TD_TRUE) {
+        return CRYPTO_SUCCESS;
+    }
+
+    ret = inner_pke_alg_resume();
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_pke_alg_resume failed\n");
+
+    ret = get_ecc_param(curve_type, &g_ecc_curve, &g_init_param);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, error_unlock, "get_ecc_param failed\n");
+    crypto_chk_goto_with_ret(ret, g_ecc_curve == NULL, error_unlock, CRYPTO_FAILURE,
+        "get_ecc_param for ecc_curve failed\n");
+    crypto_chk_goto_with_ret(ret, g_init_param == NULL, error_unlock, CRYPTO_FAILURE,
+        "get_ecc_param for init_param failed\n");
+
+    ret = hal_pke_set_init_param(g_init_param, g_ecc_curve);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, error_unlock, "hal_pke_set_init_param failed\n");
+
+    g_ecc_init_flag = TD_TRUE;
+    return ret;
+
+error_unlock:
+    inner_pke_alg_suspend();
+    g_ecc_curve = NULL;
+    g_init_param = NULL;
+    return ret;
+}
+
+void hal_pke_alg_ecc_deinit(void)
+{
+    if (g_ecc_init_flag == TD_FALSE) {
+        return;
+    }
+    g_ecc_curve = TD_NULL;
+    g_init_param = TD_NULL;
+    inner_pke_alg_suspend();
+    g_ecc_init_flag = TD_FALSE;
+}
+
+td_bool hal_pke_alg_ecc_is_init(void)
+{
+    return g_ecc_init_flag;
+}
+
+const unsigned char *hal_pke_alg_ecc_get_n(void)
+{
+    return g_ecc_curve->n;
+}
+
+const unsigned char *hal_pke_alg_ecc_get_p_minus_2(void)
+{
+    return g_init_param->p_minus_2;
+}
+
+unsigned int hal_pke_alg_ecc_get_klen(void)
+{
+    if (g_ecc_init_flag == TD_FALSE) {
+        return 0;
+    }
+    return g_ecc_curve->ksize;
+}
+
+const drv_pke_ecc_curve *hal_pke_alg_ecc_get_curve(void)
+{
+    return g_ecc_curve;
+}
+
+const pke_ecc_init_param *hal_pke_alg_ecc_get_init_param(void)
+{
+    return g_init_param;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_s.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_s.c
new file mode 100644
index 0000000..7f7a4a3
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_s.c
@@ -0,0 +1,73 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_compute_s. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_ECDSA_SIGN_SUPPORT)
+
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+
+static td_s32 ecc_ecfn_sign_s(const drv_pke_data *k_inv, const drv_pke_data *e, const drv_pke_data *d,
+    const drv_pke_data *r, const drv_pke_data *n, const drv_pke_data *s)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 work_len;
+    crypto_drv_func_enter();
+    check_sum_inspect(PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), k_inv, e, d, r, n, s);
+
+    work_len = n->length / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    /* 1. check free, no need here, for the former calculation will definitely wait for PKE not busy. */
+
+    /* Step 1: set data into PKE DRAM. the ecc_addr_rrn and ecc_addr_const_1 have been set in intial parameters. */
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_r, r->data, r->length, n->length));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_e, e->data, e->length, n->length));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_d, d->data, d->length, n->length));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_s, k_inv->data, k_inv->length, n->length));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_n, n->data, n->length, n->length));
+
+    /* Step 2. start calculate. */
+    ret = inner_batch_instr_process(&instr_ecfn_sign_s_12, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* Step 3: get data from PKE DRAM */
+    hal_pke_get_ram(sec_arg_add_cs(ecc_addr_s, s->data, s->length));
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+/* s = k^-1(e + dr) mod n */
+int hal_pke_alg_ecc_compute_s(const drv_pke_data *k, const drv_pke_data *e, const drv_pke_data *d,
+    const drv_pke_data *r, const drv_pke_data *s)
+{
+    int ret;
+    unsigned char k_inv_buf[MAX_ECC_SIZE];
+    drv_pke_data k_inv_data = {
+        .data = k_inv_buf,
+        .length = k->length
+    };
+    drv_pke_data n = {0};
+    const drv_pke_ecc_curve *ecc_curve = NULL;
+    hal_pke_alg_ecc_init_check();
+
+    ecc_curve = hal_pke_alg_ecc_get_curve();
+    n.data = (unsigned char *)ecc_curve->n;
+    n.length = ecc_curve->ksize;
+    /* Step 1. Compute k_inv. */
+    ret = hal_pke_alg_ecc_inv_mod(k, &k_inv_data);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_inv_mod failed\n");
+
+    /* Step 2. Compute s = k_inv * (e + d * r) mod n. */
+    ret = ecc_ecfn_sign_s(&k_inv_data, e, d, r, &n, s);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "ecc_ecfn_sign_s failed\n");
+
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_u1_and_u2.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_u1_and_u2.c
new file mode 100644
index 0000000..1d3acf4
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_u1_and_u2.c
@@ -0,0 +1,44 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_compute_u1_and_u2. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+
+int hal_pke_alg_ecc_compute_u1_and_u2(const drv_pke_data *w, const drv_pke_data *e, const drv_pke_data *r,
+    const drv_pke_data *u1, const drv_pke_data *u2)
+{
+    int ret;
+    unsigned int klen;
+    unsigned int work_len;
+    const drv_pke_ecc_curve *ecc_curve = NULL;
+    hal_pke_alg_ecc_init_check();
+
+    klen = hal_pke_alg_ecc_get_klen();
+    ecc_curve = hal_pke_alg_ecc_get_curve();
+    work_len = klen / ALIGNED_TO_WORK_LEN_IN_BYTE;
+
+    /* Step 1: set data into PKE DRAM. the ecc_addr_rrn and ecc_addr_const_1 is set in initial parameters. */
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_e, e->data, e->length, klen));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_r, r->data, r->length, klen));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_s, w->data, w->length, klen));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_m, ecc_curve->n, klen, klen));
+
+    /* Step 2: start calculate. */
+    ret = inner_batch_instr_process(&instr_ecfn_verify_u_10, work_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_batch_instr_process failed\n");
+
+    /* Step 3: get result out of PKE DRAM */
+    hal_pke_get_ram(sec_arg_add_cs(ecc_addr_u1, u1->data, u1->length));
+    hal_pke_get_ram(sec_arg_add_cs(ecc_addr_u2, u2->data, u2->length));
+
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_x.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_x.c
new file mode 100644
index 0000000..840552e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_compute_x.c
@@ -0,0 +1,142 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_compute_x. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_ECDSA_VERIFY_SUPPORT) || defined(CONFIG_PKE_ECC_SM2_VERIFY_SUPPORT)
+
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+
+/* Only used for hal_pke_alg_ecc_compute_x. */
+static td_s32 point_multi_mul_sim(const drv_pke_ecc_curve *ecc, const drv_pke_data *u1,
+    const drv_pke_data *u2)
+{
+    td_s32 ret = TD_FAILURE;
+    td_s32 i = 0;
+    td_s32 j = 0;
+    td_u32 work_len = ecc->ksize / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    td_u8 u1_bit = 0;
+    td_u8 u2_bit = 0;
+    td_u8 bit_2 = 0;
+    td_bool first_flag = TD_TRUE;
+    const rom_lib *rom_lib_first_list[4] = {    // 4: select by bit_2
+        TD_NULL, &instr_ecfp_cpy_p2c_3, &instr_ecfp_cpy_g2c_3, &instr_ecfp_cpy_a2c_3
+    };
+    const rom_lib *rom_lib_second_list[4] = {   // 4: select by bit_2
+        &instr_ecfp_mul_c_double_22, &instr_ecfp_mul_p_22_18, &instr_ecfp_mul_g_22_18, &instr_ecfp_mul_jj_22_23
+    };
+
+    /*
+     * 1) u1->data and u2->data are two byte arrays, their length u1->length and u2->length is the sample.
+     * 2) For each bit in u1->data and u2->data, get bit_2 = u1_bit | u2_bit in order.
+     * 3) If there is one bit_2 is not zero, then all the next bit_2(contain this time) will call
+        inner_batch_instr_process(), the first param depends on bit_2's value.
+     */
+    for (i = 0; i < (td_s32)u1->length; i++) {
+        if (i >= (td_s32)u1->length || i >= (td_s32)u2->length) {
+            break;
+        }
+        for (j = CRYPTO_BITS_IN_BYTE - 1; j >= 0; j--) {
+            u1_bit = (u1->data[i] >> j) & 1;
+            u2_bit = (u2->data[i] >> j) & 1;
+            bit_2 = ((u1_bit << 1) | u2_bit);       // bit_2 = u1_bit | u2_bit
+            if (first_flag == TD_TRUE) {
+                if (bit_2 == 0) {
+                    continue;
+                }
+                ret = inner_batch_instr_process(rom_lib_first_list[bit_2], work_len);
+                crypto_chk_return(ret != TD_SUCCESS, ret, "inner_batch_instr_process failed\n");
+                first_flag = TD_FALSE;
+            } else {
+                ret = inner_batch_instr_process(rom_lib_second_list[bit_2], work_len);
+                crypto_chk_return(ret != TD_SUCCESS, ret, "inner_batch_instr_process failed\n");
+            }
+        }
+    }
+
+    return TD_SUCCESS;
+}
+
+int hal_pke_alg_ecc_compute_x(const drv_pke_data *u1, const drv_pke_data *u2,
+    const drv_pke_ecc_point *q, const drv_pke_data *x)
+{
+    int ret;
+    unsigned int aligned_len;
+    drv_pke_ecc_point g = {0};
+    unsigned char g_x_jac[DRV_PKE_LEN_576] = {0};
+    unsigned char g_y_jac[DRV_PKE_LEN_576] = {0};
+    unsigned char q_x_jac[DRV_PKE_LEN_576] = {0};
+    unsigned char q_y_jac[DRV_PKE_LEN_576] = {0};
+    /* get const value 0, and montgomerized p */
+    drv_pke_data pp = {0};
+    drv_pke_ecc_point g_jac = {.x = g_x_jac, .y = g_y_jac};
+    drv_pke_ecc_point q_jac = {.x = q_x_jac, .y = q_y_jac};
+    const drv_pke_ecc_curve *ecc_curve = NULL;
+    const pke_ecc_init_param *init_param = NULL;
+    hal_pke_alg_ecc_init_check();
+    ecc_curve = hal_pke_alg_ecc_get_curve();
+    init_param = hal_pke_alg_ecc_get_init_param();
+
+    g.x = (unsigned char *)ecc_curve->gx;
+    g.y = (unsigned char *)ecc_curve->gy;
+    g.length = ecc_curve->ksize;
+    pp.data = (unsigned char *)ecc_curve->p;
+    pp.length = ecc_curve->ksize;
+    g_jac.length = ecc_curve->ksize;
+    q_jac.length = ecc_curve->ksize;
+
+    ret = hal_pke_set_mont_para(init_param->mont_param_p[1], init_param->mont_param_p[0]);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_set_mont_para failed\n");
+
+    /* Step 1: montgomery the input point. */
+    ret = inner_ecfp_montgomery_data_aff(&g, &pp, &g_jac);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_montgomery_data_aff failed\n");
+    ret = inner_ecfp_montgomery_data_aff(q, &pp, &q_jac);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_montgomery_data_aff failed\n");
+
+    /* Step 2: A = P + Q, from affine to jacobin. */
+    /* 2.1 set data into PKE DRAM. */
+    ret = hal_pke_get_align_val(ecc_curve->ksize, &aligned_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_get_align_val failed\n");
+
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_px, q_jac.x, q_jac.length, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_py, q_jac.y, q_jac.length, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_gx, g_jac.x, g_jac.length, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_gy, g_jac.y, g_jac.length, aligned_len));
+
+#if defined(CONFIG_PKE_ECC_TRACE_ENABLE)
+    crypto_dump_data("q_jac.x", q_jac.x, q_jac.length);
+    crypto_dump_data("q_jac.y", q_jac.y, q_jac.length);
+    crypto_dump_data("g_jac.x", g_jac.x, g_jac.length);
+    crypto_dump_data("g_jac.y", g_jac.y, g_jac.length);
+#endif
+    /* point add A = G + Q. */
+    ret = inner_batch_instr_process(&instr_ecfp_add_ja_verify_18,
+        aligned_len / ALIGNED_TO_WORK_LEN_IN_BYTE);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_batch_instr_process failed\n");
+
+    /* Step 3: simultaneous calculate multi-multiplication. */
+    ret = point_multi_mul_sim(sec_arg_add_cs(ecc_curve, u1, u2));
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "point_multi_mul_sim failed\n");
+
+    /* Step 4: trans Jacobin to Affine. */
+    ret = inner_ecfp_jac_to_aff(&pp);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_jac_to_aff failed\n");
+
+    /* Step 5: demontgomery, just process, not get data out of the DRAM. */
+    ret = inner_ecfp_demontgomery_data_aff(TD_NULL, aligned_len / ALIGNED_TO_WORK_LEN_IN_BYTE);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_demontgomery_data_aff failed\n");
+
+    /* Step 6: get result out from PKE data RAM. only need to get r.x for compare. */
+    hal_pke_get_ram(sec_arg_add_cs(ecc_addr_cx, x->data, x->length));
+
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_inner.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_inner.c
new file mode 100644
index 0000000..bb709f8
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_inner.c
@@ -0,0 +1,208 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_inner. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#include "pke_alg_inner.h"
+
+#include "hal_pke_v5.h"
+#include "hal_pke_alg.h"
+#include "crypto_drv_common.h"
+#include "pke_alg_inner.h"
+#include "drv_pke_inner.h"
+
+#define JAC_TO_AFF_INSTR_NUM    6
+static td_s32 inner_jac_to_aff_cal(const rom_lib *batch_instr, const td_u32 batch_instr_num,
+    const drv_pke_data *mod_p)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    td_s32 j = 0;
+    const td_u8 *mod_p_2 = NULL;
+    td_u8 bit_2 = 0;
+    td_bool start_flag = TD_FALSE;
+    td_u32 work_len = mod_p->length / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    crypto_drv_func_enter();
+
+    mod_p_2 = hal_pke_alg_ecc_get_p_minus_2();
+
+    /* 1. set necessary data into DRAM, which should have been set by former process. */
+    /* get work_len */
+    hal_crypto_pke_check_param(batch_instr_num != JAC_TO_AFF_INSTR_NUM);
+
+    /* 2. start transform */
+    /* 2.1 preprocess, initialize the data, use batch process step. */
+    ret = inner_batch_instr_process(&batch_instr[0], work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* 2.2 expand (p-2)'s bit length to 2n, and calculate from high bit */
+    /*
+     * 1) mod_p_2 is one byte array, mod_p->length is the byte number.
+     * 2) For each byte in mod_p_2, get bit2 = byte[7:6], byte[5:4], byte[3:2], byte[1:0] in order.
+     * 3) If there is one bit2 is not zero, then all the next bit2(contain this time) will call barch_process(),
+            the first param depends on bit2's value.
+     */
+    for (i = 0; i < mod_p->length; i++) {
+        for (j = 3; j >= 0; j--) {                  // 3: get byte[7:6], byte[5:4], byte[3:2], byte[1:0] in order.
+            bit_2 = (mod_p_2[i] >> (j * 2)) & 0x3;   // 2, 0x3: get bit2
+            if ((start_flag == TD_FALSE) && (bit_2 != 0)) {
+                start_flag = TD_TRUE;
+                ret = inner_batch_instr_process(&batch_instr[bit_2 + 1], work_len);
+                crypto_chk_return(ret != TD_SUCCESS, ret, "inner_batch_instr_process failed\n");
+                crypto_timer_end(TIMER_ID_5, "Step 2.2 process");
+            } else if (start_flag == TD_TRUE) {
+                ret = inner_batch_instr_process(&batch_instr[bit_2 + 1], work_len);
+                crypto_chk_return(ret != TD_SUCCESS, ret, "inner_batch_instr_process failed\n");
+                crypto_timer_end(TIMER_ID_5, "Step 2.2 process");
+            }
+        }
+    }
+
+    /* 2.3 postprocess, demontgomery and complete reduction */
+    ret = inner_batch_instr_process(&batch_instr[5], work_len); /* 5: instr index. */
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    crypto_timer_end(TIMER_ID_5, "Step 2.3");
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+/* use when the process only have ecc related data address. */
+td_s32 inner_ecfp_montgomery_data_aff(const drv_pke_ecc_point *in, const drv_pke_data *mod_p,
+    const drv_pke_ecc_point *out)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 in_aligned_len = 0;
+    td_u32 out_aligned_len = 0;
+    td_u32 work_len = 0;
+    crypto_drv_func_enter();
+
+    hal_crypto_pke_check_param(in == TD_NULL || in->x == TD_NULL || in->y == TD_NULL);
+    hal_crypto_pke_check_param(mod_p == TD_NULL || mod_p->data == TD_NULL);
+    /* the out should be enough to save result. */
+    hal_crypto_pke_check_param(out != TD_NULL && out->x != TD_NULL &&
+                               out->y != TD_NULL && mod_p->length != out->length);
+
+    /* P = P * rrp mod p to Montgomery data, point mul_mud */
+    /* 1. wait for PKE free */
+    ret = hal_pke_check_free();
+    crypto_chk_func_return(hal_pke_check_free, ret);
+
+    /* 2. set data to DRAM */
+    hal_pke_get_align_val(in->length, &in_aligned_len);
+    if (out != TD_NULL) {
+        hal_pke_get_align_val(out->length, &out_aligned_len);
+        in_aligned_len = (out_aligned_len >= in_aligned_len) ? out_aligned_len : in_aligned_len;
+    }
+    work_len = in_aligned_len / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_px, in->x, in->length, in_aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_py, in->y, in->length, in_aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_m, mod_p->data, mod_p->length, in_aligned_len));
+
+    /* 3. start calculate */
+    ret = inner_batch_instr_process(&instr_ecfp_mont_p_2, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* 6. get result from DRAM */
+    if (out != TD_NULL && out->x != TD_NULL && out->y != TD_NULL) {
+        hal_pke_get_ram(sec_arg_add_cs(ecc_addr_px, out->x, out->length));
+        hal_pke_get_ram(sec_arg_add_cs(ecc_addr_py, out->y, out->length));
+    }
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 inner_ecfp_demontgomery_data_aff(const drv_pke_ecc_point *r, td_u32 work_len)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_drv_func_enter();
+
+    /* Step 1: start calculate. */
+    ret = inner_batch_instr_process(&instr_ecfp_demont_c_6, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* Step 2: get data from PKE DRAM */
+    if (r != TD_NULL && r->x != TD_NULL && r->y != TD_NULL) {
+        hal_pke_get_ram(sec_arg_add_cs(ecc_addr_cx, r->x, r->length));
+        hal_pke_get_ram(sec_arg_add_cs(ecc_addr_cy, r->y, r->length));
+    }
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 inner_update_modulus(const td_u8 *n, const td_u32 n_len, td_u32 low_bit, td_u32 high_bit)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 work_len = n_len / ALIGNED_TO_WORK_LEN_IN_BYTE;
+
+    /* 1. set new modulus and const_0(by initial parameters set) into PKE DRAM. */
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_n, n, n_len, n_len));
+
+    /* 2. start calculate. */
+    ret = inner_batch_instr_process(&instr_ecfp_prime_n_1, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* 5. get new montgomery parameters and set it into register. */
+    ret = hal_pke_set_mont_para(low_bit, high_bit);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_set_mont_para failed\n");
+
+    return TD_SUCCESS;
+}
+
+#define JAC_TO_AFF_INSTR_NUM    6
+td_s32 inner_ecfp_jac_to_aff(const drv_pke_data *mod_p)
+{
+    td_s32 ret = TD_FAILURE;
+
+    /* Step 1: prepare instructions to use */
+    rom_lib batch_instr_block[JAC_TO_AFF_INSTR_NUM] = {instr_ecfp_j2a_pre_5, instr_ecfp_j2a_exp_00,
+        instr_ecfp_j2a_exp_01, instr_ecfp_j2a_exp_10, instr_ecfp_j2a_exp_11,
+        instr_ecfp_j2a_post_4};
+
+    /* Step 2: start transfer calculation. */
+    ret = inner_jac_to_aff_cal(batch_instr_block, JAC_TO_AFF_INSTR_NUM, mod_p);
+    crypto_chk_func_return(inner_jac_to_aff_cal, ret);
+
+    return ret;
+}
+
+/* (ecc_addr_px, ecc_addr_py) -> (ecc_addr_cx, ecc_addr_cy, ecc_addr_cz) */
+td_s32 inner_ecfp_aff_to_jac(const drv_pke_ecc_point *in, const drv_pke_data *mod_p, pke_ecc_point_jac *out)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 work_len = 0;
+    crypto_drv_func_enter();
+
+    /* Step 1: wait for PKE free */
+    ret = hal_pke_check_free();
+    crypto_chk_func_return(hal_pke_check_free, ret);
+
+    /* Step 2: set input data into DRAM. */
+    if (in != TD_NULL && in->x != TD_NULL && in->y != TD_NULL) {
+        hal_pke_set_ram(sec_arg_add_cs(ecc_addr_px, in->x, in->length, mod_p->length));
+        hal_pke_set_ram(sec_arg_add_cs(ecc_addr_py, in->y, in->length, mod_p->length));
+    }
+    /* need to reset modulur. */
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_m, mod_p->data, mod_p->length, mod_p->length));
+
+    /* Step 3: start calculate. */
+    work_len = mod_p->length / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    ret = inner_batch_instr_process(&instr_ecfp_cpy_p2c_3, work_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_batch_instr_process failed\n");
+
+    /* Step 4: get result from DRAM. */
+    /* no need to get result out, only a common process. */
+    if (out != TD_NULL && out->x != TD_NULL && out->y != TD_NULL && out->z != TD_NULL) {
+        hal_pke_get_ram(sec_arg_add_cs(ecc_addr_cx, out->x, out->length));
+        hal_pke_get_ram(sec_arg_add_cs(ecc_addr_cy, out->y, out->length));
+        hal_pke_get_ram(sec_arg_add_cs(ecc_addr_cz, out->z, out->length));
+    }
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_inv_mod.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_inv_mod.c
new file mode 100644
index 0000000..d9c08ba
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_inv_mod.c
@@ -0,0 +1,80 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_inv_mod. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+
+int hal_pke_alg_ecc_inv_mod(const drv_pke_data *a, const drv_pke_data *c)
+{
+    int ret;
+    const unsigned char *n_2 = NULL;
+    unsigned int aligned_len = 0;
+    unsigned int work_len = 0;
+    unsigned int i = 0;
+    int j = 0;
+    const rom_lib *rom_lib_list[4] = {
+        &instr_ecfn_inv_exp_00, &instr_ecfn_inv_exp_01, &instr_ecfn_inv_exp_10, &instr_ecfn_inv_exp_11
+    };
+    unsigned char bit_2 = 0;
+    bool start_flag = false;
+    unsigned int klen;
+    const drv_pke_ecc_curve *ecc_curve = NULL;
+    const pke_ecc_init_param *init_param = NULL;
+    hal_pke_alg_ecc_init_check();
+    ecc_curve = hal_pke_alg_ecc_get_curve();
+    init_param = hal_pke_alg_ecc_get_init_param();
+
+    klen = ecc_curve->ksize;
+    n_2 = init_param->n_minus_2;
+
+    ret = hal_pke_set_mont_para(sec_arg_add_cs(init_param->mont_param_n[1], init_param->mont_param_n[0]));
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "sec_arg_add_cs failed\n");
+
+    aligned_len = crypto_max(a->length, klen);
+    ret = hal_pke_get_align_val(aligned_len, &aligned_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_get_align_val failed\n");
+    work_len  = aligned_len / ALIGNED_TO_WORK_LEN_IN_BYTE;
+
+    /* Step 1. former 5 process. data montgomery and copy */
+    /* 1.set data into DRAM, ecc_addr_rrn and ecc_addr_mont_1_n will be set in initial parameters. */
+    hal_pke_set_ram(ecc_addr_k, a->data, a->length, aligned_len);
+    hal_pke_set_ram(ecc_addr_m, ecc_curve->n, klen, aligned_len);
+
+    /* 2. start calculate. */
+    ret = inner_batch_instr_process(&instr_ecfn_inv_pre_5, work_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_batch_instr_process failed\n");
+
+    /* Step 2. start inv calculate. */
+    /* calculate by binary data, from high address to low address. the result store in ecc_addr_s */
+    /*
+     * 1) n_2 is one byte array, n->length is the byte number.
+     * 2) For each byte in n_2, get bit2 = byte[7:6], byte[5:4], byte[3:2], byte[1:0] in order.
+     * 3) If there is one bit2 is not zero, then all the next bit2(contain this time) will call
+        inner_batch_instr_process(), the first param depends on bit2's value.
+     */
+    for (i = 0; i < klen; i++) {
+        for (j = 3; j >= 0; j--) {              // 3: get byte[7:6], byte[5:4], byte[3:2], byte[1:0] in order.
+            bit_2 = (n_2[i] >> (j * 2)) & 0x3;  // 2, 0x3: get bit2
+            if ((start_flag == false) && (bit_2 != 0)) {
+                start_flag = true;
+                ret = inner_batch_instr_process(rom_lib_list[bit_2], work_len);
+                crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_batch_instr_process failed\n");
+            } else if (start_flag == true) {
+                ret = inner_batch_instr_process(rom_lib_list[bit_2], work_len);
+                crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_batch_instr_process failed\n");
+            }
+        }
+    }
+    /* get data out from DRAM ecc_addr_s, the result is montgomeried. */
+    hal_pke_get_ram(ecc_addr_s, c->data, c->length);
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_mul_naf_inner.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_mul_naf_inner.c
new file mode 100755
index 0000000..c0cf879
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_mul_naf_inner.c
@@ -0,0 +1,181 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_mul_naf_inner. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#include "pke_alg_inner.h"
+
+#include "hal_pke_v5.h"
+#include "hal_pke_alg.h"
+#include "crypto_drv_common.h"
+#include "pke_alg_inner.h"
+#include "drv_pke_inner.h"
+
+static void inner_arry_right_shift_value(td_u8 *k, td_u32 k_len, td_u32 shift_bit)
+{
+    td_u32 i = 0;
+    td_u8 left_mask = ((1 << shift_bit) - 1) & 0xFF;
+    td_u8 right_mask = ~((1 << shift_bit) - 1) & 0xFF;
+    td_u32 left_shift_bit = CRYPTO_BITS_IN_BYTE - shift_bit;
+
+    for (i = k_len - 1; i > 0; i--) {
+        k[i] = (((k[i] & right_mask) >> shift_bit) & (0xFF >> shift_bit)) |
+            (((k[i - 1] & left_mask) << left_shift_bit) & (0xFF << left_shift_bit));
+    }
+    k[0] = ((k[0] & right_mask) >> shift_bit) & (0xFF >> shift_bit);
+
+    return;
+}
+
+CRYPTO_STATIC void inner_bn_add_one(td_u8 *data, td_u32 len)
+{
+    td_u32 idx = len - 1;
+    td_s32 carry = 1;
+    td_u32 value;
+    while (carry == 1 && idx >= 1) {
+        value = data[idx] + carry;
+        if (value > 0xFF) {
+            carry = 1;
+        } else {
+            carry = 0;
+        }
+        data[idx] = value % (0x100);
+        idx--;
+    }
+    data[idx] += carry;
+}
+
+CRYPTO_STATIC void inner_bn_sub_one(td_u8 *data, td_u32 len)
+{
+    td_s32 idx = len - 1;
+    td_s32 carry = 1;
+    while (carry == 1 && idx >= 0) {
+        if (data[idx] == 0) {
+            carry = 1;
+            data[idx] = 0xFF;
+        } else {
+            carry = 0;
+            data[idx]--;
+        }
+        if (idx == 0) {
+            return;
+        }
+        idx--;
+    }
+}
+
+static void inner_array_add_plus_minus_one(td_u8 *k, td_u32 k_len, td_s32 value)
+{
+    if (value == 0) {
+        return;
+    }
+
+    if (value == 1) {
+        inner_bn_add_one(k, k_len);
+    } else if (value == -1) {
+        inner_bn_sub_one(k, k_len);
+    }
+
+    return;
+}
+
+static td_s32 inner_convert_normal_scalar_to_naf(const td_u8 *k, const td_u32 k_len, td_s32 *k_naf,
+    td_u32 *k_naf_len)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 cnt = 0;
+
+    td_u8 *tmp = crypto_malloc(k_len);
+    crypto_chk_return((tmp == TD_NULL), ret, "malloc failed!\n");
+
+    ret = memcpy_s(tmp, k_len, k, k_len);
+    crypto_chk_goto_with_ret(ret, ret != EOK, __EXIT, ERROR_MEMCPY_S, "copy data failed!\n");
+
+    while (inner_drv_is_zero(tmp, k_len) != TD_TRUE) {
+        if (tmp[k_len - 1] % 2 == 1) {  /* 2: to check whether the byte is odd or even. */
+            /* the last byte is odd, then the whole data is odd. */
+            k_naf[cnt] = (int) (2 - tmp[k_len - 1] % CRYPTO_WORD_WIDTH);    /* 2: for normal scalar to naf trans. */
+            inner_array_add_plus_minus_one(tmp, k_len, -k_naf[cnt]);
+        } else {
+            k_naf[cnt] = 0;
+        }
+        inner_arry_right_shift_value(tmp, k_len, 1);  /* 1: right shift one. */
+        cnt++;
+    }
+
+    *k_naf_len = cnt;
+__EXIT:
+    if (tmp != TD_NULL) {
+        crypto_free(tmp);
+        tmp = TD_NULL;
+    }
+    return ret;
+}
+
+static td_s32 inner_point_mul_naf(const rom_lib *batch_instr, const td_u32 batch_instr_num,
+    const drv_pke_data *k, td_u32 work_len)
+{
+    td_s32 ret = TD_FAILURE;
+    td_s32 i = 0;
+
+    /* Step 1: convert k to non-adjacent-form. */
+    td_u32 k_naf_len = k->length * CRYPTO_BITS_IN_BYTE + 1;
+    td_s32 *k_naf = crypto_malloc(k_naf_len * sizeof(td_u32));
+    crypto_chk_return((k_naf == TD_NULL), ERROR_MALLOC, "malloc failed!\n");
+    ret = inner_convert_normal_scalar_to_naf(k->data, k->length, k_naf, &k_naf_len);
+    crypto_chk_goto((ret != TD_SUCCESS), __EXIT, "convert data to naf failed!\n");
+
+    crypto_unused(batch_instr_num);
+    /* before calculate naf_point_mul, you need to set mont_a to ecc_addr_mont_a first.
+       And keep ecc->p in the modulur. */
+    /* Step 2: calculate point multiplication by double point and point plus. k_naf couldn't be infinity point. */
+    /* instr_ecfp_mul_p_22_18[0,40], instr_ecfp_mul_g_22_18[40,40], instr_ecfp_mul_c_double_22[0,22] */
+    for (i = k_naf_len - 2; i >= 0; i--) {  /* 2: to get the start calculate index. */
+        if (k_naf[i] == 1) {
+            ret = hal_pke_set_mode(sec_arg_add_cs(PKE_BATCH_INSTR, 0, &batch_instr[0], work_len));
+        } else if (k_naf[i] == -1) {
+            ret = hal_pke_set_mode(sec_arg_add_cs(PKE_BATCH_INSTR, 0, &batch_instr[1], work_len));
+        } else {
+            ret = hal_pke_set_mode(sec_arg_add_cs(PKE_BATCH_INSTR, 0, &batch_instr[2], work_len));  /* 2: instr index */
+        }
+        crypto_chk_goto((ret != TD_SUCCESS), __EXIT, "hal_pke_set_mode failed, ret = 0x%x", ret);
+        ret = hal_pke_start(sec_arg_add_cs(PKE_BATCH_INSTR));
+        crypto_chk_goto((ret != TD_SUCCESS), __EXIT, "hal_pke_start failed, ret = 0x%x", ret);
+        ret = hal_pke_wait_done();
+        crypto_chk_goto((ret != TD_SUCCESS), __EXIT, "hal_pke_wait_done failed, ret = 0x%x", ret);
+    }
+
+__EXIT:
+    if (k_naf != TD_NULL) {
+        crypto_free(k_naf);
+        k_naf = TD_NULL;
+    }
+
+    return ret;
+}
+
+#define POINT_NAF_INSTR_NUM     3
+td_s32 inner_ecfp_mul_naf_cal(td_u32 work_len, const drv_pke_data *k)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    rom_lib batch_instr_block[POINT_NAF_INSTR_NUM] = {instr_ecfp_mul_p_22_18, instr_ecfp_mul_g_22_18,
+        instr_ecfp_mul_c_double_22};
+
+    crypto_drv_func_enter();
+
+    /* WARN: from here, there should be no other process which is not ecc, for the result in DRAM wasn't got out, other
+    process will destroy data in the DRAM. */
+    /* 3. copy negative point data */
+    ret = inner_batch_instr_process(&instr_ecfp_cpy_np2g_2, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* 4. NAF point multiplication. */
+    ret = inner_point_mul_naf(batch_instr_block, POINT_NAF_INSTR_NUM, k, work_len);
+    crypto_chk_func_return(inner_point_mul_naf, ret);
+
+    crypto_drv_func_exit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_point_mul.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_point_mul.c
new file mode 100644
index 0000000..65f052f
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/ecc_point_mul.c
@@ -0,0 +1,71 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg ecc_point_mul. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+#include "drv_pke_inner.h"
+
+int hal_pke_alg_ecc_base_point_mul(const drv_pke_data *k, const drv_pke_ecc_point *r)
+{
+    drv_pke_ecc_point base;
+    const drv_pke_ecc_curve *ecc_curve = NULL;
+    hal_pke_alg_ecc_init_check();
+
+    ecc_curve = hal_pke_alg_ecc_get_curve();
+
+    base.x = (unsigned char *)ecc_curve->gx;
+    base.y = (unsigned char *)ecc_curve->gy;
+    base.length = ecc_curve->ksize;
+
+    return hal_pke_alg_ecc_point_mul(k, &base, r);
+}
+
+int hal_pke_alg_ecc_point_mul(const drv_pke_data *k, const drv_pke_ecc_point *p, const drv_pke_ecc_point *r)
+{
+    int ret = CRYPTO_FAILURE;
+    unsigned int klen;
+    drv_pke_data mod_p = {0};
+    const drv_pke_ecc_curve *ecc_curve = NULL;
+    const pke_ecc_init_param *init_param = NULL;
+    hal_pke_alg_ecc_init_check();
+
+    ecc_curve = hal_pke_alg_ecc_get_curve();
+    init_param = hal_pke_alg_ecc_get_init_param();
+    klen = ecc_curve->ksize;
+    mod_p.data = (unsigned char *)ecc_curve->p;
+    mod_p.length = klen;
+
+    /* Step 0: set montgomery param into register. */
+    ret = inner_update_modulus(ecc_curve->p, klen, init_param->mont_param_p[1], init_param->mont_param_p[0]);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_update_modulus failed\n");
+
+    /* Step 1: montgomery point p */
+    ret = inner_ecfp_montgomery_data_aff(p, &mod_p, r);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_montgomery_data_aff failed\n");
+
+    /* Step 2: trans Affine coordinate system to Jacobin coordinate system */
+    ret = inner_ecfp_aff_to_jac(r, &mod_p, TD_NULL);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_aff_to_jac failed\n");
+
+    /* Step 3: start NAF-multiplication. */
+    ret = inner_ecfp_mul_naf_cal(klen / ALIGNED_TO_WORK_LEN_IN_BYTE, k);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_mul_naf_cal failed\n");
+
+    /* Step 4: trans result data from jacobin coordinate system to affine coordinate system. */
+    ret = inner_ecfp_jac_to_aff(&mod_p);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_jac_to_aff failed\n");
+
+    /* Step 5. demontgomery data. */
+    ret = inner_ecfp_demontgomery_data_aff(r, klen / ALIGNED_TO_WORK_LEN_IN_BYTE);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_ecfp_demontgomery_data_aff failed\n");
+
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/get_multi_random.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/get_multi_random.c
new file mode 100644
index 0000000..0f9e8aa
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/get_multi_random.c
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg get_multi_random. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#include "hal_pke_alg.h"
+#include "drv_trng.h"
+
+td_s32 drv_cipher_pke_get_multi_random(td_u8 *random, td_u32 size)
+{
+    return drv_cipher_trng_get_multi_random(size, random);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/hal_pke_alg.h b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/hal_pke_alg.h
new file mode 100644
index 0000000..df2dbdd
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/hal_pke_alg.h
@@ -0,0 +1,211 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#ifndef HAL_PKE_ALG_H
+#define HAL_PKE_ALG_H
+
+#include "crypto_pke_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define MAX_ECC_SIZE                    72
+#define ALIGNED_TO_WORK_LEN_IN_BYTE     8
+
+#define hal_pke_alg_ecc_init_check()    \
+    crypto_chk_return(hal_pke_alg_ecc_is_init() == TD_FALSE, CRYPTO_FAILURE, "call hal_pke_alg_ecc_init first!\n")
+
+int hal_pke_alg_ecc_init(drv_pke_ecc_curve_type curve_type);
+
+void hal_pke_alg_ecc_deinit(void);
+
+const unsigned char *hal_pke_alg_ecc_get_n(void);
+
+const unsigned char *hal_pke_alg_ecc_get_p_minus_2(void);
+
+unsigned int hal_pke_alg_ecc_get_klen(void);
+
+const drv_pke_ecc_curve *hal_pke_alg_ecc_get_curve(void);
+
+const pke_ecc_init_param *hal_pke_alg_ecc_get_init_param(void);
+
+td_bool hal_pke_alg_ecc_is_init(void);
+
+/**
+ * @ingroup hal_pke_alg_ecc
+ * @brief   point multiplication with base point
+ * @details r(x, y) = k * G(x, y)
+ *
+ * @param   ecc [IN] curve parameters
+ * @param   k [IN] multiplication number
+ * @param   r [OUT] result point
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int hal_pke_alg_ecc_base_point_mul(const drv_pke_data *k, const drv_pke_ecc_point *r);
+
+/**
+ * @ingroup hal_pke_alg_ecc
+ * @brief   point multiplication
+ * @details r(x, y) = k * p(x, y)
+ *
+ * @param   ecc [IN] curve parameters
+ * @param   k [IN] multiplication number
+ * @param   p [IN] multiplication point
+ * @param   r [OUT] result point
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int hal_pke_alg_ecc_point_mul(const drv_pke_data *k, const drv_pke_ecc_point *p, const drv_pke_ecc_point *r);
+
+/**
+ * @ingroup hal_pke_alg_ecc
+ * @brief   ecc compute s
+ * @details s = k^-1(e + dr) mod n
+ *
+ * @param   k [IN]
+ * @param   e [IN]
+ * @param   d [IN]
+ * @param   r [IN]
+ * @param   s [OUT]
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int hal_pke_alg_ecc_compute_s(const drv_pke_data *k, const drv_pke_data *e, const drv_pke_data *d,
+    const drv_pke_data *r, const drv_pke_data *s);
+
+/**
+ * @ingroup hal_pke_alg_ecc
+ * @brief   modulo inverse
+ * @details c = a^-1 mod n
+ *
+ * @param   a [IN] base number
+ * @param   c [OUT] result bignumber
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int hal_pke_alg_ecc_inv_mod(const drv_pke_data *a, const drv_pke_data *c);
+
+/**
+ * @ingroup hal_pke_alg_ecc
+ * @brief   compute u1 and u2
+ * @details u1 = w * e mod n, u2 = w * r mod n
+ *
+ * @param   w [IN] multiplication number
+ * @param   e [IN] multiplication number
+ * @param   r [IN] multiplication number
+ * @param   u1 [OUT] result bignumber
+ * @param   u2 [OUT] result bignumber
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int hal_pke_alg_ecc_compute_u1_and_u2(const drv_pke_data *w, const drv_pke_data *e, const drv_pke_data *r,
+    const drv_pke_data *u1, const drv_pke_data *u2);
+
+/**
+ * @ingroup hal_pke_alg_ecc
+ * @brief   compute point x
+ * @details x(x, y) = u1 * p(x, y) + u2 * q(x, y), p(x, y) is the base point of ecc curve.
+ *
+ * @param   u1 [IN] multiplication number
+ * @param   u2 [IN] multiplication number
+ * @param   q [IN] multiplication point
+ * @param   x [OUT] result point
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int hal_pke_alg_ecc_compute_x(const drv_pke_data *u1, const drv_pke_data *u2,
+    const drv_pke_ecc_point *q, const drv_pke_data *x);
+
+/**
+ * @ingroup hal_pke_alg
+ * @brief   sm2 compute s * G + t * P.
+ * @details r(x, y) = s * G(x, y) + t * P(x, y), G(x, y) is the base point of ecc curve.
+ *
+ * @param   ecc [IN] curve parameters
+ * @param   s [IN] multiplication number
+ * @param   t [IN] multiplication number
+ * @param   p [IN] multiplication point
+ * @param   r [OUT] result point
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int32_t hal_pke_alg_sm2_point_mul_add(const drv_pke_ecc_curve *ecc, const drv_pke_data *s, const drv_pke_data *t,
+    const drv_pke_ecc_point *p, const drv_pke_ecc_point *r);
+
+/**
+ * @ingroup hal_pke_alg
+ * @brief   sm2 compute signature s part.
+ * @details compute s = ((1 + d)^(-1) * (k - r*d)) mod n
+ *
+ * @param   d [IN] private key
+ * @param   k [IN] random key
+ * @param   r [IN] signature r part
+ * @param   n [IN] modulo number
+ * @param   s [IN] result signature s part
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int hal_pke_alg_sm2_compute_s(const drv_pke_data *d, const drv_pke_data *k,
+    const drv_pke_data *r, const drv_pke_data *s);
+
+/**
+ * @ingroup hal_pke_alg
+ * @brief   sm2 add mod
+ * @details compute c = (a + b) mod n.
+ *
+ * @param   a [IN] addition number
+ * @param   b [IN] addition number
+ * @param   n [IN] modulo number
+ * @param   c [OUT] result number
+ *
+ * @attention inner function, assuming all the parameters are legal.
+ * @retval  CRYPTO_SUCCESS
+ * @retval  CRYPTO_FAILURE
+ */
+int hal_pke_alg_sm2_add_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *c);
+
+int hal_pke_alg_rsa_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c);
+
+int hal_pke_alg_rsa_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out);
+
+int hal_pke_alg_calc_hash(const drv_pke_data *arr, unsigned int arr_len,
+    const drv_pke_hash_type hash_type, drv_pke_data *hash);
+
+int hal_pke_alg_ecc_check_dot_on_curve(const drv_pke_ecc_point *point, td_bool *is_on_curve);
+
+td_s32 drv_cipher_pke_get_multi_random(td_u8 *random, td_u32 size);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/pke_alg_inner.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/pke_alg_inner.c
new file mode 100644
index 0000000..f28d32b
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/pke_alg_inner.c
@@ -0,0 +1,64 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg inner utils. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#include "pke_alg_inner.h"
+
+#include "hal_pke_v5.h"
+#include "hal_pke_alg.h"
+#include "crypto_drv_common.h"
+#include "pke_alg_inner.h"
+#include "drv_pke_inner.h"
+
+td_s32 inner_pke_alg_resume(void)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_drv_func_enter();
+
+    ret = hal_pke_lock();
+    crypto_chk_func_return(hal_pke_lock, ret);
+
+    hal_pke_enable_noise();
+
+    ret = hal_pke_pre_process();
+    crypto_chk_goto((ret != TD_SUCCESS), __EXIT, "hal_pke_pre_process failed, ret = 0x%x", ret);
+
+    crypto_drv_func_exit();
+    return ret;
+__EXIT:
+    hal_pke_disable_noise();
+    hal_pke_unlock();
+    return ret;
+}
+
+void inner_pke_alg_suspend(void)
+{
+    crypto_drv_func_enter();
+    (void)hal_pke_clean_ram();
+    hal_pke_disable_noise();
+    hal_pke_unlock();
+    crypto_drv_func_exit();
+}
+
+td_s32 inner_batch_instr_process(const rom_lib *batch_instr, td_u32 work_len)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_drv_func_enter();
+
+    ret = hal_pke_set_mode(sec_arg_add_cs(PKE_BATCH_INSTR, 0, batch_instr, work_len));
+    crypto_chk_func_return(hal_pke_set_mode, ret);
+
+    ret = hal_pke_start(sec_arg_add_cs(PKE_BATCH_INSTR));
+    crypto_chk_func_return(hal_pke_start, ret);
+
+    ret = hal_pke_wait_done();
+    crypto_chk_func_return(hal_pke_wait_done, ret);
+
+    crypto_drv_func_exit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/pke_alg_inner.h b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/pke_alg_inner.h
new file mode 100644
index 0000000..e26e098
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/pke_alg_inner.h
@@ -0,0 +1,96 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg inner header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+
+#ifndef PKE_ALG_INNER_H
+#define PKE_ALG_INNER_H
+
+#include "crypto_pke_struct.h"
+#include "rom_lib.h"
+
+
+/*
+ *
+ * Used in:
+ *      ecc_common.c
+ *      rsa_exp_mod.c
+ */
+td_s32 inner_pke_alg_resume(void);
+void inner_pke_alg_suspend(void);
+
+/*
+ *
+ * Used in:
+ *      ecc_compute_x.c
+ *      ecc_point_mul.c
+ */
+td_s32 inner_ecfp_montgomery_data_aff(const drv_pke_ecc_point *in, const drv_pke_data *mod_p,
+    const drv_pke_ecc_point *out);
+
+/*
+ *
+ * Used in:
+ *      ecc_compute_x.c
+ *      ecc_point_mul.c
+ */
+td_s32 inner_ecfp_demontgomery_data_aff(const drv_pke_ecc_point *r, td_u32 work_len);
+
+/*
+ *
+ * Used in:
+ *      ecc_compute_x.c
+ *      ecc_point_mul.c
+ */
+td_s32 inner_ecfp_jac_to_aff(const drv_pke_data *mod_p);
+
+/* * struct of ecc point */
+typedef struct {
+    td_u8 *x;   /* X coordinates of the point in Jacobian coordinate system. */
+    td_u8 *y;   /* Y coordinates of the point in Jacobian coordinate system. */
+    td_u8 *z;   /* Z coordinates of the point in Jacobian coordinate system. */
+    td_u32 length;
+} pke_ecc_point_jac;
+td_s32 inner_ecfp_aff_to_jac(const drv_pke_ecc_point *in, const drv_pke_data *mod_p, pke_ecc_point_jac *out);
+
+/*
+ *
+ * Used in:
+ *      ecc_check_dot_on_curve.c
+ *      ecc_point_mul.c
+ */
+td_s32 inner_ecfp_mul_naf_cal(td_u32 work_len, const drv_pke_data *k);
+
+/*
+ *
+ * Used in:
+ *      ecc_compute_s.c
+ *      ecc_compute_u1_and_u2.c
+ *      ecc_compute_x.c
+ *      ecc_inv_mod.c
+ *      sm2_add_mod.c
+ *      sm2_compute_s.c
+ *      rsa_exp_mod.c
+ */
+td_s32 inner_batch_instr_process(const rom_lib *batch_instr, td_u32 work_len);
+
+/*
+ *
+ * Used in:
+ *      ecc_point_mul.c
+ *      sm2_compute_s.c
+ */
+td_s32 inner_update_modulus(const td_u8 *n, const td_u32 n_len, td_u32 low_bit, td_u32 high_bit);
+
+/*
+ *
+ * Used in:
+ *      rsa_exp_mod.c
+ */
+td_s32 inner_update_rsa_modulus(const td_u8 *n, const td_u32 n_len, const td_u32 aligned_len);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_exp_mod.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_exp_mod.c
new file mode 100644
index 0000000..696ad67
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_exp_mod.c
@@ -0,0 +1,122 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg rsa_exp_mod. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_RSA_SUPPORT)
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+#include "drv_pke_inner.h"
+
+#define MAX_OFFSET_OF_VALID_BIT 2
+
+static void get_valid_bit(const td_u8 *n, const td_u32 key_size, td_u32 *valid_bit_index)
+{
+    for (*valid_bit_index = 0; *valid_bit_index < key_size; (*valid_bit_index)++) {
+        if (n[*valid_bit_index] != 0x00) {
+            break;
+        }
+    }
+    return;
+}
+
+static td_s32 rsa_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    td_s32 j = 0;
+    td_u32 aligned_len = 0;
+    td_u32 work_len = 0;
+    const rom_lib *rom_lib_list[4] = {
+        &instr_rsa_exp_00, &instr_rsa_exp_01, &instr_rsa_exp_10, &instr_rsa_exp_11
+    };
+    td_u8 bit_2 = 0;
+    td_bool start_flag = TD_FALSE;
+    td_u32 n_valid_index = 0;
+    td_u32 k_valid_index = 0;
+    td_u32 in_valid_index = 0;
+
+    crypto_drv_func_enter();
+
+    /* the parameter shouldn't be too large than the modulur. */
+    get_valid_bit(n->data, n->length, &n_valid_index);
+    get_valid_bit(k->data, k->length, &k_valid_index);
+    get_valid_bit(in->data, in->length, &in_valid_index);
+    aligned_len = crypto_max(crypto_max(k->length - k_valid_index, in->length - in_valid_index),
+        n->length - n_valid_index);
+    ret = hal_pke_get_align_val(aligned_len, &aligned_len);
+    crypto_chk_func_return(hal_pke_get_align_val, ret);
+    /* the time for calculate is 2^(valid_bit_index * 8) * 15 * 25(4,40), when valid_bit_index == 3, the time >= 10s;
+        when valid_bit_index == 4, the time > 10000s, which will call timeout. */
+    crypto_chk_return((aligned_len - (n->length - n_valid_index) > MAX_OFFSET_OF_VALID_BIT),
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "the modulur is too small\n");
+    /* the length should be enough to save the result. */
+    hal_crypto_pke_check_param(out->length < aligned_len);
+
+    ret = inner_update_rsa_modulus(sec_arg_add_cs(n->data + n_valid_index, n->length - n_valid_index, aligned_len));
+    crypto_chk_func_return(inner_update_rsa_modulus, ret);
+
+    /* step 1: data montgomery and copy. */
+    /* 1. set data into DRAM. */
+    work_len = aligned_len / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    hal_pke_set_ram(sec_arg_add_cs(rsa_addr_n, n->data + n_valid_index, n->length - n_valid_index, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(rsa_addr_a, in->data + in_valid_index, in->length - in_valid_index, aligned_len));
+
+    hal_pke_set_ram_const_1(rsa_addr_const_1, aligned_len);
+    /* 2. start calculate. */
+    ret = inner_batch_instr_process(&instr_rsa_exp_pre_6, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /*
+     * 1) k->data is one byte array, k->length is the byte number.
+     * 2) For each byte in k->data, get bit2 = byte[7:6], byte[5:4], byte[3:2], byte[1:0] in order.
+     * 3) If there is one bit2 is not zero, then all the next bit2(contain this time) will call
+        inner_batch_instr_process(), the first param depends on bit2's value.
+     */
+    for (i = 0; i < k->length; i++) {
+        for (j = 3; j >= 0; j--) {                  // 3: get byte[7:6], byte[5:4], byte[3:2], byte[1:0] in order.
+            bit_2 = (k->data[i] >> (j * 2)) & 0x3;   // 2, 0x3: get bit2
+            if ((start_flag == TD_FALSE) && (bit_2 != 0)) {
+                start_flag = TD_TRUE;
+                ret = inner_batch_instr_process(rom_lib_list[bit_2], work_len);
+                crypto_chk_return(ret != TD_SUCCESS, ret, "inner_batch_instr_process failed\n");
+            } else if (start_flag == TD_TRUE) {
+                ret = inner_batch_instr_process(rom_lib_list[bit_2], work_len);
+                crypto_chk_return(ret != TD_SUCCESS, ret, "inner_batch_instr_process failed\n");
+            }
+        }
+    }
+
+    /* step 3: data demontgomery and twice modulus reduction. */
+    ret = inner_batch_instr_process(&instr_rsa_exp_post_3, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* step 4: get data out. */
+    (void)memset_s(out->data, out->length, 0x00, out->length);
+    hal_pke_get_ram(sec_arg_add_cs(rsa_addr_s, out->data + out->length - aligned_len, aligned_len));
+
+    crypto_drv_func_exit();
+    return ret;
+}
+
+int32_t hal_pke_alg_rsa_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out)
+{
+    int32_t ret = CRYPTO_FAILURE;
+
+    ret = inner_pke_alg_resume();
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_pke_alg_resume failed\n");
+
+    ret = rsa_exp_mod(n, k, in, out);
+    inner_pke_alg_suspend();
+
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_inner.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_inner.c
new file mode 100755
index 0000000..7425614
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_inner.c
@@ -0,0 +1,347 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg rsa_inner. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_RSA_SUPPORT)
+#include "pke_alg_inner.h"
+
+#include "drv_pke_inner.h"
+#include "hal_pke_v5.h"
+#include "crypto_drv_common.h"
+
+#define PKE_MONT_PARAM_LEN  2
+#define PKE_MONT_BIT_LEN    64
+#define PKE_MONT_LEN_IN_BYTE    8
+#define HALF_BYTE_VALUE 128
+#define BYTE_VALUE 256
+#define ALIGNED_TO_WORK_LEN_IN_BYTE 8
+
+typedef struct {
+    td_u32 aligned_len;
+    const rom_lib *batch_instr;
+    td_u32 loop_number;
+} rrn_loop_table;
+
+#define DRV_PKE_CAL_LEN_1536    192
+#define DRV_PKE_CAL_LEN_320     40
+#define LOOP_NUMBER_4096    8
+#define LOOP_NUMBER_3072    10
+#define LOOP_NUMBER_2048    7
+#define LOOP_NUMBER_1536    9
+#define LOOP_NUMBER_1024    6
+#define LOOP_NUMBER_192     6
+#define LOOP_NUMBER_256     4
+#define LOOP_NUMBER_320     6
+#define LOOP_NUMBER_384     7
+#define LOOP_NUMBER_512     5
+#define MAX_RRN_SUPPORT_TYPE    10
+#if defined(CONFIG_ROMABLE_API_SUPPORT)
+static const rrn_loop_table g_rrn_loop_table[MAX_RRN_SUPPORT_TYPE] = {
+    {DRV_PKE_LEN_3072, &instr_rsa_rrn_add_3072, LOOP_NUMBER_3072},
+};
+#else
+static const rrn_loop_table g_rrn_loop_table[MAX_RRN_SUPPORT_TYPE] = {
+    {DRV_PKE_LEN_3072, &instr_rsa_rrn_add_3072, LOOP_NUMBER_3072},
+    {DRV_PKE_CAL_LEN_1536, &instr_rsa_rrn_add_3072, LOOP_NUMBER_1536},
+    {DRV_PKE_LEN_192, &instr_rsa_rrn_add_3072, LOOP_NUMBER_192},
+    {DRV_PKE_LEN_256, &instr_rsa_rrn_add, LOOP_NUMBER_256},
+    {DRV_PKE_CAL_LEN_320, &instr_rsa_rrn_add_320, LOOP_NUMBER_320},
+    {DRV_PKE_LEN_384, &instr_rsa_rrn_add_3072, LOOP_NUMBER_384},
+    {DRV_PKE_LEN_512, &instr_rsa_rrn_add, LOOP_NUMBER_512},
+    {DRV_PKE_LEN_1024, &instr_rsa_rrn_add, LOOP_NUMBER_1024},
+    {DRV_PKE_LEN_2048, &instr_rsa_rrn_add, LOOP_NUMBER_2048},
+    {DRV_PKE_LEN_4096, &instr_rsa_rrn_add, LOOP_NUMBER_4096},
+};
+#endif
+
+static td_s32 inner_get_loop_number(td_u32 aligned_len, td_u32 *loop_number)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    td_u32 work_len = aligned_len / ALIGNED_TO_WORK_LEN_IN_BYTE;
+
+    /* Step3: prepare data for loop calculate. */
+    for (; i < MAX_RRN_SUPPORT_TYPE; i++) {
+        if (aligned_len == g_rrn_loop_table[i].aligned_len) {
+            ret = inner_batch_instr_process(g_rrn_loop_table[i].batch_instr, work_len);
+            crypto_chk_func_return(inner_batch_instr_process, ret);
+            *loop_number = g_rrn_loop_table[i].loop_number;
+            return TD_SUCCESS;
+        }
+    }
+    crypto_log_err("invalid modulur\n");
+    return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+}
+
+static td_s32 inner_rsa_rrn(const td_u8 *n, const td_u32 key_size, const td_u32 aligned_len, td_u8 *rrn)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 cnt = 0;
+    td_u32 i = 0;
+    /* WARN: the aligned_len maybe larger than key_size. */
+    td_u32 work_len = aligned_len / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    td_u8 bit_2[DRV_PKE_LEN_4096];
+
+    /* Step 1: get data initial data rr = 2^(bit_len - 1). */
+    (void)memset_s(bit_2, DRV_PKE_LEN_4096, 0x00, DRV_PKE_LEN_4096);
+    bit_2[0] = HALF_BYTE_VALUE;
+
+    /* Step 2: set data to PKE DRAM. */
+    hal_pke_set_ram(sec_arg_add_cs(rsa_addr_n, n, key_size, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(rsa_addr_rr, bit_2, aligned_len, aligned_len));
+
+    /* Step3: prepare data for loop calculate. */
+    ret = inner_get_loop_number(aligned_len, &cnt);
+    crypto_chk_func_return(inner_get_loop_number, ret);
+
+    /* Step 4.2: start calculate square multiplication modulur. */
+    for (i = 0; i < cnt; i++) {
+        ret = inner_batch_instr_process(&instr_rsa_rrn_mul, work_len);
+        crypto_chk_func_return(inner_batch_instr_process, ret);
+    }
+
+    /* Step 4: if rrn is not null, get data out from DRAM. */
+    if (rrn != TD_NULL) {
+        hal_pke_get_ram(sec_arg_add_cs(rsa_addr_rr, rrn, aligned_len));
+    }
+
+    return ret;
+}
+
+static td_s32 inner_byte_stream_to_int_array(const td_u8 *byte_stream, const td_u32 stream_length,
+    td_u32 *int_array, td_u32 array_length)
+{
+    td_u32 i = 0;
+    crypto_drv_func_enter();
+
+    hal_crypto_pke_check_param(stream_length % sizeof(td_u32) != 0);
+
+    (void)memset_s(int_array, array_length, 0x00, array_length);
+
+    for (i = 0; i < stream_length; i += CRYPTO_WORD_WIDTH) {
+        int_array[ i / sizeof(td_u32)] |= byte_stream[i] << 24;     /* 24: get [31:24] */
+        int_array[ i / sizeof(td_u32)] |= byte_stream[i + 1] << 16; /* 16: get [23:16] */
+        int_array[ i / sizeof(td_u32)] |= byte_stream[i + 2] << 8;  /* 2,8: get [15:8] */
+        int_array[ i / sizeof(td_u32)] |= byte_stream[i + 3];       /* 3: get[7:0] */
+    }
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+/* int this condition b will no more than a, and the most b = a - 1, so that c->length = a.length */
+static td_s32 normal_sub(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_s32 i = 0;
+    td_s32 j = 0;
+    td_s32 carry = 0;
+
+    hal_crypto_pke_check_param(a == TD_NULL);
+    hal_crypto_pke_check_param(a->data == TD_NULL);
+    hal_crypto_pke_check_param(b == TD_NULL);
+    hal_crypto_pke_check_param(b->data == TD_NULL);
+    hal_crypto_pke_check_param(c == TD_NULL);
+    hal_crypto_pke_check_param(c->data == TD_NULL);
+    hal_crypto_pke_check_param(a->length != c->length);
+
+    (void)memset_s(c->data, c->length, 0x00, c->length);
+    ret = memcpy_s(c->data, c->length, a->data, a->length);
+    crypto_chk_return(ret != EOK, ret, "memcpy_s failed\n");
+
+    for (i = a->length - 1, j = b->length - 1; i >= 1 && j >= 0; i--, j--) {
+        if (a->data[i] < b->data[j] || a->data[i] - b->data[j] < carry) {
+            /* need to call one */
+            c->data[i] = c->data[i] + (BYTE_VALUE - b->data[j] - carry);
+            carry = 1;  /* note next byte */
+        } else {
+            c->data[i] -= (b->data[j] + carry);
+            carry = 0;  /* note next byte */
+        }
+    }
+    if (j == 0) {
+        /* which means the b->length == a->length */
+        c->data[i] -= (b->data[j] + carry);
+    }
+
+    return TD_SUCCESS;
+}
+
+/* left shift const one offset bits, while offset is less than 64. */
+static td_void left_shift_const_one(const drv_pke_data *a, const td_u32 offset)
+{
+    td_u32 i = offset / CRYPTO_BITS_IN_BYTE;
+    td_u32 e = offset % CRYPTO_BITS_IN_BYTE;
+    crypto_drv_func_enter();
+
+    (void)memset_s(a->data, a->length, 0x00, a->length);
+    a->data[a->length - i - 1] = 1 << e;
+
+    crypto_drv_func_exit();
+}
+
+/* left is high address, right is low address. And c->length is larger one than the max(a->length, b->length) */
+static td_void inner_normal_add(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *c)
+{
+    td_s32 i = 0;
+    td_s32 j = 0;
+    td_s32 k = 0;
+    td_s32 carry = 0;
+    crypto_drv_func_enter();
+
+    (void)memset_s(c->data, c->length, 0x00, c->length);
+    for (i = a->length - 1, j = b->length - 1, k = c->length - 1; i >= 0 && j >= 0 && k >= 1; i--, j--, k--) {
+        carry = 0;
+        if (a->data[i] >= (BYTE_VALUE - b->data[j])) {
+            carry = b->data[j] - (BYTE_VALUE - a->data[i]); /* most value is 0xff + 0xff = 0x1fe, will cause move. */
+            c->data[k - 1] += 1;
+        } else {
+            carry = a->data[i] + b->data[j]; /* most value is 0x80 + 0x7f = 0xff. */
+        }
+        if ((carry == BYTE_VALUE - 1 && c->data[k] == 1) ||
+            (carry == BYTE_VALUE - 2 && c->data[k] == 2)) { // 2: carry in binary.
+            /* in this condition, the add process will cause carry. */
+            c->data[k] = 0;
+            c->data[k - 1] += 1;
+        } else {
+            c->data[k] += carry;
+        }
+    }
+
+    /* when out the for loop, i == 0 or j == 0 */
+    for (; j >= 0 && k >= 1; j--, k--) {
+        if ((b->data[j] == BYTE_VALUE - 1 && c->data[k] == 1) ||
+            (b->data[j] == BYTE_VALUE - 2 && c->data[k] == 2)) {  /* 2: carry in binary. */
+            /* in this condition, the add process will cause carry. */
+            c->data[k] = 0;
+            c->data[k - 1] += 1;
+        } else {
+            c->data[k] += b->data[j];
+        }
+    }
+    for (; i >= 0 && k >= 1; i--, k--) {
+        if ((a->data[i] == BYTE_VALUE - 1 && c->data[k] == 1) ||
+            (a->data[i] == BYTE_VALUE - 2 && c->data[k] == 2)) {  /* 2: carry in binary. */
+            /* in this condition, the add process will cause carry. */
+            c->data[k] = 0;
+            c->data[k - 1] += 1;
+        } else {
+            c->data[k] += a->data[i];
+        }
+    }
+
+    crypto_drv_func_exit();
+}
+
+static void inner_arry_right_shift_value(td_u8 *k, td_u32 k_len, td_u32 shift_bit)
+{
+    td_u32 i = 0;
+    td_u8 left_mask = ((1 << shift_bit) - 1) & 0xFF;
+    td_u8 right_mask = ~((1 << shift_bit) - 1) & 0xFF;
+
+    for (i = k_len - 1; i > 0; i--) {
+        k[i] = ((k[i] & right_mask) >> shift_bit) | ((k[i - 1] & left_mask) << (CRYPTO_BITS_IN_BYTE - shift_bit));
+    }
+    k[0] = (k[0] & right_mask) >> shift_bit;
+
+    return;
+}
+
+static td_s32 inner_set_mont_param(const drv_pke_data *p)
+{
+    td_s32 ret = TD_FAILURE;
+    td_s32 i = 0;
+    td_u32 s_len = PKE_MONT_LEN_IN_BYTE;
+    td_u8 s[PKE_MONT_LEN_IN_BYTE];
+    td_u8 p_cal[PKE_MONT_LEN_IN_BYTE];
+    td_u32 x_len = PKE_MONT_LEN_IN_BYTE + 1;
+    td_u8 x[PKE_MONT_LEN_IN_BYTE + 1];
+    td_u8 bit_2[PKE_MONT_LEN_IN_BYTE + 1];
+    td_u8 tmp[PKE_MONT_LEN_IN_BYTE + 1];
+    td_u8 tmp_2[PKE_MONT_LEN_IN_BYTE + 1];
+    drv_pke_data aa = { .length = s_len, .data = s };
+    drv_pke_data bb = { .length = s_len, .data = p_cal };
+    drv_pke_data cc = { .length = x_len, .data = tmp };
+    drv_pke_data dd = { .length = x_len, .data = x };
+    drv_pke_data ff = { .length = x_len, .data = tmp_2 };
+    td_u32 mont_param[PKE_MONT_PARAM_LEN] = {0};
+    crypto_drv_func_enter();
+
+    (void)memset_s(x, x_len, 0, x_len);
+    x[PKE_MONT_LEN_IN_BYTE] = 1;
+
+    /* montgomery_data_config */
+    (void)memset_s(bit_2, x_len, 0, x_len);
+    bit_2[0] = 1;   /* 2^(2*bit_len), so it need to move left one bit, which means the highest one byte value is 1. */
+    (void)memset_s(tmp, x_len, 0, x_len);
+
+    /* Step 1: only 64bit participate the calculation. */
+    ret = memcpy_s(p_cal, s_len, (p->data + p->length - s_len), s_len);
+    crypto_chk_return(ret != EOK, ret, "memcpy_s failed\n");
+
+    ret = memcpy_s(s, s_len, p_cal, s_len);
+    crypto_chk_return(ret != EOK, ret, "memcpy_s failed\n");
+
+    /* Step 2: right shift 1 to get s = (p - 1) >> 1 */
+    inner_arry_right_shift_value(s, s_len, 1);
+
+    /* x = x + (xi << i), xi << i may largest is 64 bit, so x largest is 64 bit 1, and smallest is 1. */
+    for (i = 1; i < PKE_MONT_BIT_LEN; i++) {
+        td_s32 xi = s[s_len - 1] & 1;   /* xi = s & 1; */
+        crypto_log_dbg("xi[%d] = %d\r\n", i, xi);
+        if (xi == 1) {
+            inner_normal_add(&aa, &bb, &cc);  /* s = s + xi * p; */
+            inner_arry_right_shift_value(tmp, x_len, 1);  /* right shift 1. s = s >> 1. */
+            ret = memcpy_s(s, s_len, tmp + 1, s_len); /* copy the result s for next calculation. */
+            crypto_chk_return(ret != EOK, ret, "memcpy_s failed\n");
+
+            left_shift_const_one(&cc, i);   /* xi << i */
+            inner_normal_add(&dd, &cc, &ff);  /* x + (xi << i) */
+            ret = memcpy_s(x, x_len, tmp_2, x_len);   /* x = x + (xi << i) */
+            crypto_chk_return(ret != EOK, ret, "memcpy_s failed\n");
+        } else {
+            inner_arry_right_shift_value(s, s_len, 1);    /* right shift 1. */
+        }
+    }
+    cc.data = bit_2;
+    ret = normal_sub(&cc, &dd, &ff);
+    crypto_chk_func_return(normal_sub, ret);
+
+    /* set mont_param into register. */
+    ret = inner_byte_stream_to_int_array(tmp_2 + 1, s_len, mont_param, PKE_MONT_PARAM_LEN);
+    crypto_chk_func_return(inner_byte_stream_to_int_array, ret);
+
+    crypto_log_dbg("mont_param[0] = 0x%x, mont_param[1] = 0x%x\r\n", mont_param[0], mont_param[1]);
+    ret = hal_pke_set_mont_para(sec_arg_add_cs(mont_param[1], mont_param[0]));
+    crypto_chk_func_return(hal_pke_set_mont_para, ret);
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 inner_update_rsa_modulus(const td_u8 *n, const td_u32 n_len, const td_u32 aligned_len)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u8 rrn[DRV_PKE_LEN_4096] = {0};
+    drv_pke_data mod_n = {0};
+    crypto_drv_func_enter();
+    check_sum_inspect(PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), n, n_len);
+
+    mod_n = (drv_pke_data) {.data = (td_u8 *)n, .length = n_len};
+    /* 1. get new montgomery parameters and set it into register. */
+    ret = inner_set_mont_param(&mod_n);
+    crypto_chk_func_return(inner_set_mont_param, ret);
+    /* 2. calculate to get rrn value. */
+    ret = inner_rsa_rrn(n, n_len, aligned_len, rrn);
+    crypto_chk_func_return(inner_rsa_rrn, ret);
+    /* 3. set rrn into PKE DRAM rsa_addr_rr. */
+    hal_pke_set_ram(sec_arg_add_cs(rsa_addr_rr, rrn, aligned_len, aligned_len));
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_mod.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_mod.c
new file mode 100644
index 0000000..94b42ec
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/rsa_mod.c
@@ -0,0 +1,107 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg rsa_mod. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-12-13, Create file. \n
+ */
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+#include "drv_pke_inner.h"
+
+#define MAX_OFFSET_OF_VALID_BIT 2
+
+static void get_valid_bit(const td_u8 *n, const td_u32 key_size, td_u32 *valid_bit_index)
+{
+    for (*valid_bit_index = 0; *valid_bit_index < key_size; (*valid_bit_index)++) {
+        if (n[*valid_bit_index] != 0x00) {
+            break;
+        }
+    }
+    return;
+}
+
+int inner_rsa_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 work_len = 0;
+    td_u32 aligned_len = 0;
+    td_u8 const_1[CRYPTO_WORD_WIDTH] = {0};
+    td_u8 bit_2[CRYPTO_WORD_WIDTH] = {0};
+    td_u32 a_valid_index = 0;
+    td_u32 a_valid_length = 0;
+    td_u32 p_valid_index = 0;
+    td_u32 p_valid_length = 0;
+    crypto_drv_func_enter();
+    hal_crypto_pke_check_param(p->length > DRV_PKE_LEN_4096);
+
+    const_1[CRYPTO_WORD_WIDTH - 1] = 0x1;   /* set const value. */
+
+    /* the modulur couldn't be zero. */
+    crypto_chk_return(inner_drv_is_zero(p->data, p->length) == TD_TRUE, ERROR_INVALID_PARAM, "p is zero\n");
+    /* the modulur couldn't be even data. */
+    hal_crypto_pke_check_param(p->data[p->length - 1] % 2 == 0);    /* 2: to check if even. */
+
+    /* the parameter shouldn't be too large than the modulur. */
+    get_valid_bit(a->data, a->length, &a_valid_index);
+    get_valid_bit(p->data, p->length, &p_valid_index);
+    a_valid_length = a->length - a_valid_index;
+    p_valid_length = p->length - p_valid_index;
+    hal_crypto_pke_check_param(a_valid_length > 2 * p_valid_length);    /* 2: double */
+
+    /* Note: For 521 bit mode, the actual size should be 576 */
+    ret = hal_pke_get_align_val(p_valid_length, &aligned_len);
+    crypto_chk_func_return(hal_pke_get_align_val, ret);
+    /* the time for calculate is 2^(valid_bit_index * 8) * 15 * 25(4,40), when valid_bit_index == 3, the time >= 10s;
+        when valid_bit_index == 4, the time > 10000s, which will call timeout. */
+    crypto_chk_return((aligned_len - p_valid_length > MAX_OFFSET_OF_VALID_BIT),
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "the modulur is too small\n");
+    /* the length should be enough to save the result. */
+    hal_crypto_pke_check_param(c->length < aligned_len);
+
+    (void)memset_s(bit_2, CRYPTO_WORD_WIDTH, 0x00, CRYPTO_WORD_WIDTH);
+    /* Step 1. set data into DRAM. */
+    hal_pke_set_ram(sec_arg_add_cs(rsa_addr_n, p->data + p_valid_index, p_valid_length, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(rsa_addr_const_1, const_1, CRYPTO_WORD_WIDTH, aligned_len));
+    /* set high bit into rsa_addr_t1, set low bit into rsa_addr_t0. */
+    if (a_valid_length < aligned_len) {
+        hal_pke_set_ram(sec_arg_add_cs(rsa_addr_t0, a->data + a_valid_index, a_valid_length, aligned_len));
+        hal_pke_set_ram(sec_arg_add_cs(rsa_addr_t1, bit_2, CRYPTO_WORD_WIDTH, aligned_len));
+    } else {
+        hal_pke_set_ram(sec_arg_add_cs(rsa_addr_t0, a->data + a->length - aligned_len, aligned_len, aligned_len));
+        hal_pke_set_ram(sec_arg_add_cs(rsa_addr_t1, a->data + a_valid_index, a_valid_length - aligned_len,
+            aligned_len));
+    }
+    /* set mont_param */
+    ret = inner_update_rsa_modulus(p->data + p_valid_index, p_valid_length, aligned_len);
+    crypto_chk_func_return(inner_update_rsa_modulus, ret);
+
+    /* Step 2. start calculation. */
+    work_len = aligned_len / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    ret = inner_batch_instr_process(&instr_rsa_mod, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* Step 3. get result. */
+    (void)memset_s(c->data, c->length, 0x00, c->length);
+    hal_pke_get_ram(sec_arg_add_cs(rsa_addr_a, c->data + c->length - aligned_len, aligned_len));
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+int hal_pke_alg_rsa_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    int32_t ret = CRYPTO_FAILURE;
+
+    ret = inner_pke_alg_resume();
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_pke_alg_resume failed\n");
+
+    ret = inner_rsa_mod(a, p, c);
+    inner_pke_alg_suspend();
+
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/sm2_add_mod.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/sm2_add_mod.c
new file mode 100644
index 0000000..de1dada
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/sm2_add_mod.c
@@ -0,0 +1,43 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg sm2_add_mod. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_SUPPORT_SM2)
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+
+int hal_pke_alg_sm2_add_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *c)
+{
+    int ret = CRYPTO_FAILURE;
+    unsigned int klen;
+    unsigned int work_len;
+    const drv_pke_ecc_curve *ecc_curve = NULL;
+    hal_pke_alg_ecc_init_check();
+
+    ecc_curve = hal_pke_alg_ecc_get_curve();
+
+    klen = ecc_curve->ksize;
+    work_len = klen / ALIGNED_TO_WORK_LEN_IN_BYTE;
+
+    /* Step 1: set data into DRAM. */
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_r, a->data, a->length, klen));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_s, b->data, b->length, klen));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_m, ecc_curve->n, klen, klen));
+
+    /* Step 2: start calculate. */
+    ret = inner_batch_instr_process(&instr_sm2_verify_t_3, work_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_batch_instr_process failed\n");
+
+    /* Step 3: get data out of DRAM. */
+    hal_pke_get_ram(sec_arg_add_cs(ecc_addr_t, c->data, c->length));
+
+    return CRYPTO_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/sm2_compute_s.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/sm2_compute_s.c
new file mode 100644
index 0000000..8b99a0d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_alg/sm2_compute_s.c
@@ -0,0 +1,79 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: Provides pke_alg sm2_compute_s. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-11-28, Create file. \n
+ */
+#if defined(CONFIG_PKE_ECC_SM2_SIGN_SUPPORT)
+
+#include "hal_pke_alg.h"
+
+#include "crypto_drv_common.h"
+#include "hal_pke_v5.h"
+#include "pke_alg_inner.h"
+
+static td_s32 sm2_ecfn_sign_s(const drv_pke_data *k, const drv_pke_data *d, const drv_pke_data *n,
+    const drv_pke_data *r, const drv_pke_data *s)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 work_len = n->length / ALIGNED_TO_WORK_LEN_IN_BYTE;
+    td_u8 k_inv[DRV_PKE_LEN_576] = {0};
+    drv_pke_data aa = {0};
+    crypto_drv_func_enter();
+
+    /* Step 1: set data into DRAM. */
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_k, k->data, k->length, n->length));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_d, d->data, d->length, n->length));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_r, r->data, r->length, n->length));
+    /* set module, the addr is ecc_addr_m */
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_m, n->data, n->length, n->length));
+
+    /* Step 2: start calculate. montgomery the data, and calculate (1 + dA) & (k - r*dA). */
+    ret = inner_batch_instr_process(&instr_sm2_sign_s_pre_6, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+    /* Step 2.1 get data from the DRAM. 1+da from ecc_addr_k, k-r*da from ecc_addr_e */
+    hal_pke_get_ram(sec_arg_add_cs(ecc_addr_k, k_inv, n->length));
+
+    /* Step 3: calculate the (1+da)^(-1). */
+    aa = (drv_pke_data) {.data = k_inv, .length = n->length};
+
+    ret = hal_pke_alg_ecc_inv_mod(&aa, s);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_pke_alg_ecc_inv_mod failed\n");
+
+    /* Step 4: calculate k_inv * (k - r*da) mod n. and demontgomery the r & s. */
+    ret = inner_batch_instr_process(&instr_sm2_sign_s_post_6, work_len);
+    crypto_chk_func_return(inner_batch_instr_process, ret);
+
+    /* Step 5: get data out from the DRAM. */
+    hal_pke_get_ram(sec_arg_add_cs(ecc_addr_s, s->data, s->length));
+    hal_pke_get_ram(sec_arg_add_cs(ecc_addr_r, r->data, r->length));
+
+    crypto_drv_func_exit();
+    return TD_SUCCESS;
+}
+
+int hal_pke_alg_sm2_compute_s(const drv_pke_data *d, const drv_pke_data *k,
+    const drv_pke_data *r, const drv_pke_data *s)
+{
+    int ret = CRYPTO_FAILURE;
+    drv_pke_data n;
+    const drv_pke_ecc_curve *ecc_curve = NULL;
+    const pke_ecc_init_param *init_param = NULL;
+    hal_pke_alg_ecc_init_check();
+
+    ecc_curve = hal_pke_alg_ecc_get_curve();
+    init_param = hal_pke_alg_ecc_get_init_param();
+    n.data = (unsigned char *)ecc_curve->n;
+    n.length = ecc_curve->ksize;
+
+    ret = inner_update_modulus(n.data, n.length, init_param->mont_param_n[1], init_param->mont_param_n[0]);
+    crypto_chk_func_return(inner_update_modulus, ret);
+
+    ret = sm2_ecfn_sign_s(k, d, &n, r, s);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "sm2_ecfn_sign_s failed\n");
+
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_v4/hal_pke.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_v4/hal_pke.c
new file mode 100644
index 0000000..c1eb30a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_v4/hal_pke.c
@@ -0,0 +1,556 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "hal_pke_v4.h"
+#include "hal_pke_reg_v4.h"
+#include "crypto_drv_common.h"
+#include "securec.h"
+
+#define PKE_TIME_OUT     6000000
+#define BYTE_BITS        0x08
+#define BYTE_MASK        0xFF
+#define U16_MSB          0x8000
+#define CRC16_POLYNOMIAL 0x1021
+#define BITS_PER_BYTE    8
+#define BYTES_PER_WORD   4
+#define PKE_COMPAT_ERRNO(err_code)      HAL_COMPAT_ERRNO(ERROR_MODULE_PKE, err_code)
+
+typedef struct {
+    const td_void *wait;
+    crypto_wait_timeout_interruptible wait_func;
+    td_u32 timeout_ms;
+    td_bool wait_done;
+} pke_wait_event_type;
+
+static td_u32 g_pke_initialize = TD_FALSE;
+static pke_wait_event_type g_pke_wait_event = {
+    .wait = TD_NULL,
+    .wait_func = TD_NULL,
+    .timeout_ms = 0,
+    .wait_done = TD_FALSE
+};
+
+typedef struct {
+    hal_pke_len pke_len;
+    td_u32 pke_data_len_reg;
+} pke_len_reg_map;
+
+// Define the union of pke module interrupt enable register
+typedef union {
+    // Define the struct bits
+    struct {
+        td_u32 pke_ie : 1;
+        td_u32 reserved : 31;
+    } bits;
+
+    // Define an unsigned member
+    td_u32 u32;
+} pke_ie;
+
+static const pke_len_reg_map g_pke_len_reg_table[] = {
+    {HAL_PKE_LEN_256, 0},
+    {HAL_PKE_LEN_384, 1},
+    {HAL_PKE_LEN_512, 2},
+    {HAL_PKE_LEN_521, 2},
+    {HAL_PKE_LEN_2048, 3},
+    {HAL_PKE_LEN_3072, 4},
+    {HAL_PKE_LEN_4096, 5}
+};
+
+#if defined(CONFIG_PKE_TIMEOUT_DEBUG)
+static td_void hal_cipher_pke_debug(td_void)
+{
+    crypto_log_dbg("PKE_BUSY is 0x%x\n", pke_reg_read(PKE_BUSY));
+    crypto_log_dbg("PKE_WORK_MODE is 0x%x\n", pke_reg_read(PKE_WORK_MODE));
+    crypto_log_dbg("PKE_INT_ENABLE is 0x%x\n", pke_reg_read(PKE_INT_ENABLE));
+    crypto_log_dbg("PKE_LOCK_INT_ENABLE is 0x%x\n", pke_reg_read(PKE_LOCK_INT_ENABLE));
+    crypto_log_dbg("PKE_INT_STATUS is 0x%x\n", pke_reg_read(PKE_INT_STATUS));
+    crypto_log_dbg("PKE_INT_NOMASK_STATUS is 0x%x\n", pke_reg_read(PKE_INT_NOMASK_STATUS));
+    crypto_log_dbg("PKE_NOISE_EN is 0x%x\n", pke_reg_read(PKE_NOISE_EN));
+    crypto_log_dbg("PKE_LOCK_STATUS is 0x%x\n", pke_reg_read(PKE_LOCK_STATUS));
+    crypto_log_dbg("PKE_INT_RAW is 0x%x\n", pke_reg_read(PKE_INT_RAW));
+}
+#else
+#define hal_cipher_pke_debug(...)
+#endif
+
+td_s32 hal_pke_init(void)
+{
+    g_pke_initialize = TD_TRUE;
+    return TD_SUCCESS;
+}
+
+td_s32 hal_pke_deinit(void)
+{
+    g_pke_initialize = TD_FALSE;
+    return TD_SUCCESS;
+}
+
+static td_bool pke_wait_condition(const td_void *param __attribute__((unused)))
+{
+    if (g_pke_wait_event.wait_done == TD_TRUE) {
+        g_pke_wait_event.wait_done = TD_FALSE;
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+static td_void inner_pke_lock_irq_enable(td_bool enable)
+{
+    pke_lock_int_enable pke_lock_en;
+
+    if (g_pke_wait_event.wait_func == TD_NULL) {
+        return;
+    }
+    pke_lock_en.u32 = pke_reg_read(PKE_LOCK_INT_ENABLE);
+    pke_lock_en.bits.pke_lock_int_en = enable;
+    pke_reg_write(PKE_LOCK_INT_ENABLE, pke_lock_en.u32);
+}
+
+static td_void inner_pke_irq_enable(td_bool enable)
+{
+    pke_int_enable pke_int_en;
+    if (g_pke_wait_event.wait_func == TD_NULL) {
+        return;
+    }
+    pke_int_en.u32 = pke_reg_read(PKE_INT_ENABLE);
+    pke_int_en.bits.finish_int_enable = enable;
+    pke_reg_write(PKE_INT_ENABLE, pke_int_en.u32);
+}
+
+td_s32 hal_pke_lock(void)
+{
+    pke_lock_ctrl lock_ctrl;
+    pke_lock_status lock_status;
+    td_u32 lock_type;
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    if (g_pke_initialize == TD_FALSE) {
+        crypto_log_err("pke must be initialized!\n");
+        return TD_FAILURE;
+    }
+    if (crypto_get_cpu_type() == CRYPTO_CPU_TYPE_SCPU) {
+        lock_type = LOCK_STATUS_SCPU;
+    } else {
+        lock_type = LOCK_STATUS_ACPU;
+    }
+
+    inner_pke_lock_irq_enable(TD_TRUE);
+    /* lock pke */
+    lock_ctrl.u32 = pke_reg_read(PKE_LOCK_CTRL);
+    lock_ctrl.bits.pke_lock_type = 0; /* lock command */
+    lock_ctrl.bits.pke_lock = 1;
+    pke_reg_write(PKE_LOCK_CTRL, lock_ctrl.u32);
+
+    if (g_pke_wait_event.wait_func != TD_NULL) {
+        g_pke_wait_event.wait_done = TD_FALSE;
+        ret = g_pke_wait_event.wait_func(g_pke_wait_event.wait, pke_wait_condition, (td_void *)(uintptr_t)lock_type,
+            g_pke_wait_event.timeout_ms);
+        if (ret <= 0) {
+            ret = PKE_COMPAT_ERRNO(ERROR_PKE_LOCK_TIMEOUT);
+        }
+    } else {
+        for (i = 0; i < PKE_TIME_OUT; i++) {
+            /* check lock result */
+            lock_status.u32 = pke_reg_read(PKE_LOCK_STATUS);
+            if (lock_status.bits.pke_lock_stat == lock_type) {
+                break;
+            }
+            crypto_udelay(1); // 1 us is empirical value of register lock read
+        }
+        if (i >= PKE_TIME_OUT) {
+            crypto_log_err("pke lock timeout\n");
+            ret = PKE_COMPAT_ERRNO(ERROR_PKE_LOCK_TIMEOUT);
+        }
+    }
+    if (ret == PKE_COMPAT_ERRNO(ERROR_PKE_LOCK_TIMEOUT)) {
+        hal_cipher_pke_debug();
+    } else {
+        ret = CRYPTO_SUCCESS;
+    }
+    inner_pke_lock_irq_enable(TD_FALSE);
+
+    inner_pke_irq_enable(TD_TRUE);
+
+    return ret;
+}
+
+td_s32 hal_pke_unlock(void)
+{
+    pke_lock_ctrl lock_ctrl;
+    pke_lock_status lock_status;
+
+    inner_pke_irq_enable(TD_FALSE);
+
+    /* unlock pke */
+    lock_ctrl.u32 = pke_reg_read(PKE_LOCK_CTRL);
+    lock_ctrl.bits.pke_lock_type = 1; /* unlock command */
+    lock_ctrl.bits.pke_lock = 1;
+    pke_reg_write(PKE_LOCK_CTRL, lock_ctrl.u32);
+
+    /* check unlock result */
+    lock_status.u32 = pke_reg_read(PKE_LOCK_STATUS);
+    if ((lock_status.bits.pke_lock_stat != PKE_LOCK_UNLOCK) ||
+        (lock_status.bits.pke_unlock_fail == 1)) {
+        crypto_log_err("pke unlock timeout\n");
+        return TD_FAILURE;
+    }
+    return TD_SUCCESS;
+}
+
+td_void hal_pke_secure(td_bool enable)
+{
+    pke_noise_en noise;
+
+    /* enable noise */
+    noise.u32 = pke_reg_read(PKE_NOISE_EN);
+    noise.bits.noise_en = 0;
+    if (enable) {
+        noise.bits.noise_en = 1;
+    }
+    pke_reg_write(PKE_NOISE_EN, noise.u32);
+}
+
+#if defined(CRYPTO_OS_INT_SUPPORT)
+td_u32 hal_pke_done_try(void)
+{
+    pke_lock_int_dat lock_int_dat = {0};
+    pke_int_dat int_dat = {0};
+
+    lock_int_dat.u32 = pke_reg_read(PKE_INT_RAW);
+    int_dat.u32 = pke_reg_read(PKE_INT_NOMASK_STATUS);
+
+    if (lock_int_dat.bits.pke_lock_int_raw == 0x1) {
+        lock_int_dat.bits.pke_lock_int_raw = 0x1;
+        pke_reg_write(PKE_INT_RAW, lock_int_dat.u32);
+        return 1;
+    }
+
+    if (int_dat.bits.finish_int_nomask == 0x5) {
+        int_dat.bits.finish_int_nomask = 0x1;
+        pke_reg_write(PKE_INT_NOMASK_STATUS, int_dat.u32);
+        return 1;
+    }
+
+    return 0;
+}
+
+td_void hal_pke_done_notify(void)
+{
+    g_pke_wait_event.wait_done = TD_TRUE;
+}
+#endif
+
+td_s32 hal_pke_wait_free(void)
+{
+    td_u32 i = 0;
+    pke_busy busy;
+    /* wait ready */
+    for (i = 0; i < PKE_TIME_OUT; i++) {
+        busy.u32 = pke_reg_read(PKE_BUSY);
+        if (!busy.bits.pke_busy) {
+            break;
+        }
+        crypto_udelay(1);
+    }
+
+    if (i >= PKE_TIME_OUT) {
+        crypto_log_err("error, pke wait free timeout\n");
+        return PKE_COMPAT_ERRNO(ERROR_PKE_WAIT_DONE_TIMEOUT);
+    }
+    return CRYPTO_SUCCESS;
+}
+
+static pke_mode mode_map(hal_pke_mode mode)
+{
+    switch (mode) {
+        case HAL_PKE_MODE_CLR_RAM:
+            return PKE_MODE_CLR_RAM ;
+        case HAL_PKE_MODE_EXP_MOD:
+            return PKE_MODE_EXP_MOD;
+        case HAL_PKE_MODE_MUL_DOT:
+            return PKE_MODE_MUL_DOT;
+        case HAL_PKE_MODE_ADD_DOT:
+            return PKE_MODE_ADD_DOT;
+        case HAL_PKE_MODE_TIMES_DOT:
+            return PKE_MODE_TIMES_DOT;
+        case HAL_PKE_MODE_MINV_MOD:
+            return PKE_MODE_MINV_MOD;
+        case HAL_PKE_MODE_SUB_MOD:
+            return PKE_MODE_SUB_MOD;
+        case HAL_PKE_MODE_MUL_MOD:
+            return PKE_MODE_MUL_MOD;
+        case HAL_PKE_MODE_ADD_MOD:
+            return PKE_MODE_ADD_MOD;
+        case HAL_PKE_MODE_MOD:
+            return PKE_MODE_MOD;
+        case HAL_PKE_MODE_MUL:
+            return PKE_MODE_MUL;
+        case HAL_PKE_MODE_MG_MUL_DOT:
+            return PKE_MODE_MG_MUL_DOT;
+        case HAL_PKE_MODE_ED_MUL_DOT:
+            return PKE_MODE_ED_MUL_DOT;
+        case HAL_PKE_MODE_ED_ADD_DOT:
+            return PKE_MODE_ED_ADD_DOT;
+        default:
+            return PKE_MODE_UNSUPPORTTED;
+    }
+}
+
+td_s32 hal_pke_set_mode(hal_pke_mode mode, td_u32 len)
+{
+    td_u32 i = 0;
+    pke_work_mode work;
+    pke_mode mode_mapped = mode_map(mode);
+
+    work.u32 = pke_reg_read(PKE_WORK_MODE);
+
+    if (mode_mapped == PKE_MODE_UNSUPPORTTED) {
+        crypto_log_err("This soc doesn't support this work mode!");
+        return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    work.bits.mode_sel = mode_mapped;
+
+    for (i = 0; i < sizeof(g_pke_len_reg_table) / sizeof(pke_len_reg_map); i++) {
+        if (len == g_pke_len_reg_table[i].pke_len) {
+            work.bits.data_len = g_pke_len_reg_table[i].pke_data_len_reg;
+            break;
+        }
+    }
+
+    pke_reg_write(PKE_WORK_MODE, work.u32);
+    return TD_SUCCESS;
+}
+
+td_void hal_pke_set_ram(td_u32 addr, const td_u8 *ram, td_u32 data_len, td_u32 padded_len)
+{
+    td_u32 start, val, i, j;
+    start = addr;
+
+    /* Input the data which is aligned with 4 bytes;
+       For little-endian system, on reading one word from ram to val, byte sequence should be adjusted as -
+       in ram: Byte1 | Byte2 | Byte3 | Byte4 (addr low <--> addr high)
+       to val: Byte4 | Byte3 | Byte2 | Byte1 (MSB <--> LSB)
+    */
+    for (i = data_len; i >= WORD_WIDTH; i -= WORD_WIDTH) {
+        val = ram[i - 4] << 24;  /* i-4 index shift 24 bits */
+        val |= ram[i - 3] << 16; /* i-3 index shift 16 bits */
+        val |= ram[i - 2] << 8;  /* i-2 index shift 8 bits */
+        val |= ram[i - 1];
+        pke_reg_write(start, val);
+        start += WORD_WIDTH;
+    }
+
+    /* Input the data which is not aligned with 4 bytes */
+    if (i != 0) {
+        val = 0;
+        for (j = 0; j < i; j++) {
+            val |= ram[j] << (8 * (i - 1 - j)); // 8 bit = 1 byte
+        }
+        pke_reg_write(start, val);
+        start += WORD_WIDTH;
+    }
+
+    /* Pad the remaining part with 0x00 */
+    for (; start < addr + padded_len; start += WORD_WIDTH) {
+        val = 0x0;
+        pke_reg_write(start, val);
+    }
+    return;
+}
+
+td_void hal_pke_start(void)
+{
+    pke_start start;
+
+    start.u32 = 0x00;
+    start.bits.pke_start = PKE_START_CODE;
+
+    pke_reg_write(PKE_START, start.u32);
+
+    return;
+}
+
+static td_s32 hal_pke_wait_free_int(void)
+{
+    td_s32 ret = TD_FAILURE;
+    /* wait ready */
+    if (g_pke_wait_event.wait_func != TD_NULL) {
+        ret = g_pke_wait_event.wait_func(g_pke_wait_event.wait, pke_wait_condition, TD_NULL,
+            g_pke_wait_event.timeout_ms);
+        if (ret > 0) {
+            return TD_SUCCESS;
+        } else {
+            hal_cipher_pke_debug();
+            return PKE_COMPAT_ERRNO(ERROR_PKE_WAIT_DONE_TIMEOUT);
+        }
+    }
+
+    return hal_pke_wait_free();
+}
+
+static td_s32 hal_pke_check_robust_warn(void)
+{
+    pke_robust_warn result;
+
+    result.u32 = pke_reg_read(PKE_INT_NOMASK_STATUS);
+    if (result.bits.alarm_int_nomask == PKE_INT_NOMASK_ALARM) {
+        result.u32 = PKE_INT_NOMASK_CLR; // clear warn interrupt
+        pke_reg_write(PKE_INT_NOMASK_STATUS, result.u32);
+        return TD_SUCCESS;
+    }
+    return TD_FAILURE;
+}
+
+static td_s32 hal_pke_error_code(void)
+{
+    pke_failure_flag result;
+    result.u32 = pke_reg_read(PKE_FAILURE_FLAG);
+    return result.u32;
+}
+
+/* wait pke done */
+td_s32 hal_pke_wait_done(void)
+{
+    td_s32 ret = TD_FAILURE;
+
+    ret = hal_pke_wait_free_int();
+    if (ret != TD_SUCCESS) {
+        hal_cipher_pke_debug();
+        return ret;
+    }
+
+    if (hal_pke_check_robust_warn() == TD_SUCCESS) {
+        return TD_FAILURE;
+    }
+
+    ret = hal_pke_error_code();
+    if (ret != 0) {
+        return ret;
+    }
+    return TD_SUCCESS;
+}
+
+td_void hal_pke_get_ram(td_u32 addr, td_u8 *ram, td_u32 klen)
+{
+    td_u32 val, i;
+    if (ram == TD_NULL) {
+        return;
+    }
+    for (i = klen; i >= WORD_WIDTH; i -= WORD_WIDTH) {
+        val = pke_reg_read(addr + i - WORD_WIDTH);
+        ram[klen - i + 0] = (val >> 24) & 0xFF; /* byte 0: bit 31~24 */
+        ram[klen - i + 1] = (val >> 16) & 0xFF; /* byte 1: bit 23~16 */
+        ram[klen - i + 2] = (val >> 8) & 0xFF;  /* byte 2: bit 15~8  */
+        ram[klen - i + 3] = (val) & 0xFF;       /* byte 3: bit 7~0   */
+    }
+    return;
+}
+
+static td_u16 crc_table(td_u8 byte)
+{
+    td_u16 n_remainder = (td_u16)byte << BYTE_BITS;
+    td_u16 m = 0;
+    for (m = BYTE_BITS; m > 0; m--) {
+        if (n_remainder & U16_MSB) {
+            n_remainder = (n_remainder << 1) ^ CRC16_POLYNOMIAL;
+        } else {
+            n_remainder = (n_remainder << 1);
+        }
+    }
+    return n_remainder;
+}
+
+static td_u16 hal_pke_crc16(td_u16 initial, const td_u8 *input, td_u32 len)
+{
+    td_u16 crc = initial, idx;
+    td_s32 i, j;
+
+    for (i = len - 1; i >= 0; i--) {
+        j = (i % BYTES_PER_WORD) * 2; // 2 * len
+        idx = ((crc >> BITS_PER_BYTE) ^ (*(input + i + 3 - j))) & 0xFF; // 3: offset
+        crc = crc_table(idx) ^ (crc << BITS_PER_BYTE);
+    }
+
+    return crc;
+}
+
+
+td_void hal_pke_set_key(const td_u8 *inkey, td_u8 *outkey, td_u32 klen, pke_block *random, td_u32 pad_len)
+{
+    td_u32 i = 0;
+    td_u16 crc16 = 0;
+
+    /* The padded data will be 0x0 */
+    for (i = (pad_len - 1); i >= klen; i--) {
+        td_u32 idx = (pad_len - 1 - i) & PKE_LEN_BLOCK_MASK;
+        outkey[pad_len - 1 - i] = random->byte[idx];
+    }
+
+    /* key must be protected */
+    for (i = 0; i < klen; i++) {
+        outkey[pad_len - 1 - i] = inkey[klen - 1 - i] ^ random->byte[(pad_len - 1 - i) & PKE_LEN_BLOCK_MASK];
+    }
+
+    crc16 = hal_pke_crc16(0x0000, random->byte, 4); // 4 is len of cube in crc
+    crc16 = hal_pke_crc16(crc16, outkey, pad_len);
+
+    /* set Random */
+    pke_reg_write(PKE_KEY_RANDOM, crypto_cpu_to_be32(random->word[0]));
+
+    /* set crc16 */
+    pke_reg_write(PKE_KEY_CRC, crc16);
+
+    return;
+}
+
+td_s32 hal_pke_align_len(td_u32 a_len, td_u32 *a_len_aligned, diff_len_in_chips len)
+{
+    crypto_param_require(a_len_aligned != TD_NULL);
+    if (len == HAL_ALIGN_LEN) {
+        if (a_len <= HAL_PKE_LEN_256) {
+            *a_len_aligned = HAL_PKE_LEN_256;
+        } else if (a_len <= HAL_PKE_LEN_384) {
+            *a_len_aligned = HAL_PKE_LEN_384;
+        } else if (a_len <= HAL_PKE_LEN_521) {
+            *a_len_aligned = HAL_PKE_LEN_521;
+        } else if (a_len <= HAL_PKE_LEN_2048) {
+            *a_len_aligned = HAL_PKE_LEN_2048;
+        } else if (a_len <= HAL_PKE_LEN_3072) {
+            *a_len_aligned = HAL_PKE_LEN_3072;
+        } else if (a_len <= HAL_PKE_LEN_4096) {
+            *a_len_aligned = HAL_PKE_LEN_4096;
+        } else {
+            return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+        }
+        return TD_SUCCESS;
+    } else if (len == HAL_SET_KEY_LEN) {
+        *a_len_aligned = SET_KEY_LEN;
+    } else if (len == HAL_RAM_SECTION_LEN) {
+        *a_len_aligned = RAM_SECTION_LEN;
+    } else if (len == HAL_ECC_512_LEN) {
+        *a_len_aligned = HAL_PKE_LEN_512;
+    } else if (len == HAL_ECC_521_LEN) {
+        *a_len_aligned = HAL_PKE_LEN_521;
+    } else {
+        return PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+    return TD_SUCCESS;
+}
+
+#if defined(CRYPTO_OS_INT_SUPPORT)
+td_s32 hal_cipher_pke_register_wait_func(td_void *wait,
+    crypto_wait_timeout_interruptible wait_func, td_u32 timeout_ms)
+{
+    crypto_hal_func_enter();
+
+    g_pke_wait_event.wait = wait;
+    g_pke_wait_event.wait_func = wait_func;
+    g_pke_wait_event.timeout_ms = timeout_ms;
+    g_pke_wait_event.wait_done = TD_FALSE;
+
+    crypto_hal_func_exit();
+    return CRYPTO_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_v4/hal_pke_reg_v4.h b/bsp/security_subsys/security_subsys_common/hal_code/pke_v4/hal_pke_reg_v4.h
new file mode 100644
index 0000000..6113d47
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_v4/hal_pke_reg_v4.h
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef HAL_PKE_REG_V4_H
+#define HAL_PKE_REG_V4_H
+
+#define PKE_INT_NOMASK_ALARM                 0x5
+#define PKE_INT_NOMASK_CLR                   0x6b4a89c6
+#define PKE_LEN_BLOCK_MASK                   0x03
+
+#define PKE_KEY_RANDOM                  (0x24)
+
+#define PKE_BUSY                        0x4
+#define PKE_WORK_MODE                   0x8
+#define PKE_START                       0xc
+#define PKE_INT_ENABLE                  0x10
+#define PKE_INT_STATUS                  0x14
+#define PKE_INT_NOMASK_STATUS           0x18
+#define PKE_NOISE_EN                    (0x1c)
+#define PKE_LOCK_INT_ENABLE             (0x1c00)
+#define PKE_INT_RAW                     (0x1c04)
+#define PKE_LOCK_CTRL                   (0x1C10)
+#define PKE_LOCK_STATUS                 (0x1c14)
+#define PKE_LOCK_UNLOCK                  0x00
+
+#define PKE_FAILURE_FLAG                (0x28)
+#define PKE_START_CODE                   0x05
+
+#define SET_KEY_LEN                     0x48
+#define RAM_SECTION_LEN                 0x44
+
+#define LOCK_STATUS_SCPU                0xa5
+#define LOCK_STATUS_ACPU                0xaa
+// same with v900
+typedef union {
+    struct {
+        unsigned int    pke_lock              : 1; /* [0]  */
+        unsigned int    pke_lock_type         : 1; /* [1]  */
+        unsigned int    reserved_0            : 30; /* [31..2]  */
+    } bits;
+    unsigned int    u32;
+} pke_lock_ctrl;
+
+typedef union {
+    struct {
+        unsigned int    pke_lock_busy         : 1; /* [0]  */
+        unsigned int    pke_unlock_fail       : 1; /* [1]  */
+        unsigned int    reserved_0            : 2; /* [3..2]  */
+        unsigned int    pke_lock_cnt          : 3; /* [6..4]  */
+        unsigned int    reserved_1            : 1; /* [7]  */
+        unsigned int    pke_lock_stat         : 8; /* [15..8]  */
+        unsigned int    reserved_2            : 16; /* [31..16]  */
+    } bits;
+    unsigned int    u32;
+} pke_lock_status;
+
+typedef union {
+    struct {
+        unsigned int pke_start : 4;   /* [3..0] */
+    }bits;
+    unsigned int u32;
+} pke_start;
+
+// difference with v900
+
+typedef enum {
+    HAL_PKE_LEN_256 = 32,
+    HAL_PKE_LEN_384 = 48,
+    HAL_PKE_LEN_512 = 64,
+    HAL_PKE_LEN_521 = 68, // deference with v900
+    HAL_PKE_LEN_2048 = 256,
+    HAL_PKE_LEN_3072 = 384,
+    HAL_PKE_LEN_4096 = 512,
+} hal_pke_len;
+
+/*! \Define the operation mode */
+typedef enum {
+    PKE_MODE_CLR_RAM        = 0x0,
+    PKE_MODE_EXP_MOD        = 0x1,
+    PKE_MODE_MUL_DOT        = 0x2,
+    PKE_MODE_ADD_DOT        = 0x3,
+    PKE_MODE_TIMES_DOT      = 0x4,
+    PKE_MODE_MINV_MOD       = 0x5,
+    PKE_MODE_SUB_MOD        = 0x6,
+    PKE_MODE_MUL_MOD        = 0x7,
+    PKE_MODE_ADD_MOD        = 0x8,
+    PKE_MODE_MOD            = 0x9,
+    PKE_MODE_MUL            = 0xa,
+    PKE_MODE_MG_MUL_DOT     = 0xb,
+    PKE_MODE_ED_MUL_DOT     = 0xc,
+    PKE_MODE_ED_ADD_DOT     = 0xd,
+    PKE_MODE_UNSUPPORTTED   = 0xff
+} pke_mode;
+
+typedef union {
+    struct {
+        unsigned int power_en : 4;    /* [3..0] */
+        unsigned int reserved_0 : 28; /* [31..4] */
+    } bits;
+    unsigned int u32;
+} pke_power_on;
+
+typedef union {
+    struct {
+        unsigned int finish_int : 4;  /* [3..0] */
+        unsigned int alarm_int : 4;   /* [7..4] */
+        unsigned int reserved_0 : 24; /* [31..8] */
+    } bits;
+    unsigned int u32;
+} pke_int_status;
+
+typedef union {
+    struct {
+        unsigned int finish_int_nomask : 4; /* [3..0] */
+        unsigned int alarm_int_nomask : 4;  /* [7..4] */
+        unsigned int reserved_0 : 24;       /* [31..8] */
+    } bits;
+    unsigned int u32;
+} pke_int_nomask_status;
+
+typedef union {
+    struct {
+        unsigned int finish_int_enable : 1; /* [0] */
+        unsigned int reserved : 31;       /* [31..1] */
+    } bits;
+    unsigned int u32;
+} pke_int_enable;
+
+typedef union {
+    struct {
+        unsigned int pke_lock_int_en : 1;   /* [0] */
+        unsigned int reserved : 31;         /* [31..1] */
+    } bits;
+    unsigned int u32;
+} pke_lock_int_enable;
+
+typedef union {
+    struct {
+        unsigned int pke_busy : 1;    /* [0] */
+        unsigned int reserved_0 : 31; /* [31..1] */
+    } bits;
+    unsigned int u32;
+} pke_busy;
+
+typedef union {
+    struct {
+        unsigned int pke_result_flag : 4; /* [3..0] */
+        unsigned int reserved_0 : 28;     /* [31..4] */
+    } bits;
+    unsigned int u32;
+} pke_result_flag;
+
+typedef union {
+    struct {
+        unsigned int otp_key_sel : 4; /* [3..0] */
+        unsigned int reserved_0 : 28; /* [31..4] */
+    } bits;
+    unsigned int u32;
+} pke_otp_key_sel;
+
+typedef enum {
+    PKE_RESULT_FLAG_IDLE = 0x00,
+    PKE_RESULT_FLAG_OK = 0x05,
+    PKE_RESULT_FLAG_FAIL = 0x0A,
+} pke_result_code;
+
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    mode_sel              : 4; /* [3..0]  */
+        unsigned int    data_len              : 3; /* [6..4]  */
+        unsigned int    reserved_0            : 25; /* [31..7]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_work_mode;
+
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    finish_int_nomask       : 4; /* [3..0]  */
+        unsigned int    alarm_int_nomask        : 4; /* [7..4]  */
+        unsigned int    reserved_0              : 24; /* [31..8]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_robust_warn;
+
+/* Define the union U_PKE_FAILURE_FLAG */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    invalid_k               : 1; /* [0]  */
+        unsigned int    invalid_len_cfg         : 1; /* [1]  */
+        unsigned int    invalid_mode            : 1; /* [2]  */
+        unsigned int    invalid_p               : 1; /* [3]  */
+        unsigned int    invalid_n               : 1; /* [4]  */
+        unsigned int    invalid_crc             : 1; /* [5]  */
+        unsigned int    invalid_data_len        : 1; /* [6]  */
+        unsigned int    infinite_dot            : 1; /* [7]  */
+        unsigned int    in_dot_not_on_curve     : 1; /* [8]  */
+        unsigned int    out_dot_not_on_curve    : 1; /* [9]  */
+        unsigned int    no_result_in_inv_mod    : 1; /* [10]  */
+        unsigned int    invalid_n_in_inv_mod    : 1; /* [11]  */
+        unsigned int    invalid_pm_in_mg        : 1; /* [12]  */
+        unsigned int    invalid_x2_in_mg        : 1; /* [13]  */
+        unsigned int    invalid_hpi_cfg         : 1; /* [14]  */
+        unsigned int    reserved_0              : 17; /* [31..15]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_failure_flag;
+
+/* Define the union U_PKE_POWER_NOISE_LOCK */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    noise_en              : 1; /* [0]  */
+        unsigned int    reserved_0            : 31; /* [31..1]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_noise_en;
+
+typedef union {
+    // Define the struct bits
+    struct {
+        td_u32 pke_lock_int_raw : 1;
+        td_u32 pke_int_raw : 1;
+        td_u32 reserved : 30;
+    } bits;
+
+    // Define an unsigned member
+    td_u32 u32;
+} pke_lock_int_dat;
+
+typedef union {
+    // Define the struct bits
+    struct {
+        td_u32 finish_int_nomask : 4;
+        td_u32 alarm_int_nomask : 4;
+        td_u32 reserved : 24;
+    } bits;
+
+    // Define an unsigned member
+    td_u32 u32;
+} pke_int_dat;
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/ecc_data_ram_addr.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/ecc_data_ram_addr.c
new file mode 100644
index 0000000..f1d2998
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/ecc_data_ram_addr.c
@@ -0,0 +1,64 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2022. All rights reserved.
+ * Description: define the data store address in the PKE DRAM.
+ * Author: CompanyName
+ * Create: 2022-08-17
+*/
+
+#include "rom_lib.h"
+
+/* the largest bit length to support is 521bits, so that we should allocate 3 block DRAM for one data,
+to avoid data stamping */
+
+/* store modulus */
+const td_u32 ecc_addr_m  = 0;
+/* store the result of point multiplication operation */
+const td_u32 ecc_addr_cx = 3;
+const td_u32 ecc_addr_cy = 6;
+const td_u32 ecc_addr_cz = 9;
+/* Temporary point coordinate storage space */
+const td_u32 ecc_addr_ax = 12;
+const td_u32 ecc_addr_ay = 15;
+const td_u32 ecc_addr_az = 18;
+/* Storage space for input point coordinates */
+const td_u32 ecc_addr_px = 21;
+const td_u32 ecc_addr_py = 24;
+/* Storage space for input point coordinates */
+const td_u32 ecc_addr_gx = 27;
+const td_u32 ecc_addr_gy = 30;
+/* Temporary variable storage space for operations */
+const td_u32 ecc_addr_t0 = 33;
+const td_u32 ecc_addr_t1 = 36;
+const td_u32 ecc_addr_t2 = 39;
+const td_u32 ecc_addr_t3 = 42;
+const td_u32 ecc_addr_t4 = 45;
+const td_u32 ecc_addr_tp = 48;
+
+/* Storage space for constant values */
+const td_u32 ecc_addr_p      = 51;
+const td_u32 ecc_addr_rrp    = 54;
+const td_u32 ecc_addr_n      = 57;
+const td_u32 ecc_addr_rrn    = 60;
+const td_u32 ecc_addr_mont_a = 63;
+const td_u32 ecc_addr_mont_b = 66;
+const td_u32 ecc_addr_mont_1_p = 69;
+const td_u32 ecc_addr_mont_1_n = 72;
+const td_u32 ecc_addr_const_1 = 75;
+const td_u32 ecc_addr_const_0 = 78 ;
+
+/* Storage space for digital signatures */
+const td_u32 ecc_addr_s = 81;
+const td_u32 ecc_addr_r = 84;
+/* Storage space of the message hash value */
+const td_u32 ecc_addr_e = 87;
+
+/* Storage space of intermediate variables during signature and verification */
+const td_u32 ecc_addr_k = 12; /* ecc_addr_k = ecc_addr_ax */
+const td_u32 ecc_addr_d = 15; /* ecc_addr_d = ecc_addr_ay */
+
+const td_u32 ecc_addr_u1 = 3; /* ecc_addr_u1 = ecc_addr_cx */
+const td_u32 ecc_addr_u2 = 6; /* ecc_addr_u2 = ecc_addr_cy */
+
+const td_u32 ecc_addr_v = 3; /* ecc_addr_v = ecc_addr_cx */
+const td_u32 ecc_addr_rx = 3; /* ecc_addr_rx = ecc_addr_R = ecc_addr_cx */
+const td_u32 ecc_addr_t = 3; /* ecc_addr_t = ecc_addr_cx */
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/hal_pke.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/hal_pke.c
new file mode 100644
index 0000000..afdc90b
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/hal_pke.c
@@ -0,0 +1,841 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2022. All rights reserved.
+ * Description: PKE driver HAL API and logical algorithm compelement.
+ * Author: CompanyName
+ * Create: 2022-08-09
+*/
+
+#include "hal_pke_v5.h"
+#include "hal_pke_reg_v5.h"
+#include "crypto_errno.h"
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+#include "rom_lib.h"
+
+#if defined(CONFIG_PKE_RAM_MASK_SUPPORT)
+#include "hal_trng.h"
+#endif
+
+/************************************************** global define start************************************/
+#define PKE_COMPAT_ERRNO(err_code)      HAL_COMPAT_ERRNO(ERROR_MODULE_PKE, err_code)
+#if (defined(CRYPTO_LOG_LEVEL) && (CRYPTO_LOG_LEVEL == 2 || CRYPTO_LOG_LEVEL == 3 || CRYPTO_LOG_LEVEL == 4))
+#define crypto_dump_buffer(buffer_name, buffer, len) crypto_dump_data(buffer_name, buffer, len)
+#else
+#define crypto_dump_buffer(fmt, args...)
+#endif
+
+td_u32 g_pke_initialize;
+static td_u32 g_lock_code = CPU_ID_SCPU;
+
+
+/************************************************** global define end************************************/
+
+/************************************************** hal inner API start************************************/
+/* function define */
+td_bool pke_lock_condition(const td_void *param __attribute__((unused)));
+td_s32 hal_pke_check_robust_warn(void);
+td_s32 hal_pke_error_code(void);
+td_s32 check_instr_rdy(pke_mode mode);
+void hal_pke_start_pre_process(void);
+td_s32 get_lock_code(td_u32 *lock_code);
+
+/**
+ * @brief start PKE calculate in single instruction0 mode
+ */
+void hal_pke_start0(void);
+
+/**
+ * @brief start PKE calculate in sigle instruction1 mode
+ */
+void hal_pke_start1(void);
+
+/**
+ * @brief start PKE calculate in batch processing mode
+ */
+void hal_pke_batch_start(void);
+
+/**
+ * @brief PKE wait for free in loop
+ *
+ * @return td_s32
+ */
+td_s32 hal_pke_wait_free(void);
+
+td_s32 hal_pke_check_robust_warn(void)
+{
+    pke_alarm_status result = {.u32 = PKE_NON_SPECIAL_VAL};
+
+    result.u32 = pke_reg_read(PKE_ALARM_STATUS);
+    if (result.bits.alarm_int == PKE_ALARM_STATUS_EFFECTIVE_CODE) {
+        result.u32 = PKE_ALARM_STATUS_CLEAN_CODE; // clear warn interrupt
+        pke_reg_write(PKE_ALARM_STATUS, result.u32);
+        return TD_SUCCESS;
+    }
+    return TD_FAILURE;
+}
+
+td_s32 hal_pke_error_code(void)
+{
+    pke_failure_flag result = {.u32 = PKE_NON_SPECIAL_VAL};
+
+    result.u32 = pke_reg_read(PKE_FAILURE_FLAG);
+    if (result.u32 == 0) {
+        return TD_SUCCESS;
+    }
+
+    crypto_log_err("Hardware Error Code: 0x%x\n", result.u32);
+    return PKE_COMPAT_ERRNO(ERROR_PKE_LOGIC);
+}
+
+td_s32 check_instr_rdy(pke_mode mode)
+{
+    pke_instr_rdy instr_rdy;
+    td_u32 mode_rdy_location;
+    td_u32 i;
+
+    switch (mode) {
+        case PKE_SINGLE_INSTR0: {
+            mode_rdy_location = 0x1; /* single_instr0: 0x1 */
+            break;
+        }
+        case PKE_SINGLE_INSTR1: {
+            mode_rdy_location = 0x2; /* single_instr0: 0x2 */
+            break;
+        }
+        case PKE_BATCH_INSTR: {
+            mode_rdy_location = 0x4; /* batch_instr: 0x4 */
+            break;
+        }
+        default:
+            crypto_log_err("error, pke_instr_start_mode invaild!\n");
+            return TD_FAILURE;
+    }
+
+    /* wait ready */
+    for (i = 0; i < CONFIG_PKE_TIMEOUT_IN_US; i++) {
+        instr_rdy.u32  = pke_reg_read(PKE_INSTR_RDY);
+        if ((instr_rdy.u32 & mode_rdy_location) == mode_rdy_location) {
+            break;
+        }
+        crypto_udelay(1); /* 1us */
+    }
+
+    if (i >= CONFIG_PKE_TIMEOUT_IN_US) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_WAIT_DONE_TIMEOUT);
+    }
+
+    return TD_SUCCESS;
+}
+
+void hal_pke_start_pre_process(void)
+{
+    /* 1.clear interrupt */
+    pke_int_no_mask_status result = {.u32 = PKE_NON_SPECIAL_VAL};
+    result.u32 = pke_reg_read(PKE_INT_NOMASK_STATUS);
+    result.bits.finish_int_nomask = 1;
+    pke_reg_write(PKE_INT_NOMASK_STATUS, result.u32);
+
+    /* call back for secure enhancement */
+    result.u32 = pke_reg_read(PKE_INT_NOMASK_STATUS);
+    val_enhance_chk(result.bits.finish_int_nomask, 1);
+}
+
+#if defined(CONFIG_PKE_SINGLE_INSTR_SUPPORT)
+void hal_pke_start0(void)
+{
+    pke_start start = {0};
+    hal_pke_start_pre_process();
+
+    start = (pke_start) {.u32 = PKE_NON_SPECIAL_VAL};
+    start.u32 = PKE_START0_CODE;
+    pke_reg_write(PKE_START, start.u32);
+
+    /* call back for secure enhancement */
+    reg_callback_chk(PKE_START, PKE_START0_CODE);
+
+    return;
+}
+
+void hal_pke_start1(void)
+{
+    pke_start start = {0};
+    hal_pke_start_pre_process();
+
+    start = (pke_start) {.u32 = PKE_NON_SPECIAL_VAL};
+    start.u32 = PKE_START1_CODE;
+    pke_reg_write(PKE_START, start.u32);
+
+    /* call back for secure enhancement */
+    reg_callback_chk(PKE_START, PKE_START1_CODE);
+
+    return;
+}
+#endif
+
+void hal_pke_batch_start(void)
+{
+    pke_start start = {0};
+    hal_pke_start_pre_process();
+
+    start = (pke_start) {.u32 = PKE_NON_SPECIAL_VAL};
+    start.u32 = PKE_BATCH_START_CODE;
+    pke_reg_write(PKE_START, start.u32);
+
+    /* call back for secure enhancement */
+    reg_callback_chk(PKE_START, PKE_BATCH_START_CODE);
+
+    return;
+}
+
+td_s32 hal_pke_wait_free(void)
+{
+    td_u32 i = 0;
+    td_s32 ret = TD_FAILURE;
+    pke_busy busy = {.u32 = PKE_NON_SPECIAL_VAL};
+    pke_int_no_mask_status int_status = {0};
+
+    /* wait ready */
+    for (i = 0; i < CONFIG_PKE_TIMEOUT_IN_US; i++) {
+        busy.u32 = pke_reg_read(PKE_BUSY);
+        if (busy.bits.pke_busy == 0) {
+            break;
+        }
+        crypto_udelay(1); /* 1us */
+    }
+
+    /* get interrupt status */
+    int_status.u32 = PKE_NON_SPECIAL_VAL;
+    int_status.u32 = pke_reg_read(PKE_INT_NOMASK_STATUS);
+    if (i < CONFIG_PKE_TIMEOUT_IN_US && int_status.bits.finish_int_nomask == PKE_INT_NOMASK_FINISH_EFFECTIVE_CODE) {
+        /* clear interrupt */
+        int_status.bits.finish_int_nomask = 1;
+        pke_reg_write(PKE_INT_NOMASK_STATUS, int_status.u32);
+        ret = TD_SUCCESS;
+    } else {
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_WAIT_DONE_TIMEOUT);
+    }
+    crypto_chk_print((ret != TD_SUCCESS), "error, pke wait free timeout\n");
+
+    return ret;
+}
+
+/************************************************** hal inner API end************************************/
+
+/************************************************** hal outter API start************************************/
+
+td_s32 hal_pke_init(void)
+{
+    if (g_pke_initialize == TD_TRUE) {
+        return TD_SUCCESS;
+    }
+    get_lock_code(&g_lock_code);
+    g_pke_initialize = TD_TRUE;
+    return TD_SUCCESS;
+}
+
+td_s32 hal_pke_deinit(void)
+{
+    if (g_pke_initialize == TD_TRUE) {
+        g_pke_initialize = TD_FALSE;
+        return TD_SUCCESS;
+    }
+
+    return PKE_COMPAT_ERRNO(ERROR_NOT_INIT);
+}
+
+td_s32 get_lock_code(td_u32 *lock_code)
+{
+    crypto_cpu_type cpu_type = crypto_get_cpu_type();
+    switch (cpu_type) {
+        case CRYPTO_CPU_TYPE_SCPU:
+            *lock_code = CPU_ID_SCPU;
+            break;
+        case CRYPTO_CPU_TYPE_ACPU:
+            *lock_code = CPU_ID_ACPU;
+            break;
+        case CRYPTO_CPU_TYPE_PCPU:
+            *lock_code = CPU_ID_PCPU;
+            break;
+        case CRYPTO_CPU_TYPE_AIDSP:
+            *lock_code = CPU_ID_AIDSP;
+            break;
+        default:
+            *lock_code = CPU_ID_ACPU;
+            return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+
+td_s32 hal_pke_lock(void)
+{
+    td_u32 i = 0;
+    td_s32 ret = TD_FAILURE;
+    pke_lock_ctrl lock_ctrl = {.u32 = PKE_NON_SPECIAL_VAL};
+    pke_lock_status lock_status = {.u32 = PKE_NON_SPECIAL_VAL};
+
+    /* lock pke */
+    lock_ctrl.u32 = pke_reg_read(PKE_LOCK_CTRL);
+    lock_ctrl.bits.pke_lock_type = 0; /* lock command */
+    lock_ctrl.bits.pke_lock = 1;
+    pke_reg_write(PKE_LOCK_CTRL, lock_ctrl.u32);
+
+    for (i = 0; i < CONFIG_PKE_TIMEOUT_IN_US; i++) {
+        /* check lock result */
+        lock_status.u32 = pke_reg_read(PKE_LOCK_STATUS);
+        if (lock_status.bits.pke_lock_stat == g_lock_code) {
+            break;
+        }
+        crypto_udelay(1); // 1 us is empirical value of register lock read
+    }
+    if (i < CONFIG_PKE_TIMEOUT_IN_US) {
+        ret = TD_SUCCESS;
+    } else {
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_LOCK_TIMEOUT);
+    }
+
+    crypto_chk_print((ret != TD_SUCCESS), "pke lock timeout\n");
+    return ret;
+}
+
+void hal_pke_unlock(void)
+{
+    pke_lock_ctrl lock_ctrl = {.u32 = PKE_NON_SPECIAL_VAL};
+
+    /* unlock pke */
+    lock_ctrl.u32 = pke_reg_read(PKE_LOCK_CTRL);
+    lock_ctrl.bits.pke_lock_type = 1; /* unlock command */
+    lock_ctrl.bits.pke_lock = 1;
+    pke_reg_write(PKE_LOCK_CTRL, lock_ctrl.u32);
+}
+
+void hal_pke_enable_noise(void)
+{
+    pke_noise_en noise = {
+        .u32 = PKE_NON_SPECIAL_VAL
+    };
+
+    /* enable noise */
+    noise.u32 = pke_reg_read(PKE_NOISE_EN);
+    noise.bits.noise_en = 1;
+    pke_reg_write(PKE_NOISE_EN, noise.u32);
+}
+
+void hal_pke_disable_noise(void)
+{
+    pke_noise_en noise = {.u32 = PKE_NON_SPECIAL_VAL};
+
+    /* disable noise */
+    noise.u32 = pke_reg_read(PKE_NOISE_EN);
+    noise.bits.noise_en = 0;
+    pke_reg_write(PKE_NOISE_EN, noise.u32);
+}
+
+td_s32 hal_pke_pre_process(void)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 random_num = DEFAULT_MASK_CODE;
+    /* 2. set claculate will use random number for mask */
+    pke_mask_rng_cfg mask_rng = {.u32 = PKE_NON_SPECIAL_VAL};
+    mask_rng.u32 = pke_reg_read(PKE_MASK_RNG_CFG);
+    mask_rng.bits.mask_rng_cfg = 1;
+    pke_reg_write(PKE_MASK_RNG_CFG, mask_rng.u32);
+    /* call back for secure enhancement */
+    reg_callback_chk(PKE_MASK_RNG_CFG, mask_rng.u32);
+
+    crypto_unused(ret);
+    crypto_unused(random_num);
+    /* 3. set mask random number */
+#if defined(CONFIG_PKE_RAM_MASK_SUPPORT)
+    random_num = pke_reg_read(PKE_DRAM_MASK);
+    ret = hal_cipher_trng_get_random(&random_num);
+    crypto_chk_func_return(hal_cipher_trng_get_random, ret);
+    pke_reg_write(PKE_DRAM_MASK, random_num);
+    /* call back for secure enhancement */
+    reg_callback_chk(PKE_DRAM_MASK, random_num);
+#endif
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 hal_pke_check_free(void)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 i = 0;
+    pke_busy busy = {.u32 = PKE_NON_SPECIAL_VAL};
+
+    /* wait ready */
+    for (i = 0; i < CONFIG_PKE_TIMEOUT_IN_US; i++) {
+        busy.u32 = pke_reg_read(PKE_BUSY);
+        if (busy.bits.pke_busy == 0) {
+            break;
+        }
+        crypto_udelay(1); /* 1us */
+    }
+
+    if (i < CONFIG_PKE_TIMEOUT_IN_US) {
+        ret = TD_SUCCESS;
+    } else {
+        ret = PKE_COMPAT_ERRNO(ERROR_PKE_WAIT_DONE_TIMEOUT);
+    }
+    crypto_chk_print((ret != TD_SUCCESS), "error, pke wait free timeout\n");
+
+    return ret;
+}
+
+td_void hal_pke_set_ram_const_1(td_u32 ram_section, td_u32 data_len)
+{
+    int32_t i;
+    td_u32 random_num = DEFAULT_MASK_CODE;
+    td_u32 start_dram_addr = PKE_DRAM_BASE + ram_section * PKE_DRAM_BLOCK_LENGTH;
+    /* 1. get mask number */
+    random_num = pke_reg_read(PKE_DRAM_MASK);
+
+    for (i = data_len; i >= 0; i -= CRYPTO_WORD_WIDTH) {
+        if (i == (int32_t)data_len) {
+            pke_reg_write(start_dram_addr, 0x1 ^ random_num);
+        } else {
+            pke_reg_write(start_dram_addr, 0 ^ random_num);
+        }
+        start_dram_addr += CRYPTO_WORD_WIDTH;
+    }
+}
+
+td_void hal_pke_set_ram(td_u32 ram_section, const td_u8 *data, td_u32 data_len, td_u32 aligned_len CIPHER_CHECK_WORD)
+{
+    td_u32 i = 0;
+    td_u32 j = 0;
+    td_u32 val = 0;
+    td_u32 random_num = DEFAULT_MASK_CODE;
+    td_u32 start_dram_addr = PKE_DRAM_BASE + ram_section * PKE_DRAM_BLOCK_LENGTH;
+    td_u32 write_len = (data_len + CRYPTO_WORD_WIDTH - 1) / CRYPTO_WORD_WIDTH * CRYPTO_WORD_WIDTH;
+
+    crypto_hal_func_enter();
+    if (data == TD_NULL) {
+        crypto_log_err("\r\n%s:%d data is NULL\n", __func__, __LINE__);
+        return;
+    }
+
+    /* secure enhancement */
+    check_sum_assert(ram_section, data, data_len, aligned_len);
+    crypto_dump_buffer("data", data, data_len);
+
+    /* 1. get mask number */
+    random_num = pke_reg_read(PKE_DRAM_MASK);
+    crypto_log_dbg("random_num: 0x%x\r\n", random_num);
+
+    /* 2. set data into DRAM */
+    /* Input the data which is aligned with 8 bytes;
+       For little-endian system, on reading one word from ram to val, byte sequence should be adjusted as -
+       in ram: Byte1 | Byte2 | Byte3 | Byte4 (section low <--> section high)
+       to val: Byte4 | Byte3 | Byte2 | Byte1 (MSB <--> LSB)
+    */
+    /* not use dynamic micro in rom code, otherwise it won't be able to be changed after chip delivery. */
+    for (i = data_len; i >= CRYPTO_WORD_WIDTH; i -= CRYPTO_WORD_WIDTH) {
+        val = 0;
+        val = data[i - 4] << 24; /* i - 4 index shift 24 bits */
+        val |= data[i - 3] << 16; /* i - 3 index shift 16 bits */
+        val |= data[i - 2] << 8; /* i - 2 index shift 8 bits */
+        val |= data[i - 1];
+        val ^= random_num;
+        pke_reg_write(start_dram_addr, val);
+        start_dram_addr += CRYPTO_WORD_WIDTH;
+    }
+    /* secure enhancement */
+    val_enhance_chk(i < CRYPTO_WORD_WIDTH, TD_TRUE);
+
+    /* Input the data which is not aligned with 4 bytes */
+    if (i != 0) {
+        val = 0;
+        for (j = 0; j < i; j++) {
+            val |= data[j] << (CRYPTO_BITS_IN_BYTE * (i - j - 1));
+        }
+        /* secure enhancement */
+        val_enhance_chk(j, i);
+        val ^= random_num;
+        pke_reg_write(start_dram_addr, val);
+        start_dram_addr += CRYPTO_WORD_WIDTH;
+    }
+    /* secure enhancement */
+    val_enhance_chk(start_dram_addr, PKE_DRAM_BASE + ram_section * PKE_DRAM_BLOCK_LENGTH + write_len);
+
+    /* 3. padding with 0x00 for not aligned with 64bits data */
+    for (; write_len < aligned_len; write_len += CRYPTO_WORD_WIDTH) {
+        val = 0x0;
+        val ^= random_num;
+        pke_reg_write(start_dram_addr, val);
+        start_dram_addr += CRYPTO_WORD_WIDTH;
+    }
+    /* secure enhancement */
+    val_enhance_chk(start_dram_addr, PKE_DRAM_BASE + ram_section * PKE_DRAM_BLOCK_LENGTH + aligned_len);
+
+    crypto_hal_func_exit();
+    return;
+}
+
+td_void hal_pke_get_ram(td_u32 ram_section, td_u8 *data, td_u32 data_len CIPHER_CHECK_WORD)
+{
+    td_u32 val = 0;
+    td_u32 i = 0;
+    td_u32 count = 0;
+    td_u32 mask_random = DEFAULT_MASK_CODE;
+    td_u32 count_len = data_len;
+    td_u32 start_dram_addr = PKE_DRAM_BASE + ram_section * PKE_DRAM_BLOCK_LENGTH;
+
+    crypto_hal_func_enter();
+    if (data == TD_NULL) {
+        crypto_log_err("data is NULL\n");
+        return;
+    }
+
+    /* secure enhancement */
+    check_sum_assert(ram_section, data, data_len);
+
+    /* 1. get the mask random number */
+    mask_random = pke_reg_read(PKE_DRAM_MASK);
+
+    if ((count_len % CRYPTO_WORD_WIDTH) != 0) {
+        val = pke_reg_read(start_dram_addr + (count_len - (count_len % CRYPTO_WORD_WIDTH)));
+        val ^= mask_random;
+        for (count = 0; count < (count_len % CRYPTO_WORD_WIDTH); count++) {
+            *(data + count) = val >> (CRYPTO_BITS_IN_BYTE * ((count_len % CRYPTO_WORD_WIDTH) - 1 - count)) & 0xFF;
+        }
+        val_enhance_chk(count, count_len % CRYPTO_WORD_WIDTH);
+        count_len = count_len - (count_len % CRYPTO_WORD_WIDTH);
+    }
+    for (i = count_len; i >= CRYPTO_WORD_WIDTH; i -= CRYPTO_WORD_WIDTH) {
+        val = pke_reg_read(start_dram_addr + i - CRYPTO_WORD_WIDTH);
+        val ^= mask_random;
+        *(data + count + 0) = (val >> 24) & 0xFF; /* shift 24 bits */
+        *(data + count + 1) = (val >> 16) & 0xFF; /* shift 16 bits */
+        *(data + count + 2) = (val >> 8) & 0xFF;  /* offset 2, shift 8 bits */
+        *(data + count + 3) = (val) & 0xFF;       /* offset 3 */
+        count += CRYPTO_WORD_WIDTH;
+    }
+    val_enhance_chk(count, count_len);
+
+#ifdef SEC_ENHANCE
+    /* secure enhancement */
+    count = 0;
+    count_len = data_len;
+    if ((count_len % CRYPTO_WORD_WIDTH) != 0) {
+        val = 0;
+        for (count = 0; count < (count_len % CRYPTO_WORD_WIDTH); count++) {
+            val |= *(data + count) << (CRYPTO_BITS_IN_BYTE * (CRYPTO_WORD_WIDTH - 1 - count));
+        }
+        val ^= mask_random;
+        val_enhance_chk(val, pke_reg_read(start_dram_addr + (count_len - (count_len % CRYPTO_WORD_WIDTH))));
+        count_len = count_len - (count_len % CRYPTO_WORD_WIDTH);
+    }
+
+    for (i = count_len; i >= CRYPTO_WORD_WIDTH; i -= CRYPTO_WORD_WIDTH) {
+        val = (*(data + count + 0) << 24) + // 24 bits left-shift according to algorithmn
+            (*(data + count + 1) << 16) + // 16 bits left-shift according to algorithmn
+            (*(data + count + 2) << CRYPTO_BITS_IN_BYTE) + // 2 is byte index: 0, 1, 2, 3
+            *(data + count + 3); // 3 is byte index: 0, 1, 2, 3
+        val ^= mask_random;
+        val_enhance_chk(pke_reg_read(start_dram_addr + i - CRYPTO_WORD_WIDTH), val);
+        count += CRYPTO_WORD_WIDTH;
+    }
+    val_enhance_chk(count, count_len);
+#endif
+
+    crypto_dump_buffer("data", data, data_len);
+    crypto_hal_func_exit();
+    return;
+}
+
+td_s32 hal_pke_clean_ram(void)
+{
+    td_s32 ret = TD_FAILURE;
+    pke_dram_clr dram_clr = {0};
+    crypto_hal_func_enter();
+
+    /* 1. wait for PKE free, no need to wait. */
+    /* Fotr that, if wait_done success, here will also success, if wait_done failed, here will also failed, but will
+    cost a long time to wait failure result.  */
+
+    dram_clr.u32 = PKE_NON_SPECIAL_VAL;
+    dram_clr.u32 = pke_reg_read(PKE_DRAM_CLR);
+    dram_clr.bits.dram_clr = 0x1;
+    pke_reg_write(PKE_DRAM_CLR, dram_clr.u32);
+
+    /* 2. wait for PKE free */
+    ret = hal_pke_check_free();
+    crypto_hal_func_exit();
+    return ret;
+}
+
+td_s32 hal_pke_set_mode(pke_mode mode, td_u32 single_instr, const rom_lib *batch_instr,
+    pke_data_work_len work_len CIPHER_CHECK_WORD)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 batch_instr_addr = 0;
+    td_u32 batch_instr_num = 0;
+    crypto_hal_func_enter();
+    /* secure enhancement */
+    check_sum_assert(mode, single_instr, batch_instr, work_len);
+
+    crypto_chk_return((mode == PKE_SINGLE_INSTR0 || mode == PKE_SINGLE_INSTR1) && single_instr == 0,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "mode is invalid\n");
+    crypto_chk_return(mode == PKE_BATCH_INSTR && batch_instr == TD_NULL,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "mode is invalid\n");
+
+    if (batch_instr != TD_NULL) {
+        /* avoid dynamic MICRO to be used in rom code. */
+        batch_instr_addr = batch_instr->instr_addr;
+        batch_instr_num = batch_instr->instr_num * CRYPTO_WORD_WIDTH;
+
+        crypto_log_dbg("batch_instr_addr = %d\r\n",
+            (batch_instr_addr - CONFIG_PKE_ROM_LIB_START_ADDR) / CRYPTO_WORD_WIDTH);
+        crypto_log_dbg("batch_instr_len = %d\r\n", batch_instr->instr_num);
+        crypto_log_dbg("batch_instr_0 = 0x%x\r\n", crypto_reg_read(batch_instr_addr));
+    }
+
+    /* 1. set work_len, work_len = celing(width/64bit) */
+    pke_reg_write(PKE_WORK_LEN, work_len);
+    /* call back for secure enhancement */
+    reg_callback_chk(PKE_WORK_LEN, work_len);
+
+    /* 2. check pke instr ready */
+    ret = check_instr_rdy(mode);
+    crypto_chk_func_return(check_instr_rdy, ret);
+
+    /* 3. set calculate instruction */
+    if (mode == PKE_SINGLE_INSTR0) {
+        pke_reg_write(PKE_INSTR0, single_instr);
+        /* call back for secure enhancement */
+        reg_callback_chk(PKE_INSTR0, single_instr);
+    } else if (mode == PKE_SINGLE_INSTR1) {
+        pke_reg_write(PKE_INSTR1, single_instr);
+        /* call back for secure enhancement */
+        reg_callback_chk(PKE_INSTR1, single_instr);
+    } else if (mode == PKE_BATCH_INSTR) {
+        pke_reg_write(PKE_INSTR_ADDR_LOW, batch_instr_addr);
+        /* call back for secure enhancement */
+        reg_callback_chk(PKE_INSTR_ADDR_LOW, batch_instr_addr);
+        /* WARN: need to set. */
+        pke_reg_write(PKE_INSTR_ADDR_HIG, 0);
+        /* call back for secure enhancement */
+        reg_callback_chk(PKE_INSTR_ADDR_HIG, 0);
+        /* here the PKE_INSTR_LEN should be set in byte, and should be aligned to 4 bytes. And eatch instr
+        will occupy 4 bytes. */
+        pke_reg_write(PKE_INSTR_LEN, batch_instr_num);
+        /* call back for secure enhancement */
+        reg_callback_chk(PKE_INSTR_LEN, batch_instr_num);
+    }
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_pke_start(pke_mode mode CIPHER_CHECK_WORD)
+{
+    crypto_hal_func_enter();
+    /* secure enhancement */
+    check_sum_assert(mode);
+
+    switch (mode) {
+#if defined(CONFIG_PKE_SINGLE_INSTR_SUPPORT)
+        case PKE_SINGLE_INSTR0: {
+            hal_pke_start0();
+            break;
+        }
+        case PKE_SINGLE_INSTR1: {
+            hal_pke_start1();
+            break;
+        }
+#endif
+        case PKE_BATCH_INSTR: {
+            hal_pke_batch_start();
+            break;
+        }
+        default:
+            crypto_log_err("error, pke_instr_start_mode invaild!\n");
+            return TD_FAILURE;
+    }
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_pke_wait_done(void)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_hal_func_enter();
+
+    /* wait ready */
+    ret = hal_pke_wait_free();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    if (hal_pke_check_robust_warn() == TD_SUCCESS) {
+        return PKE_COMPAT_ERRNO(ERROR_PKE_ROBUST_WARNING);
+    }
+
+    ret = hal_pke_error_code();
+    crypto_chk_func_return(hal_pke_error_code, ret);
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_pke_get_align_val(const td_u32 len, td_u32 *aligned_len)
+{
+    unsigned int i;
+    td_u32 aligned_len_list[] = {
+        DRV_PKE_LEN_192, DRV_PKE_LEN_256, DRV_PKE_LEN_384, DRV_PKE_LEN_512, DRV_PKE_LEN_576,
+        DRV_PKE_LEN_1024, DRV_PKE_LEN_1536, DRV_PKE_LEN_2048, DRV_PKE_LEN_3072, DRV_PKE_LEN_4096
+    };
+    crypto_hal_func_enter();
+    crypto_chk_return(aligned_len == TD_NULL, PKE_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "aligned_len is NULL\n");
+    for (i = 0; i < crypto_array_size(aligned_len_list); i++) {
+        if (len <= aligned_len_list[i]) {
+            *aligned_len = aligned_len_list[i];
+            crypto_hal_func_exit();
+            return TD_SUCCESS;
+        }
+    }
+
+    crypto_hal_func_exit();
+    return TD_FAILURE;
+}
+
+td_s32 hal_pke_set_mont_para(td_u32 low_bit, td_u32 high_bit CIPHER_CHECK_WORD)
+{
+    crypto_hal_func_enter();
+    check_sum_inspect(PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), low_bit, high_bit);
+
+    /* set low 32bit data */
+    pke_reg_write(PKE_MONT_PARA0, low_bit);
+    /* call back for secure enhancement */
+    reg_callback_chk(PKE_MONT_PARA0, low_bit);
+
+    /* set high 32bit data */
+    pke_reg_write(PKE_MONT_PARA1, high_bit);
+    /* call back for secure enhancement */
+    reg_callback_chk(PKE_MONT_PARA1, high_bit);
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+#ifdef CONFIG_PKE_SUPPORT_CURVE
+td_s32 hal_pke_set_curve_param(const pke_ecc_init_param *init_param, const drv_pke_ecc_curve *ecc_curve)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 aligned_len = ecc_curve->ksize;
+    crypto_hal_func_enter();
+    crypto_chk_return(ecc_curve->ecc_type != DRV_PKE_ECC_TYPE_RFC7748 &&
+        ecc_curve->ecc_type != DRV_PKE_ECC_TYPE_RFC7748_448,
+        PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM), "ecc_type is invalid\n");
+
+    if (ecc_curve->ksize == DRV_PKE_LEN_448) {
+        aligned_len = DRV_PKE_LEN_448;
+    } else {
+        ret = hal_pke_get_align_val(ecc_curve->ksize, &aligned_len);
+        crypto_chk_return((ret != TD_SUCCESS), ret, "hal_pke_get_align_val failed!\n");
+    }
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_n, ecc_curve->n, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_p, ecc_curve->p, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_rrn, init_param->rrn, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_rrp, init_param->rrp, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_const_0, init_param->const_0, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_const_1, init_param->const_1, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_mont_a24, init_param->mont_a, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_mont_1_p, init_param->mont_1_p, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(curve_addr_mont_1_n, init_param->mont_1_n, ecc_curve->ksize, aligned_len));
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+#endif
+
+#ifdef CONFIG_PKE_SUPPORT_EDWARD
+td_s32 hal_pke_set_ed_param(const pke_ecc_init_param *init_param, const drv_pke_ecc_curve *ecc_curve)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 aligned_len = ecc_curve->ksize;
+    crypto_chk_return(ecc_curve->ecc_type != DRV_PKE_ECC_TYPE_RFC8032, PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "ecc_type is invalid\n");
+
+    ret = hal_pke_get_align_val(ecc_curve->ksize, &aligned_len);
+    crypto_chk_return((ret != TD_SUCCESS), ret, "hal_pke_get_align_val failed!\n");
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_n, ecc_curve->n, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_p, ecc_curve->p, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_rrn, init_param->rrn, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_rrp, init_param->rrp, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_const_0, init_param->const_0, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_const_1, init_param->const_1, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_mont_d, init_param->mont_a, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_sqrt_m1, init_param->mont_b, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_mont_1_p, init_param->mont_1_p, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ed_addr_mont_1_n, init_param->mont_1_n, ecc_curve->ksize, aligned_len));
+    return TD_SUCCESS;
+}
+#endif
+
+#ifdef CONFIG_PKE_ECC_SUPPORT
+td_s32 hal_pke_set_ecc_param(const pke_ecc_init_param *init_param, const drv_pke_ecc_curve *ecc_curve)
+{
+    td_s32 ret = TD_FAILURE;
+    td_u32 aligned_len = ecc_curve->ksize;
+    crypto_hal_func_enter();
+
+    ret = hal_pke_get_align_val(ecc_curve->ksize, &aligned_len);
+    crypto_chk_return((ret != TD_SUCCESS), ret, "hal_pke_get_align_val failed!\n");
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_n, ecc_curve->n, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_p, ecc_curve->p, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_rrn, init_param->rrn, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_rrp, init_param->rrp, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_const_0, init_param->const_0, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_const_1, init_param->const_1, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_mont_a, init_param->mont_a, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_mont_b, init_param->mont_b, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_mont_1_p, init_param->mont_1_p, ecc_curve->ksize, aligned_len));
+    hal_pke_set_ram(sec_arg_add_cs(ecc_addr_mont_1_n, init_param->mont_1_n, ecc_curve->ksize, aligned_len));
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+#endif
+
+td_s32 hal_pke_set_init_param(const pke_ecc_init_param *init_param, const drv_pke_ecc_curve *ecc_curve)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_hal_func_enter();
+
+    crypto_unused(init_param);
+
+    switch (ecc_curve->ecc_type) {
+#ifdef CONFIG_PKE_SUPPORT_CURVE
+        case DRV_PKE_ECC_TYPE_RFC7748:
+        case DRV_PKE_ECC_TYPE_RFC7748_448:
+            ret = hal_pke_set_curve_param(init_param, ecc_curve);
+            break;
+#endif
+#ifdef CONFIG_PKE_SUPPORT_EDWARD
+        case DRV_PKE_ECC_TYPE_RFC8032:
+            ret = hal_pke_set_ed_param(init_param, ecc_curve);
+            break;
+#endif
+#ifdef CONFIG_PKE_ECC_SUPPORT
+        case DRV_PKE_ECC_TYPE_RFC5639_P256:
+        case DRV_PKE_ECC_TYPE_RFC5639_P384:
+        case DRV_PKE_ECC_TYPE_RFC5639_P512:
+        case DRV_PKE_ECC_TYPE_FIPS_P192R:
+        case DRV_PKE_ECC_TYPE_FIPS_P224R:
+        case DRV_PKE_ECC_TYPE_FIPS_P256R:
+        case DRV_PKE_ECC_TYPE_FIPS_P384R:
+        case DRV_PKE_ECC_TYPE_FIPS_P521R:
+        case DRV_PKE_ECC_TYPE_SM2:
+            ret = hal_pke_set_ecc_param(init_param, ecc_curve);
+            break;
+#endif
+        default:
+            crypto_log_err("invalid ecc_type!\n");
+            ret = PKE_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+            break;
+    }
+
+    crypto_hal_func_exit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/hal_pke_reg_v5.h b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/hal_pke_reg_v5.h
new file mode 100644
index 0000000..6d7111a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/hal_pke_reg_v5.h
@@ -0,0 +1,222 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2022. All rights reserved.
+ * Description: define the logic related register micro.
+ * Author: CompanyName
+ * Create: 2022-12-12
+*/
+
+#ifndef HAL_PKE_REG_V5_H
+#define HAL_PKE_REG_V5_H
+
+/************************************************** reg related MICRO DEFINE start************************************/
+/* Define non-special val for secure enhancement */
+#define PKE_NON_SPECIAL_VAL 0xA5C36987 // 0xA5C36987 is for secure enhancement (with bit 0/1 the same count)
+#define PKE_START0_CODE 0xAA5
+#define PKE_START1_CODE 0xA5A
+#define PKE_BATCH_START_CODE 0x5AA
+#define PKE_INT_NOMASK_FINISH_EFFECTIVE_CODE 0x5
+#define PKE_INT_NOMASK_FINISH_INVALID_CODE 0xA
+#define PKE_ALARM_STATUS_EFFECTIVE_CODE 0x5
+#define PKE_ALARM_STATUS_INVALID_CODE 0xA
+#define PKE_ALARM_STATUS_CLEAN_CODE 0x6B4A89C6
+#define DEFAULT_MASK_CODE 0xE69BC3A7
+#define PKE_DRAM_BLOCK_LENGTH 32
+#define ALIGNED_TO_WORK_LEN_IN_BYTE 8
+#define PKE_MONT_PARAM_LEN 2
+#define PKE_FAIL_FLAG_CNT 0xB
+#define PKE_MONT_BIT_LEN 64
+
+/* define logic related register micro. */
+#define PKE_WORK_LEN                    (0x00)
+#define PKE_INSTR0                      (0x04)
+#define PKE_INSTR1                      (0x08)
+#define PKE_INSTR_ADDR_LOW              (0x0c)
+#define PKE_INSTR_ADDR_HIG              (0x10)
+#define PKE_INSTR_LEN                   (0x14)
+#define PKE_MASK_RNG_CFG                (0x18)
+#define PKE_MONT_PARA0                  (0x20)
+#define PKE_MONT_PARA1                  (0x24)
+#define PKE_INSTR_RDY                   (0x44)
+#define PKE_BUSY                        (0x48)
+#define PKE_NOISE_EN                    (0x4c)
+#define PKE_START                       (0x40)
+#define PKE_INT_ENABLE                  (0x80)
+#define PKE_INT_NOMASK_STATUS           (0x84)
+#define PKE_ALARM_STATUS                (0x8c)
+#define PKE_FAILURE_FLAG                (0x90)
+#define PKE_DRAM_CLR                    (0xc0)
+#define PKE_DRAM_MASK                   (0xf0)
+#define PKE_LOCK_CTRL                   (0x810)
+#define PKE_LOCK_STATUS                 (0x814)
+#define PKE_DRAM_BASE                   (0x1000)
+
+/* define the instr mode num */
+#define CMD_MUL_MOD 0
+#define CMD_ADD_MOD 1
+#define CMD_SUB_MOD 2
+#define MAX_RAM_SECTION 127
+#define OPCODE_OFFSET   0
+#define APOS_OFFSET     4
+#define BPOS_OFFSET     11
+#define TPOS_OFFSET     18
+#define RPOS_OFFSET     25
+
+/************************************************** reg related MICRO DEFINE end************************************/
+
+/************************************************** reg related struct start************************************/
+
+/* Define the union U_PKE_LOCK_CTRL */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    pke_lock              : 1; /* [0]  */
+        unsigned int    pke_lock_type         : 1; /* [1]  */
+        unsigned int    reserved_0            : 30; /* [31..2]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_lock_ctrl;
+
+/* Define the union U_PKE_LOCK_STATUS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    pke_lock_busy         : 1; /* [0]  */
+        unsigned int    pke_unlock_fail       : 1; /* [1]  */
+        unsigned int    reserved_0            : 2; /* [3..2]  */
+        unsigned int    pke_lock_cnt          : 3; /* [6..4]  */
+        unsigned int    reserved_1            : 1; /* [7]  */
+        unsigned int    pke_lock_stat         : 8; /* [15..8]  */
+        unsigned int    reserved_2            : 16; /* [31..16]  */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_lock_status;
+
+/* Define the union U_PKE_POWER_NOISE_LOCK */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    noise_en              : 1; /* [0]  */
+        unsigned int    reserved_0            : 31; /* [31..1]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_noise_en;
+
+/* Define the union U_PKE_INT_NOMASK_STATUS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    finish_int_nomask   : 4; /* [0:3] */
+        unsigned int    reserved_0          : 28; /* [4:31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_int_no_mask_status;
+
+/* Define the union U_PKE_ALARM_STATUS */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    alarm_int       : 4; /* [0:3] */
+        unsigned int    reserved_0      : 28; /* [4:31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_alarm_status;
+
+/* Define the union U_PKE_FAILURE_FLAG */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    pke_failure_flag    : 11; /* [0:10] */
+        unsigned int    reserved_0          : 21; /* [11:31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_failure_flag;
+
+/* Define the union U_PKE_INT_ENABLE */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    finish_int_enable     : 1; /* [0]  */
+        unsigned int    reserved_0            : 31; /* [31..1]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_int_enable;
+
+/* Define the union U_PKE_START */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    pke_start0    : 4; /* [0:3] */
+        unsigned int    pke_start1    : 4; /* [4:7] */
+        unsigned int    pke_batch_start    : 4; /* [8:11] */
+        unsigned int    reserved_0    : 20; /* [12:31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_start;
+
+/* Define the union U_PKE_BUSY */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    pke_busy              : 1; /* [0]  */
+        unsigned int    reserved_0            : 31; /* [31..1]  */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_busy;
+
+/* Define the union U_PKE_DRAM_CLR */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    dram_clr    : 1; /* [0] */
+        unsigned int    reserved_0    : 31; /* [1:31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_dram_clr;
+
+/* Define the union U_PKE_MASK_RNG_CFG */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    mask_rng_cfg    : 1; /* [0] */
+        unsigned int    reserved_0    : 31; /* [1:31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_mask_rng_cfg;
+
+/* Define the union U_PKE_INSTR_RDY: */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int    instr0_rdy    : 1; /* [0] */
+        unsigned int    instr1_rdy    : 1; /* [1] */
+        unsigned int    batch_instr_rdy    : 1; /* [2] */
+        unsigned int    reserved_0    : 29; /* [3:31] */
+    } bits;
+
+    /* Define an unsigned member */
+    unsigned int    u32;
+} pke_instr_rdy;
+
+/************************************************** reg related struct end************************************/
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rom_lib.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rom_lib.c
new file mode 100644
index 0000000..4b8ddd7
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rom_lib.c
@@ -0,0 +1,592 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2022. All rights reserved.
+ * Description: romlib instruction functions content.
+ * Author: CompanyName
+ * Create: 2022-08-16
+ */
+
+#include "crypto_osal_lib.h"
+#include "crypto_common_def.h"
+#include "rom_lib.h"
+
+#if defined(CONFIG_PKE_ECC_SUPPORT)
+/*
+ * preprocess, initialize the data, include copy and generate tmpera variable.
+ * [fp_mul, fp_mul, fp_mul, fp_sub, fp_add]
+ * [415359168, 1119903936, 1220567568, 2730659090, 2730640657]
+ */
+const rom_lib instr_ecfp_j2a_pre_5 = {
+    .instr_addr = 143 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 5,
+};
+
+/* ************************************************* ecc instr start*********************************** */
+
+/* mul mod while e_bin[i:i+2] == '00'. */
+const rom_lib instr_ecfp_j2a_exp_00 = {
+    .instr_addr = 148 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* mul mod while e_bin[i:i+2] == '01'. */
+const rom_lib instr_ecfp_j2a_exp_01 = {
+    .instr_addr = 148 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* mul mod while e_bin[i:i+2] == '10'. */
+const rom_lib instr_ecfp_j2a_exp_10 = {
+    .instr_addr = 151 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* mul mod while e_bin[i:i+2] == '11'. */
+const rom_lib instr_ecfp_j2a_exp_11 = {
+    .instr_addr = 154 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* postprocess, include the mul mod. */
+const rom_lib instr_ecfp_j2a_post_4 = {
+    .instr_addr = 157 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 4,
+};
+
+/* demontgomery affine point, demont and fully sub mod. */
+const rom_lib instr_ecfp_demont_c_6 = {
+    .instr_addr = 165 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 6,
+};
+
+/* demont and fully sub mod for z. */
+const rom_lib instr_ecfp_demont_cz_3 = {
+    .instr_addr = 171 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* montgomery point data. */
+const rom_lib instr_ecfp_mont_p_2 = {
+    .instr_addr = 163 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* affine coordinate system to jacobin coordinate system. */
+const rom_lib instr_ecfp_cpy_p2c_3 = {
+    .instr_addr = 177 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* copy the negative point of P(px,py) to G(gx,gy). */
+const rom_lib instr_ecfp_cpy_np2g_2 = {
+    .instr_addr = 180 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* double point and point add algorithm while ki is 1. */
+const rom_lib instr_ecfp_mul_p_22_18 = {
+    .instr_addr = 0 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 40,
+};
+
+/* double point and point add algorithm while ki is -1. */
+const rom_lib instr_ecfp_mul_g_22_18 = {
+    .instr_addr = 40 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 40,
+};
+
+/* double point. */
+const rom_lib instr_ecfp_mul_c_double_22 = {
+    .instr_addr = 0 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 22,
+};
+
+/* copy new modulus into address 0. */
+const rom_lib instr_ecfp_prime_n_1 = {
+    .instr_addr = 197 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 1,
+};
+
+/* copy new modulus into address 0. */
+const rom_lib instr_ecfn_sign_r_2 = {
+    .instr_addr = 198 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* the former 5 process for inv calculate to get XXX. */
+const rom_lib instr_ecfn_inv_pre_5 = {
+    .instr_addr = 200 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 5,
+};
+
+/* twice square calculate ecc_addr_s * ecc_addr_s. */
+const rom_lib instr_ecfn_inv_exp_00 = {
+    .instr_addr = 205 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* multiplication modulus calculate ecc_addr_s * ecc_addr_k. */
+const rom_lib instr_ecfn_inv_exp_01 = {
+    .instr_addr = 205 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate ecc_addr_s * ecc_addr_t0. */
+const rom_lib instr_ecfn_inv_exp_10 = {
+    .instr_addr = 208 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate ecc_addr_s * ecc_addr_t1. */
+const rom_lib instr_ecfn_inv_exp_11 = {
+    .instr_addr = 211 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* calculate the s for ecdsa signature. */
+const rom_lib instr_ecfn_sign_s_12 = {
+    .instr_addr = 214 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 12,
+};
+
+/* calculate the u1 and u2 for ecdsa verify. */
+const rom_lib instr_ecfn_verify_u_10 = {
+    .instr_addr = 226 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 10,
+};
+
+/* calculate the A = P + Q and set data into ecc_addr_ax, ecc_addr_ay, ecc_addr_az. */
+const rom_lib instr_ecfp_add_ja_verify_18 = {
+    .instr_addr = 125 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 18,
+};
+
+/* affine coordinate system to jacobin coordinate system. */
+const rom_lib instr_ecfp_cpy_a2c_3 = {
+    .instr_addr = 182 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* affine coordinate system to jacobin coordinate system. */
+const rom_lib instr_ecfp_cpy_g2c_3 = {
+    .instr_addr = 174 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* jacobin double point and jac + jac calculation. */
+const rom_lib instr_ecfp_mul_jj_22_23 = {
+    .instr_addr = 80 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 45,
+};
+
+/* jacobin double point and jac + jac calculation. */
+const rom_lib instr_ecfn_verify_v_4 = {
+    .instr_addr = 236 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 4,
+};
+
+/* ************************************************* ecc instr end*********************************** */
+
+/* ************************************************* sm2 instr start*********************************** */
+/* ecc ecfp modular addition. */
+const rom_lib instr_sm2_sign_r_1 = {
+    .instr_addr = 240 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 1,
+};
+
+/* data montgomery and calculate the (1+da) & (k - r*da). */
+const rom_lib instr_sm2_sign_s_pre_6 = {
+    .instr_addr = 241 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 6,
+};
+
+/* calculate the (1+da)^(-1) * (k - r*da) and demontgomery the data. */
+const rom_lib instr_sm2_sign_s_post_6 = {
+    .instr_addr = 247 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 6,
+};
+
+/* calculate the (1+da)^(-1) * (k - r*da) and demontgomery the data. */
+const rom_lib instr_sm2_verify_t_3 = {
+    .instr_addr = 253 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+/* ************************************************* sm2 instr end*********************************** */
+
+/* ************************************************* curve instr start*********************************** */
+#ifdef CONFIG_PKE_SUPPORT_CURVE
+/* point add and times point calculation while k_bin[i] == 0. */
+const rom_lib instr_curve25519_ladder_0 = {
+    .instr_addr = 332 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 18,
+};
+
+/* point add and times point calculation while k_bin[i] == 1. */
+const rom_lib instr_curve25519_ladder_1 = {
+    .instr_addr = 350 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 18,
+};
+
+/* x coordinate montgomerized and data copy. */
+const rom_lib instr_curve25519_pre_ladder = {
+    .instr_addr = 368 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 5,
+};
+
+/* data initialize: data copy. */
+const rom_lib instr_curve25519_xz2x_pre = {
+    .instr_addr = 373 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 5,
+};
+
+/* twice square calculate curve_addr_t0 * curve_addr_t0. */
+const rom_lib instr_curve25519_xz2x_exp_00 = {
+    .instr_addr = 378 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* multiplication modulus calculate curve_addr_t0 * curve_addr_t1. */
+const rom_lib instr_curve25519_xz2x_exp_01 = {
+    .instr_addr = 378 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate curve_addr_t0 * curve_addr_t2. */
+const rom_lib instr_curve25519_xz2x_exp_10 = {
+    .instr_addr = 381 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate curve_addr_t0 * curve_addr_t3. */
+const rom_lib instr_curve25519_xz2x_exp_11 = {
+    .instr_addr = 384 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* demontgomery and twice modular reduction, result in curve_addr_x2. */
+const rom_lib instr_curve25519_xz2x_post = {
+    .instr_addr = 387 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 4,
+};
+#endif
+/* ************************************************* curve instr end*********************************** */
+
+/* ************************************************* ed instr start*********************************** */
+#ifdef CONFIG_PKE_SUPPORT_EDWARD
+/* mul_naf: times point calculation while k_bin[i] == 0. */
+const rom_lib instr_ed25519_mul_loop_0 = {
+    .instr_addr = 391 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 14,
+};
+
+/* mul_naf: point add and times point calculation while k_bin[i] == 1. */
+const rom_lib instr_ed25519_mul_a_loop_1 = {
+    .instr_addr = 391 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 33,
+};
+
+/* mul_naf: point add and times point calculation while k_bin[i] == -1. */
+const rom_lib instr_ed25519_mul_p_loop_1 = {
+    .instr_addr = 424 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 33,
+};
+
+/* double point and point add while si == 0 && hi == 1. */
+const rom_lib instr_ed25519_mul_g_loop_1 = {
+    .instr_addr = 457 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 33,
+};
+
+/* data initialize: data montgomerized and data copy. */
+const rom_lib instr_ed25519_mul_a_pre = {
+    .instr_addr = 490 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 12,
+};
+
+/* data initialize: data copy. */
+const rom_lib instr_ed_ecfp_xyz2xy_pre = {
+    .instr_addr = 502 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 5,
+};
+
+/* twice square calculate ed_addr_t0 * ed_addr_t0. */
+const rom_lib instr_ed_ecfp_xyz2xy_exp_00 = {
+    .instr_addr = 507 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* multiplication modulus calculate ed_addr_t0 * ed_addr_t1. */
+const rom_lib instr_ed_ecfp_xyz2xy_exp_01 = {
+    .instr_addr = 507 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate ed_addr_t0 * ed_addr_t2. */
+const rom_lib instr_ed_ecfp_xyz2xy_exp_10 = {
+    .instr_addr = 510 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate ed_addr_t0 * ed_addr_t3. */
+const rom_lib instr_ed_ecfp_xyz2xy_exp_11 = {
+    .instr_addr = 513 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* demontgomery and twice modular reduction. */
+const rom_lib instr_ed_ecfp_xyz2xy_post = {
+    .instr_addr = 516 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 8,
+};
+
+/* data preparation, include data montgomery and data copy. */
+const rom_lib instr_ed25519_mul_sub_pre = {
+    .instr_addr = 524 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 33,
+};
+
+/* modulo operation for ed25519/ed448. */
+const rom_lib instr_ed25519_calc_h = {
+    .instr_addr = 566 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 7,
+};
+
+/* calculate the result s of signature. */
+const rom_lib instr_ed25519_calc_s = {
+    .instr_addr = 573 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 8,
+};
+
+/* data initialize: data montgomerized and data copy. */
+const rom_lib instr_ed25519_recover_x_pre = {
+    .instr_addr = 581 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 15,
+};
+
+/* twice square calculate ed_addr_t4 * ed_addr_t4. */
+const rom_lib instr_ed25519_recover_x_exp_00 = {
+    .instr_addr = 596 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* multiplication modulus calculate ed_addr_t4 * ed_addr_t1. */
+const rom_lib instr_ed25519_recover_x_exp_01 = {
+    .instr_addr = 596 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate ed_addr_t4 * ed_addr_t2. */
+const rom_lib instr_ed25519_recover_x_exp_10 = {
+    .instr_addr = 599 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate ed_addr_t4 * ed_addr_t3. */
+const rom_lib instr_ed25519_recover_x_exp_11 = {
+    .instr_addr = 602 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* demontgomery and twice modular reduction, result in ed_addr_tx0 and ed_addr_tx1. */
+const rom_lib instr_ed25519_recover_x_post = {
+    .instr_addr = 605 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 22,
+};
+
+/* data copy: ed_addr_tx1 = ed_addr_m - ed_addr_tx0. */
+const rom_lib instr_ed25519_cpy_tx0_to_tx1 = {
+    .instr_addr = 627 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 1,
+};
+
+/* copy and move: ed_addr_tx0 = ed_addr_tx1, ed_addr_tx1 = ed_addr_m - ed_addr_tx1. */
+const rom_lib instr_ed25519_cpy_tx1_to_tx0 = {
+    .instr_addr = 628 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* copy data from ed_addr_tx0, ed_addr_ty to ed_addr_gx, ed_addr_gy. */
+const rom_lib instr_ed25519_cpy_t2g = {
+    .instr_addr = 630 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* copy data from ed_addr_tx0, ed_addr_ty to ed_addr_rx, ed_addr_ry. */
+const rom_lib instr_ed25519_cpy_t2r = {
+    .instr_addr = 632 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* ed_addr_cx(cy) = ed_addr_cx(cy) - ed_addr_rx(ry) * ed_addr_cz. */
+const rom_lib instr_ed25519_c_eq_r = {
+    .instr_addr = 634 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 12,
+};
+#endif
+/* ************************************************* ed instr end*********************************** */
+#endif
+
+/* ************************************************* rsa instr start*********************************** */
+/* data montgomery. */
+const rom_lib instr_rsa_exp_pre_6 = {
+    .instr_addr = 268 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 6,
+};
+
+/* twice square calculate rsa_addr_s * rsa_addr_s. */
+const rom_lib instr_rsa_exp_00 = {
+    .instr_addr = 274 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* multiplication modulus calculate rsa_addr_s * rsa_addr_a. */
+const rom_lib instr_rsa_exp_01 = {
+    .instr_addr = 274 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate rsa_addr_s * rsa_addr_t0. */
+const rom_lib instr_rsa_exp_10 = {
+    .instr_addr = 277 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* multiplication modulus calculate rsa_addr_s * rsa_addr_t1. */
+const rom_lib instr_rsa_exp_11 = {
+    .instr_addr = 280 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* demontgomery and twice modular reduction. */
+const rom_lib instr_rsa_exp_post_3 = {
+    .instr_addr = 283 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 3,
+};
+
+/* big data regular multiplication. */
+const rom_lib instr_rsa_regular_mul = {
+    .instr_addr = 286 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 1,
+};
+
+/* pre 17 times add_mod for rrn calculate. */
+const rom_lib instr_rsa_rrn_add = {
+    .instr_addr = 287 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 17,
+};
+
+/* pre 17 times add_mod for rrn calculate. */
+const rom_lib instr_rsa_rrn_add_3072 = {
+    .instr_addr = 287 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 4,
+};
+
+/* pre 17 times add_mod for rrn calculate. */
+const rom_lib instr_rsa_rrn_add_320 = {
+    .instr_addr = 287 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 6,
+};
+
+/* multiplication modular for square calculate. */
+const rom_lib instr_rsa_rrn_mul = {
+    .instr_addr = 304 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 1,
+};
+
+const rom_lib instr_rsa_mod = {
+    .instr_addr = 305 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 7,
+};
+
+/* demont and fully sub mod for z. */
+const rom_lib instr_rsa_mod_add = {
+    .instr_addr = 322 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* demont and fully sub mod for z. */
+const rom_lib instr_rsa_mod_sub = {
+    .instr_addr = 324 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 2,
+};
+
+/* montgomery multiplication modular with twice modular reduction. */
+const rom_lib instr_rsa_mod_mul = {
+    .instr_addr = 326 * CRYPTO_WORD_WIDTH + CONFIG_PKE_ROM_LIB_START_ADDR,
+    .instr_num = 6,
+};
+#ifdef DEBUG_IN_RAM
+static const td_u32 g_instr_rom[] = {
+    1220548656, 1321218144, 1421887632, 1522612272, 1522625233, 1522625233, 1421955744, 1421998752,
+    1421943457, 1421943457, 1421943457, 1220629152, 1220635202, 113338946, 314591328, 314591377,
+    1522539218, 1522619088, 1321286257, 1321286256, 1321286257, 213990098, 1220561040, 1321224768,
+    1220586048, 1321255536, 1220616242, 1321218674, 314646672, 1421943360, 1220629056, 1421875872,
+    113326704, 113319985, 213922368, 1220629153, 113319986, 1421955122, 1421949600, 213922466,
+    1220548656, 1321218144, 1421887632, 1522612272, 1522625233, 1522625233, 1421955744, 1421998752,
+    1421943457, 1421943457, 1421943457, 1220629152, 1220635202, 113338946, 314591328, 314591377,
+    1522539218, 1522619088, 1321286257, 1321286256, 1321286257, 213990098, 1220561040, 1321224768,
+    1220598336, 1321267824, 1220616242, 1321218674, 314646672, 1421943360, 1220629056, 1421875872,
+    113326704, 113319985, 213922368, 1220629153, 113319986, 1421955122, 1421949600, 213922466, 1220548656,
+    1321218144, 1421887632, 1522612272, 1522625233, 1522625233, 1421955744, 1421998752, 1421943457, 1421943457,
+    1421943457, 1220629152, 1220635202, 113338946, 314591328, 314591377, 1522539218, 1522619088, 1321286257,
+    1321286256, 1321286257, 213990098, 1119897744, 1220579616, 1321279536, 1421936832, 1220579904, 1220555328,
+    1119898128, 1119910416, 1421949602, 314609808, 314658960, 1522619040, 1421961888, 1119953426, 1321298544,
+    113314320, 113332274, 113326130, 113326130, 1220629056, 1321212530, 1321273968, 213983858, 1220684880,
+    1321347648, 1220586048, 1321255536, 1220616626, 1321267826, 616637520, 1421943360, 1220629056, 1421925024,
+    415316592, 415310017, 515961408, 1220629153, 415310018, 1421955266, 1421949600, 515930786, 1119947282,
+    1220561425, 1321280064, 1421943408, 1120021009, 1119947280, 1119947280, 1119953424, 1119947280, 1119947280,
+    1119959568, 1119947280, 1119947280, 1119965712, 1220610576, 113319984, 1220610624, 213983328, 918663600,
+    1019326944, 717336912, 818000256, 113399856, 214063200, 113246258, 113246258, 213909602, 213909602,
+    314726544, 314572946, 314572946, 113406385, 214069729, 314715361, 113406289, 214069633, 314715361,
+    918712657, 1019265026, 113406145, 214069489, 314610913, 1119928704, 1120033296, 1220585808,
+    1220586048, 1321249776, 1220622913, 1220678209, 1220696640, 1119953426, 1119879698, 1119879698,
+    12743473, 12743569, 2831328578, 2831162689, 415359168, 1119903936, 1220567568, 2730659090,
+    2730640657, 2730659088, 2730659088, 2730517776, 2730659088, 2730659088, 2730560784, 2730659088,
+    2730659088, 2730566928, 2831279424, 516022512, 2931942768, 516071664, 516077809, 2730523920,
+    2730646800, 2831310144, 2831273282, 2831273282, 2730609938, 2730609938, 2931942768, 1120003392,
+    113413488, 214075920, 113399856, 214063200, 113246258, 113246258, 213909602, 213909602, 113406001,
+    113246258, 113246258, 214081586, 2831162737, 415359168, 1120002288, 2931942720, 2931887472, 2931996866,
+    415389937, 2730671376, 2730646800, 2831273282, 2831273282, 2730609938, 2730609938, 113413441, 113246258,
+    113246258, 113424433, 113246258, 113246258, 214081586, 1120002576, 1220665920, 1321329264, 1220622912,
+    1119953425, 1120033296, 1119879698, 1119879698, 2168587266, 2168554497, 2168521728, 557908224, 3242230016,
+    3779102208, 2168587264, 2168587264, 2168488960, 2168587264, 2168587264, 2168652800, 2168587264, 2168587264,
+    2168685568, 2168554496, 2168456194, 2168456194, 2168686080, 1094779393, 1094779393, 1094779393, 1094779393,
+    1094779393, 1094779393, 1094779393, 1094779393, 1094779393, 1094779393, 1094779393, 1094779393, 1094779393,
+    1094779393, 1094779393, 1094779393, 1094779393, 1094779392, 3779135232, 3779135232, 3242264064, 558073345,
+    557875968, 557842690, 557842690, 1363231362, 1363231746, 3242279938, 3242264064, 1900086144, 2168571392,
+    2168554496, 2168456194, 2168456194, 2168587777, 2168686081, 2168456194, 2168686082, 2168456194, 3242264064,
+    3779135232, 2168686080, 2168554496, 2168456194, 2168456194, 409477153, 476602560, 543694882, 610828544,
+    677941474, 745029729, 812138594, 409493888, 543719776, 208175297, 208154720, 745046210, 812167520, 275272064,
+    73961696, 141075040, 141062209, 141074496, 409485409, 476602560, 543703138, 610828544, 677941474, 745021473,
+    812130338, 409493888, 543719776, 73957569, 73928736, 745046210, 812167520, 141054336, 208179424, 275292768,
+    275280001, 275292288, 342421664, 141041730, 74006593, 208162881, 275333185, 409493698, 476586177, 543715552,
+    610824448, 409551041, 409493696, 409493696, 409497792, 409493696, 409493696, 409501888, 409493696, 409493696,
+    409505984, 73949216, 74014752, 73924642, 73924642, 1216876576, 1283989568, 1351102560, 1351172737, 1418277441,
+    1485316129, 1485398720, 1485398690, 1216950850, 1284055681, 76100288, 143217216, 277435072, 210313824,
+    1216876610, 1284001986, 1216950848, 1283985473, 1351110849, 1284063840, 1351164514, 1418273377, 1216905344,
+    1216983616, 1216946753, 1284010080, 1284059745, 1485382242, 1216946785, 76112512, 143217216, 277435008,
+    210313920, 1216876576, 1283989568, 1351102560, 1351172737, 1418277441, 1485316129, 1485398720, 1485398690,
+    1216950850, 1284055681, 76100288, 143217216, 277435072, 210313824, 1216876610, 1284018498, 1216950848,
+    1283985473, 1351127361, 1284063840, 1351164514, 1418273377, 1216921728, 1216983616, 1216946753, 1284026464,
+    1284059745, 1485382242, 1216946785, 76112512, 143217216, 277435008, 210313920, 1216876576, 1283989568,
+    1351102560, 1351172737, 1418277441, 1485316129, 1485398720, 1485398690, 1216950850, 1284055681, 76100288,
+    143217216, 277435072, 210313824, 1216876610, 1284035010, 1216950848, 1283985473, 1351143873, 1284063840,
+    1351164514, 1418273377, 1216938112, 1216983616, 1216946753, 1284042848, 1284059745, 1485382242, 1216946785,
+    76112512, 143217216, 277435008, 210313920, 344555680, 411664576, 478802817, 545808544, 76043233, 143156193,
+    210269153, 277382113, 612914146, 680027105, 747140065, 814253026, 1216946754, 1283994177, 1351168608, 1418277504,
+    1216987713, 1216946752, 1216946752, 1216950848, 1216946752, 1216946752, 1216954944, 1216946752, 1216946752,
+    1216959040, 76095520, 76144672, 76021794, 76021794, 143204416, 143253568, 143130690, 143130690, 612991264,
+    680100160, 747238273, 814260512, 881426848, 948535744, 1015673729, 1082712480, 881382370, 1082721250,
+    1216909634, 1284035010, 1216950848, 1284018497, 1351143873, 1284063840, 1351164514, 1418273377, 1216938368,
+    1216983616, 1216946753, 1284043104, 1284059745, 1485382242, 1216946785, 344547968, 411652672, 545870464,
+    478749376, 76025890, 143246305, 210355169, 277364866, 9040609, 9040673, 1284088416, 1284088416, 1216979520,
+    2223583809, 2223641536, 2223506466, 2223506466, 1284088416, 1284088416, 1216979520, 2290692673, 2290754496,
+    2290615362, 2290615362, 2290721856, 2357830752, 2223612960, 2424972384, 2424968321, 2424956032, 2424833154,
+    2424833154, 2760475936, 2492110112, 2559161504, 2492056738, 2559165633, 1217029312, 1217028672, 1284055616,
+    1284137568, 1217024576, 1284133472, 1351168608, 1418277504, 1485398722, 1485423297, 1485398720, 1485398720,
+    1485386432, 1485398720, 1485398720, 1485390528, 1485398720, 1485398720, 1485394624, 1485382336, 1418289856,
+    1418355360, 1217024674, 2626319586, 2626249953, 2760500512, 1216995904, 2626282720, 1216873026, 1216873026,
+    2626159842, 2626159842, 1284133537, 1351189504, 2693350080, 1284104800, 2693391616, 1283981922, 1283981922,
+    2693268738, 2693268738, 2693427202, 2626286849, 2693431298, 881456353, 948565281, 2961831137, 3028940065,
+    2961802624, 2961716608, 3028911520, 3028825504, 76202018, 143315010, 76144672, 143253568, 76021794, 76021794,
+    143130690, 143130690};
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rom_lib.h b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rom_lib.h
new file mode 100644
index 0000000..055708d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rom_lib.h
@@ -0,0 +1,357 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2022. All rights reserved.
+ * Description: romlib instruction functions.
+ * Author: CompanyName
+ * Create: 2022-08-15
+*/
+
+#ifndef ROM_LIB_H
+#define ROM_LIB_H
+
+#include "crypto_pke_struct.h"
+
+/************************************************** ecc instr start************************************/
+
+extern const rom_lib instr_ecfp_j2a_pre_5;
+
+extern const rom_lib instr_ecfp_j2a_exp_00;
+
+extern const rom_lib instr_ecfp_j2a_exp_01;
+
+extern const rom_lib instr_ecfp_j2a_exp_10;
+
+extern const rom_lib instr_ecfp_j2a_exp_11;
+
+extern const rom_lib instr_ecfp_j2a_post_4;
+
+extern const rom_lib instr_ecfp_demont_c_6;
+
+extern const rom_lib instr_ecfp_demont_cz_3;
+
+extern const rom_lib instr_ecfp_mont_p_2;
+
+extern const rom_lib instr_ecfp_cpy_p2c_3;
+
+extern const rom_lib instr_ecfp_cpy_np2g_2;
+
+extern const rom_lib instr_ecfp_mul_p_22_18;
+
+extern const rom_lib instr_ecfp_mul_g_22_18;
+
+extern const rom_lib instr_ecfp_mul_c_double_22;
+
+extern const rom_lib instr_ecfp_prime_n_1;
+
+extern const rom_lib instr_ecfn_inv_pre_5;
+
+extern const rom_lib instr_ecfn_inv_exp_00;
+
+extern const rom_lib instr_ecfn_inv_exp_01;
+
+extern const rom_lib instr_ecfn_inv_exp_10;
+
+extern const rom_lib instr_ecfn_inv_exp_11;
+
+extern const rom_lib instr_ecfn_sign_s_12;
+
+extern const rom_lib instr_ecfn_verify_u_10;
+
+extern const rom_lib instr_ecfp_add_ja_verify_18;
+
+extern const rom_lib instr_ecfp_cpy_a2c_3;
+
+extern const rom_lib instr_ecfp_cpy_g2c_3;
+
+extern const rom_lib instr_ecfp_mul_jj_22_23;
+
+extern const rom_lib instr_ecfn_verify_v_4;
+
+/************************************************** ecc instr end************************************/
+
+/************************************************** sm2 instr start************************************/
+extern const rom_lib instr_sm2_sign_r_1;
+
+extern const rom_lib instr_sm2_sign_s_pre_6;
+
+extern const rom_lib instr_sm2_sign_s_post_6;
+
+extern const rom_lib instr_sm2_verify_t_3;
+/************************************************** sm2 instr end************************************/
+
+/************************************************** curve instr start************************************/
+#ifdef CONFIG_PKE_SUPPORT_CURVE
+extern const rom_lib instr_curve25519_pre_ladder;
+
+extern const rom_lib instr_curve25519_ladder_0;
+
+extern const rom_lib instr_curve25519_ladder_1;
+
+extern const rom_lib instr_curve25519_xz2x_pre;
+
+extern const rom_lib instr_curve25519_xz2x_exp_00;
+
+extern const rom_lib instr_curve25519_xz2x_exp_01;
+
+extern const rom_lib instr_curve25519_xz2x_exp_10;
+
+extern const rom_lib instr_curve25519_xz2x_exp_11;
+
+extern const rom_lib instr_curve25519_xz2x_post;
+#endif
+/************************************************** curve instr end************************************/
+
+/************************************************** ed instr start************************************/
+#ifdef CONFIG_PKE_SUPPORT_EDWARD
+extern const rom_lib instr_ed25519_mul_loop_0;
+
+extern const rom_lib instr_ed25519_mul_a_loop_1;
+
+extern const rom_lib instr_ed25519_mul_p_loop_1;
+
+extern const rom_lib instr_ed25519_mul_g_loop_1;
+
+extern const rom_lib instr_ed25519_mul_a_pre;
+
+extern const rom_lib instr_ed_ecfp_xyz2xy_pre;
+
+extern const rom_lib instr_ed_ecfp_xyz2xy_exp_00;
+
+extern const rom_lib instr_ed_ecfp_xyz2xy_exp_01;
+
+extern const rom_lib instr_ed_ecfp_xyz2xy_exp_10;
+
+extern const rom_lib instr_ed_ecfp_xyz2xy_exp_11;
+
+extern const rom_lib instr_ed_ecfp_xyz2xy_post;
+
+extern const rom_lib instr_ed25519_mul_sub_pre;
+
+extern const rom_lib instr_ed25519_calc_h;
+
+extern const rom_lib instr_ed25519_calc_s;
+
+extern const rom_lib instr_ed25519_recover_x_pre;
+
+extern const rom_lib instr_ed25519_recover_x_exp_00;
+
+extern const rom_lib instr_ed25519_recover_x_exp_01;
+
+extern const rom_lib instr_ed25519_recover_x_exp_10;
+
+extern const rom_lib instr_ed25519_recover_x_exp_11;
+
+extern const rom_lib instr_ed25519_recover_x_post;
+
+extern const rom_lib instr_ed25519_cpy_tx0_to_tx1;
+
+extern const rom_lib instr_ed25519_cpy_tx1_to_tx0;
+
+extern const rom_lib instr_ed25519_cpy_t2g;
+
+extern const rom_lib instr_ed25519_cpy_t2r;
+
+extern const rom_lib instr_ed25519_c_eq_r;
+#endif
+/************************************************** ed instr end************************************/
+
+/************************************************** rsa instr start************************************/
+extern const rom_lib instr_rsa_exp_pre_6;
+
+extern const rom_lib instr_rsa_exp_00;
+
+extern const rom_lib instr_rsa_exp_01;
+
+extern const rom_lib instr_rsa_exp_10;
+
+extern const rom_lib instr_rsa_exp_11;
+
+extern const rom_lib instr_rsa_exp_post_3;
+
+extern const rom_lib instr_rsa_regular_mul;
+
+extern const rom_lib instr_rsa_rrn_add;
+
+extern const rom_lib instr_rsa_rrn_add_3072;
+
+extern const rom_lib instr_rsa_rrn_add_320;
+
+extern const rom_lib instr_rsa_rrn_mul;
+
+extern const rom_lib instr_rsa_mod;
+
+extern const rom_lib instr_rsa_mod_add;
+
+extern const rom_lib instr_rsa_mod_sub;
+
+extern const rom_lib instr_rsa_mod_mul;
+/************************************************** rsa instr end************************************/
+
+/********************************************** ecc param storage space define start********************************/
+extern const td_u32 ecc_addr_m;
+extern const td_u32 ecc_addr_cx;
+extern const td_u32 ecc_addr_cy;
+extern const td_u32 ecc_addr_cz;
+extern const td_u32 ecc_addr_ax;
+extern const td_u32 ecc_addr_ay;
+extern const td_u32 ecc_addr_az;
+extern const td_u32 ecc_addr_px;
+extern const td_u32 ecc_addr_py;
+extern const td_u32 ecc_addr_gx;
+extern const td_u32 ecc_addr_gy;
+extern const td_u32 ecc_addr_t0;
+extern const td_u32 ecc_addr_t1;
+extern const td_u32 ecc_addr_t2;
+extern const td_u32 ecc_addr_t3;
+extern const td_u32 ecc_addr_t4;
+extern const td_u32 ecc_addr_tp;
+
+extern const td_u32 ecc_addr_p;
+extern const td_u32 ecc_addr_rrp;
+extern const td_u32 ecc_addr_n;
+extern const td_u32 ecc_addr_rrn;
+extern const td_u32 ecc_addr_mont_a;
+extern const td_u32 ecc_addr_mont_b;
+extern const td_u32 ecc_addr_mont_1_p;
+extern const td_u32 ecc_addr_mont_1_n;
+extern const td_u32 ecc_addr_const_1;
+extern const td_u32 ecc_addr_const_0;
+
+extern const td_u32 ecc_addr_s;
+extern const td_u32 ecc_addr_r;
+extern const td_u32 ecc_addr_e;
+
+extern const td_u32 ecc_addr_k;
+extern const td_u32 ecc_addr_d;
+
+extern const td_u32 ecc_addr_u1;
+extern const td_u32 ecc_addr_u2;
+
+extern const td_u32 ecc_addr_v;
+extern const td_u32 ecc_addr_rx;
+extern const td_u32 ecc_addr_t;
+/********************************************** ecc param storage space define end********************************/
+
+/*************************************** curve param storage space define start************************************/
+#ifdef CONFIG_PKE_SUPPORT_CURVE
+extern const td_u32 curve_addr_m;
+/* store results */
+extern const td_u32 curve_addr_x2;
+extern const td_u32 curve_addr_z2;
+/* store point coordinate temporarily */
+extern const td_u32 curve_addr_x3;
+extern const td_u32 curve_addr_z3;
+extern const td_u32 curve_addr_x1;
+
+/* store temporary variable */
+extern const td_u32 curve_addr_t0;
+extern const td_u32 curve_addr_t1;
+extern const td_u32 curve_addr_t2;
+extern const td_u32 curve_addr_t3;
+extern const td_u32 curve_addr_t4;
+extern const td_u32 curve_addr_t5;
+extern const td_u32 curve_addr_t6;
+extern const td_u32 curve_addr_tp;
+
+/* store the const value */
+extern const td_u32 curve_addr_p;
+extern const td_u32 curve_addr_rrp;
+extern const td_u32 curve_addr_n;
+extern const td_u32 curve_addr_rrn;
+extern const td_u32 curve_addr_mont_a;
+extern const td_u32 curve_addr_mont_a24;
+extern const td_u32 curve_addr_mont_1_p;
+extern const td_u32 curve_addr_mont_1_n;
+extern const td_u32 curve_addr_const_1;
+extern const td_u32 curve_addr_const_0;
+#endif
+/*************************************** curve param storage space define end************************************/
+
+/*************************************** eddsa param storage space define start************************************/
+#ifdef CONFIG_PKE_SUPPORT_EDWARD
+/* store modulus */
+extern const td_u32 ed_addr_m;
+/* store the result for point mulplication. */
+extern const td_u32 ed_addr_cx;
+extern const td_u32 ed_addr_cy;
+extern const td_u32 ed_addr_cz;
+extern const td_u32 ed_addr_ct;
+/* store point coordinate for temporary */
+extern const td_u32 ed_addr_ax;
+extern const td_u32 ed_addr_ay;
+extern const td_u32 ed_addr_az;
+extern const td_u32 ed_addr_at;
+/* store the input point */
+extern const td_u32 ed_addr_px;
+extern const td_u32 ed_addr_py;
+extern const td_u32 ed_addr_pz;
+extern const td_u32 ed_addr_pt;
+/* store the input point */
+extern const td_u32 ed_addr_gx;
+extern const td_u32 ed_addr_gy;
+extern const td_u32 ed_addr_gz;
+extern const td_u32 ed_addr_gt;
+
+/* store the tmeporary variable */
+extern const td_u32 ed_addr_tp;
+extern const td_u32 ed_addr_t0;
+extern const td_u32 ed_addr_t1;
+extern const td_u32 ed_addr_t2;
+extern const td_u32 ed_addr_t3;
+extern const td_u32 ed_addr_t4;
+
+/* store the const value */
+extern const td_u32 ed_addr_p;
+extern const td_u32 ed_addr_rrp;
+extern const td_u32 ed_addr_n;
+extern const td_u32 ed_addr_rrn;
+extern const td_u32 ed_addr_mont_d;
+extern const td_u32 ed_addr_mont_1_p;
+extern const td_u32 ed_addr_mont_1_n;
+extern const td_u32 ed_addr_const_1;
+extern const td_u32 ed_addr_const_0;
+extern const td_u32 ed_addr_sqrt_m1;
+
+/* store intermediate variable for sign */
+extern const td_u32 ed_addr_r;
+extern const td_u32 ed_addr_h;
+/* store private key for sign */
+extern const td_u32 ed_addr_sk;
+/* store result for signature */
+extern const td_u32 ed_addr_s;
+
+/* store temporary variable for verify */
+extern const td_u32 ed_addr_u;
+extern const td_u32 ed_addr_v;
+
+extern const td_u32 ed_addr_tx0;
+extern const td_u32 ed_addr_tx1;
+extern const td_u32 ed_addr_ty;
+extern const td_u32 ed_addr_bx;
+extern const td_u32 ed_addr_by;
+extern const td_u32 ed_addr_rx;
+extern const td_u32 ed_addr_ry;
+#endif
+/*************************************** eddsa param storage space define end************************************/
+
+/********************************************** rsa param storage space define start******************************/
+/* modulus storage space */
+extern const td_u32 rsa_addr_n;
+/* storage space for base number of the modular exponentiation */
+extern const td_u32 rsa_addr_a;
+/* storage sapce for montgomery parameter */
+extern const td_u32 rsa_addr_rr;
+/* storage sapce for constant value 1 */
+extern const td_u32 rsa_addr_const_1;
+/* storage sapce of result */
+extern const td_u32 rsa_addr_s;
+/* storage sapce for intermediate variable of CRT mode */
+extern const td_u32 rsa_addr_m2;
+extern const td_u32 rsa_addr_q_inv;
+/* storage sapce for common intermediate variable */
+extern const td_u32 rsa_addr_tp;
+/* storage sapce for input data */
+extern const td_u32 rsa_addr_t0;
+extern const td_u32 rsa_addr_t1;
+/********************************************** rsa param storage space define end******************************/
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rsa_data_ram_addr.c b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rsa_data_ram_addr.c
new file mode 100644
index 0000000..44296a2
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/pke_v5/rsa_data_ram_addr.c
@@ -0,0 +1,27 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2022. All rights reserved.
+ * Description: define the data store address of RSA in the PKE DRAM.
+ * Author: CompanyName
+ * Create: 2022-08-19
+*/
+
+#include "rom_lib.h"
+
+/* modulus storage space */
+const td_u32 rsa_addr_n  = 0;
+/* storage space for base number ofr the modular exponentiation */
+const td_u32 rsa_addr_a  = 16;
+/* storage sapce for montgomery parameter */
+const td_u32 rsa_addr_rr  = 32;
+/* storage sapce for constant value 1 */
+const td_u32 rsa_addr_const_1  = 48;
+/* storage sapce of result */
+const td_u32 rsa_addr_s  = 64;
+/* storage sapce for intermediate variable of CRT mode */
+const td_u32 rsa_addr_m2  = 40;
+const td_u32 rsa_addr_q_inv  = 56;
+/* storage sapce for common intermediate variable */
+const td_u32 rsa_addr_tp  = 80;
+/* storage sapce for input data */
+const td_u32 rsa_addr_t0  = 96;
+const td_u32 rsa_addr_t1  = 112;
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_hash.c b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_hash.c
new file mode 100755
index 0000000..b0deb9d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_hash.c
@@ -0,0 +1,699 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal hash. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "hal_hash.h"
+
+#include "crypto_drv_common.h"
+#include "hal_spacc_reg.h"
+
+#ifndef crypto_memory_barrier
+#define crypto_memory_barrier()
+#endif
+
+#define HASH_COMPAT_ERRNO(err_code)         HAL_COMPAT_ERRNO(ERROR_MODULE_HASH, err_code)
+
+typedef struct {
+    td_u32 hash_first_node : 1;
+    td_u32 hash_last_node : 1;
+    td_u32 reserved_0 : 30;       // reserve
+    td_u32 hash_alg_length;       // hash message length
+    td_u32 hash_start_addr_l;     // hash message address
+    td_u32 hash_start_addr_h : 4; // hash message address
+} hash_entry_in;
+
+typedef struct {
+    hash_entry_in *entry_in;    /* ! spacc digest in entry struct */
+    td_u32 idx_in;              /* !< current hash nodes to be used */
+    td_u32 idx_cnt;             /* !< total hash nodes */
+    td_bool is_last;
+    td_bool is_locked;
+    td_u32 block_size;
+#if defined(CONFIG_HASH_WAIT_FUNCTION_SUPPORT)
+    td_void *wait;
+    crypto_wait_timeout_interruptible wait_func;
+    td_bool done;
+    td_bool is_wait;
+    td_u32 timeout_ms;
+#endif
+} hal_hash_hard_chn_ctx;
+
+typedef enum {
+    HASH_CHN_ALG_SEL_SHA1   = 0xa,
+    HASH_CHN_ALG_SEL_SHA2   = 0xb,
+    HASH_CHN_ALG_SEL_SM3    = 0xc,
+} hash_chn_alg_sel_e;
+
+typedef enum {
+    HASH_CHN_ALG_MODE_224   = 0x0,
+    HASH_CHN_ALG_MODE_256   = 0x1,
+    HASH_CHN_ALG_MODE_384   = 0x2,
+    HASH_CHN_ALG_MODE_512   = 0x3,
+} hash_chn_alg_mode_e;
+
+#define CONFIG_HASH_NODE_DEPTH              2
+#define HASH_NODE_SIZE              (sizeof(hash_entry_in) * CONFIG_HASH_NODE_DEPTH)
+
+#if !defined(CONFIG_MMU_SUPPORT)
+static td_u8 g_node_buffer[HASH_NODE_SIZE * CONFIG_HASH_HARD_CHN_CNT];
+#else
+static td_u8 *g_node_buffer = TD_NULL;
+#endif
+
+static hal_hash_hard_chn_ctx g_hash_hard_ctx[CONFIG_HASH_HARD_CHN_CNT];
+static td_bool g_hal_hash_initialize = TD_FALSE;
+
+static void inner_hash_irq_enable(td_u32 chn_num, td_bool enable)
+{
+#if defined(CONFIG_HASH_WAIT_FUNCTION_SUPPORT)
+    td_u32 reg_val;
+
+    reg_val = spacc_reg_read(HASH_CHANN_RAW_INT_EN);
+    if (enable == TD_TRUE) {
+        reg_val |= (1 << chn_num);
+    } else {
+        reg_val &= ~(1 << chn_num);
+    }
+    spacc_reg_write(HASH_CHANN_RAW_INT_EN, reg_val);
+#endif
+    crypto_unused(chn_num);
+    crypto_unused(enable);
+}
+
+static td_s32 hal_hash_clear_channel(td_u32 chn_num)
+{
+    td_u32 i = 0;
+    td_u32 clear_finish_reg = 0;
+    td_u32 mask = 0x01 << chn_num;
+
+    /* disable int_en default. */
+    inner_hash_irq_enable(chn_num, TD_FALSE);
+
+    spacc_reg_write(SPACC_HASH_CHN_CLEAR_REQ, mask);
+    for (i = 0; i < CONFIG_HASH_CLEAR_CHN_TIMEOUT; i++) {
+        clear_finish_reg = spacc_reg_read(SPACC_INT_RAW_HASH_CLEAR_FINISH);
+        if ((mask & clear_finish_reg) != 0) {
+            spacc_reg_write(SPACC_INT_RAW_HASH_CLEAR_FINISH, mask);
+            break;
+        }
+        crypto_udelay(1);
+    }
+
+    if (i >= CONFIG_HASH_CLEAR_CHN_TIMEOUT) {
+#if defined(CONFIG_HASH_TIMEOUT_DEBUG)
+        hal_hash_debug();
+        hal_hash_debug_chn(chn_num);
+#endif
+        crypto_log_err("hash clear channel timeout\n");
+        return HASH_COMPAT_ERRNO(ERROR_HASH_CALC_TIMEOUT);
+    }
+
+    return TD_SUCCESS;
+}
+
+typedef struct {
+    crypto_hash_type type;
+    hash_chn_alg_mode_e mode;
+    hash_chn_alg_sel_e alg;
+    td_u32 state_size;
+} hal_hash_cfg_item;
+
+static hal_hash_cfg_item g_hash_cfg_item_list[] = {
+#if defined(CONFIG_HASH_SHA1_SUPPORT)
+    {
+        .type = CRYPTO_HASH_TYPE_SHA1, .mode = 0, .alg = HASH_CHN_ALG_SEL_SHA1, .state_size = HASH_STATE_SIZE_160
+    },
+#endif
+#if defined(CONFIG_HASH_SHA224_SUPPORT)
+    {
+        .type = CRYPTO_HASH_TYPE_SHA224, .mode = HASH_CHN_ALG_MODE_224,
+        .alg = HASH_CHN_ALG_SEL_SHA2, .state_size = HASH_STATE_SIZE_256
+    },
+#endif
+#if defined(CONFIG_HASH_SHA256_SUPPORT)
+    {
+        .type = CRYPTO_HASH_TYPE_SHA256, .mode = HASH_CHN_ALG_MODE_256,
+        .alg = HASH_CHN_ALG_SEL_SHA2, .state_size = HASH_STATE_SIZE_256
+    },
+#endif
+#if defined(CONFIG_HASH_SHA384_SUPPORT)
+    {
+        .type = CRYPTO_HASH_TYPE_SHA384, .mode = HASH_CHN_ALG_MODE_384,
+        .alg = HASH_CHN_ALG_SEL_SHA2, .state_size = HASH_STATE_SIZE_512
+    },
+#endif
+#if defined(CONFIG_HASH_SHA512_SUPPORT)
+    {
+        .type = CRYPTO_HASH_TYPE_SHA512, .mode = HASH_CHN_ALG_MODE_512,
+        .alg = HASH_CHN_ALG_SEL_SHA2, .state_size = HASH_STATE_SIZE_512
+    },
+#endif
+#if defined(CONFIG_HASH_SM3_SUPPORT)
+    {
+        .type = CRYPTO_HASH_TYPE_SM3, .mode = HASH_CHN_ALG_MODE_224,
+        .alg = HASH_CHN_ALG_SEL_SM3, .state_size = HASH_STATE_SIZE_256
+    },
+#endif
+};
+
+static td_s32 priv_hal_hash_get_cfg(crypto_hash_type hash_type, hash_chn_alg_mode_e *mode, hash_chn_alg_sel_e *alg,
+    td_u32 *state_size)
+{
+    td_u32 i;
+    crypto_hash_type type = crypto_hash_remove_hmac_flag(hash_type);
+    for (i = 0; i < crypto_array_size(g_hash_cfg_item_list); i++) {
+        if (g_hash_cfg_item_list[i].type == type) {
+            *mode = g_hash_cfg_item_list[i].mode;
+            *alg = g_hash_cfg_item_list[i].alg;
+            *state_size = g_hash_cfg_item_list[i].state_size;
+            return TD_SUCCESS;
+        }
+    }
+    crypto_log_err("Invalid Hash Mode!\n");
+    return HASH_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+
+td_s32 hal_cipher_hash_init(td_void)
+{
+    td_u32 i;
+    td_s32 ret = TD_FAILURE;
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+
+    if (g_hal_hash_initialize == TD_TRUE) {
+        return TD_SUCCESS;
+    }
+    (td_void)memset_s(g_hash_hard_ctx, sizeof(g_hash_hard_ctx), 0, sizeof(g_hash_hard_ctx));
+
+#if !!defined(CONFIG_MMU_SUPPORT)
+    g_node_buffer = crypto_malloc_mmz(HASH_NODE_SIZE * CONFIG_HASH_HARD_CHN_CNT, "crypto_hash_node_buffer");
+    if (g_node_buffer == TD_NULL) {
+        crypto_log_err("crypto_malloc_mmz failed\n");
+        return TD_FAILURE;
+    }
+#endif
+    for (i = 0; i < CONFIG_HASH_HARD_CHN_CNT; i++) {
+        hard_ctx = &g_hash_hard_ctx[i];
+        hard_ctx->entry_in = (hash_entry_in *)((uintptr_t)g_node_buffer + HASH_NODE_SIZE * i);
+        hard_ctx->idx_cnt = CONFIG_HASH_NODE_DEPTH;
+        hard_ctx->idx_in = 0;
+    }
+
+    g_hal_hash_initialize = TD_TRUE;
+
+    ret = TD_SUCCESS;
+    crypto_hal_func_exit();
+    return ret;
+}
+
+td_s32 hal_cipher_hash_deinit(td_void)
+{
+    td_u32 i;
+    td_s32 ret = TD_FAILURE;
+    td_u32 node_size = HASH_NODE_SIZE * CONFIG_HASH_HARD_CHN_CNT;
+    crypto_hal_func_enter();
+
+    if (g_hal_hash_initialize == TD_FALSE) {
+        return TD_SUCCESS;
+    }
+
+    for (i = 0; i < CONFIG_HASH_HARD_CHN_CNT; i++) {
+        hal_hash_unlock(i);
+    }
+    (td_void)memset_s(g_node_buffer, node_size, 0, node_size);
+#if !!defined(CONFIG_MMU_SUPPORT)
+    crypto_free_coherent(g_node_buffer);
+#endif
+    g_hal_hash_initialize = TD_FALSE;
+    ret = TD_SUCCESS;
+    crypto_hal_func_exit();
+    return ret;
+}
+
+#define HASH_SS_SECURE_VAL      0x5
+#define HASH_SS_NONSECURE_VAL    0xa
+
+td_s32 hal_hash_lock(td_u32 chn_num)
+{
+    td_s32 ret;
+    td_u32 used = 0;
+    td_u32 chnn_who_used = 0;
+    spacc_cpu_mask cpu_mask = SPACC_CPU_IDLE;
+    in_hash_chn_ctrl ctrl = { 0 };
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    td_u64 entry_in_phys_addr = 0;
+
+    crypto_hal_func_enter();
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    if (chn_num >= CONFIG_HASH_HARD_CHN_CNT || chn_num == 0) {
+        return TD_FAILURE;
+    }
+
+    hard_ctx = &g_hash_hard_ctx[chn_num];
+    if (crypto_get_cpu_type() == CRYPTO_CPU_TYPE_SCPU) {
+        cpu_mask = SPACC_CPU_TEE;
+    } else {
+        cpu_mask = SPACC_CPU_REE;
+    }
+
+    used = spacc_reg_read(SPACC_HASH_CHN_LOCK);
+
+    /* try to use this channel. */
+    chnn_who_used = CHN_WHO_USED_GET(used, chn_num);
+    crypto_chk_return_only(chnn_who_used != SPACC_CPU_IDLE, HASH_COMPAT_ERRNO(ERROR_CHN_BUSY));
+
+    CHN_WHO_USED_SET(used, chn_num, cpu_mask);
+    spacc_reg_write(SPACC_HASH_CHN_LOCK, used);
+
+    /* check if lock success. */
+    used = spacc_reg_read(SPACC_HASH_CHN_LOCK);
+    chnn_who_used = CHN_WHO_USED_GET(used, chn_num);
+    crypto_chk_return_only(chnn_who_used != cpu_mask, HASH_COMPAT_ERRNO(ERROR_CHN_BUSY));
+
+    /* clear hash channel. */
+    ret = hal_hash_clear_channel(chn_num);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_hash_clear_channel failed\n");
+    /* set secure cfg. */
+    ctrl.bits.hash_chn_en = 1;
+    if (crypto_get_cpu_type() == CRYPTO_CPU_TYPE_SCPU) {
+        ctrl.bits.hash_chn_ss = HASH_SS_SECURE_VAL;
+    } else {
+        ctrl.bits.hash_chn_ss = HASH_SS_NONSECURE_VAL;
+    }
+    spacc_reg_write(IN_HASH_CHN_CTRL(chn_num), ctrl.u32);
+
+    /* set node start addr and node length. */
+    entry_in_phys_addr = crypto_get_phys_addr(hard_ctx->entry_in);
+    spacc_reg_write(IN_HASH_CHN_NODE_START_ADDR_L(chn_num), crypto_addr_l(entry_in_phys_addr));
+    spacc_reg_write(IN_HASH_CHN_NODE_START_ADDR_H(chn_num), crypto_addr_h(entry_in_phys_addr));
+    spacc_reg_write(IN_HASH_CHN_NODE_LENGTH(chn_num), CONFIG_HASH_NODE_DEPTH);
+
+    hal_cipher_hash_done_try(chn_num);
+
+    hard_ctx->idx_in = 0;
+    hard_ctx->is_locked = TD_TRUE;
+    (td_void)memset_s(hard_ctx->entry_in, HASH_NODE_SIZE, 0, HASH_NODE_SIZE);
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_hash_unlock(td_u32 chn_num)
+{
+    td_u32 used;
+    crypto_hal_func_enter();
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    used = spacc_reg_read(SPACC_HASH_CHN_LOCK);
+    CHN_WHO_USED_CLR(used, chn_num);
+    spacc_reg_write(SPACC_HASH_CHN_LOCK, used);
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_hash_config(td_u32 chn_num, crypto_hash_type hash_type, const td_u32 *state)
+{
+    td_s32 ret;
+    td_u32 i;
+    in_hash_chn_key_ctrl hash_key_ctrl = { 0 };
+    hash_chn_alg_mode_e mode;
+    hash_chn_alg_sel_e alg;
+    td_u32 state_size;
+    crypto_hal_func_enter();
+
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+    crypto_param_require(chn_num < CONFIG_HASH_HARD_CHN_CNT);
+    crypto_param_require(state != TD_NULL);
+
+    ret = priv_hal_hash_get_cfg(hash_type, &mode, &alg, &state_size);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_hal_hash_get_cfg failed\n");
+
+    hash_key_ctrl.u32 = spacc_reg_read(IN_HASH_CHN_KEY_CTRL(chn_num));
+    hash_key_ctrl.bits.hash_chn_alg_mode = mode;
+    hash_key_ctrl.bits.hash_chn_alg_sel = alg;
+    spacc_reg_write(IN_HASH_CHN_KEY_CTRL(chn_num), hash_key_ctrl.u32);
+
+    /* Write last state */
+    for (i = 0; i < state_size / CRYPTO_WORD_WIDTH; i++) {
+        spacc_reg_write(CHANN_HASH_STATE_VAL_ADDR(chn_num), i);
+        spacc_reg_write(CHANN_HASH_STATE_VAL(chn_num), state[i]);
+    }
+
+    g_hash_hard_ctx[chn_num].block_size = crypto_hash_get_block_size(hash_type) / CRYPTO_BITS_IN_BYTE;
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_hash_attach(td_u32 chn_num, td_u32 keyslot_chn_num)
+{
+    in_hash_chn_key_ctrl hash_key_ctrl = { 0 };
+    crypto_hal_func_enter();
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    hash_key_ctrl.u32 = spacc_reg_read(IN_HASH_CHN_KEY_CTRL(chn_num));
+    hash_key_ctrl.bits.hash_key_chn_id = keyslot_chn_num;
+    hash_key_ctrl.bits.hmac_vld = 1;
+    spacc_reg_write(IN_HASH_CHN_KEY_CTRL(chn_num), hash_key_ctrl.u32);
+    crypto_hal_func_exit();
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 hal_cipher_hash_add_in_node(td_u32 chn_num, td_u64 data_phys, td_u32 data_len,
+    in_node_type_e in_node_type)
+{
+    td_u32 idx;
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    hash_entry_in *entry_in = TD_NULL;
+    crypto_hal_func_enter();
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    crypto_chk_return(data_phys == 0, HASH_COMPAT_ERRNO(ERROR_INVALID_PHYS_ADDR), "data_phys is invalid\n");
+    crypto_chk_return(data_phys % CONFIG_SPACC_ADDR_ALIGN_LEN != 0, HASH_COMPAT_ERRNO(ERROR_HASH_ADDR_NOT_ALIGNED),
+        "data_phys must be aligned to %u-byte\n", CONFIG_SPACC_ADDR_ALIGN_LEN);
+    hard_ctx = &g_hash_hard_ctx[chn_num];
+
+    crypto_chk_return(hard_ctx->block_size == 0, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "block_size is zero!\n");
+    crypto_chk_return(data_len % hard_ctx->block_size != 0, HASH_COMPAT_ERRNO(ERROR_HASH_LEN_NOT_ALIGNED),
+        "data_len must be aligned to block size\n");
+
+    idx = hard_ctx->idx_in++;
+    hard_ctx->idx_in %= hard_ctx->idx_cnt;
+
+    /* clear entry_in. */
+    entry_in = &hard_ctx->entry_in[idx];
+    (td_void)memset_s(entry_in, sizeof(hash_entry_in), 0, sizeof(hash_entry_in));
+
+    /* set addr and length. */
+    entry_in->hash_first_node = ((in_node_type & IN_NODE_TYPE_FIRST) == 0) ? 0 : 1;
+    entry_in->hash_last_node = ((in_node_type & IN_NODE_TYPE_LAST) == 0) ? 0 : 1;
+    entry_in->hash_start_addr_l = data_phys;
+    entry_in->hash_start_addr_h = crypto_addr_h(data_phys);
+    entry_in->hash_alg_length = data_len;
+
+    if ((in_node_type & IN_NODE_TYPE_LAST) != 0) {
+        hard_ctx->is_last = TD_TRUE;
+    } else {
+        hard_ctx->is_last = TD_FALSE;
+    }
+
+    crypto_hal_func_exit();
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 hal_cipher_hash_start(td_u32 chn_num, td_bool is_wait)
+{
+    td_u32 ptr;
+    in_hash_chn_node_wr_point in_node_wr_ptr;
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    crypto_unused(is_wait);
+    hard_ctx = &g_hash_hard_ctx[chn_num];
+
+#if defined(CONFIG_HASH_WAIT_FUNCTION_SUPPORT)
+    if (hard_ctx->wait_func != TD_NULL && is_wait) {
+        hard_ctx->done = TD_FALSE;
+        hard_ctx->is_wait = TD_TRUE;
+        inner_hash_irq_enable(chn_num, TD_TRUE);
+    }
+#endif
+
+    /* configure in-node, only compute one nodes */
+    in_node_wr_ptr.u32 = spacc_reg_read(IN_HASH_CHN_NODE_WR_POINT(chn_num));
+
+    ptr = in_node_wr_ptr.bits.hash_chn_node_wr_point + 1;
+    in_node_wr_ptr.bits.hash_chn_node_wr_point = ptr % hard_ctx->idx_cnt;
+
+    /* make sure all the above explicit memory accesses and instructions are completed
+     * before start the hardware.
+     */
+    crypto_memory_barrier();
+    crypto_cache_flush((uintptr_t)hard_ctx->entry_in, HASH_NODE_SIZE);
+    crypto_cache_all();
+    /* Start */
+    spacc_reg_write(IN_HASH_CHN_NODE_WR_POINT(chn_num), in_node_wr_ptr.u32);
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+#if defined(CONFIG_HASH_WAIT_FUNCTION_SUPPORT)
+static td_bool hal_hash_condition(const td_void *param)
+{
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    td_u32 chn_num = *(td_u32 *)param;
+
+    hard_ctx = &g_hash_hard_ctx[chn_num];
+    if (hard_ctx->done == TD_TRUE) {
+        hard_ctx->done = TD_FALSE;
+        return TD_TRUE;
+    } else {
+        return TD_FALSE;
+    }
+}
+#endif
+
+static td_s32 inner_hash_wait_chain_done(td_u32 chn_num, hal_hash_hard_chn_ctx *hard_ctx)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 i;
+
+    crypto_unused(hard_ctx);
+#if defined(CONFIG_HASH_WAIT_FUNCTION_SUPPORT)
+    if ((hard_ctx->is_wait == TD_TRUE) && (hard_ctx->wait_func != TD_NULL)) {
+        ret = hard_ctx->wait_func(hard_ctx->wait, hal_hash_condition, (td_void *)(&chn_num), hard_ctx->timeout_ms);
+        if (ret <= 0) {
+            crypto_log_err("wait_func Timeout!\n");
+            return HASH_COMPAT_ERRNO(ERROR_HASH_CALC_TIMEOUT);
+        }
+        return TD_SUCCESS;
+    }
+#endif
+
+    for (i = 0; i < CONFIG_HASH_CALC_TIMEOUT; i++) {
+        if (hal_cipher_hash_done_try(chn_num) != 0) {
+            break;
+        }
+        crypto_udelay(1);
+    }
+    if (i >= CONFIG_HASH_CALC_TIMEOUT) {
+        crypto_log_err("hash wait done timeout, chn=%d\n", chn_num);
+        ret = HASH_COMPAT_ERRNO(ERROR_HASH_CALC_TIMEOUT);
+    }
+
+    return ret;
+}
+
+static td_s32 inner_hash_wait_node_done(td_u32 chn_num)
+{
+    td_u32 i;
+    td_u32 unproc_data_len = 0;
+    in_hash_chn_node_wr_point hash_wr_ptr = { 0 };
+    in_hash_chn_node_rd_point hash_rd_ptr = { 0 };
+
+    for (i = 0; i < CONFIG_HASH_CALC_TIMEOUT; i++) {
+        hash_rd_ptr.u32 = spacc_reg_read(IN_HASH_CHN_NODE_RD_POINT(chn_num));
+        hash_wr_ptr.u32 = spacc_reg_read(IN_HASH_CHN_NODE_WR_POINT(chn_num));
+        if (hash_rd_ptr.u32 == hash_wr_ptr.u32) {
+            break;
+        }
+        crypto_udelay(1);
+    }
+
+    if (i >= CONFIG_HASH_CALC_TIMEOUT) {
+        return HASH_COMPAT_ERRNO(ERROR_HASH_CALC_TIMEOUT);
+    }
+
+    // After the value of the read pointer is increased by 1, wait a microsecond to ensure that the
+    // value of IN_HASH_CHN_DATA_LEN is switched from 0 to the actual unprocessed data length.
+    crypto_udelay(1);
+    for (i = 0; i < CONFIG_HASH_CALC_TIMEOUT; i++) {
+        unproc_data_len = spacc_reg_read(IN_HASH_CHN_DATA_LEN(chn_num));
+        if (unproc_data_len == 0) {
+            break;
+        }
+        crypto_udelay(1);
+    }
+    if (i >= CONFIG_HASH_CALC_TIMEOUT) {
+        return HASH_COMPAT_ERRNO(ERROR_HASH_CALC_TIMEOUT);
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 hal_cipher_hash_wait_done(td_u32 chn_num, td_u32 *state, td_u32 state_size)
+{
+    td_u32 i;
+    td_s32 ret = TD_SUCCESS;
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    hard_ctx = &g_hash_hard_ctx[chn_num];
+
+    if (hard_ctx->is_last) {
+        ret = inner_hash_wait_chain_done(chn_num, hard_ctx);
+    } else {
+        ret = inner_hash_wait_node_done(chn_num);
+    }
+    inner_hash_irq_enable(chn_num, TD_FALSE);
+    if (ret == HASH_COMPAT_ERRNO(ERROR_HASH_CALC_TIMEOUT)) {
+#if defined(CONFIG_HASH_TIMEOUT_DEBUG)
+        hal_hash_debug();
+        hal_hash_debug_chn(chn_num);
+#endif
+    } else {
+        ret = CRYPTO_SUCCESS;
+    }
+
+    /* read hash result */
+    if (state != TD_NULL) {
+        for (i = 0; i < state_size / CRYPTO_WORD_WIDTH; i++) {
+            spacc_reg_write(CHANN_HASH_STATE_VAL_ADDR(chn_num), i);
+            state[i] = spacc_reg_read(CHANN_HASH_STATE_VAL(chn_num));
+        }
+    }
+
+    crypto_hal_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_HASH_WAIT_FUNCTION_SUPPORT)
+td_s32 hal_cipher_hash_register_wait_func(td_u32 chn_num, td_void *wait,
+    crypto_wait_timeout_interruptible wait_func, td_u32 timeout_ms)
+{
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    hard_ctx = &g_hash_hard_ctx[chn_num];
+    hard_ctx->wait = wait;
+    hard_ctx->wait_func = wait_func;
+    hard_ctx->timeout_ms = timeout_ms;
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_hash_done_notify(td_u32 chn_num)
+{
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    hard_ctx = &g_hash_hard_ctx[chn_num];
+    hard_ctx->done = TD_TRUE;
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+#endif
+
+td_u32 hal_cipher_hash_done_try(td_u32 chn_num)
+{
+    hash_chann_raw_int hash_fin_int_raw = { 0 };
+    crypto_param_require(g_hal_hash_initialize == TD_TRUE);
+
+    hash_fin_int_raw.u32 = spacc_reg_read(HASH_CHANN_RAW_INT);
+    hash_fin_int_raw.u32 &= (0x01 << chn_num);
+    spacc_reg_write(HASH_CHANN_RAW_INT, hash_fin_int_raw.u32);
+
+    return hash_fin_int_raw.u32;
+}
+
+#if defined(CONFIG_HASH_TIMEOUT_DEBUG)
+td_void hal_hash_debug(td_void)
+{
+    td_u32 i;
+    td_u32 chnn_who_used;
+    td_u32 used;
+    crypto_hal_func_enter();
+
+    used = spacc_reg_read(SPACC_HASH_CHN_LOCK);
+
+    crypto_print("Current Cpu Type is %s\n", crypto_get_cpu_type() == CRYPTO_CPU_TYPE_SCPU ? "SCPU" : "ACPU");
+    crypto_print("The Status of Hash Hard Channel:\n");
+    for (i = 0; i < CONFIG_HASH_HARD_CHN_CNT; i++) {
+        chnn_who_used = CHN_WHO_USED_GET(used, i);
+        if (chnn_who_used == SPACC_CPU_REE) {
+            crypto_print("CHN %d is locked by REE CPU\n", i);
+        } else if (chnn_who_used == SPACC_CPU_TEE) {
+            crypto_print("CHN %d is locked by TEE CPU\n", i);
+        } else {
+            crypto_print("CHN %d is idle\n", i);
+        }
+    }
+    crypto_print("HASH_CHANN_RAW_INT is 0x%x\n", spacc_reg_read(HASH_CHANN_RAW_INT));
+    crypto_print("HASH_CHANN_RAW_INT_EN is 0x%x\n", spacc_reg_read(HASH_CHANN_RAW_INT_EN));
+
+    crypto_print("TEE_HASH_CALC_CTRL_CHECK_ERR is 0x%x\n", spacc_reg_read(TEE_HASH_CALC_CTRL_CHECK_ERR));
+    crypto_print("TEE_HASH_CALC_CTRL_CHECK_ERR_STATUS is 0x%x\n", spacc_reg_read(TEE_HASH_CALC_CTRL_CHECK_ERR_STATUS));
+
+    crypto_print("REE_HASH_CALC_CTRL_CHECK_ERR is 0x%x\n", spacc_reg_read(REE_HASH_CALC_CTRL_CHECK_ERR));
+    crypto_print("REE_HASH_CALC_CTRL_CHECK_ERR_STATUS is 0x%x\n", spacc_reg_read(REE_HASH_CALC_CTRL_CHECK_ERR_STATUS));
+
+    crypto_hal_func_exit();
+}
+
+td_void hal_hash_debug_chn(td_u32 chn_num)
+{
+    td_u32 i;
+    hal_hash_hard_chn_ctx *hard_ctx = TD_NULL;
+    hash_entry_in *entry_in = TD_NULL;
+    crypto_hal_func_enter();
+
+    crypto_unused(entry_in);
+    if (chn_num >= CONFIG_HASH_HARD_CHN_CNT) {
+        crypto_log_err("Invalid chn_num!\n");
+        return;
+    }
+
+    hard_ctx = &g_hash_hard_ctx[chn_num];
+
+    crypto_print("The Status of Hash Hard Channel %d:\n", chn_num);
+    crypto_print("IN_HASH_CHN_CTRL is 0x%x\n", spacc_reg_read(IN_HASH_CHN_CTRL(chn_num)));
+    crypto_print("IN_HASH_CHN_KEY_CTRL is 0x%x\n", spacc_reg_read(IN_HASH_CHN_KEY_CTRL(chn_num)));
+    crypto_print("IN_HASH_CHN_NODE_LENGTH: 0x%x\n", spacc_reg_read(IN_HASH_CHN_NODE_LENGTH(chn_num)));
+    crypto_print("IN_HASH_CHN_NODE_START_ADDR_L: 0x%x\n", spacc_reg_read(IN_HASH_CHN_NODE_START_ADDR_L(chn_num)));
+    crypto_print("IN_HASH_CHN_NODE_START_ADDR_H: 0x%x\n", spacc_reg_read(IN_HASH_CHN_NODE_START_ADDR_H(chn_num)));
+
+    crypto_print("IN_HASH_CHN_NODE_WR_POINT: 0x%x\n", spacc_reg_read(IN_HASH_CHN_NODE_WR_POINT(chn_num)));
+    crypto_print("IN_HASH_CHN_NODE_RD_POINT: 0x%x\n", spacc_reg_read(IN_HASH_CHN_NODE_RD_POINT(chn_num)));
+
+    crypto_print("entry_in's virtual addr is %p, physical addr is 0x%lx\n", hard_ctx->entry_in,
+        (td_ulong)crypto_get_phys_addr(hard_ctx->entry_in));
+    crypto_print("Total Entry Count is %u, Current Entry IDX is %u\n", hard_ctx->idx_cnt, hard_ctx->idx_in);
+#if defined(CONFIG_HASH_WAIT_FUNCTION_SUPPORT)
+    if (hard_ctx->wait_func != TD_NULL) {
+        crypto_print("Register Wait Func, timeout is %u ms, done flag is %s\n", hard_ctx->timeout_ms, hard_ctx->done ?
+            "TD_TRUE" : "TD_FALSE");
+    }
+#endif
+    /* Print Entry_In. */
+    for (i = 0; i < CONFIG_HASH_NODE_DEPTH; i++) {
+        crypto_print("Entry_IN[%u]:\n", i);
+        entry_in = &hard_ctx->entry_in[i];
+        crypto_print("hash_first_node is 0x%x\n", entry_in->hash_first_node);
+        crypto_print("hash_last_node is 0x%x\n", entry_in->hash_last_node);
+        crypto_print("hash_alg_length is 0x%x\n", entry_in->hash_alg_length);
+        crypto_print("hash_start_addr_l is 0x%x\n", entry_in->hash_start_addr_l);
+        crypto_print("hash_start_addr_h is 0x%x\n", entry_in->hash_start_addr_h);
+    }
+
+    /* Print last state */
+    for (i = 0; i < CRYPTO_HASH_RESULT_SIZE_MAX_IN_WORD; i++) {
+        spacc_reg_write(CHANN_HASH_STATE_VAL_ADDR(chn_num), i);
+        crypto_print("CHANn_HASH_STATE_VAL[%d] is 0x%x\n", i, spacc_reg_read(CHANN_HASH_STATE_VAL(chn_num)));
+    }
+    crypto_hal_func_exit();
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_spacc_inner.h b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_spacc_inner.h
new file mode 100644
index 0000000..1c9bd50
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_spacc_inner.h
@@ -0,0 +1,62 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal spacc register header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_SPACC_INNER_H
+#define HAL_SPACC_INNER_H
+
+#include "crypto_type.h"
+
+/* current cpu */
+#define SPACC_CPU_CUR ((crypto_get_cpu_type() == CRYPTO_CPU_TYPE_SCPU) ? SPACC_CPU_TEE : SPACC_CPU_REE)
+
+#define SYMC_COMPAT_ERRNO(err_code)         HAL_COMPAT_ERRNO(ERROR_MODULE_SYMC, err_code)
+
+/* ! \Numbers of nodes list */
+#define CRYPTO_SYMC_MAX_LIST_NUM            2
+
+/* ! spacc symc int entry struct which is defined by hardware, you can't change it */
+typedef struct {
+    td_u32 sym_first_node : 1;         /* !<  Indicates whether the node is the first node */
+    td_u32 sym_last_node : 1;          /* !<  Indicates whether the node is the last node */
+    td_u32 rev1 : 7;                   /* !<  reserve */
+    td_u32 odd_even : 1;               /* !<  Indicates whether the key is an odd key or even key */
+    td_u32 rev2 : 22;                  /* !<  reserve */
+    td_u32 sym_alg_length;             /* !<  symc data length */
+    td_u32 sym_start_addr;             /* !<  symc start low addr */
+    td_u32 sym_start_high;             /* !<  symc start high addr */
+    td_u32 iv[CRYPTO_AES_IV_SIZE_IN_WORD]; /* !<  symc IV */
+} crypto_symc_entry_in;
+
+/* ! spacc symc out entry struct which is defined by hardware, you can't change it */
+typedef struct {
+    td_u32 rev1;           /* !<  reserve */
+    td_u32 sym_alg_length; /* !<  syma data length */
+    td_u32 sym_start_addr; /* !<  syma start low addr */
+    td_u32 sym_start_high; /* !<  syma start high addr */
+} crypto_symc_entry_out;
+
+typedef struct {
+    crypto_symc_entry_in *entry_in;
+    crypto_symc_entry_out *entry_out;
+    td_u32 idx_in;
+    td_u32 idx_out;
+    td_u32 cnt_in;
+    td_u32 cnt_out;
+    td_void *wait;
+    crypto_wait_timeout_interruptible wait_func;
+    td_bool done;
+    td_bool is_wait;
+    td_u32 timeout_ms;
+    hal_symc_config_t symc_config;
+} crypto_symc_hard_context;
+
+crypto_symc_hard_context *inner_hal_get_symc_ctx(td_u32 chn_num);
+
+td_s32 hal_cipher_symc_wait_noout_done(td_u32 chn_num);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_spacc_reg.h b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_spacc_reg.h
new file mode 100644
index 0000000..c877127
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_spacc_reg.h
@@ -0,0 +1,683 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal spacc register header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_HASH_REG_H
+#define HAL_HASH_REG_H
+
+#define SYMC_ALG_AES_VAL        0x2
+#define SYMC_ALG_SM4_VAL        0x5
+#define SYMC_ALG_GHASH_VAL      0x6
+
+#define SYMC_ALG_MODE_ECB_VAL           0x1
+#define SYMC_ALG_MODE_CBC_VAL           0x3
+#define SYMC_ALG_MODE_CTR_VAL           0x6
+#define SYMC_ALG_MODE_OFB_VAL           0x7
+#define SYMC_ALG_MODE_CFB_VAL           0x8
+#define SYMC_ALG_MODE_GCTR_VAL          0xb
+#define SYMC_ALG_MODE_CMAC_VAL          0xc
+#define SYMC_ALG_MODE_CBC_NOOUT_VAL     0xd
+#define SYMC_ALG_MODE_GCTR_NOOUT_VAL    0xe
+
+typedef enum {
+    SPACC_CPU_IDLE = 0x00000000,
+    SPACC_CPU_REE = 0x00000001,
+    SPACC_CPU_TEE = 0x00000002,
+    SPACC_CPU_PCPU = 0x00000004,
+    SPACC_CPU_AIDSP = 0x00000005,
+    SPACC_CPU_INVALID = 0xffffffff
+} spacc_cpu_mask;
+
+#define SPACC_CALC_CRG_CFG                  (0x8030)
+
+#define SPACC_IE                            (0x00000004)
+
+#define CHN_WHO_USED_CLR(used, chn)      (used) &= ~(0x0fU << ((chn) * 4U))
+#define CHN_WHO_USED_SET(used, chn, who) (used) |= (td_u32)(who) << ((td_u32)(chn) * 4U)
+#define CHN_WHO_USED_GET(used, chn)      ((((used) >> ((chn) * 4U))) & 0x0fU)
+
+/*! \Define the offset of HASH reg */
+#define SPACC_HASH_CHN_LOCK                        0x0040
+#define SPACC_HASH_CHN_CLEAR_REQ                   0x0068
+#define SPACC_INT_RAW_HASH_CLEAR_FINISH            0x0014
+#define CHANN_HASH_STATE_VAL_ADDR(id)              (0xa004 + (id) * 0x80)
+#define CHANN_HASH_STATE_VAL(id)                   (0xa000 + (id) * 0x80)
+#define IN_HASH_CHN_CTRL(id)                       (0x5100 + ((id) - 1) * 0x100)
+#define IN_HASH_CHN_KEY_CTRL(id)                   (0x5110 + ((id) - 1) * 0x100)
+#define IN_HASH_CHN_NODE_START_ADDR_H(id)          (0x5120 + ((id) - 1) * 0x100)
+#define IN_HASH_CHN_NODE_START_ADDR_L(id)          (0x5124 + ((id) - 1) * 0x100)
+#define IN_HASH_CHN_NODE_LENGTH(id)                (0x512c + ((id) - 1) * 0x100)
+#define IN_HASH_CHN_NODE_WR_POINT(id)              (0x5130 + ((id) - 1) * 0x100)
+#define IN_HASH_CHN_NODE_RD_POINT(id)              (0x5134 + ((id) - 1) * 0x100)
+#define IN_HASH_CHN_DATA_LEN(id)                   (0x51C0 + ((id) - 1) * 0x100)
+#define HASH_CHANN_RAW_INT                         0x8600
+#define HASH_CHANN_RAW_INT_EN                      0x8604
+#define TEE_HASH_CALC_CTRL_CHECK_ERR               0x8068
+#define TEE_HASH_CALC_CTRL_CHECK_ERR_STATUS        0x806c
+#define REE_HASH_CALC_CTRL_CHECK_ERR               0x8078
+#define REE_HASH_CALC_CTRL_CHECK_ERR_STATUS        0x807c
+#define PCPU_HASH_CALC_CTRL_CHECK_ERR              0x8088
+#define PCPU_HASH_CALC_CTRL_CHECK_ERR_STATUS       0x808c
+#define AIDSP_HASH_CALC_CTRL_CHECK_ERR             0x8098
+#define AIDSP_HASH_CALC_CTRL_CHECK_ERR_STATUS      0x809c
+
+#define SYM_CALC_CTRL_CHECK_ERR(cpu)        (0x8000 + 0x80 - (cpu) * 0x10)
+
+#define ENCRYPT 0x5A
+#define DECRYPT 0xA5
+
+/* ! \Define the offset of Cipher reg */
+#define SPACC_SYM_CHN_LOCK                    0x0020
+#define SPACC_INT_RAW_SYM_CLEAR_FINISH        0x0008
+#define SPACC_EN_INT_RAW_SYM_CLEAR_FINISH     0x000c
+#define SPACC_SYM_CHN_CLEAR_REQ               0x0060
+#define SPACC_BUS_ERR                         0x0200
+#define IN_SYM_CHN_CTRL(id)                   (0x4100 + ((id) - 1) * 0x100)
+#define IN_SYM_OUT_CTRL(id)                   (0x4104 + ((id) - 1) * 0x100)
+#define IN_SYM_CHN_KEY_CTRL(id)               (0x4110 + ((id) - 1) * 0x100)
+#define IN_SYM_CHN_NODE_START_ADDR_H(id)      (0x4120 + ((id) - 1) * 0x100)
+#define IN_SYM_CHN_NODE_START_ADDR_L(id)      (0x4124 + ((id) - 1) * 0x100)
+#define IN_SYM_CHN_NODE_LENGTH(id)            (0x412c + ((id) - 1) * 0x100)
+#define IN_SYM_CHN_NODE_WR_POINT(id)          (0x4130 + ((id) - 1) * 0x100)
+#define IN_SYM_CHN_NODE_RD_POINT(id)          (0x4134 + ((id) - 1) * 0x100)
+#define IN_SYM_CHN_NODE_CTRL(id)              (0x4140 + ((id) - 1) * 0x100)
+#define DBG_IN_SYM_CHN_RD_ADDR_H(id)          (0x41a0 + ((id) - 1) * 0x100)
+#define DBG_IN_SYM_CHN_RD_ADDR_L(id)          (0x41a4 + ((id) - 1) * 0x100)
+#define DBG_IN_SYM_CHN_DATA_LEN(id)           (0x41c0 + ((id) - 1) * 0x100)
+
+#define TEE_SYM_CALC_CTRL_CHECK_ERR           0x8060
+#define TEE_SYM_CALC_CTRL_CHECK_ERR_STATUS    0x8064
+#define REE_SYM_CALC_CTRL_CHECK_ERR           0x8070
+#define REE_SYM_CALC_CTRL_CHECK_ERR_STATUS    0x8074
+#define PCPU_SYM_CALC_CTRL_CHECK_ERR          0x8080
+#define PCPU_SYM_CALC_CTRL_CHECK_ERR_STATUS   0x8084
+#define AIDSP_SYM_CALC_CTRL_CHECK_ERR         0x8090
+#define AIDSP_SYM_CALC_CTRL_CHECK_ERR_STATUS  0x8094
+
+#define SYM_CHANN_RAW_INT     0x8610
+#define SYM_CHANN_RAW_INT_EN  0x8614
+#define SYM_CHANN_INT         0x8618
+
+#define CHANN_CIPHER_IVOUT(id)             (0x9000 + (id) * 0x80)
+#define CHANN_CIPHER_DFA_EN(id)            (0x9020 + (id) * 0x80)
+
+#define OUT_SYM_CHAN_RAW_LAST_NODE_INT     0xc000
+#define OUT_SYM_CHAN_RAW_LAST_NODE_INT_EN  0xc004
+#define OUT_SYM_CHAN_LAST_NODE_INT         0xc008
+#define OUT_SYM_CHAN_RAW_LEVEL_INT         0xc010
+#define OUT_SYM_CHAN_RAW_LEVEL_INT_EN      0xc014
+#define OUT_SYM_CHAN_LEVEL_INT             0xc018
+
+#define OUT_SYM_CHN_STATUS(id)                (0xD004 + ((id) - 1) * 0x100)
+#define OUT_SYM_CHN_NODE_START_ADDR_H(id)     (0xD020 + ((id) - 1) * 0x100)
+#define OUT_SYM_CHN_NODE_START_ADDR_L(id)     (0xD024 + ((id) - 1) * 0x100)
+#define OUT_SYM_CHN_NODE_LENGTH(id)           (0xD028 + ((id) - 1) * 0x100)
+#define OUT_SYM_CHN_NODE_WR_POINT(id)         (0xD030 + ((id) - 1) * 0x100)
+#define OUT_SYM_CHN_NODE_RD_POINT(id)         (0xD034 + ((id) - 1) * 0x100)
+#define OUT_SYM_CHN_NODE_CTRL(id)             (0xD040 + ((id) - 1) * 0x100)
+#define DBG_OUT_SYM_CHN_RD_ADDR_H(id)         (0xD0a0 + ((id) - 1) * 0x100)
+#define DBG_OUT_SYM_CHN_RD_ADDR_L(id)         (0xD0a4 + ((id) - 1) * 0x100)
+#define DBG_OUT_SYM_CHN_NODE_LEFT_BUF_LEN(id) (0xD0a8 + ((id) - 1) * 0x100)
+
+#define IN_SYM_CHN0_CTRL                   0x4000
+#define IN_SYM_CHN0_SPECIAL_CTRL           0x4004
+#define IN_SYM_CHN0_KEY_CTRL               0x4010
+#define IN_SYM_CHN0_IV_DATA_CTRL           0x4030
+#define IN_SYM_CHN0_IV0                    0x4040
+#define IN_SYM_CHN0_IV1                    0x4044
+#define IN_SYM_CHN0_IV2                    0x4048
+#define IN_SYM_CHN0_IV3                    0x404C
+#define IN_SYM_CHN0_DATA0                  0x4050
+#define IN_SYM_CHN0_DATA1                  0x4054
+#define IN_SYM_CHN0_DATA2                  0x4058
+#define IN_SYM_CHN0_DATA3                  0x405C
+#define CHAN0_CIPHER_DOUT0                 0x8100
+
+#define SYMC_KEY_SIZE (32)
+#define NODE_DEPTH    (2)
+
+#define SYMC_CFG_SECURE             (0x05)
+#define SYMC_CFG_NON_SECURE         (0x0A)
+
+
+#define ALG_DMA_REG   (0)
+#define ALG_AES_REG   (2)
+#define ALG_LEA_REG   (4)
+#define ALG_SM4_REG   (5)
+#define ALG_GHASH_REG (6)
+#define ALG_TDES_REG  (7)
+
+#define MODE_ECB_REG        (0x01)
+#define MODE_CBC_REG        (0x03)
+#define MODE_CTR_REG        (0x06)
+#define MODE_OFB_REG        (0x07)
+#define MODE_CFB_REG        (0x08)
+#define MODE_CCM_REG        (0x09)
+#define MODE_GCM_REG        (0x0A)
+#define MODE_GCTR_REG       (0x0B)
+#define MODE_CMAC_REG       (0x0C)
+#define MODE_CBC_NOOUT_REG  (0x0D)
+#define MODE_GCTR_NOOUT_REG (0x0E)
+
+#define BIT_WIDTH_1_REG   (2)
+#define BIT_WIDTH_8_REG   (1)
+#define BIT_WIDTH_64_REG  (3)
+#define BIT_WIDTH_128_REG (3)
+
+// internal iv state
+#define SYMC_IV_STATE_START  (0)
+#define SYMC_IV_STATE_UPDATE (1)
+#define SYMC_IV_STATE_FINISH (2)
+
+typedef union {
+    struct {
+        td_u32 reserved_0 : 8;
+        td_u32 hash_chn_ss : 4;
+        td_u32 reserved_1 : 19;
+        td_u32 hash_chn_en : 1;
+    } bits;
+    td_u32 u32;
+} in_hash_chn_ctrl;
+
+typedef union {
+    struct {
+        td_u32 hash_key_chn_id : 4;
+        td_u32 reserved_0 : 5;
+        td_u32 hmac_vld : 1;
+        td_u32 reserved_1 : 6;
+        td_u32 hash_chn_alg_sel : 4;
+        td_u32 hash_chn_alg_mode : 4;
+        td_u32 reserved_2 : 8;
+    } bits;
+    td_u32 u32;
+} in_hash_chn_key_ctrl;
+
+// Define the union in_hash_chn_node_wr_point
+typedef union {
+    // Define the struct bits
+    struct {
+        td_u32 hash_chn_node_wr_point : 8; // [7..0]
+        td_u32 reserved_0 : 24;            // [31..8]
+    } bits;
+
+    // Define an unsigned member
+    td_u32 u32;
+} in_hash_chn_node_wr_point;
+
+// Define the union in_hash_chn_node_wr_point
+typedef union {
+    // Define the struct bits
+    struct {
+        td_u32 hash_chn_node_rd_point : 8; // [7..0]
+        td_u32 reserved_0 : 24;            // [31..8]
+    } bits;
+
+    // Define an unsigned member
+    td_u32 u32;
+} in_hash_chn_node_rd_point;
+
+// Define the union hash_chann_raw_int
+typedef union {
+    // Define the struct bits
+    struct {
+        td_u32 hash_chann_raw_int : 16; // [15..0]
+        td_u32 reserved_0 : 16;         // [31..16]
+    } bits;
+
+    // Define an unsigned member
+    td_u32 u32;
+} hash_chann_raw_int;
+
+// Define the union tee_hash_calc_ctrl_check_err
+typedef union {
+    // Define the struct bits
+    struct {
+        td_u32 reserved_0 : 1;
+        td_u32 hash_check_ss_error : 1;
+        td_u32 hash_check_alg_error : 1;
+        td_u32 hash_check_alg_invld_error : 1;
+        td_u32 reserved_1 : 2;
+        td_u32 hash_check_sc_error : 1;
+        td_u32 reserved_2 : 6;
+        td_u32 hash_check_sm3_disable_error : 1;
+        td_u32 hash_check_sha1_disable_error : 1;
+        td_u32 reserved_3 : 2;
+        td_u32 hash_tonly_error : 1;
+        td_u32 hash_aidsp_error : 1;
+        td_u32 reserved_4 : 13;
+    } bits;
+
+    // Define an unsigned member
+    td_u32 u32;
+} hash_calc_ctrl_check_err;
+
+// Define the union tee_hash_calc_ctrl_check_err
+typedef union {
+    // Define the struct bits
+    struct {
+        td_u32 hash_error_code_clr : 1;
+        td_u32 reserved_0 : 15;
+        td_u32 error_hash_chan_id : 4;
+        td_u32 reserved_1 : 12;
+    } bits;
+
+    // Define an unsigned member
+    td_u32 u32;
+} hash_calc_ctrl_check_err_status;
+
+/* Define the union in_sym_out_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_dma_copy : 2; /* [1..0] */
+        td_u32 reserved : 30;    /* [31..2] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_out_ctrl;
+
+/* Define the union in_sym_chn_key_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_key_chn_id : 9;     /* [8..0] */
+        td_u32 reserved : 7;           /* [15..9] */
+        td_u32 sym_alg_sel : 4;        /* [19..16] */
+        td_u32 sym_alg_mode : 4;       /* [23..20] */
+        td_u32 sym_alg_key_len : 2;    /* [25..24] */
+        td_u32 sym_alg_data_width : 2; /* [27..26] */
+        td_u32 sym_alg_decrypt : 1;    /* [28] */
+        td_u32 reserved_2 : 3;         /* [31..29] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn_key_ctrl;
+
+/* Define the union in_sym_chn_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 reserved : 8;       /* [7..0] */
+        td_u32 sym_chn_ss : 4;     /* [8..11] */
+        td_u32 sym_chn_ds : 4;     /* [12..15] */
+        td_u32 reserved_2 : 15;    /* [30..16] */
+        td_u32 sym_chn_en : 1;     /* [31] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn_ctrl;
+
+/* Define the union in_sym_chn0_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 reserved : 31;     /* [30..0] */
+        td_u32 sym_chn0_req : 1;  /* [31] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn0_ctrl;
+
+/* Define the union in_sym_chn0_special_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn0_odd_even : 1; /* [0] */
+        td_u32 reserved : 31;         /* [31..1] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn0_special_ctrl;
+
+/* Define the union in_sym_chn0_iv_data_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn0_first_block : 1; /* [0] */
+        td_u32 sym_chn0_last_block : 1;  /* [1] */
+        td_u32 reserved : 14;            /* [15..2] */
+        td_u32 sym_chn0_block_len : 5;   /* [20..16] */
+        td_u32 reserved2 : 11;           /* [31..21] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn0_iv_data_ctrl;
+
+/* Define the union out_sym_chan_raw_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 out_sym_chan_raw_int : 16; /* [15..0] */
+        td_u32 reserved_1 : 16;           /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} out_sym_chan_raw_int;
+
+/* Define the union out_sym_chan_raw_int_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 out_sym_chan_int_en : 16; /* [15..1] */
+        td_u32 reserved_1 : 16;          /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} out_sym_chan_raw_int_en;
+
+/* Define the union out_sym_chn_status */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 out_sym_chn_int_status : 16;     /* [15..1] */
+        td_u32 reserved_1 : 16;                 /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} out_sym_chn_status;
+
+/* Define the union out_sym_chn_node_wr_point */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn_node_wr_point : 8; /* [7..0] */
+        td_u32 reserved_1 : 24;               /* [31..8] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} out_sym_chn_node_wr_point;
+
+/* Define the union out_sym_chn_node_wr_point */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn_node_wr_point : 8; /* [7..0] */
+        td_u32 reserved_1 : 24;           /* [31..8] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn_node_wr_point;
+
+/* Define the union out_sym_chn_node_rd_point */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn_node_rd_point : 8; /* [7..0] */
+        td_u32 reserved_1 : 24;               /* [31..8] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} out_sym_chn_node_rd_point;
+
+/* Define the union out_sym_chn_node_rd_point */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn_node_rd_point : 8; /* [7..0] */
+        td_u32 reserved_1 : 24;           /* [31..8] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn_node_rd_point;
+
+/* Define the union in_sym_chn_node_length */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn_node_length : 8; /* [7..0] */
+        td_u32 reserved_1 : 24;         /* [31..8] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn_node_length;
+
+/* Define the union out_sym_chn_node_length */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn_node_length : 8; /* [7..0] */
+        td_u32 reserved_1 : 24;             /* [31..8] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} out_sym_chn_node_length;
+
+/* Define the union dbg_in_sym_chn_rd_addr_h */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 dbg_sym_chn_rd_addr_h : 4; /* [3..0] */
+        td_u32 reserved : 28;             /* [31..4] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} dbg_in_sym_chn_rd_addr_h;
+
+/* Define the union dbg_out_sym_chn_rd_addr_h */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 dbg_sym_chn_rd_addr_h : 4; /* [3..0] */
+        td_u32 reserved : 28;             /* [31..4] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} dbg_out_sym_chn_rd_addr_h;
+
+/* Define the union sym_calc_ctrl_check_err */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32    calc_ctrl_check_ds_error : 1;          /* [0]  */
+        td_u32    calc_ctrl_check_ss_error : 1;          /* [1]  */
+        td_u32    calc_ctrl_check_alg_error : 1;         /* [2]  */
+        td_u32    calc_ctrl_check_alg_invld_error : 1;   /* [3]  */
+        td_u32    calc_ctrl_check_dec_error : 1;         /* [4]  */
+        td_u32    reserved0 : 1;                         /* [5]  */
+        td_u32    calc_ctrl_check_sc_error : 1;          /* [6]  */
+        td_u32    calc_ctrl_check_key_size_error : 1;    /* [7]  */
+        td_u32    reserved : 8;                          /* [15..8]  */
+        td_u32    calc_ctrl_big_key_info_diff_error : 1; /* [16]  */
+        td_u32    calc_ctrl_tonly_error            : 1;  /* [17]  */
+        td_u32    calc_ctrl_aidsp_error : 1;             /* [18]  */
+        td_u32    reserved2 : 13;                        /* [31..19]  */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_calc_ctrl_check_err;
+
+/* Define the union sym_calc_ctrl_check_err_status */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_error_code_clr : 1; /* [0] */
+        td_u32 reserved : 15;              /* [15..1] */
+        td_u32 error_sym_chan_id : 4;  /* [19..16] */
+        td_u32 reserved1 : 12;             /* [31..20] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_calc_ctrl_check_err_status;
+
+/* Define the union in_sym_chn_node_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn_node_level : 8;     /* [7..0] */
+        td_u32 reserved_0 : 8;             /* [15..8] */
+        td_u32 sym_chn_node_cnt : 8;       /* [23..16] */
+        td_u32 reserved_1 : 7;             /* [30..24] */
+        td_u32 sym_chn_node_cnt_clear : 1; /* [31] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} in_sym_chn_node_ctrl;
+
+/* Define the union out_sym_chn_node_ctrl */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 out_sym_chn_node_level : 8; /* [7..0] */
+        td_u32 reserved_0 : 24;            /* [31..8] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} out_sym_chn_node_ctrl;
+
+/* Define the union spacc_sym_chn_clear_req */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chn_clear_req : 16; /* [15..0] */
+        td_u32 reserved_0 : 16;        /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} spacc_sym_chn_clear_req;
+
+/* Define the union spacc_int_raw_sym_clear_finish */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 int_raw_sym_clear_finish : 16; /* [15..0] */
+        td_u32 reserved_0 : 16;               /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} spacc_int_raw_sym_clear_finish;
+
+/* Define the union sym_chann_raw_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chann_raw_int : 16; /* [0] */
+        td_u32 reserved_0 : 16;        /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chann_raw_int;
+
+/* Define the union sym_chann_raw_int_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chann_int_en : 16; /* [0] */
+        td_u32 reserved_0 : 16;       /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chann_raw_int_en;
+
+/* Define the union sym_chann_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chann_int : 16; /* [0] */
+        td_u32 reserved_0 : 16;    /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chann_int;
+
+/* Define the union sym_chan0_finish_raw_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chan0_finish_raw_int : 1; /* [0] */
+        td_u32 reserved_0 : 31;              /* [31..1] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chan0_finish_raw_int;
+
+/* Define the union sym_chan0_finish_raw_int_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chan0_finish_int_en : 1; /* [0] */
+        td_u32 reserved_0 : 31;             /* [31..1] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chan0_finish_raw_int_en;
+
+/* Define the union sym_chan0_finish_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chan0_finish_int : 1; /* [0] */
+        td_u32 reserved_0 : 31;          /* [31..1] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chan0_finish_int;
+
+/* Define the union sym_chann_error_raw_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chan_raw_err_int : 16; /* [0] */
+        td_u32 reserved_0 : 16;           /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chann_error_raw_int;
+
+/* Define the union sym_chann_error_raw_int_en */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chan_err_int_en : 16; /* [0] */
+        td_u32 reserved_0 : 16;          /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chann_error_raw_int_en;
+
+typedef union {
+    struct {
+        td_u32 chann_dfa_en  : 4;  /* [3..0]  */
+        td_u32 reserved      : 28; /* [31..4] */
+    } bits;
+    td_u32 u32;
+} symc_chann_dfa_en;
+
+/* Define the union sym_chann_error_int */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32 sym_chan_err_int : 16; /* [0] */
+        td_u32 reserved_0 : 16;       /* [31..16] */
+    } bits;
+    /* Define an unsigned member */
+    td_u32 u32;
+} sym_chann_error_int;
+
+typedef union {
+    struct {
+        td_u32 sec_dfa_en  : 4;  /* [3..0]  */
+        td_u32 reserved    : 28; /* [31..4] */
+    } bits;
+    td_u32 u32;
+} spacc_sec_dfa_en;
+
+/* Define the union spacc_ie */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        unsigned int spacc_ie_ree : 1; /* [0] */
+        unsigned int reserved_0 : 3;   /* [3..1] */
+        unsigned int spacc_ie_tee : 1; /* [4] */
+        unsigned int reserved_1 : 3;   /* [7..5] */
+        unsigned int spacc_ie_hpp : 1; /* [8] */
+        unsigned int reserved_2 : 23;  /* [31..9] */
+    } bits;
+    /* Define an unsigned member */
+    unsigned int u32;
+} spacc_ie;
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc.c b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc.c
new file mode 100644
index 0000000..c0e19b8
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc.c
@@ -0,0 +1,1030 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal symc. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#include "hal_symc.h"
+#include "hal_spacc_reg.h"
+#include "hal_spacc_inner.h"
+
+#include "crypto_drv_common.h"
+
+#ifndef crypto_memory_barrier
+#define crypto_memory_barrier()
+#endif
+
+#define CRYPTO_SYMC_IN_NODE_SIZE            (sizeof(crypto_symc_entry_in) * CRYPTO_SYMC_MAX_LIST_NUM)
+#define CRYPTO_SYMC_OUT_NODE_SIZE           (sizeof(crypto_symc_entry_out) * CRYPTO_SYMC_MAX_LIST_NUM)
+#define CRYPTO_SYMC_NODE_SIZE               (CRYPTO_SYMC_IN_NODE_SIZE + CRYPTO_SYMC_OUT_NODE_SIZE)
+#define CRYPTO_SYMC_NODE_LIST_SIZE          (CRYPTO_SYMC_NODE_SIZE * CONFIG_SYMC_HARD_CHN_CNT)
+
+#if !defined(CONFIG_MMU_SUPPORT)
+static td_u8 g_symc_node_buffer[CRYPTO_SYMC_NODE_LIST_SIZE];
+#else
+static td_u8 *g_symc_node_buffer = NULL;
+#endif
+
+static crypto_symc_hard_context g_symc_hard_context[CONFIG_SYMC_HARD_CHN_CNT];
+static td_bool g_hal_symc_initialize = TD_FALSE;
+
+
+static td_s32 hal_cipher_symc_out_node_done_try(td_u32 chn_num);
+
+static void inner_hal_symc_irq_enable(td_u8 chn_num, td_bool enable)
+{
+    td_u32 reg_val;
+
+    reg_val = spacc_reg_read(OUT_SYM_CHAN_RAW_LAST_NODE_INT_EN);
+    if (enable == TD_TRUE) {
+        reg_val |= (1 << chn_num);
+    } else {
+        reg_val &= ~(1 << chn_num);
+    }
+    spacc_reg_write(OUT_SYM_CHAN_RAW_LAST_NODE_INT_EN, reg_val);
+}
+
+static void inner_symc_int_raw_enable(td_u8 chn_num, td_bool enable)
+{
+    td_u32 reg_val;
+
+    reg_val = spacc_reg_read(SYM_CHANN_RAW_INT_EN);
+    if (enable == TD_TRUE) {
+        reg_val |= (1 << chn_num);
+    } else {
+        reg_val &= ~(1 << chn_num);
+    }
+    spacc_reg_write(SYM_CHANN_RAW_INT_EN, reg_val);
+}
+
+static td_s32 hal_cipher_symc_clear_channel(td_u32 chn_num)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 i;
+    td_u32 chn_mask;
+    spacc_sym_chn_clear_req symc_chn_clear = {0};
+    spacc_int_raw_sym_clear_finish symc_chn_clear_finish = {0};
+
+    chn_mask = 0x1 << chn_num;
+    symc_chn_clear.u32 = spacc_reg_read(SPACC_SYM_CHN_CLEAR_REQ);
+    symc_chn_clear.bits.sym_chn_clear_req |= chn_mask;
+    spacc_reg_write(SPACC_SYM_CHN_CLEAR_REQ, symc_chn_clear.u32);
+
+    for (i = 0; i < CONFIG_SYMC_CLEAR_TIMEOUT_IN_US; i++) {
+        symc_chn_clear_finish.u32 = spacc_reg_read(SPACC_INT_RAW_SYM_CLEAR_FINISH);
+        symc_chn_clear_finish.bits.int_raw_sym_clear_finish &= chn_mask;
+        if (symc_chn_clear_finish.bits.int_raw_sym_clear_finish != 0) {
+            spacc_reg_write(SPACC_INT_RAW_SYM_CLEAR_FINISH, symc_chn_clear.u32);
+            break;
+        }
+        crypto_udelay(1);
+    }
+    if (i >= CONFIG_SYMC_CLEAR_TIMEOUT_IN_US) {
+        crypto_log_err("SYMC CHN %u Clear Channel Timeout\n", chn_num);
+        return TD_FAILURE;
+    }
+    inner_symc_int_raw_enable(chn_num, TD_FALSE);
+
+    return ret;
+}
+
+#define CRYPTO_SYMC_DFA_ENABLE_VAL          0x1
+#define CRYPTO_SYMC_DFA_DISABLE_VAL         0xa
+static td_void hal_cipher_symc_dfa_config(td_u32 chn_num, td_bool enable)
+{
+#if defined(CONFIG_SPACC_DFA_SUPPORT)
+    symc_chann_dfa_en dfa_en = { 0 };
+
+    dfa_en.u32 = spacc_reg_read(CHANN_CIPHER_DFA_EN(chn_num));
+    if (enable == TD_TRUE) {
+        dfa_en.bits.chann_dfa_en = CRYPTO_SYMC_DFA_ENABLE_VAL;
+    } else {
+        dfa_en.bits.chann_dfa_en = CRYPTO_SYMC_DFA_DISABLE_VAL;
+    }
+    spacc_reg_write(CHANN_CIPHER_DFA_EN(chn_num), dfa_en.u32);
+#else
+    crypto_unused(chn_num);
+    crypto_unused(enable);
+    return;
+#endif
+}
+
+static td_void hal_cipher_symc_set_entry_node(td_u32 chn_num, crypto_symc_hard_context *hard_ctx)
+{
+    in_sym_chn_node_length symc_in_node_length;
+    out_sym_chn_node_length symc_out_node_length;
+    td_u64 entry_in_phy = crypto_get_phys_addr((td_void *)hard_ctx->entry_in);
+    td_u64 entry_out_phy = crypto_get_phys_addr((td_void *)hard_ctx->entry_out);
+
+    /* set start addr for cipher in node and node length. */
+    spacc_reg_write(IN_SYM_CHN_NODE_START_ADDR_L(chn_num), entry_in_phy);
+    spacc_reg_write(IN_SYM_CHN_NODE_START_ADDR_H(chn_num), 0);
+
+    symc_in_node_length.u32 = spacc_reg_read(IN_SYM_CHN_NODE_LENGTH(chn_num));
+    symc_in_node_length.bits.sym_chn_node_length = CRYPTO_SYMC_MAX_LIST_NUM;
+    spacc_reg_write(IN_SYM_CHN_NODE_LENGTH(chn_num), symc_in_node_length.u32);
+
+    /* set start addr for cipher out node and node length. */
+    spacc_reg_write(OUT_SYM_CHN_NODE_START_ADDR_L(chn_num), entry_out_phy);
+    spacc_reg_write(OUT_SYM_CHN_NODE_START_ADDR_H(chn_num), 0);
+
+    symc_out_node_length.u32 = spacc_reg_read(OUT_SYM_CHN_NODE_LENGTH(chn_num));
+    symc_out_node_length.bits.sym_chn_node_length = CRYPTO_SYMC_MAX_LIST_NUM;
+    spacc_reg_write(OUT_SYM_CHN_NODE_LENGTH(chn_num), symc_out_node_length.u32);
+
+    hard_ctx->idx_in = 0;
+    hard_ctx->idx_out = 0;
+    hard_ctx->cnt_in = 0;
+    hard_ctx->cnt_out = 0;
+    (td_void)memset_s(hard_ctx->entry_in, CRYPTO_SYMC_IN_NODE_SIZE, 0, CRYPTO_SYMC_IN_NODE_SIZE);
+    (td_void)memset_s(hard_ctx->entry_out, CRYPTO_SYMC_OUT_NODE_SIZE, 0, CRYPTO_SYMC_OUT_NODE_SIZE);
+}
+
+td_s32 hal_cipher_symc_wait_noout_done(td_u32 chn_num)
+{
+    td_u32 i = 0;
+    td_s32 ret;
+    crypto_hal_func_enter();
+
+    for (i = 0; i < CONFIG_SYMC_WAIT_TIMEOUT_IN_US; i++) {
+        ret = hal_cipher_symc_out_node_done_try(chn_num);
+        if (ret == TD_SUCCESS) {
+            break;
+        }
+        crypto_udelay(1);
+    }
+
+    if (i >= CONFIG_SYMC_WAIT_TIMEOUT_IN_US) {
+        ret = SYMC_COMPAT_ERRNO(ERROR_SYMC_CALC_TIMEOUT);
+    }
+    if (ret == SYMC_COMPAT_ERRNO(ERROR_SYMC_CALC_TIMEOUT)) {
+        crypto_log_err("symc wait done timeout, chn is %u\n", chn_num);
+#if defined(CONFIG_SYMC_HAL_DEBUG_ENABLE)
+        hal_cipher_symc_debug();
+        hal_cipher_symc_debug_chn(chn_num);
+#endif
+        return ret;
+    }
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+static td_void inner_spacc_interrupt_enable(td_bool enable)
+{
+    spacc_ie cfg_val = { 0 };
+    cfg_val.u32 = spacc_reg_read(SPACC_IE);
+    if (crypto_get_cpu_type() == CRYPTO_CPU_TYPE_SCPU) {
+        cfg_val.bits.spacc_ie_tee = enable;
+    } else {
+        cfg_val.bits.spacc_ie_ree = enable;
+    }
+
+    spacc_reg_write(SPACC_IE, cfg_val.u32);
+}
+
+crypto_symc_hard_context *inner_hal_get_symc_ctx(td_u32 chn_num)
+{
+    if (chn_num >= CONFIG_SYMC_HARD_CHN_CNT) {
+        return TD_NULL;
+    }
+    return &g_symc_hard_context[chn_num];
+}
+
+td_s32 hal_cipher_symc_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 i;
+    td_u8 *entry_buffer = TD_NULL;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+
+    if (g_hal_symc_initialize == TD_TRUE) {
+        return TD_SUCCESS;
+    }
+    /* Node Buffer must be MMZ. */
+#if defined(CONFIG_MMU_SUPPORT)
+    g_symc_node_buffer = crypto_malloc_mmz(CRYPTO_SYMC_NODE_LIST_SIZE, "crypto_symc_node_buffer");
+    if (g_symc_node_buffer == TD_NULL) {
+        crypto_log_err("crypto_malloc_mmz failed\n");
+        return TD_FAILURE;
+    }
+#endif
+    entry_buffer = g_symc_node_buffer;
+    (td_void)memset_s(g_symc_hard_context, sizeof(g_symc_hard_context), 0, sizeof(g_symc_hard_context));
+    for (i = 0; i < CONFIG_SYMC_HARD_CHN_CNT; i++) {
+        hard_ctx = &g_symc_hard_context[i];
+        hard_ctx->entry_in = (void *)(entry_buffer + i * CRYPTO_SYMC_NODE_SIZE);
+        hard_ctx->entry_out = (void *)(entry_buffer + i * CRYPTO_SYMC_NODE_SIZE +
+            CRYPTO_SYMC_IN_NODE_SIZE);
+    }
+
+    inner_spacc_interrupt_enable(TD_FALSE);
+
+#if defined(CRYPTO_ERROR_ENV)
+    if (CRYPTO_ERROR_ENV != ERROR_ENV_NOOS) {
+        /* release all previously locked channels */
+        for (i = 0; i < CONFIG_SYMC_HARD_CHN_CNT; i++) {
+            (td_void)hal_cipher_symc_unlock_chn(i);
+        }
+    }
+#endif
+
+    g_hal_symc_initialize = TD_TRUE;
+    crypto_hal_func_exit();
+    return ret;
+}
+
+td_s32 hal_cipher_symc_deinit(td_void)
+{
+    td_u8 *entry_buffer = TD_NULL;
+    td_u32 i;
+    crypto_hal_func_enter();
+
+    if (g_hal_symc_initialize == TD_FALSE) {
+        return TD_SUCCESS;
+    }
+    entry_buffer = g_symc_node_buffer;
+    (td_void)memset_s(entry_buffer, CRYPTO_SYMC_NODE_LIST_SIZE, 0, CRYPTO_SYMC_NODE_LIST_SIZE);
+#if defined(CONFIG_MMU_SUPPORT)
+    crypto_free_coherent(entry_buffer);
+#endif
+    (td_void)memset_s(g_symc_hard_context, sizeof(g_symc_hard_context), 0, sizeof(g_symc_hard_context));
+    for (i = 0; i < CONFIG_SYMC_HARD_CHN_CNT; i++) {
+        hal_cipher_symc_unlock_chn(i);
+    }
+    g_hal_symc_initialize = TD_FALSE;
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_lock_chn(td_u32 chn_num)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 used;
+    td_u32 chnn_who_used = 0;
+    spacc_cpu_mask cpu_mask = SPACC_CPU_IDLE;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    in_sym_chn_ctrl in_ctrl;
+    crypto_hal_func_enter();
+
+    if (chn_num == 0) {
+        return CRYPTO_FAILURE;
+    }
+
+    cpu_mask = SPACC_CPU_CUR;
+
+    used = spacc_reg_read(SPACC_SYM_CHN_LOCK);
+    chnn_who_used = CHN_WHO_USED_GET(used, chn_num);
+    if (chnn_who_used != SPACC_CPU_IDLE) {
+        return TD_FAILURE;
+    }
+    CHN_WHO_USED_SET(used, chn_num, cpu_mask);
+    spacc_reg_write(SPACC_SYM_CHN_LOCK, used);
+
+    /* Read Back. */
+    used = spacc_reg_read(SPACC_SYM_CHN_LOCK);
+    chnn_who_used = CHN_WHO_USED_GET(used, chn_num);
+    crypto_chk_return(chnn_who_used != cpu_mask, TD_FAILURE, "Lock SYMC CHN %u Failed\n", chn_num);
+
+    ret = hal_cipher_symc_clear_channel(chn_num);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("hal_cipher_symc_clear_channel failed\n");
+        hal_cipher_symc_unlock_chn(chn_num);
+        return ret;
+    }
+    hard_ctx = &g_symc_hard_context[chn_num];
+    hal_cipher_symc_set_entry_node(chn_num, hard_ctx);
+
+    /* enable channel. */
+    in_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_CTRL(chn_num));
+    in_ctrl.bits.sym_chn_en = 1;
+    if (crypto_get_cpu_type() == CRYPTO_CPU_TYPE_SCPU) {
+        in_ctrl.bits.sym_chn_ss = SYMC_CFG_SECURE;
+        in_ctrl.bits.sym_chn_ds = SYMC_CFG_SECURE;
+    } else {
+        in_ctrl.bits.sym_chn_ss = SYMC_CFG_NON_SECURE;
+        in_ctrl.bits.sym_chn_ds = SYMC_CFG_NON_SECURE;
+    }
+    spacc_reg_write(IN_SYM_CHN_CTRL(chn_num), in_ctrl.u32);
+
+    /* Check whether there are residual interrupts. If yes, clear the interrupts. */
+    hal_cipher_symc_done_try(chn_num);
+    hal_cipher_symc_out_node_done_try(chn_num);
+
+    /* DFA Enable(Default). */
+    hal_cipher_symc_dfa_config(chn_num, TD_TRUE);
+
+    crypto_hal_func_exit();
+    return ret;
+}
+
+td_s32 hal_cipher_symc_unlock_chn(td_u32 chn_num)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 used;
+    td_u32 chnn_who_used = 0;
+    spacc_cpu_mask cpu_mask = SPACC_CPU_IDLE;
+    crypto_hal_func_enter();
+
+    cpu_mask = SPACC_CPU_CUR;
+
+    used = spacc_reg_read(SPACC_SYM_CHN_LOCK);
+    chnn_who_used = CHN_WHO_USED_GET(used, chn_num);
+    if (chnn_who_used != cpu_mask) {
+        return TD_SUCCESS;
+    }
+
+    ret = hal_cipher_symc_clear_channel(chn_num);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("hal_cipher_symc_clear_channel failed\n");
+    }
+
+    used = spacc_reg_read(SPACC_SYM_CHN_LOCK);
+    CHN_WHO_USED_CLR(used, chn_num);
+    spacc_reg_write(SPACC_SYM_CHN_LOCK, used);
+
+    crypto_hal_func_exit();
+    return ret;
+}
+
+td_s32 hal_cipher_symc_attach(td_u32 symc_chn_num, td_u32 keyslot_chn_num)
+{
+    in_sym_chn_key_ctrl in_key_ctrl;
+    crypto_hal_func_enter();
+
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(symc_chn_num));
+    /* Keyslot CHN Num. */
+    in_key_ctrl.bits.sym_key_chn_id = keyslot_chn_num;
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(symc_chn_num), in_key_ctrl.u32);
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_set_iv(td_u32 chn_num, const td_u8 *iv, td_u32 iv_len)
+{
+    td_s32 ret;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    crypto_symc_entry_in *entry_in = TD_NULL;
+    td_u32 idx;
+    crypto_hal_func_enter();
+
+    crypto_assert_eq(chn_num < CONFIG_SYMC_HARD_CHN_CNT, TD_TRUE);
+    crypto_assert_neq(iv, TD_NULL);
+    crypto_assert_eq(iv_len, sizeof(entry_in->iv));
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+    idx = hard_ctx->idx_in;
+    entry_in = &hard_ctx->entry_in[idx];
+
+    ret = memcpy_s(entry_in->iv, sizeof(entry_in->iv), iv, iv_len);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("memcpy_s failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_get_iv(td_u32 chn_num, td_u8 *iv, td_u32 iv_len)
+{
+    td_u32 i;
+    td_u32 iv_get[CRYPTO_AES_IV_SIZE_IN_WORD] = {0};
+    crypto_hal_func_enter();
+    crypto_unused(iv_len);
+
+    crypto_assert_eq(chn_num < CONFIG_SYMC_HARD_CHN_CNT, TD_TRUE);
+    crypto_assert_neq(iv, TD_NULL);
+    crypto_assert_eq(iv_len, CRYPTO_IV_LEN_IN_BYTES);
+
+    for (i = 0; i < CRYPTO_AES_IV_SIZE_IN_WORD; i++) {
+        iv_get[i] = spacc_reg_read(CHANN_CIPHER_IVOUT(chn_num) + i * CRYPTO_WORD_WIDTH);
+    }
+
+    (td_void)memcpy_s(iv, CRYPTO_IV_LEN_IN_BYTES, iv_get, CRYPTO_IV_LEN_IN_BYTES);
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+/* 1. Key Length. */
+#define SYMC_KEY_64BIT_VAL      0
+#define SYMC_KEY_128BIT_VAL     1
+#define SYMC_KEY_192BIT_VAL     2
+#define SYMC_KEY_256BIT_VAL     3
+
+static const crypto_table_item g_symc_key_length_table[] = {
+#if defined(CONFIG_SYMC_64_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_KEY_64BIT, .value = SYMC_KEY_64BIT_VAL
+    },
+#endif
+    {
+        .index = CRYPTO_SYMC_KEY_128BIT, .value = SYMC_KEY_128BIT_VAL
+    },
+#if defined(CONFIG_SYMC_192_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_KEY_192BIT, .value = SYMC_KEY_192BIT_VAL
+    },
+#endif
+#if defined(CONFIG_SYMC_256_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_KEY_256BIT, .value = SYMC_KEY_256BIT_VAL
+    },
+#endif
+};
+
+/* 2. ALg Mode. */
+static const crypto_table_item g_symc_alg_mode_table[] = {
+#if defined(CONFIG_SYMC_MODE_ECB_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_ECB, .value = SYMC_ALG_MODE_ECB_VAL
+    },
+#endif
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_CBC, .value = SYMC_ALG_MODE_CBC_VAL
+    },
+#if defined(CONFIG_SYMC_MODE_CTR_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_CTR, .value = SYMC_ALG_MODE_CTR_VAL
+    },
+#endif
+#if defined(CONFIG_SYMC_MODE_OFB_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_OFB, .value = SYMC_ALG_MODE_OFB_VAL
+    },
+#endif
+#if defined(CONFIG_SYMC_MODE_CFB_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_CFB, .value = SYMC_ALG_MODE_CFB_VAL
+    },
+#endif
+#if defined(CONFIG_SYMC_MODE_CCM_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_CCM, .value = SYMC_ALG_MODE_CTR_VAL
+    },
+#endif
+#if defined(CONFIG_SYMC_MODE_GCM_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_GCM, .value = SYMC_ALG_MODE_GCTR_VAL
+    },
+#endif
+#if defined(CONFIG_SYMC_MODE_CBC_MAC_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_CBC_MAC, .value = SYMC_ALG_MODE_CBC_NOOUT_VAL
+    },
+#endif
+#if defined(CONFIG_SYMC_MODE_CMAC_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_WORK_MODE_CMAC, .value = SYMC_ALG_MODE_CMAC_VAL
+    }
+#endif
+};
+
+/* 3. Alg. */
+static const crypto_table_item g_symc_alg_table[] = {
+    {
+        .index = CRYPTO_SYMC_ALG_AES, .value = SYMC_ALG_AES_VAL
+    },
+#if defined(CONFIG_SYMC_ALG_SM4_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_ALG_SM4, .value = SYMC_ALG_SM4_VAL
+    },
+#endif
+};
+
+/* 4. Bit Width. */
+#define SYMC_ALG_BIT_WIDTH_128BIT   0
+#define SYMC_ALG_BIT_WIDTH_64BIT    1
+#define SYMC_ALG_BIT_WIDTH_8BIT     1
+#define SYMC_ALG_BIT_WIDTH_1BIT     2
+
+static const crypto_table_item g_symc_bit_width_table[] = {
+    {
+        .index = CRYPTO_SYMC_BIT_WIDTH_128BIT, .value = SYMC_ALG_BIT_WIDTH_128BIT
+    },
+#if defined(CONFIG_SYMC_BIT_WIDTH_64_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_BIT_WIDTH_64BIT, .value = SYMC_ALG_BIT_WIDTH_64BIT
+    },
+#endif
+#if defined(CONFIG_SYMC_BIT_WIDTH_8_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_BIT_WIDTH_8BIT, .value = SYMC_ALG_BIT_WIDTH_8BIT
+    },
+#endif
+#if defined(CONFIG_SYMC_BIT_WIDTH_1_SUPPORT)
+    {
+        .index = CRYPTO_SYMC_BIT_WIDTH_1BIT, .value = SYMC_ALG_BIT_WIDTH_1BIT
+    },
+#endif
+};
+
+static td_s32 inner_symc_config_key_ctrl(td_u32 chn_num, const hal_symc_config_t *symc_config)
+{
+    volatile td_s32 ret = TD_FAILURE;
+    td_u32 reg_value = 0;
+    in_sym_chn_key_ctrl in_key_ctrl = {0};
+    td_bool is_decrypt = symc_config->is_decrypt;
+    crypto_symc_alg symc_alg = symc_config->symc_alg;
+    crypto_symc_work_mode work_mode = symc_config->work_mode;
+    crypto_symc_key_length symc_key_length = symc_config->symc_key_length;
+    crypto_symc_bit_width symc_bit_width = symc_config->symc_bit_width;
+
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+
+    /* alg_decrypt. */
+    in_key_ctrl.bits.sym_alg_decrypt = is_decrypt;
+
+    /* alg_sel. */
+    ret = crypto_get_value_by_index(g_symc_alg_table, crypto_array_size(g_symc_alg_table),
+        symc_alg, &reg_value);
+    crypto_chk_return(ret != TD_SUCCESS, TD_FAILURE, "Invalid Alg!\n");
+    in_key_ctrl.bits.sym_alg_sel = reg_value;
+
+    /* alg_mode. */
+    ret = crypto_get_value_by_index(g_symc_alg_mode_table, crypto_array_size(g_symc_alg_mode_table),
+        work_mode, &reg_value);
+    crypto_chk_return(ret != TD_SUCCESS, TD_FAILURE, "Invalid Alg_Mode!\n");
+    in_key_ctrl.bits.sym_alg_mode = reg_value;
+
+    /* alg_key_len. */
+    ret = crypto_get_value_by_index(g_symc_key_length_table, crypto_array_size(g_symc_key_length_table),
+        symc_key_length, &reg_value);
+    crypto_chk_return(ret != TD_SUCCESS, TD_FAILURE, "Invalid key_len!\n");
+    in_key_ctrl.bits.sym_alg_key_len = reg_value;
+
+    /* alg_data_width. */
+    ret = crypto_get_value_by_index(g_symc_bit_width_table, crypto_array_size(g_symc_bit_width_table),
+        symc_bit_width, &reg_value);
+    crypto_chk_return(ret != TD_SUCCESS, TD_FAILURE, "Invalid alg_data_width!\n");
+    in_key_ctrl.bits.sym_alg_data_width = reg_value;
+
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(chn_num), in_key_ctrl.u32);
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_set_flag(td_u32 chn_num, td_bool is_decrypt)
+{
+    in_sym_chn_key_ctrl in_key_ctrl = {0};
+    crypto_hal_func_enter();
+
+    crypto_assert_eq(chn_num < CONFIG_SYMC_HARD_CHN_CNT, TD_TRUE);
+
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+
+    in_key_ctrl.bits.sym_alg_decrypt = is_decrypt;
+
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(chn_num), in_key_ctrl.u32);
+    
+    crypto_hal_func_exit();
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_config(td_u32 chn_num, const hal_symc_config_t *symc_config)
+{
+    td_s32 ret;
+    in_sym_out_ctrl cipher_dma_ctrl = { 0 };
+    crypto_symc_alg symc_alg = symc_config->symc_alg;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+
+    crypto_hal_func_enter();
+    crypto_assert_eq(chn_num < CONFIG_SYMC_HARD_CHN_CNT, TD_TRUE);
+    crypto_assert_neq(symc_config, TD_NULL);
+
+    /* dma enable. */
+    cipher_dma_ctrl.u32 = spacc_reg_read(IN_SYM_OUT_CTRL(chn_num));
+    if (symc_alg == CRYPTO_SYMC_ALG_DMA) {
+        cipher_dma_ctrl.bits.sym_dma_copy = TD_TRUE;
+        spacc_reg_write(IN_SYM_OUT_CTRL(chn_num), cipher_dma_ctrl.u32);
+        return TD_SUCCESS;
+    }
+    cipher_dma_ctrl.bits.sym_dma_copy = TD_FALSE;
+    spacc_reg_write(IN_SYM_OUT_CTRL(chn_num), cipher_dma_ctrl.u32);
+
+    ret = inner_symc_config_key_ctrl(chn_num, symc_config);
+    crypto_chk_return(ret != TD_SUCCESS, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "inner_symc_config_key_ctrl failed\n");
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+
+    (td_void)memcpy_s(&(hard_ctx->symc_config), sizeof(hal_symc_config_t), symc_config, sizeof(hal_symc_config_t));
+
+    crypto_hal_func_exit();
+
+    return ret;
+}
+
+td_s32 hal_cipher_symc_get_config(td_u32 chn_num, hal_symc_config_t *symc_config)
+{
+    td_s32 ret;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+
+    crypto_hal_func_enter();
+    crypto_assert_eq(chn_num < CONFIG_SYMC_HARD_CHN_CNT, TD_TRUE);
+    crypto_assert_neq(symc_config, TD_NULL);
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+
+    ret = memcpy_s(symc_config, sizeof(hal_symc_config_t), &hard_ctx->symc_config, sizeof(hal_symc_config_t));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "memcpy_s failed\n");
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_start(td_u32 chn_num)
+{
+    in_sym_chn_node_wr_point in_node_wr_ptr;
+    out_sym_chn_node_wr_point out_node_wr_ptr;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    td_u32 ptr;
+
+    crypto_hal_func_enter();
+    crypto_assert_eq(chn_num < CONFIG_SYMC_HARD_CHN_CNT, TD_TRUE);
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+
+    /* if wait_func registered, enable interrupt */
+    if (hard_ctx->wait_func != TD_NULL) {
+        hard_ctx->done = TD_FALSE;
+        hard_ctx->is_wait = TD_TRUE;
+        inner_hal_symc_irq_enable(chn_num, TD_TRUE);
+    } else {
+        hard_ctx->is_wait = TD_FALSE;
+        inner_hal_symc_irq_enable(chn_num, TD_FALSE);
+    }
+
+    /* configure out nodes. */
+    out_node_wr_ptr.u32 = spacc_reg_read(OUT_SYM_CHN_NODE_WR_POINT(chn_num));
+    ptr = out_node_wr_ptr.bits.sym_chn_node_wr_point + hard_ctx->cnt_out;
+    out_node_wr_ptr.bits.sym_chn_node_wr_point = ptr % CRYPTO_SYMC_MAX_LIST_NUM;
+
+    /* make sure all the above explicit memory accesses and instructions are completed
+     * before start the hardware.
+     */
+    crypto_memory_barrier();
+
+    spacc_reg_write(OUT_SYM_CHN_NODE_WR_POINT(chn_num), out_node_wr_ptr.u32);
+
+    /* configure in nodes. */
+    in_node_wr_ptr.u32 = spacc_reg_read(IN_SYM_CHN_NODE_WR_POINT(chn_num));
+
+    ptr = in_node_wr_ptr.bits.sym_chn_node_wr_point + hard_ctx->cnt_in;
+    in_node_wr_ptr.bits.sym_chn_node_wr_point = ptr % CRYPTO_SYMC_MAX_LIST_NUM;
+
+    /* make sure all the above explicit memory accesses and instructions are completed
+     * before start the hardware.
+     */
+    crypto_memory_barrier();
+
+    crypto_cache_flush((uintptr_t)hard_ctx->entry_in, CRYPTO_SYMC_IN_NODE_SIZE);
+    crypto_cache_flush((uintptr_t)hard_ctx->entry_out, CRYPTO_SYMC_OUT_NODE_SIZE);
+
+    crypto_cache_all();
+    spacc_reg_write(IN_SYM_CHN_NODE_WR_POINT(chn_num), in_node_wr_ptr.u32);
+
+    hard_ctx->cnt_in = 0;
+    hard_ctx->cnt_out = 0;
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_done_try(td_u32 chn_num)
+{
+    out_sym_chan_raw_int last_raw;
+
+    td_u32 mask;
+
+    last_raw.u32 = spacc_reg_read(OUT_SYM_CHAN_RAW_LAST_NODE_INT);
+    last_raw.bits.out_sym_chan_raw_int &= (0x01 << chn_num);
+    spacc_reg_write(OUT_SYM_CHAN_RAW_LAST_NODE_INT, last_raw.u32);
+
+    mask = last_raw.bits.out_sym_chan_raw_int;
+    if (mask == 0) {
+        return CRYPTO_FAILURE;
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+#if defined(CONFIG_SPACC_IRQ_ENABLE)
+td_s32 hal_cipher_symc_done_notify(td_u32 chn_num)
+{
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+    crypto_assert_eq(chn_num < CONFIG_SYMC_HARD_CHN_CNT, TD_TRUE);
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+    hard_ctx->done = TD_TRUE;
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+#endif
+
+static td_s32 hal_cipher_symc_out_node_done_try(td_u32 chn_num)
+{
+    sym_chann_raw_int raw_int;
+    td_u32 mask;
+    crypto_hal_func_enter();
+
+    raw_int.u32 = spacc_reg_read(SYM_CHANN_RAW_INT);
+    raw_int.bits.sym_chann_raw_int &= (0x01 << chn_num);
+    spacc_reg_write(SYM_CHANN_RAW_INT, raw_int.u32);
+
+    mask = raw_int.bits.sym_chann_raw_int;
+    if (mask == 0) {
+        return TD_FAILURE;
+    }
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+#if defined(CONFIG_SPACC_IRQ_ENABLE)
+static td_bool hal_symc_condition(const td_void *param)
+{
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    td_u32 chn_num = *(td_u32 *)param;
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+    if (hard_ctx->done == TD_TRUE) {
+        hard_ctx->done = TD_FALSE;
+        return TD_TRUE;
+    } else {
+        return TD_FALSE;
+    }
+}
+
+td_s32 hal_wait_in_node_done(td_u32 chn_num)
+{
+    td_u32 i;
+
+    in_sym_chn_node_wr_point in_node_wr_ptr = {0};
+    in_sym_chn_node_rd_point in_node_rd_ptr = {0};
+
+    for (i = 0; i < CONFIG_SYMC_WAIT_TIMEOUT_IN_US; i++) {
+        in_node_wr_ptr.u32 = spacc_reg_read(IN_SYM_CHN_NODE_WR_POINT(chn_num));
+        in_node_rd_ptr.u32 = spacc_reg_read(IN_SYM_CHN_NODE_RD_POINT(chn_num));
+        if (in_node_rd_ptr.bits.sym_chn_node_rd_point == in_node_wr_ptr.bits.sym_chn_node_wr_point) {
+            break;
+        }
+        crypto_udelay(1);
+    }
+
+    if (i >= CONFIG_SYMC_WAIT_TIMEOUT_IN_US) {
+        crypto_log_err("hal_wait_in_node_done Timeout!\n");
+        return TD_FAILURE;
+    }
+
+    return TD_SUCCESS;
+}
+#endif
+
+static td_s32 symc_wait_done(td_u32 chn_num, td_bool is_wait, crypto_symc_hard_context *hard_ctx)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    td_u32 i = 0;
+    (void)(is_wait);
+    if ((hard_ctx->is_wait == TD_TRUE) && (hard_ctx->wait_func != TD_NULL)) {
+#if defined(CONFIG_SPACC_IRQ_ENABLE)
+        ret = hard_ctx->wait_func(hard_ctx->wait, hal_symc_condition, (td_void *)(&chn_num), hard_ctx->timeout_ms);
+        if (ret <= 0) {
+            crypto_log_err("wait_func Timeout!\n");
+            ret = SYMC_COMPAT_ERRNO(ERROR_SYMC_CALC_TIMEOUT);
+        }
+#endif
+    } else {
+        for (i = 0; i < CONFIG_SYMC_WAIT_TIMEOUT_IN_US; i++) {
+            ret = hal_cipher_symc_done_try(chn_num);
+            if (ret == TD_SUCCESS) {
+                break;
+            }
+            crypto_udelay(1);
+        }
+        if (i >= CONFIG_SYMC_WAIT_TIMEOUT_IN_US) {
+            ret = SYMC_COMPAT_ERRNO(ERROR_SYMC_CALC_TIMEOUT);
+        }
+    }
+
+    return ret;
+}
+
+td_s32 hal_cipher_symc_wait_done(td_u32 chn_num, td_bool is_wait)
+{
+    td_s32 ret;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+
+    ret = symc_wait_done(chn_num, is_wait, hard_ctx);
+    inner_hal_symc_irq_enable(chn_num, TD_FALSE);
+    if (ret == SYMC_COMPAT_ERRNO(ERROR_SYMC_CALC_TIMEOUT)) {
+        crypto_log_err("symc wait done timeout, chn is %u\n", chn_num);
+#if defined(CONFIG_SYMC_HAL_DEBUG_ENABLE)
+        hal_cipher_symc_debug();
+        hal_cipher_symc_debug_chn(chn_num);
+#endif
+        return ret;
+    }
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_add_in_node(td_u32 chn_num, td_u64 data_phys_addr, td_u32 data_len,
+    in_node_type_e in_node_type)
+{
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    crypto_symc_entry_in *entry_in = TD_NULL;
+
+    crypto_hal_func_enter();
+    crypto_chk_return(data_phys_addr == 0, SYMC_COMPAT_ERRNO(ERROR_INVALID_PHYS_ADDR), "data_phys_addr is invalid\n");
+    crypto_chk_return(data_phys_addr % CONFIG_SPACC_ADDR_ALIGN_LEN != 0, SYMC_COMPAT_ERRNO(ERROR_SYMC_ADDR_NOT_ALIGNED),
+        "phys_addr should align to %u-Byte\n", CONFIG_SPACC_ADDR_ALIGN_LEN);
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+    entry_in = &hard_ctx->entry_in[hard_ctx->idx_in];
+
+    entry_in->sym_first_node = (in_node_type & IN_NODE_TYPE_FIRST) ? 0x1 : 0;
+    entry_in->sym_last_node = (in_node_type & IN_NODE_TYPE_LAST) ? 0x1 : 0;
+    entry_in->sym_alg_length = data_len;
+    entry_in->sym_start_addr = data_phys_addr;
+    entry_in->sym_start_high = 0;
+
+    hard_ctx->idx_in++;
+    hard_ctx->cnt_in++;
+    hard_ctx->idx_in %= CRYPTO_SYMC_MAX_LIST_NUM;
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_symc_add_out_node(td_u32 chn_num, td_u64 data_phys_addr, td_u32 data_len)
+{
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    crypto_symc_entry_out *entry_out = TD_NULL;
+    td_u32 idx_out;
+    crypto_hal_func_enter();
+    crypto_chk_return(data_phys_addr == 0, SYMC_COMPAT_ERRNO(ERROR_INVALID_PHYS_ADDR), "data_phys_addr is invalid\n");
+    crypto_chk_return(data_phys_addr % CONFIG_SPACC_ADDR_ALIGN_LEN != 0, SYMC_COMPAT_ERRNO(ERROR_SYMC_ADDR_NOT_ALIGNED),
+        "phys_addr should align to %u-Byte\n", CONFIG_SPACC_ADDR_ALIGN_LEN);
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+    idx_out = hard_ctx->idx_out;
+    if (hard_ctx->entry_out == TD_NULL) {
+        crypto_log_err("hard_ctx->entry_out is NULL\n");
+        return TD_FAILURE;
+    }
+    entry_out = &hard_ctx->entry_out[idx_out];
+
+    entry_out->sym_alg_length = data_len;
+    entry_out->sym_start_addr = data_phys_addr;
+    entry_out->sym_start_high = 0;
+
+    hard_ctx->idx_out++;
+    hard_ctx->cnt_out++;
+    hard_ctx->idx_out %= CRYPTO_SYMC_MAX_LIST_NUM;
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+#if defined(CONFIG_SPACC_IRQ_ENABLE)
+td_s32 hal_cipher_symc_register_wait_func(td_u32 chn_num, td_void *wait,
+    crypto_wait_timeout_interruptible wait_func, td_u32 timeout_ms)
+{
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    crypto_hal_func_enter();
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+    hard_ctx->wait = wait;
+    hard_ctx->wait_func = wait_func;
+    hard_ctx->timeout_ms = timeout_ms;
+
+    if (wait_func != TD_NULL) {
+        inner_spacc_interrupt_enable(TD_TRUE);
+    }
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_SYMC_HAL_DEBUG_ENABLE)
+td_s32 hal_cipher_symc_debug(td_void)
+{
+    crypto_print("CRYPTO_SYMC_IN_NODE_SIZE is 0x%x\n", (unsigned int)CRYPTO_SYMC_IN_NODE_SIZE);
+    crypto_print("CRYPTO_SYMC_OUT_NODE_SIZE is 0x%x\n", (unsigned int)CRYPTO_SYMC_OUT_NODE_SIZE);
+    crypto_print("CRYPTO_SYMC_NODE_SIZE is 0x%x\n", (unsigned int)CRYPTO_SYMC_NODE_SIZE);
+    crypto_print("CRYPTO_SYMC_NODE_LIST_SIZE is 0x%x\n", (unsigned int)CRYPTO_SYMC_NODE_LIST_SIZE);
+    crypto_print("SPACC_IE is 0x%x\n", spacc_reg_read(SPACC_IE));
+    crypto_print("SPACC_SYMC_CHN_LOCK is 0x%x\n", spacc_reg_read(SPACC_SYM_CHN_LOCK));
+    crypto_print("OUT_SYM_CHAN_RAW_LAST_NODE_INT is 0x%x\n", spacc_reg_read(OUT_SYM_CHAN_RAW_LAST_NODE_INT));
+    crypto_print("OUT_SYM_CHAN_RAW_LAST_NODE_INT_EN is 0x%x\n", spacc_reg_read(OUT_SYM_CHAN_RAW_LAST_NODE_INT_EN));
+    crypto_print("OUT_SYM_CHAN_RAW_LEVEL_INT is 0x%x\n", spacc_reg_read(OUT_SYM_CHAN_RAW_LEVEL_INT));
+    crypto_print("SYM_CHANN_RAW_INT is 0x%x\n", spacc_reg_read(SYM_CHANN_RAW_INT));
+    crypto_print("SYM_CHANN_RAW_INT_EN is 0x%x\n", spacc_reg_read(SYM_CHANN_RAW_INT_EN));
+    crypto_print("TEE_SYM_CALC_CTRL_CHECK_ERR is 0x%x\n", spacc_reg_read(TEE_SYM_CALC_CTRL_CHECK_ERR));
+    crypto_print("TEE_SYM_CALC_CTRL_CHECK_ERR_STATUS is 0x%x\n", spacc_reg_read(TEE_SYM_CALC_CTRL_CHECK_ERR_STATUS));
+    crypto_print("REE_SYM_CALC_CTRL_CHECK_ERR is 0x%x\n", spacc_reg_read(REE_SYM_CALC_CTRL_CHECK_ERR));
+    crypto_print("REE_SYM_CALC_CTRL_CHECK_ERR_STATUS is 0x%x\n", spacc_reg_read(REE_SYM_CALC_CTRL_CHECK_ERR_STATUS));
+
+    return TD_SUCCESS;
+}
+
+static td_void hal_cipher_symc_print_entry_in(const crypto_symc_entry_in *entry_in)
+{
+    crypto_unused(entry_in);
+    crypto_print("The Details of Entry In:\n");
+    crypto_print("sym_first_node is 0x%x\n", entry_in->sym_first_node);
+    crypto_print("sym_last_node is 0x%x\n", entry_in->sym_last_node);
+    crypto_print("odd_even is 0x%x\n", entry_in->odd_even);
+    crypto_print("sym_alg_length is 0x%x\n", entry_in->sym_alg_length);
+    crypto_print("sym_start_addr is 0x%x\n", entry_in->sym_start_addr);
+    crypto_print("sym_start_high is 0x%x\n", entry_in->sym_start_high);
+    crypto_dump_data("iv", (td_u8 *)entry_in->iv, sizeof(entry_in->iv));
+}
+
+static td_void hal_cipher_symc_print_entry_out(const crypto_symc_entry_out *entry_in)
+{
+    crypto_unused(entry_in);
+    crypto_print("The Details of Entry Out:\n");
+    crypto_print("sym_alg_length is 0x%x\n", entry_in->sym_alg_length);
+    crypto_print("sym_start_addr is 0x%x\n", entry_in->sym_start_addr);
+    crypto_print("sym_start_high is 0x%x\n", entry_in->sym_start_high);
+}
+
+td_s32 hal_cipher_symc_debug_chn(td_u32 chn_num)
+{
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    crypto_symc_entry_in *entry_in = TD_NULL;
+    crypto_symc_entry_out *entry_out = TD_NULL;
+    td_u32 i;
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES] = {0};
+
+    hard_ctx = &g_symc_hard_context[chn_num];
+    entry_in = hard_ctx->entry_in;
+    entry_out = hard_ctx->entry_out;
+
+    crypto_print("The Status of SYMC CHN %u:\n", chn_num);
+    crypto_print("IN_SYM_CHN_NODE_START_ADDR_L is 0x%x\n", spacc_reg_read(IN_SYM_CHN_NODE_START_ADDR_L(chn_num)));
+    crypto_print("IN_SYM_CHN_NODE_START_ADDR_H is 0x%x\n", spacc_reg_read(IN_SYM_CHN_NODE_START_ADDR_H(chn_num)));
+    crypto_print("IN_SYM_CHN_NODE_LENGTH is 0x%x\n", spacc_reg_read(IN_SYM_CHN_NODE_LENGTH(chn_num)));
+
+    crypto_print("OUT_SYM_CHN_NODE_START_ADDR_L is 0x%x\n", spacc_reg_read(OUT_SYM_CHN_NODE_START_ADDR_L(chn_num)));
+    crypto_print("OUT_SYM_CHN_NODE_START_ADDR_H is 0x%x\n", spacc_reg_read(OUT_SYM_CHN_NODE_START_ADDR_H(chn_num)));
+    crypto_print("OUT_SYM_CHN_NODE_LENGTH is 0x%x\n", spacc_reg_read(OUT_SYM_CHN_NODE_LENGTH(chn_num)));
+
+    crypto_print("IN_SYM_CHN_CTRL is 0x%x\n", spacc_reg_read(IN_SYM_CHN_CTRL(chn_num)));
+    crypto_print("IN_SYM_OUT_CTRL is 0x%x\n", spacc_reg_read(IN_SYM_OUT_CTRL(chn_num)));
+    crypto_print("IN_SYM_CHN_KEY_CTRL is 0x%x\n", spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num)));
+
+    crypto_print("OUT_SYM_CHN_NODE_WR_POINT is 0x%x\n", spacc_reg_read(OUT_SYM_CHN_NODE_WR_POINT(chn_num)));
+    crypto_print("OUT_SYM_CHN_NODE_RD_POINT is 0x%x\n", spacc_reg_read(OUT_SYM_CHN_NODE_RD_POINT(chn_num)));
+
+    crypto_print("IN_SYM_CHN_NODE_WR_POINT is 0x%x\n", spacc_reg_read(IN_SYM_CHN_NODE_WR_POINT(chn_num)));
+    crypto_print("IN_SYM_CHN_NODE_RD_POINT is 0x%x\n", spacc_reg_read(IN_SYM_CHN_NODE_RD_POINT(chn_num)));
+
+    for (i = 0; i < CRYPTO_SYMC_MAX_LIST_NUM; i++) {
+        crypto_print("IDX_IN %u:\n", i);
+        hal_cipher_symc_print_entry_in(&entry_in[i]);
+    }
+    for (i = 0; i < CRYPTO_SYMC_MAX_LIST_NUM; i++) {
+        crypto_print("IDX_OUT %u:\n", i);
+        hal_cipher_symc_print_entry_out(&entry_out[i]);
+    }
+
+    hal_cipher_symc_get_iv(chn_num, iv, sizeof(iv));
+    crypto_dump_data("Current IV", iv, sizeof(iv));
+
+    return TD_SUCCESS;
+}
+#endif
+
+
+td_void hal_cipher_set_chn_secure(td_u32 chn_num, td_bool dest_sec, td_bool src_sec)
+{
+    crypto_unused(chn_num);
+    crypto_unused(dest_sec);
+    crypto_unused(src_sec);
+
+    return;
+}
+
+#if defined(CONFIG_SYMC_SUSPEND_SUPPORT)
+td_s32 hal_cipher_symc_resume(td_void)
+{
+    return TD_SUCCESS;
+}
+ 
+td_s32 hal_cipher_symc_suspend(td_void)
+{
+    return TD_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_cbc_mac.c b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_cbc_mac.c
new file mode 100755
index 0000000..c7c1e29
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_cbc_mac.c
@@ -0,0 +1,60 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal symc. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#include "hal_symc.h"
+#include "hal_spacc_reg.h"
+#include "hal_spacc_inner.h"
+
+#include "crypto_drv_common.h"
+
+int32_t hal_cipher_symc_cbc_mac_update(uint32_t chn_num, uint64_t data_phys_addr, uint32_t data_len,
+    uint8_t *cbc_mac, uint32_t cbc_mac_len)
+{
+    td_s32 ret;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    in_sym_chn_key_ctrl in_key_ctrl;
+
+    crypto_hal_func_enter();
+
+#if defined(CONFIG_SYMC_CBC_MAC_TRACE_ENABLE)
+    crypto_dump_phys_addr("cbc mac update data", data_phys_addr, data_len);
+    crypto_dump_data("cbc mac before", cbc_mac, cbc_mac_len);
+#endif
+    crypto_chk_return(data_len % CRYPTO_AES_BLOCK_SIZE_IN_BYTES != 0, SYMC_COMPAT_ERRNO(ERROR_SYMC_LEN_NOT_ALIGNED),
+        "data_len must be aligned to 16-Byte\n");
+
+    hard_ctx = inner_hal_get_symc_ctx(chn_num);
+    crypto_chk_return(hard_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid chn_num");
+
+    ret = hal_cipher_symc_set_iv(chn_num, cbc_mac, cbc_mac_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed\n");
+
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+    in_key_ctrl.bits.sym_alg_sel = SYMC_ALG_AES_VAL;
+    in_key_ctrl.bits.sym_alg_mode = SYMC_ALG_MODE_CBC_NOOUT_VAL;
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(chn_num), in_key_ctrl.u32);
+
+    ret = hal_cipher_symc_add_in_node(chn_num, data_phys_addr, data_len, IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_hal_priv_set_in_node failed\n");
+
+    ret = hal_cipher_symc_start(chn_num);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_start failed\n");
+
+    ret = hal_cipher_symc_wait_noout_done(chn_num);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_wait_noout_done failed\n");
+
+    ret = hal_cipher_symc_get_iv(chn_num, cbc_mac, cbc_mac_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_get_iv failed\n");
+
+#if defined(CONFIG_SYMC_CBC_MAC_TRACE_ENABLE)
+    crypto_dump_data("cbc mac after", cbc_mac, cbc_mac_len);
+#endif
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_ccm.c b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_ccm.c
new file mode 100644
index 0000000..7458e56
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_ccm.c
@@ -0,0 +1,96 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal symc. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#if defined(CONFIG_SYMC_CCM_SUPPORT)
+
+#include "hal_symc.h"
+#include "hal_spacc_reg.h"
+#include "hal_spacc_inner.h"
+
+#include "crypto_drv_common.h"
+
+int32_t hal_cipher_ccm_cmac_update(uint32_t chn_num, uint64_t data_phys_addr, uint32_t data_len,
+    uint8_t *cmac, uint32_t cmac_len)
+{
+    int ret;
+    in_sym_chn_key_ctrl in_key_ctrl = {0};
+    crypto_symc_hard_context *hard_ctx = NULL;
+
+    hard_ctx = inner_hal_get_symc_ctx(chn_num);
+    crypto_chk_return(hard_ctx == NULL, CRYPTO_FAILURE, "inner_hal_get_symc_ctx failed\n");
+
+    /* To mac_update, you should choose MODE_CBC_NOOUT. */
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+    in_key_ctrl.bits.sym_alg_mode = SYMC_ALG_MODE_CBC_NOOUT_VAL;
+    in_key_ctrl.bits.sym_alg_decrypt = TD_FALSE;
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(chn_num), in_key_ctrl.u32);
+
+    /* You should set iv_mac before mac_update. */
+    ret = hal_cipher_symc_set_iv(chn_num, cmac, cmac_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed\n");
+
+    ret = hal_cipher_symc_add_in_node(chn_num, data_phys_addr, data_len, IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "hal_cipher_symc_add_in_node failed\n");
+
+    hal_cipher_symc_start(chn_num);
+
+    ret = hal_cipher_symc_wait_noout_done(chn_num);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_wait_noout_done failed\n");
+
+    /* You should update iv_mac after mac_update. */
+    ret = hal_cipher_symc_get_iv(chn_num, cmac, cmac_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_get_iv failed\n");
+
+    return CRYPTO_SUCCESS;
+}
+
+int32_t hal_cipher_ccm_compute_s0(uint32_t chn_num, const uint8_t *ctr0, uint32_t ctr0_len,
+    uint8_t *s0, uint32_t s0_len)
+{
+    int ret;
+    in_sym_chn_key_ctrl in_key_ctrl = {0};
+    crypto_symc_hard_context *hard_ctx = NULL;
+    uint8_t *data_buf = NULL;
+
+    data_buf = crypto_malloc_coherent(CRYPTO_AES_BLOCK_SIZE_IN_BYTES, "ccm_s0_buf");
+    crypto_chk_return(data_buf == NULL, ERROR_MALLOC, "crypto_malloc_coherent failed\n");
+
+    (void)memset_s(data_buf, CRYPTO_AES_BLOCK_SIZE_IN_BYTES, 0, CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+
+    hard_ctx = inner_hal_get_symc_ctx(chn_num);
+    crypto_chk_goto_with_ret(ret, hard_ctx == NULL, exit_free, CRYPTO_FAILURE, "inner_hal_get_symc_ctx failed\n");
+
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+    in_key_ctrl.bits.sym_alg_mode = SYMC_ALG_MODE_CTR_VAL;
+    in_key_ctrl.bits.sym_alg_decrypt = TD_FALSE;
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(chn_num), in_key_ctrl.u32);
+
+    ret = hal_cipher_symc_set_iv(chn_num, ctr0, ctr0_len);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_set_iv failed\n");
+
+    ret = hal_cipher_symc_add_in_node(chn_num, crypto_get_phys_addr(data_buf), CRYPTO_AES_BLOCK_SIZE_IN_BYTES,
+        IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "hal_cipher_symc_add_in_node failed\n");
+
+    ret = hal_cipher_symc_add_out_node(chn_num, crypto_get_phys_addr(data_buf), CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "hal_cipher_symc_add_out_node failed\n");
+
+    hal_cipher_symc_start(chn_num);
+
+    ret = hal_cipher_symc_wait_done(chn_num, TD_FALSE);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_wait_done failed\n");
+
+    ret = memcpy_s(s0, s0_len, data_buf, CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, ERROR_MEMCPY_S, "memcpy_s failed\n");
+
+    ret = CRYPTO_SUCCESS;
+exit_free:
+    crypto_free_coherent(data_buf);
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_cmac.c b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_cmac.c
new file mode 100644
index 0000000..7b2b683
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_cmac.c
@@ -0,0 +1,128 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal symc. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#if defined(CONFIG_SYMC_CMAC_SUPPORT) || defined(CONFIG_SYMC_CBC_MAC_SUPPORT)
+
+#include "hal_symc.h"
+#include "hal_spacc_reg.h"
+#include "hal_spacc_inner.h"
+
+#include "crypto_drv_common.h"
+
+int32_t hal_cipher_symc_cmac_update(uint32_t chn_num, uint64_t data_phys_addr, uint32_t data_len, crypto_cmac_ctx *ctx)
+{
+    td_s32 ret;
+    uint8_t *cmac_buf = NULL;
+    uint32_t cmac_buf_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    uint32_t left = data_len;
+    uint32_t processing_len = 0;
+
+    crypto_hal_func_enter();
+#if defined(CONFIG_SYMC_CMAC_TRACE_ENABLE)
+    crypto_dump_data("cmac before", ctx->mac, sizeof(ctx->mac));
+#endif
+    crypto_chk_return(data_len == 0, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "data_len is zero!\n");
+
+    /* process the left block. */
+    if (ctx->left_len != 0) {
+        crypto_chk_return(ctx->left_len != CRYPTO_AES_BLOCK_SIZE_IN_BYTES, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+            "cmac left must be 16 Bytes\n");
+        cmac_buf = crypto_malloc_coherent(cmac_buf_len, "cmac_buf");
+        crypto_chk_return(cmac_buf == NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+#if defined(CONFIG_SYMC_CMAC_TRACE_ENABLE)
+        crypto_dump_data("cmac update left data", ctx->left, ctx->left_len);
+#endif
+        (void)memcpy_s(cmac_buf, cmac_buf_len, ctx->left, ctx->left_len);
+        ret = hal_cipher_symc_cbc_mac_update(chn_num, crypto_get_phys_addr(cmac_buf), cmac_buf_len,
+            ctx->mac, sizeof(ctx->mac));
+        crypto_free_coherent(cmac_buf);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_cbc_mac_update failed\n");
+    }
+
+    /* store the final block. */
+    processing_len = crypto_min(CRYPTO_AES_BLOCK_SIZE_IN_BYTES, data_len);
+    ret = crypto_copy_from_phys_addr(ctx->left, sizeof(ctx->left),
+        data_phys_addr + data_len - processing_len, processing_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_phys_copy_to_virt failed\n");
+    ctx->left_len = processing_len;
+    left -= processing_len;
+
+    if (left != 0) {
+#if defined(CONFIG_SYMC_CMAC_TRACE_ENABLE)
+        crypto_dump_phys_addr("cmac update data", data_phys_addr, left);
+#endif
+        ret = hal_cipher_symc_cbc_mac_update(chn_num, data_phys_addr, left, ctx->mac, sizeof(ctx->mac));
+        crypto_chk_return(ret != ret, ret, "hal_cipher_symc_cbc_mac_update failed\n");
+    }
+
+#if defined(CONFIG_SYMC_CMAC_TRACE_ENABLE)
+    crypto_dump_data("cmac after", ctx->mac, sizeof(ctx->mac));
+    crypto_dump_data("cmac left", ctx->left, ctx->left_len);
+#endif
+
+    crypto_hal_func_exit();
+    return TD_SUCCESS;
+}
+
+int32_t hal_cipher_symc_cmac_finish(uint32_t chn_num, crypto_cmac_ctx *ctx)
+{
+    td_s32 ret;
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+    in_sym_chn_key_ctrl in_key_ctrl;
+    uint8_t *cmac_buf = NULL;
+    uint32_t cmac_buf_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+
+    crypto_hal_func_enter();
+#if defined(CONFIG_SYMC_CMAC_TRACE_ENABLE)
+    crypto_dump_data("cmac_finish_data", ctx->left, ctx->left_len);
+    crypto_dump_data("cmac before", ctx->mac, sizeof(ctx->mac));
+#endif
+
+    hard_ctx = inner_hal_get_symc_ctx(chn_num);
+    crypto_chk_return(hard_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid chn_num");
+
+    ret = hal_cipher_symc_set_iv(chn_num, ctx->mac, sizeof(ctx->mac));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed\n");
+
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+    in_key_ctrl.bits.sym_alg_sel = SYMC_ALG_AES_VAL;
+    in_key_ctrl.bits.sym_alg_mode = SYMC_ALG_MODE_CMAC_VAL;
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(chn_num), in_key_ctrl.u32);
+
+    cmac_buf = crypto_malloc_coherent(cmac_buf_len, "cmac_buf");
+    crypto_chk_return(cmac_buf == NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    ret = memcpy_s(cmac_buf, cmac_buf_len, ctx->left, sizeof(ctx->left));
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = hal_cipher_symc_add_in_node(chn_num, crypto_get_phys_addr(cmac_buf), ctx->left_len,
+        IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_add_in_node failed\n");
+
+    ret = hal_cipher_symc_add_out_node(chn_num, crypto_get_phys_addr(cmac_buf), CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_add_out_node failed\n");
+
+    ret = hal_cipher_symc_start(chn_num);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_start failed\n");
+
+    ret = hal_cipher_symc_wait_done(chn_num, TD_FALSE);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_wait_done failed\n");
+
+    ret = hal_cipher_symc_get_iv(chn_num, ctx->mac, sizeof(ctx->mac));
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_get_iv failed\n");
+
+#if defined(CONFIG_SYMC_CMAC_TRACE_ENABLE)
+    crypto_dump_data("cmac after", ctx->mac, sizeof(ctx->mac));
+#endif
+    ret = TD_SUCCESS;
+exit_free:
+    crypto_free_coherent(cmac_buf);
+    crypto_hal_func_exit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_gcm.c b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_gcm.c
new file mode 100644
index 0000000..3b3f4c5
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_gcm.c
@@ -0,0 +1,119 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal symc. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#if defined(CONFIG_SYMC_GCM_SUPPORT)
+
+#include "hal_symc.h"
+#include "hal_spacc_reg.h"
+#include "hal_spacc_inner.h"
+
+#include "crypto_drv_common.h"
+
+int32_t hal_cipher_gcm_ghash_update(uint32_t chn_num, uint64_t data_phys_addr, uint32_t data_len,
+    uint8_t *ghash, uint32_t ghash_len)
+{
+    int32_t ret;
+    in_sym_chn_key_ctrl in_key_ctrl = {0};
+    crypto_symc_hard_context *hard_ctx = TD_NULL;
+
+    crypto_hal_func_enter();
+
+    hard_ctx = inner_hal_get_symc_ctx(chn_num);
+    crypto_chk_return(hard_ctx == NULL, CRYPTO_FAILURE, "inner_hal_get_symc_ctx failed\n");
+
+    /* To gcm_mac_update, you should choose ALG_GHASH. */
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+    in_key_ctrl.bits.sym_alg_sel = SYMC_ALG_GHASH_VAL;
+    /* symc_alg_mode must be 0 for GHASH, otherwise the calculation will timeout. */
+    in_key_ctrl.bits.sym_alg_mode = 0;
+    in_key_ctrl.bits.sym_alg_decrypt = TD_FALSE;
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(chn_num), in_key_ctrl.u32);
+
+    /**
+    * You should set iv before mac_update.
+    **/
+    ret = hal_cipher_symc_set_iv(chn_num, ghash, ghash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_set_iv failed\n");
+
+    ret = hal_cipher_symc_add_in_node(chn_num, data_phys_addr, data_len, IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_add_in_node failed\n");
+
+    hal_cipher_symc_start(chn_num);
+
+    /**
+     * For last node, you need to wait until the interrupt(SYM_CHANN_RAW_INT) occurs;
+     **/
+    ret = hal_cipher_symc_wait_noout_done(chn_num);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_wait_noout_done failed\n");
+
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_data("gcm ghash before", ghash, ghash_len);
+#endif
+
+    ret = hal_cipher_symc_get_iv(chn_num, ghash, ghash_len);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "hal_cipher_symc_get_iv failed\n");
+
+#if defined(CONFIG_SYMC_GCM_TRACE_ENABLE)
+    crypto_dump_data("gcm ghash after", ghash, ghash_len);
+#endif
+    return TD_SUCCESS;
+}
+
+/**
+ * tag = AES-CTR(iv=j0, data=ghash)
+ */
+int32_t hal_cipher_gcm_compute_tag(uint32_t chn_num, const uint8_t *ghash, uint32_t ghash_len,
+    const uint8_t *j0, uint32_t j0_len,
+    uint8_t *tag, uint32_t tag_len)
+{
+    int ret;
+    in_sym_chn_key_ctrl in_key_ctrl = {0};
+    crypto_symc_hard_context *hard_ctx = NULL;
+    uint8_t *data_buf = NULL;
+
+    crypto_chk_return(tag_len > CRYPTO_AES_BLOCK_SIZE_IN_BYTES, ERROR_INVALID_PARAM, "tag_len is too long\n");
+
+    data_buf = crypto_malloc_coherent(CRYPTO_AES_BLOCK_SIZE_IN_BYTES, "gcm_tag_buf");
+    crypto_chk_return(data_buf == NULL, ERROR_MALLOC, "crypto_malloc_coherent failed\n");
+
+    hard_ctx = inner_hal_get_symc_ctx(chn_num);
+    crypto_chk_goto_with_ret(ret, hard_ctx == NULL, exit_free, CRYPTO_FAILURE, "inner_hal_get_symc_ctx failed\n");
+
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+    in_key_ctrl.bits.sym_alg_sel = SYMC_ALG_AES_VAL;
+    in_key_ctrl.bits.sym_alg_mode = SYMC_ALG_MODE_CTR_VAL;
+    in_key_ctrl.bits.sym_alg_decrypt = TD_FALSE;
+    spacc_reg_write(IN_SYM_CHN_KEY_CTRL(chn_num), in_key_ctrl.u32);
+
+    ret = memcpy_s(data_buf, CRYPTO_AES_BLOCK_SIZE_IN_BYTES, ghash, ghash_len);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, ERROR_MEMCPY_S, "memcpy_s failed\n");
+
+    ret = hal_cipher_symc_set_iv(chn_num, j0, j0_len);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_set_iv failed\n");
+
+    ret = hal_cipher_symc_add_in_node(chn_num, crypto_get_phys_addr(data_buf), CRYPTO_AES_BLOCK_SIZE_IN_BYTES,
+        IN_NODE_TYPE_FIRST | IN_NODE_TYPE_LAST);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "hal_cipher_symc_add_in_node failed\n");
+
+    ret = hal_cipher_symc_add_out_node(chn_num, crypto_get_phys_addr(data_buf), CRYPTO_AES_BLOCK_SIZE_IN_BYTES);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "hal_cipher_symc_add_out_node failed\n");
+
+    hal_cipher_symc_start(chn_num);
+
+    ret = hal_cipher_symc_wait_done(chn_num, TD_FALSE);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_free, "hal_cipher_symc_wait_done failed\n");
+
+    ret = memcpy_s(tag, tag_len, data_buf, tag_len);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, ERROR_MEMCPY_S, "memcpy_s failed\n");
+
+    ret = CRYPTO_SUCCESS;
+exit_free:
+    crypto_free_coherent(data_buf);
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_proc.c b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_proc.c
new file mode 100644
index 0000000..6e1602b
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/spacc_v4/hal_symc_proc.c
@@ -0,0 +1,97 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal symc. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#if defined(CONFIG_SYMC_PROC_SUPPORT)
+
+#include "hal_symc.h"
+#include "hal_spacc_reg.h"
+#include "hal_spacc_inner.h"
+
+#include "crypto_drv_common.h"
+
+td_s32 hal_cipher_symc_get_proc_info(td_u32 chn_num, crypto_symc_proc_info *proc_symc_info)
+{
+    td_s32 ret;
+    hal_symc_config_t symc_config;
+
+    in_sym_chn_key_ctrl in_key_ctrl;
+ 
+    out_sym_chan_raw_int out_raw_int;
+    out_sym_chan_raw_int_en out_sym_int_en;
+    out_sym_chn_status out_sym_int_status;
+ 
+    in_sym_chn_node_wr_point in_node_wr_ptr;
+    in_sym_chn_node_rd_point in_node_rd_ptr;
+    in_sym_chn_node_length in_node_depth;
+ 
+    out_sym_chn_node_wr_point out_node_wr_ptr;
+    out_sym_chn_node_rd_point out_node_rd_ptr;
+    out_sym_chn_node_length out_node_depth;
+ 
+    crypto_hal_func_enter();
+ 
+    crypto_chk_return(proc_symc_info == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "proc_symc_info is NULL\n");
+ 
+    /* Get Key Ctrl. */
+    in_key_ctrl.u32 = spacc_reg_read(IN_SYM_CHN_KEY_CTRL(chn_num));
+ 
+    ret = hal_cipher_symc_get_config(chn_num, &symc_config);
+    crypto_chk_return(ret != TD_SUCCESS, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "hal_cipher_symc_get_config failed\n");
+
+    proc_symc_info->is_decrypt = symc_config.is_decrypt;
+
+    /* Alg. */
+    proc_symc_info->alg = symc_config.symc_alg;
+ 
+    /* Alg Mode. */
+    proc_symc_info->mode = symc_config.work_mode;
+ 
+    /* Key Length. */
+    proc_symc_info->key_len = symc_config.symc_key_length;
+ 
+    /* Key Source. */
+    proc_symc_info->key_source = in_key_ctrl.bits.sym_key_chn_id;
+ 
+    /* int_raw. */
+    out_raw_int.u32 = spacc_reg_read(OUT_SYM_CHAN_RAW_LAST_NODE_INT);
+    proc_symc_info->int_raw = (out_raw_int.bits.out_sym_chan_raw_int >> chn_num) & 0x1;
+ 
+    /* int_en. */
+    out_sym_int_en.u32 = spacc_reg_read(OUT_SYM_CHAN_RAW_LAST_NODE_INT_EN);
+    proc_symc_info->int_en = (out_sym_int_en.bits.out_sym_chan_int_en >> chn_num) & 0x1;
+ 
+    /* int status. */
+    out_sym_int_status.u32 = spacc_reg_read(OUT_SYM_CHAN_LAST_NODE_INT);
+    proc_symc_info->int_status = (out_sym_int_status.bits.out_sym_chn_int_status >> chn_num) & 0x1;
+ 
+    /* is_secure. */
+    proc_symc_info->is_secure = (crypto_get_cpu_type() == CRYPTO_CPU_TYPE_SCPU) ? 1 : 0;
+ 
+    /* in node: head(r/w/d) */
+    in_node_wr_ptr.u32 = spacc_reg_read(IN_SYM_CHN_NODE_WR_POINT(chn_num));
+    in_node_rd_ptr.u32 = spacc_reg_read(IN_SYM_CHN_NODE_RD_POINT(chn_num));
+    in_node_depth.u32 = spacc_reg_read(IN_SYM_CHN_NODE_LENGTH(chn_num));
+    proc_symc_info->in_node_head = spacc_reg_read(IN_SYM_CHN_NODE_START_ADDR_L(chn_num));
+    proc_symc_info->in_node_rptr = in_node_rd_ptr.bits.sym_chn_node_rd_point;
+    proc_symc_info->in_node_wptr = in_node_wr_ptr.bits.sym_chn_node_wr_point;
+    proc_symc_info->in_node_depth = in_node_depth.bits.sym_chn_node_length;
+ 
+    /* out node: head(r/w/d) */
+    out_node_wr_ptr.u32 = spacc_reg_read(OUT_SYM_CHN_NODE_WR_POINT(chn_num));
+    out_node_rd_ptr.u32 = spacc_reg_read(OUT_SYM_CHN_NODE_RD_POINT(chn_num));
+    out_node_depth.u32 = spacc_reg_read(OUT_SYM_CHN_NODE_LENGTH(chn_num));
+    proc_symc_info->out_node_head = spacc_reg_read(OUT_SYM_CHN_NODE_START_ADDR_L(chn_num));
+    proc_symc_info->out_node_rptr = out_node_rd_ptr.bits.sym_chn_node_rd_point;
+    proc_symc_info->out_node_wptr = out_node_wr_ptr.bits.sym_chn_node_wr_point;
+    proc_symc_info->out_node_depth = out_node_depth.bits.sym_chn_node_length;
+ 
+    crypto_hal_func_exit();
+ 
+    return TD_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/trng_v4/hal_trng.c b/bsp/security_subsys/security_subsys_common/hal_code/trng_v4/hal_trng.c
new file mode 100644
index 0000000..581350c
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/trng_v4/hal_trng.c
@@ -0,0 +1,123 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal trng. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#include "hal_trng.h"
+#include "hal_trng_reg.h"
+
+#include "crypto_drv_common.h"
+
+#define TRNG_OSC_SEL   0x02
+#define TRNG_POWER_ON  0x05
+#define TRNG_POWER_OFF 0x0a
+
+#define TRNG_COMPAT_ERRNO(err_code)     HAL_COMPAT_ERRNO(ERROR_MODULE_TRNG, err_code)
+
+static td_bool g_hal_trng_init_flag = TD_FALSE;
+
+#if defined(CONFIG_TRNG_RING_ENABLE)
+static void inner_trng_ring_enable(td_bool enable)
+{
+    trng_sec_cfg ring_en = { 0 };
+
+    ring_en.u16 = crypto_reg_read_u16(TRNG_SEC_CFB);
+    if (enable == TD_TRUE) {
+        if (ring_en.bits.trng_ring_en != TRNG_RING_ENABLE) {
+            ring_en.bits.trng_ring_en = TRNG_RING_ENABLE;
+            crypto_ex_reg_write_u16(TRNG_SEC_CFB, ring_en.u16);
+        }
+    } else {
+        if (ring_en.bits.trng_ring_en != TRNG_RING_DISABLE) {
+            ring_en.bits.trng_ring_en = TRNG_RING_DISABLE;
+            crypto_ex_reg_write_u16(TRNG_SEC_CFB, ring_en.u16);
+        }
+    }
+}
+#endif /* CONFIG_TRNG_RING_ENABLE */
+
+#define TRNG_RING_ENABLE_WAIT_US 200
+td_s32 hal_cipher_trng_init(td_void)
+{
+#if defined(CONFIG_ENTROPY_SOURCES_FROM_FRO)
+    /* Select the entropy source and change the default configuration of the register.
+     This parameter is required only for cfbb. */
+    /* Step 1: Configure the output clock of the Fro ring in the TRN. */
+    hisc_com_trng_fro_sample_clk_sel clk_sel = {0};
+    hisc_com_trng_fro_div_cnt div_cnt = {0};
+    clk_sel.u32 = trng_reg_read(HISC_COM_TRNG_FRO_SAMPLE_CLK_SEL);
+    /* If it is not configured, configure it. */
+    if (clk_sel.bits.fro_sample_clk_sel != TRNG_INNER_FRO_CLK) {
+        /* Configure it to use the output clock of the TRNG's internal FRO ring */
+        clk_sel.bits.fro_sample_clk_sel = TRNG_INNER_FRO_CLK;
+        trng_reg_write(HISC_COM_TRNG_FRO_SAMPLE_CLK_SEL, clk_sel.u32);
+        /* Divide the frequency of the output clock of the FRO ring by 54. */
+        div_cnt.u32 = trng_reg_read(HISC_COM_TRNG_FRO_DIV_CNT);
+        div_cnt.bits.fro_div_cnt = TRNG_INNER_FRO_DIV_CNT;
+        trng_reg_write(HISC_COM_TRNG_FRO_DIV_CNT, div_cnt.u32);
+    }
+#endif /* CONFIG_ENTROPY_SOURCES_FROM_FRO */
+#if defined(CONFIG_TRNG_RING_ENABLE)
+    inner_trng_ring_enable(TD_TRUE);
+    crypto_udelay_ex(TRNG_RING_ENABLE_WAIT_US);
+#endif /* CONFIG_TRNG_RING_ENABLE */
+    g_hal_trng_init_flag = TD_TRUE;
+    return TD_SUCCESS;
+}
+
+td_s32 hal_cipher_trng_deinit(void)
+{
+#if defined(CONFIG_TRNG_RING_ENABLE)
+    inner_trng_ring_enable(TD_FALSE);
+#endif /* CONFIG_TRNG_RING_ENABLE */
+    g_hal_trng_init_flag = TD_FALSE;
+    return TD_SUCCESS;
+}
+
+static td_bool is_trng_ready(void)
+{
+    hisc_com_trng_fifo_ready trng_ready = {0};
+
+    if (crypto_get_cpu_type() != CRYPTO_CPU_TYPE_SCPU) { /* Not check status on non-secure Core */
+        return TD_TRUE;
+    }
+
+    trng_ready.u32 = 0;  /* trng not done, and not ready. */
+    trng_ready.u32 = trng_reg_read(HISC_COM_TRNG_FIFO_READY);
+
+    if ((trng_ready.bits).trng_done != TRNG_DONE ||
+        (trng_ready.bits).trng_data_ready != TRNG_DATA_READY) {
+            return TD_FALSE;
+    }
+    return TD_TRUE;
+}
+
+td_s32 hal_cipher_trng_get_random(td_u32 *randnum)
+{
+    td_u32 times = 0;
+    td_u32 chk_randnum = 0;
+
+    crypto_chk_return(g_hal_trng_init_flag == TD_FALSE, TRNG_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(randnum == TD_NULL, TRNG_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "randnum is NULL\n");
+
+    while (times < CONFIG_TRNG_TIMEOUT_IN_US) {
+        times++;
+        if (is_trng_ready() == TD_FALSE) {
+            continue;
+        }
+
+        if (is_trng_ready() == TD_TRUE) {
+            *randnum = trng_reg_read(HISC_COM_TRNG_FIFO_DATA);
+            chk_randnum = trng_reg_read(HISC_COM_TRNG_FIFO_DATA);
+            if ((*randnum != 0x00000000) && (*randnum != 0xffffffff) && (*randnum != chk_randnum)) {
+                return TD_SUCCESS;
+            }
+        }
+    }
+
+    crypto_log_err("get_trng timeout\n");
+    return TRNG_COMPAT_ERRNO(ERROR_GET_TRNG_TIMEOUT);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/hal_code/trng_v4/hal_trng_reg.h b/bsp/security_subsys/security_subsys_common/hal_code/trng_v4/hal_trng_reg.h
new file mode 100644
index 0000000..18e08a9
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/hal_code/trng_v4/hal_trng_reg.h
@@ -0,0 +1,78 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal trng register header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_TRNG_REG_H
+#define HAL_TRNG_REG_H
+
+#include "crypto_type.h"
+
+/*! \Define the offset of TRNG reg */
+#define HISC_COM_TRNG_FIFO_DATA             (0x100)
+#define HISC_COM_TRNG_FIFO_READY            (0x104)
+#define HISC_COM_TRNG_DATA_ST               (0x108)
+#define HISC_COM_TRNG_FRO_SAMPLE_CLK_SEL    (0x174)
+#define HISC_COM_TRNG_FRO_DIV_CNT           (0x178)
+#define TRNG_SEC_CFB                        (0x52001600)
+
+#define TRNG_DONE                           1
+#define TRNG_DATA_READY                     1
+#define TRNG_INNER_FRO_CLK                  0x1
+#define TRNG_INNER_FRO_DIV_CNT              0x1b
+#define TRNG_RING_ENABLE                    1
+#define TRNG_RING_DISABLE                   0
+
+/* Define the union hisc_com_trng_fifo_ready */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32    trng_data_ready             :  1;  /* [0]  */
+        td_u32    trng_done                   :  1;  /* [1]  */
+        td_u32    reserved_0                  :  30; /* [31..2]  */
+    } bits;
+
+    /* Define an unsigned member */
+    td_u32    u32;
+} hisc_com_trng_fifo_ready;
+
+/* Define the union U_HISC_COM_TRNG_FRO_SAMPLE_CLK_SEL */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32  fro_sample_clk_sel  : 1;    /* [0] */
+        td_u32  reserved_0          : 31;    /* [31..1] */
+    } bits;
+
+    /* Define an unsigned member */
+    td_u32  u32;
+} hisc_com_trng_fro_sample_clk_sel;
+
+
+/* Define the union U_HISC_COM_TRNG_FRO_DIV_CNT */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u32  fro_div_cnt     : 8; /* [7..0] */
+        td_u32  reserved_0      : 24;   /* [31..8] */
+    } bits;
+
+    /* Define an unsigned member */
+    td_u32  u32;
+} hisc_com_trng_fro_div_cnt;
+
+/* Define the union TRNG_SEC_CFG */
+typedef union {
+    /* Define the struct bits */
+    struct {
+        td_u16  trng_ring_en     : 1;   /* [0] */
+        td_u16  reserved_0       : 15;  /* [15..1] */
+    } bits;
+
+    /* Define an unsigned member */
+    td_u16  u16;
+} trng_sec_cfg;
+#endif
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_def.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_def.h
new file mode 100644
index 0000000..83f2dc1
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_def.h
@@ -0,0 +1,161 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto common def header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef CRYPTO_COMMON_DEF_H
+#define CRYPTO_COMMON_DEF_H
+
+#define MS_TO_US        1000
+
+#define CRYPTO_BITS_IN_BYTE         8
+#define CRYPTO_BYTE_MAX             0xFF
+
+#define CRYPTO_AES_IV_SIZE          16
+#define CRYPTO_AES_IV_SIZE_IN_WORD  4
+#define CRYPTO_WORD_WIDTH           4
+#define CRYPTO_IV_LEN_IN_BYTES      16
+
+#define CRYPTO_128_KEY_LEN          16
+#define CRYPTO_192_KEY_LEN          24
+#define CRYPTO_256_KEY_LEN          32
+
+#define CRYPTO_AES_MAX_TAG_SIZE     16
+#define CRYPTO_AES_CCM_N_LEN_IN_BYTES   16
+
+#define CRYPTO_AES_BLOCK_SIZE_IN_BYTES  16
+
+#define CRYPTO_BIT_3        3
+#define CRYPTO_BIT_6        6
+#define CRYPTO_BIT_8        8
+#define CRYPTO_BIT_16       16
+#define CRYPTO_BIT_24       24
+#define CRYPTO_BYTE_1        1
+#define CRYPTO_BYTE_2        2
+#define CRYPTO_BYTE_3        3
+
+#define CRYPTO_AES_CCM_NQ_LEN           14
+#define CRYPTO_SYMC_CCM_Q_LEN_2B        2
+#define CRYPTO_SYMC_CCM_Q_LEN_3B        3
+#define CRYPTO_SYMC_CCM_Q_LEN_4B        4
+#define CRYPTO_SYMC_CCM_HEADER_LEN      2
+
+#define HASH_SHA1_BLOCK_SIZE   64
+#define HASH_SHA224_BLOCK_SIZE 64
+#define HASH_SHA256_BLOCK_SIZE 64
+#define HASH_SHA384_BLOCK_SIZE 128
+#define HASH_SHA512_BLOCK_SIZE 128
+#define HASH_SM3_BLOCK_SIZE    64
+#define HASH_MAX_BLOCK_SIZE     128
+
+#define HASH_SHA1_RESULT_SIZE   20
+#define HASH_SHA224_RESULT_SIZE 28
+#define HASH_SHA256_RESULT_SIZE 32
+#define HASH_SHA384_RESULT_SIZE 48
+#define HASH_SHA512_RESULT_SIZE 64
+#define HASH_SM3_RESULT_SIZE    32
+#define HASH_MAX_RESULT_SIZE    64
+
+#define HASH_STATE_SIZE_160     20
+#define HASH_STATE_SIZE_256     32
+#define HASH_STATE_SIZE_512     64
+
+#define CRYPTO_GCM_SPECIAL_IV_BYTES     12
+#define CRYPTO_AES_MAX_TAG_LEN          16
+
+#define CRYPTO_CENC_IV_LEN              8
+
+#define CRYPTO_TYPE_ENCRYPT             0x0
+#define CRYPTO_TYPE_DECRYPT             0x1
+#define CRYPTO_TYPE_DMA                 0x2
+
+#define CRYPTO_RSA_1024_LEN             128
+#define CRYPTO_RSA_2048_LEN             256
+#define CRYPTO_RSA_3072_LEN             384
+#define CRYPTO_RSA_4096_LEN             512
+
+#define SM2_LEN_IN_BYTES                32
+
+/* Memory Limit. */
+#define CRYPTO_MAX_AAD_SIZE         (4 * 1024)
+#define CRYPTO_MAX_CRYPTO_SIZE      (4 * 1024)
+
+/* PBKDF2 Limits. */
+#define CRYPTO_PBKDF2_PASS_MAX_LENGTH   1024
+#define CRYPTO_PBKDF2_SALT_MAX_LENGTH   1024
+#define CRYPTO_PBKDF2_OUT_MAX_LENGTH    1024
+#define CRYPTO_PBKDF2_MAX_COUNT         100000
+
+/* Hash Limits. */
+#define CRYPTO_HASH_KEY_MAX_LENGTH      128
+#define CRYPTO_HASH_MIN_LEN             20
+#define CRYPTO_HASH_MAX_LEN             64
+#define CRYPTO_HASH_UPDATE_MAX_LEN      0xffff0000
+#define CRYPTO_SHA256_BLOCK_SIZE        64
+
+/* CENC Limits. */
+#define CRYPTO_SYMC_CENC_SUBSAMPLE_MAX_SIZE     200
+
+/* SYMC Limits. */
+#define CRYPTO_SYMC_MULTI_PACK_MAX_SIZE         200
+#define CRYPTO_SYMC_AAD_MAX_SIZE                (4 * 1024)
+#define CRYPTO_SYMC_MAC_UPDATE_MAX_LEN          0xffff0000
+
+/* PKE Limits. */
+#define CRYPTO_PKE_ECC_KEY_MIN_SIZE             32
+#define CRYPTO_PKE_ECC_KEY_MAX_SIZE             72
+#define CRYPTO_PKE_RSA_KEY_MIN_SIZE             256
+#define CRYPTO_PKE_RSA_KEY_MAX_SIZE             512
+
+/* TRNG Limits. */
+#define CRYPTO_MULTI_RANDOM_MAX_LENGTH          1024
+
+/* HKDF Limits. */
+#define HKDF_EXPAND_INFO_MAX_LENGTH                1024
+
+#define CRYPTO_PKE_MSG_MIN_SIZE                 1
+#define CRYPTO_PKE_MSG_MAX_SIZE                 (2 * 1024 * 1024)
+#define CRYPTO_PKE_SM2_ID_MIN_SIZE              1
+#define CRYPTO_PKE_SM2_ID_MAX_SIZE              1024
+#define CRYPTO_PKE_SM2_PLAIN_TEXT_MIN_SIZE      1
+#define CRYPTO_PKE_SM2_PLAIN_TEXT_MAX_SIZE      1024
+#define CRYPTO_PKE_RSA_LABLE_MAX_SIZE           1024
+
+#define CRYPTO_SM2_ADD_LENGTH_IN_BYTE           97
+
+#define KAPI_SYMC_MODULE_ID                 0x01
+#define KAPI_HASH_MODULE_ID                 0x02
+#define KAPI_KEYSLOT_MODULE_ID              0x03
+#define KAPI_KLAD_MODULE_ID                 0x04
+/*
+ * Handle Process
+ * Kapi Handle consists of the following parts:
+ *|<---- SOC_ID_CIPHER(8-bit) --->|<---- Reserved(7-bit) --->|
+ * <- Soft alg flag(1-bit) ->|<---- Module ID(8-bit) ---->|<---- Context Idx(8-bit)---->|
+ */
+#define crypto_set_soft_alg_flag(handle)                      ((handle) | 0x10000)
+#define crypto_check_soft_alg_flag(handle)                    (((handle) >> 16) & 0x1)
+#define crypto_get_soft_channel_id(handle)                    ((handle) & 0xff)
+
+#define kapi_get_module_id(kapi_handle)                  (((kapi_handle) >> 8) & 0xff)
+#define kapi_get_ctx_idx(kapi_handle)                    ((kapi_handle) & 0xff)
+#define synthesize_kapi_handle(module_id, ctx_id)             (((0x33) << 24) | ((module_id) << 8) | (ctx_id))
+
+/*
+ *|<---- Reserved(8-bit) --->|<- keyslot_type(8-bit) ->|<---- Module ID(8-bit) ---->|<---- Context Idx(8-bit)---->|
+ * keyslot_type: 0 - MCIPHER, 1 - HMAC
+ */
+#define crypto_keyslot_compat_handle(keyslot_type, idx) \
+    (((keyslot_type) << 16) | ((KAPI_KEYSLOT_MODULE_ID) << 8) | (idx))
+#define crypto_keyslot_compat_hmac_handle(idx)  crypto_keyslot_compat_handle(1, idx)
+#define crypto_keyslot_compat_mcipher_handle(idx)  crypto_keyslot_compat_handle(0, idx)
+#define crypto_keyslot_is_hmac(handle)          ((((handle) >> 16) & 0xff) == 0x1)
+#define crypto_keyslot_is_mcipher(handle)       ((((handle) >> 16) & 0xff) == 0)
+#define crypto_keyslot_get_idx(handle)          ((handle) & 0xff)
+#define crypto_keyslot_get_module_id(handle)    (((handle) >> 8) & 0xff)
+
+#endif
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_macro.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_macro.h
new file mode 100644
index 0000000..98518ed
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_macro.h
@@ -0,0 +1,218 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto common def header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef CRYPTO_COMMON_MACRO_H
+#define CRYPTO_COMMON_MACRO_H
+
+#ifndef CRYPTO_STATIC
+#define CRYPTO_STATIC static
+#endif
+
+#define crypto_addr_h(addr)     (unsigned int)(((addr) & 0xFFFFFFFF00000000) >> 32)
+#define crypto_addr_l(addr)     (unsigned int)((addr) & 0xFFFFFFFF)
+
+#define crypto_cpu_to_be32(v) ((((td_u32)(v)) >> 24) | ((((td_u32)(v)) >> 8) & 0xff00) \
+    | ((((td_u32)(v)) << 8) & 0xff0000) | (((td_u32)(v)) << 24))
+
+#define crypto_max(a, b)    ((a) > (b)) ? (a) : (b)
+#define crypto_min(a, b)    ((a) > (b)) ? (b) : (a)
+
+#ifndef crypto_unused
+#define crypto_unused(x)    (td_void)(x)
+#endif
+
+#define crypto_array_size(arr)  (sizeof(arr) / sizeof((arr)[0]))
+
+#define crypto_reg_read(reg_addr)               (*(volatile td_u32 *)(uintptr_t)(reg_addr))
+#define crypto_reg_write(reg_addr, value)       (*(volatile td_u32 *)(uintptr_t)(reg_addr) = (value))
+#define crypto_reg_read_u16(reg_addr)           (*(volatile td_u16 *)(uintptr_t)(reg_addr))
+
+#define crypto_set_bits(src, bit)   ((src) |= (1 << (bit)))
+#define crypto_clear_bits(src, bit) ((src) &= ~(1 << (bit)))
+
+/* Assert Check. */
+#if defined(CONFIG_CRYPTO_ASSERT_ENABLE)
+#define crypto_assert_eq(a, b) do { \
+    if ((a) != (b)) {   \
+        crypto_log_err("ASSERT_EQ Failure. \nExpected: %s == %s\nReal: %s is 0x%x, %s is 0x%x\n",   \
+            #a, #b, #a, a, #b, b);  \
+    }   \
+} while (0)
+#define crypto_assert_neq(a, b) do { \
+    if ((a) == (b)) {   \
+        crypto_log_err("ASSERT_EQ Failure. \nExpected: %s != %s\nReal: %s is 0x%x, %s is 0x%x\n",   \
+            #a, #b, #a, a, #b, b);  \
+    }   \
+} while (0)
+#else
+#define crypto_assert_eq(a, b)
+#define crypto_assert_neq(a, b)
+#endif
+
+/* Error Check. */
+#ifndef crypto_chk_print
+#define crypto_chk_print(cond, ...) do {      \
+    if (cond) {                                         \
+        crypto_log_err(__VA_ARGS__);                       \
+    }                                                   \
+} while (0)
+#endif
+
+#ifndef crypto_chk_return
+#define crypto_chk_return(cond, err_ret, ...) do {      \
+    if (cond) {                                         \
+        crypto_log_err(__VA_ARGS__);                       \
+        return err_ret;                                 \
+    }                                                   \
+} while (0)
+#endif
+
+#ifndef crypto_chk_return_only
+#define crypto_chk_return_only(cond, err_ret) do {      \
+    if (cond) {                                         \
+        return err_ret;                                 \
+    }                                                   \
+} while (0)
+#endif
+
+#ifndef crypto_chk_return_void
+#define crypto_chk_return_void(cond, ...) do { \
+    if (cond) { \
+        crypto_log_err(__VA_ARGS__);                       \
+        return; \
+    }   \
+} while (0)
+#endif
+
+#ifndef crypto_chk_goto
+#define crypto_chk_goto(cond, label, ...) do {          \
+    if (cond) {                                         \
+        crypto_log_err(__VA_ARGS__);                       \
+        goto label;                                     \
+    }                                                   \
+} while (0)
+#endif
+
+/* Input Params Check. */
+#ifndef crypto_param_require
+#define crypto_param_require(cond)  do {                \
+    if (!(cond)) {                                      \
+        crypto_log_err("Param Check %s failed\n", #cond);  \
+        return CRYPTO_FAILURE;                          \
+    }                                                   \
+} while (0)
+#endif
+
+#ifndef crypto_param_check
+#define crypto_param_check(cond)  do {                  \
+    if (cond) {                                         \
+        crypto_log_err("Param Check %s failed\n", #cond);  \
+        return CRYPTO_FAILURE;                          \
+    }                                                   \
+} while (0)
+#endif
+
+#ifndef crypto_chk_goto_with_ret
+#define crypto_chk_goto_with_ret(ret, cond, label, err_ret, fmt, ...) do {           \
+    if (cond) {                                                                 \
+        crypto_log_err(fmt, ##__VA_ARGS__);                                        \
+        ret = err_ret;                                                          \
+        goto label;                                                             \
+    }                                                                           \
+} while (0)
+#endif
+
+#ifndef crypto_print_func_err
+#define crypto_print_func_err(_func, _err_code) do { \
+    crypto_log_err("%s failed! error code: 0x%x \r\n", #_func, _err_code); \
+} while (0)
+#endif
+
+#ifndef crypto_chk_func_return
+#define crypto_chk_func_return(func, ret) do { \
+    if ((ret) != TD_SUCCESS) { \
+        crypto_print_func_err(func, ret);   \
+        return ret; \
+    }   \
+} while (0)
+#endif
+
+#ifndef drv_crypto_pke_check_param
+#define drv_crypto_pke_check_param(cond) do {       \
+    if (cond) {         \
+        crypto_log_err("%s invalid\n", #cond);  \
+        return DRV_COMPAT_ERRNO(ERROR_MODULE_PKE, ERROR_INVALID_PARAM);     \
+    }       \
+} while (0)
+#endif
+
+#ifndef hal_crypto_pke_check_param
+#define hal_crypto_pke_check_param(cond) do {       \
+    if (cond) {         \
+        crypto_log_err("%s invalid\n", #cond);  \
+        return HAL_COMPAT_ERRNO(ERROR_MODULE_PKE, ERROR_INVALID_PARAM);     \
+    }       \
+} while (0)
+#endif
+
+#if defined(CONFIG_CRYPTO_LOG_PTR_CHK_INFO_DISABLE)
+#define crypto_null_ptr_chk(ptr, errno)    \
+    crypto_chk_return((ptr) == TD_NULL, errno, "param is NULL\n")
+#else
+#define crypto_null_ptr_chk(ptr, errno)    \
+    crypto_chk_return((ptr) == TD_NULL, errno, #ptr " is NULL\n")
+#endif
+
+#define symc_null_ptr_chk(ptr)      crypto_null_ptr_chk(ptr, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL))
+#define hash_null_ptr_chk(ptr)      crypto_null_ptr_chk(ptr, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL))
+#define pke_null_ptr_chk(ptr)       crypto_null_ptr_chk(ptr, PKE_COMPAT_ERRNO(ERROR_PARAM_IS_NULL))
+#define trng_null_ptr_chk(ptr)      crypto_null_ptr_chk(ptr, TRNG_COMPAT_ERRNO(ERROR_PARAM_IS_NULL))
+#define km_null_ptr_chk(ptr)        crypto_null_ptr_chk(ptr, KM_COMPAT_ERRNO(ERROR_PARAM_IS_NULL))
+
+#if defined(CRYPTO_HAL_FUNC_TRACE_ENABLE)
+#define crypto_hal_func_enter()        crypto_print("########%s===>Enter\n", __func__)
+#define crypto_hal_func_exit()         crypto_print("########%s<===Exit\n", __func__)
+#else
+#define crypto_hal_func_enter()
+#define crypto_hal_func_exit()
+#endif
+
+#if defined(CRYPTO_KAPI_FUNC_TRACE_ENABLE)
+#define crypto_kapi_func_enter()        crypto_print("%s===>Enter\n", __func__)
+#define crypto_kapi_func_exit()         crypto_print("%s<===Exit\n", __func__)
+#else
+#define crypto_kapi_func_enter()
+#define crypto_kapi_func_exit()
+#endif
+
+#if defined(CRYPTO_DRV_FUNC_TRACE_ENABLE)
+#define crypto_drv_func_enter()        crypto_print("####%s===>Enter\n", __func__)
+#define crypto_drv_func_exit()         crypto_print("####%s<===Exit\n", __func__)
+#else
+#define crypto_drv_func_enter()
+#define crypto_drv_func_exit()
+#endif
+
+#if defined(CRYPTO_DISPATCH_FUNC_TRACE_ENABLE)
+#define crypto_dispatch_func_enter()        crypto_print("%s===>Enter\n", __func__)
+#define crypto_dispatch_func_exit()         crypto_print("%s<===Exit\n", __func__)
+#else
+#define crypto_dispatch_func_enter()
+#define crypto_dispatch_func_exit()
+#endif
+
+#if defined(CRYPTO_UAPI_FUNC_TRACE_ENABLE)
+#define crypto_uapi_func_enter()    crypto_print("%s ===>Enter\n", __func__)
+#define crypto_uapi_func_exit()     crypto_print("%s <===Exit\n", __func__)
+#else
+#define crypto_uapi_func_enter()
+#define crypto_uapi_func_exit()
+#endif
+
+#endif
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_struct.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_struct.h
new file mode 100644
index 0000000..1827f28
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_common_struct.h
@@ -0,0 +1,112 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto common def header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef CRYPTO_COMMON_STRUCT_H
+#define CRYPTO_COMMON_STRUCT_H
+
+#include "crypto_type.h"
+
+/* ! \union of compat addr */
+typedef union {
+    void *p;                /* !<  virtual address */
+    unsigned long long phy; /* !<  physical address */
+    unsigned int word[2];   /* !<  2 word of address */
+} crypto_compat_addr;
+
+typedef enum {
+    CRYPTO_BUF_SECURE,
+    CRYPTO_BUF_NONSECURE,
+} crypto_buffer_secure;
+
+typedef struct {
+    unsigned long long uapi_mem_handle;     /* Handle to buffer header address */
+    unsigned long long addr_offset;         /* buffer offset, unused. */
+    td_void *kapi_mem_handle;
+
+    unsigned long long phys_addr;
+    void *virt_addr;
+    crypto_buffer_secure buf_sec;           /* NONSECURE or SECURE */
+} crypto_buf_attr;
+
+typedef enum {
+    CPU_ID_AIDSP = 0x00000035,
+    CPU_ID_PCPU = 0x0000006a,
+    CPU_ID_SCPU = 0x000000a5,
+    CPU_ID_ACPU = 0x000000aa,
+    CPU_ID_INVALID = 0xffffffff
+} ca_misc_cpu_id;
+
+typedef enum {
+    CRYPTO_MEM_TYPE_MMZ,
+    CRYPTO_MEM_TYPE_SMMU,
+} crypto_mem_type;
+
+typedef enum {
+    CRYPTO_CPU_TYPE_SCPU,
+    CRYPTO_CPU_TYPE_ACPU,
+    CRYPTO_CPU_TYPE_HPPCPU,
+    CRYPTO_CPU_TYPE_PCPU,
+    CRYPTO_CPU_TYPE_AIDSP,
+    CRYPTO_CPU_TYPE_INVALID
+} crypto_cpu_type;
+
+typedef enum {
+    IN_NODE_TYPE_FIRST = 1 << 0,
+    IN_NODE_TYPE_NORMAL = 1 << 1,
+    IN_NODE_TYPE_LAST = 1 << 2,
+    /* CCM. */
+    IN_NODE_TYPE_CCM_N = 1 << 3,
+    IN_NODE_TYPE_CCM_AAD = 1 << 4,
+    IN_NODE_TYPE_CCM_P = 1 << 5,
+    IN_NODE_TYPE_CCM_LAST = 1 << 6,
+    /* GCM. */
+    IN_NODE_TYPE_GCM_FIRST = 1 << 7,
+    IN_NODE_TYPE_GCM_A = 1 << 8,
+    IN_NODE_TYPE_GCM_P = 1 << 9,
+    IN_NODE_TYPE_GCM_LEN = 1 << 10,
+    IN_NODE_TYPE_GCM_GHASH = 1 << 11,
+    IN_NODE_TYPE_GCM_IV = 1 << 12,
+} in_node_type_e;
+
+typedef void *(*func_malloc)(unsigned int size);
+typedef void (*func_free)(const void *ptr);
+typedef void (*func_udelay)(unsigned int us);
+typedef void *(*func_malloc_coherent)(unsigned int size, crypto_mem_type mem_type, const td_char *name);
+typedef void (*func_free_coherent)(void *ptr);
+typedef td_u64 (*func_get_phys_address)(const void *ptr);
+typedef void *(*func_get_virt_addr)(void *ptr);
+typedef td_bool (*func_get_smmu_table_addr)(td_u64 *table, td_u64 *rdaddr, td_u64 *wraddr);
+typedef void *(*func_register_coherent_mem)(void *virt_addr, td_u64 phys_addr, unsigned int size);
+typedef void (*func_unregister_coherent_mem)(void *virt_addr);
+typedef crypto_cpu_type (*func_get_cpu_type)(void);
+typedef td_u32 (*func_get_pke_rom_lib_start_addr)(td_void);
+
+typedef struct {
+    func_malloc malloc;
+    func_free free;
+    func_udelay udelay;
+} crypto_romable_drv_func;
+
+typedef struct {
+    func_malloc_coherent malloc_coherent;
+    func_free_coherent free_coherent;
+    func_get_phys_address get_phys_addr;
+    func_get_virt_addr get_virt_addr;
+    func_get_smmu_table_addr get_smmu_table_addr;
+    func_register_coherent_mem register_coherent_mem;
+    func_unregister_coherent_mem unregister_coherent_mem;
+    func_get_cpu_type get_cpu_type;
+    func_get_pke_rom_lib_start_addr get_pke_rom_lib_start_addr;
+} crypto_drv_func;
+
+typedef td_bool (*drv_wait_condition_func)(const td_void *param);
+typedef td_s32 (*crypto_wait_timeout_interruptible)(const td_void *wait, drv_wait_condition_func func,
+    const td_void *param, const td_u32 timeout_ms);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_errno.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_errno.h
new file mode 100755
index 0000000..aee5d28
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_errno.h
@@ -0,0 +1,160 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto common def header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef CRYPTO_ERRNO_H
+#define CRYPTO_ERRNO_H
+#include "ot_type.h"
+/**
+ * The Struction of Error Number is as follows:
+ * Env(4 bits) | Layer(4 bits) | Modules(4 bits) | Reserved(12 bits) | Error Code(8 bits)
+ **/
+
+/* Error for Environments Definition. */
+#define ERROR_ENV_LINUX         0x1
+#define ERROR_ENV_ITRUSTEE      0x2
+#define ERROR_ENV_OPTEE         0x3
+#define ERROR_ENV_LITEOS        0x4
+#define ERROR_ENV_SELITEOS      0x5
+#define ERROR_ENV_NOOS          0x6
+#define ERROR_ENV_FREERTOS      0x7
+#define ERROR_ENV_ALIOS         0x8
+
+/* Error for Layer Enumerations. */
+enum {
+    ERROR_LAYER_UAPI = 0x1,
+    ERROR_LAYER_DISPATCH,
+    ERROR_LAYER_KAPI,
+    ERROR_LAYER_DRV,
+    ERROR_LAYER_HAL,
+};
+
+/* Error for Module Enumerations. */
+enum {
+    ERROR_MODULE_SYMC = 0x1,
+    ERROR_MODULE_HASH,
+    ERROR_MODULE_PKE,
+    ERROR_MODULE_TRNG,
+    ERROR_MODULE_KM,
+    ERROR_MODULE_OTP,
+    ERROR_MODULE_OTHER
+};
+
+/* Error for Error Code Enumerations. */
+enum {
+    /* Common Error Code. 0x01 ~ 0x3F. */
+    ERROR_INVALID_PARAM = 0x1,      /* return when the input param's value is not in the valid range. */
+    ERROR_PARAM_IS_NULL,            /* return when the input param is NULL and required not NULL. */
+    ERROR_NOT_INIT,                 /* return when call other functions before call init function. */
+    ERROR_UNSUPPORT,                /* return when some configuration is unsupport. */
+    ERROR_UNEXPECTED,               /* reture when unexpected error occurs. */
+    ERROR_TRY_TIMES,                /* return when the number of try attempts failed. */
+    ERROR_CHN_BUSY,                 /* return when try to create one channel but all channels are busy. */
+    ERROR_CTX_CLOSED,               /* return when using one ctx to do something but has been closed. */
+    ERROR_NOT_SET_CONFIG,           /* return when not set_config but need for symc. */
+    ERROR_NOT_ATTACHED,             /* return when not attach but need for symc. */
+    ERROR_NOT_SET_SESSION_KEY,      /* return when not set_session_key but need for klad. */
+    ERROR_NOT_MAC_START,            /* return when not mac_start but need for symc. */
+    ERROR_INVALID_HANDLE,           /* return when pass one invalid handle. */
+    ERROR_GET_PHYS_ADDR,            /* return when transfer from virt_addr to phys_addr failed. */
+    ERROR_SYMC_LEN_NOT_ALIGNED,     /* return when length isn't aligned to 16-Byte except CTR/CCM/GCM.  */
+    ERROR_SYMC_ADDR_NOT_ALIGNED,    /* return when the phys_addr writing to register is not aligned to 4-Byte. */
+    ERROR_PKE_RSA_SAME_DATA,        /* return when rsa exp_mod, the input is equal to output. */
+    ERROR_PKE_RSA_CRYPTO_V15_CHECK, /* return when rsa crypto v15 padding check failed. */
+    ERROR_PKE_RSA_CRYPTO_OAEP_CHECK,    /* return when rsa crypto oaep padding check failed. */
+    ERROR_PKE_RSA_VERIFY_V15_CHECK,     /* return when rsa verify v15 padding check failed. */
+    ERROR_PKE_RSA_VERIFY_PSS_CHECK,     /* return when rsa verify pss padding check failed. */
+    ERROR_PKE_RSA_GEN_KEY,          /* return when rsa generate key failed. */
+    ERROR_PKE_SM2_DECRYPT,          /* return when sm2 decrypt failed. */
+    ERROR_ECDSA_SIGN_R_IS_ZERO,     /* return when ecdsa sign, the sig_r is zero. */
+    ERROR_ECDSA_SIGN_S_IS_ZERO,     /* return when ecdsa sign, the sig_s is zero. */
+    ERROR_PKE_ECDSA_VERIFY_CHECK,   /* return when ecdsa verify check failed. */
+    ERROR_OTP_ADDR_NOT_ALIGNED,     /* return when otp address is not aligned to 4. */
+    ERROR_HASH_ADDR_NOT_ALIGNED,    /* return when hash data's address is not aligned */
+    ERROR_HASH_LEN_NOT_ALIGNED,     /* return when hash length is not aligned to block size. */
+
+    /* Outer's Error Code. 0x40 ~ 0x5F. */
+    ERROR_MEMCPY_S      = 0x40,     /* return when call memcpy_s failed. */
+    ERROR_MALLOC,                   /* return when call xxx_malloc failed. */
+    ERROR_MUTEX_INIT,               /* return when call xxx_mutex_init failed. */
+    ERROR_MUTEX_LOCK,               /* return when call xxx_lock failed. */
+    /* Specific Error Code for UAPI. 0x60 ~ 0x6F. */
+    ERROR_DEV_OPEN_FAILED,          /* return when open dev failed. */
+    ERROR_COUNT_OVERFLOW,           /* return when call init too many times. */
+
+    /* Specific Error Code for Dispatch. 0x70 ~ 0x7F. */
+    ERROR_CMD_DISMATCH  = 0x70,     /* return when cmd is dismatched. */
+    ERROR_COPY_FROM_USER,           /* return when call copy_from_user failed. */
+    ERROR_COPY_TO_USER,             /* return when call copy_to_user failed. */
+    ERROR_MEM_HANDLE_GET,           /* return when parse user's mem handle to kernel's mem handle failed. */
+    ERROR_GET_OWNER,                /* return when call crypto_get_owner failed. */
+
+    /* Specific Error Code for KAPI. 0x80 ~ 0x8F. */
+    ERROR_PROCESS_NOT_INIT = 0x80,  /* return when one process not call kapi_xxx_init first. */
+    ERROR_MAX_PROCESS,              /* return when process's num is over the limit. */
+    ERROR_MEMORY_ACCESS,            /* return when access the memory that does not belong to itself.  */
+    ERROR_INVALID_PROCESS,          /* return when the process accesses resources of other processes. */
+    /* Specific Error Code for DRV. 0x90 ~ 0x9F. */
+
+    /* Specific Error Code for HAL. 0xA0 ~ 0xAF. */
+    ERROR_HASH_LOGIC    = 0xA0,     /* return when hash logic's error occurs. */
+    ERROR_PKE_LOGIC,                /* return when pke logic's error occurs. */
+    ERROR_INVALID_CPU_TYPE,         /* return when logic get the invalid cpu type. */
+    ERROR_INVALID_REGISTER_VALUE,   /* return when value in register is invalid. */
+    ERROR_INVALID_PHYS_ADDR,        /* return when phys_addr is invalid. */
+    ERROR_OTP_PERMISSION,           /* return when otp access is forbidden. */
+    ERROR_KM_LOGIC,                  /* return when km logic's error occurs. */
+    ERROR_KM_KL_LOGIC,              /* return when km HKL logic's error occurs. */
+    ERROR_KM_KC_LOGIC,              /* return when km KEY CTRL logic's error occurs. */
+    ERROR_KLAD_ROOTKEY_NOT_READY,   /* return when klad rootkey is not ready. */
+
+    /* Specific Error Code for Timeout. 0xB0 ~ 0xBF. */
+    ERROR_GET_TRNG_TIMEOUT = 0xB0,  /* return when logic get rnd timeout. */
+    ERROR_HASH_CLEAR_CHN_TIMEOUT,   /* return when clear hash channel timeout. */
+    ERROR_HASH_CALC_TIMEOUT,        /* return when hash calculation timeout. */
+    ERROR_SYMC_CLEAR_CHN_TIMEOUT,   /* return when clear symc channel timeout. */
+    ERROR_SYMC_CALC_TIMEOUT,        /* return when symc crypto timeout. */
+    ERROR_SYMC_GET_TAG_TIMEOUT,     /* return when symc get tag timeout. */
+    ERROR_PKE_LOCK_TIMEOUT,         /* return when pke lock timeout. */
+    ERROR_PKE_WAIT_DONE_TIMEOUT,    /* return when pke wait done timeout. */
+    ERROR_PKE_ROBUST_WARNING,    /* return when pke wait done timeout. */
+    ERROR_RKP_LOCK_TIMEOUT,      /* return when rkp lock timeout. */
+    ERROR_RKP_CALC_TIMEOUT,      /* return when rkp calculate timeout. */
+    ERROR_KLAD_COM_ROUTE_TIMEOUT,   /* return when klad com route timeout. */
+    ERROR_OTP_TIMEOUT,          /* return when otp wait timeout. */
+    ERROR_KEYSLOT_TIMEOUT,       /* return when keyslot wait timeout. */
+    ERROR_KEYSLOT_LOCK,          /* return when keyslot lock or unlock fail. */
+    ERROR_KLAD_TIMEOUT,          /* return when klad wait timeout. */
+    ERROR_KLAD_LOCK,             /* return when klad lock or unlock fail. */
+};
+
+#define CRYPTO_COMPAT_ERRNO(env, layer, module, err_code) \
+    ((((env) & 0xF) << 28) | (((layer) & 0xF) << 24) | (((module) & 0xF) << 20) | ((err_code) & 0xFF))
+
+/* Notice: you should define CRYPTO_ERROR_ENV as one of ERROR_ENV_XXX before using these macros. */
+#define UAPI_COMPAT_ERRNO(module, err_code)     \
+    CRYPTO_COMPAT_ERRNO(CRYPTO_ERROR_ENV, ERROR_LAYER_UAPI, module, err_code)
+
+#define DISPATCH_COMPAT_ERRNO(module, err_code)     \
+    CRYPTO_COMPAT_ERRNO(CRYPTO_ERROR_ENV, ERROR_LAYER_DISPATCH, module, err_code)
+
+#define KAPI_COMPAT_ERRNO(module, err_code)     \
+    CRYPTO_COMPAT_ERRNO(CRYPTO_ERROR_ENV, ERROR_LAYER_KAPI, module, err_code)
+
+#define DRV_COMPAT_ERRNO(module, err_code)     \
+    CRYPTO_COMPAT_ERRNO(CRYPTO_ERROR_ENV, ERROR_LAYER_DRV, module, err_code)
+
+#define HAL_COMPAT_ERRNO(module, err_code)      \
+    CRYPTO_COMPAT_ERRNO(CRYPTO_ERROR_ENV, ERROR_LAYER_HAL, module, err_code)
+
+enum {
+    CRYPTO_SUCCESS          = TD_SUCCESS,
+    CRYPTO_FAILURE          = TD_FAILURE,
+};
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_hash_struct.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_hash_struct.h
new file mode 100644
index 0000000..5c6423b
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_hash_struct.h
@@ -0,0 +1,207 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto common def header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef CRYPTO_HASH_STRUCT_H
+#define CRYPTO_HASH_STRUCT_H
+
+#include "crypto_common_struct.h"
+
+/*
+ * Component of crypto_hash_type.
+ * is_hmac(4 bits) | alg(4 bits) | mode(4 bits) | max_message_length(4 bits) | block_size(4 bits) | result_size(12 bits)
+ * is_hmac: h'0 - hash
+ *          h'1 - hmac
+ * alg:     h'0 - sha1
+ *          h'1 - sha2
+ *          h'2 - sm3
+ * mode:    h'0 - 224
+ *          h'1 - 256
+ *          h'2 - 384
+ *          h'3 - 512
+ * max_message_length:
+ *          h'6 - 2**6 -> 64, longest 2**64 Bits. For SHA256.
+ *          h'7 - 2**7 -> 128, longest 2**128 Bits. For SHA384/SHA512.
+ * block_size:
+ *          h'9 - 2**9 -> 512, Block Size is 512 Bits. For SHA256.
+ *          h'a - 2**10 -> 1024, Block Size is 1024 Bits. For SHA384/SHA512.
+ * result_size:
+ *          h'100 - 256, Result Size is 256 Bits. For SHA256.
+ *          h'180 - 384, Result Size is 384 Bits. For SHA384.
+ *          h'200 - 512, Result Size is 512 Bits. For SHA512.
+ */
+#define compat_hash_type(is_hmac, alg, mode, max_message_length, block_size, result_size)          \
+    ((((is_hmac) & 0xF) << 28) | (((alg) & 0xF) << 24) | (((mode) & 0xF) << 20) |                  \
+    (((max_message_length) & 0xF) << 16) | (((block_size) & 0xF) << 12) | ((result_size) & 0xFFF))
+
+#define CRYPTO_HASH_TYPE        0
+#define CRYPTO_HMAC_TYPE        1
+#define CRYPTO_IS_HMAC_MASK     0xF0000000
+#define CRYPTO_IS_HMAC_SHIFT    28
+
+#define CRYPTO_HASH_ALG_SHA1    0
+#define CRYPTO_HASH_ALG_SHA2    1
+#define CRYPTO_HASH_ALG_SM3     2
+#define CRYPTO_HASH_ALG_MASK    0x0F000000
+#define CRYPTO_HASH_ALG_SHIFT   24
+
+#define CRYPTO_HASH_MODE_224    0
+#define CRYPTO_HASH_MODE_256    1
+#define CRYPTO_HASH_MODE_384    2
+#define CRYPTO_HASH_MODE_512    3
+#define CRYPTO_HASH_MODE_UNDEF  0xf
+#define CRYPTO_HASH_MODE_MASK   0x00F00000
+#define CRYPTO_HASH_MODE_SHIFT  20
+
+#define CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT   0x6
+#define CRYPTO_HASH_MAX_MESSAGE_LEN_128BIT  0x7
+#define CRYPTO_HASH_MAX_MESSAGE_LEN_MASK    0x000F0000
+#define CRYPTO_HASH_MAX_MESSAGE_LEN_SHIFT   16
+
+#define CRYPTO_HASH_BLOCK_SIZE_512BIT       0x9
+#define CRYPTO_HASH_BLOCK_SIZE_1024BIT      0xa
+#define CRYPTO_HASH_BLOCK_SIZE_MASK         0x0000F000
+#define CRYPTO_HASH_BLOCK_SIZE_SHIFT        12
+
+#define CRYPTO_HASH_RESULT_SIZE_160BIT      0xa0
+#define CRYPTO_HASH_RESULT_SIZE_224BIT      0xe0
+#define CRYPTO_HASH_RESULT_SIZE_256BIT      0x100
+#define CRYPTO_HASH_RESULT_SIZE_384BIT      0x180
+#define CRYPTO_HASH_RESULT_SIZE_512BIT      0x200
+#define CRYPTO_HASH_RESULT_SIZE_MASK        0x00000FFF
+#define CRYPTO_HASH_RESULT_SIZE_SHIFT       0
+
+#define CRYPTO_HASH_BLOCK_SIZE_20BYTE       0x14
+#define CRYPTO_HASH_BLOCK_SIZE_32BYTE       0x20
+#define CRYPTO_HASH_BLOCK_SIZE_64BYTE       0x40
+
+#define crypto_hash_get_attr(value, mask, shift)         (((td_u32)(value) & (td_u32)(mask)) >> (shift))
+#define crypto_hash_macth(value, mask, target, shift)    (crypto_hash_get_attr(value, mask, shift) == (target))
+
+#define crypto_hash_get_alg(hash_type)              \
+    crypto_hash_get_attr(hash_type, CRYPTO_HASH_ALG_MASK, CRYPTO_HASH_ALG_SHIFT)
+#define crypto_hash_get_mode(hash_type)             \
+    crypto_hash_get_attr(hash_type, CRYPTO_HASH_MODE_MASK, CRYPTO_HASH_MODE_SHIFT)
+#define crypto_hash_is_hmac(hash_type)              \
+    crypto_hash_macth(hash_type, CRYPTO_IS_HMAC_MASK, CRYPTO_HMAC_TYPE, CRYPTO_IS_HMAC_SHIFT)
+#define crypto_hash_get_message_len(hash_type)      \
+    (1 << crypto_hash_get_attr(hash_type, CRYPTO_HASH_MAX_MESSAGE_LEN_MASK, CRYPTO_HASH_MAX_MESSAGE_LEN_SHIFT))
+#define crypto_hash_get_block_size(hash_type)       \
+    (1 << crypto_hash_get_attr(hash_type, CRYPTO_HASH_BLOCK_SIZE_MASK, CRYPTO_HASH_BLOCK_SIZE_SHIFT))
+#define crypto_hash_get_result_size(hash_type)      \
+    crypto_hash_get_attr(hash_type, CRYPTO_HASH_RESULT_SIZE_MASK, CRYPTO_HASH_RESULT_SIZE_SHIFT)
+#define crypto_hash_remove_hmac_flag(hash_type)     \
+    ((hash_type) & (0x0FFFFFFF))
+
+typedef enum {
+    /* Hash. */
+    CRYPTO_HASH_TYPE_SHA1 = compat_hash_type(
+        CRYPTO_HASH_TYPE, CRYPTO_HASH_ALG_SHA1, CRYPTO_HASH_MODE_UNDEF, CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT,
+        CRYPTO_HASH_BLOCK_SIZE_512BIT, CRYPTO_HASH_RESULT_SIZE_160BIT
+    ),
+    CRYPTO_HASH_TYPE_SHA224 = compat_hash_type(
+        CRYPTO_HASH_TYPE, CRYPTO_HASH_ALG_SHA2, CRYPTO_HASH_MODE_224, CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT,
+        CRYPTO_HASH_BLOCK_SIZE_512BIT, CRYPTO_HASH_RESULT_SIZE_224BIT
+    ),
+    CRYPTO_HASH_TYPE_SHA256 = compat_hash_type(
+        CRYPTO_HASH_TYPE, CRYPTO_HASH_ALG_SHA2, CRYPTO_HASH_MODE_256, CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT,
+        CRYPTO_HASH_BLOCK_SIZE_512BIT, CRYPTO_HASH_RESULT_SIZE_256BIT
+    ),
+    CRYPTO_HASH_TYPE_SHA384 = compat_hash_type(
+        CRYPTO_HASH_TYPE, CRYPTO_HASH_ALG_SHA2, CRYPTO_HASH_MODE_384, CRYPTO_HASH_MAX_MESSAGE_LEN_128BIT,
+        CRYPTO_HASH_BLOCK_SIZE_1024BIT, CRYPTO_HASH_RESULT_SIZE_384BIT
+    ),
+    CRYPTO_HASH_TYPE_SHA512 = compat_hash_type(
+        CRYPTO_HASH_TYPE, CRYPTO_HASH_ALG_SHA2, CRYPTO_HASH_MODE_512, CRYPTO_HASH_MAX_MESSAGE_LEN_128BIT,
+        CRYPTO_HASH_BLOCK_SIZE_1024BIT, CRYPTO_HASH_RESULT_SIZE_512BIT
+    ),
+    CRYPTO_HASH_TYPE_SM3 = compat_hash_type(
+        CRYPTO_HASH_TYPE, CRYPTO_HASH_ALG_SM3, CRYPTO_HASH_MODE_256, CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT,
+        CRYPTO_HASH_BLOCK_SIZE_512BIT, CRYPTO_HASH_RESULT_SIZE_256BIT
+    ),
+
+    /* HMAC. */
+    CRYPTO_HASH_TYPE_HMAC_SHA1 = compat_hash_type(
+        CRYPTO_HMAC_TYPE, CRYPTO_HASH_ALG_SHA1, CRYPTO_HASH_MODE_UNDEF, CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT,
+        CRYPTO_HASH_BLOCK_SIZE_512BIT, CRYPTO_HASH_RESULT_SIZE_160BIT
+    ),
+    CRYPTO_HASH_TYPE_HMAC_SHA224 = compat_hash_type(
+        CRYPTO_HMAC_TYPE, CRYPTO_HASH_ALG_SHA2, CRYPTO_HASH_MODE_224, CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT,
+        CRYPTO_HASH_BLOCK_SIZE_512BIT, CRYPTO_HASH_RESULT_SIZE_224BIT
+    ),
+    CRYPTO_HASH_TYPE_HMAC_SHA256 = compat_hash_type(
+        CRYPTO_HMAC_TYPE, CRYPTO_HASH_ALG_SHA2, CRYPTO_HASH_MODE_256, CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT,
+        CRYPTO_HASH_BLOCK_SIZE_512BIT, CRYPTO_HASH_RESULT_SIZE_256BIT
+    ),
+    CRYPTO_HASH_TYPE_HMAC_SHA384 = compat_hash_type(
+        CRYPTO_HMAC_TYPE, CRYPTO_HASH_ALG_SHA2, CRYPTO_HASH_MODE_384, CRYPTO_HASH_MAX_MESSAGE_LEN_128BIT,
+        CRYPTO_HASH_BLOCK_SIZE_1024BIT, CRYPTO_HASH_RESULT_SIZE_384BIT
+    ),
+    CRYPTO_HASH_TYPE_HMAC_SHA512 = compat_hash_type(
+        CRYPTO_HMAC_TYPE, CRYPTO_HASH_ALG_SHA2, CRYPTO_HASH_MODE_512, CRYPTO_HASH_MAX_MESSAGE_LEN_128BIT,
+        CRYPTO_HASH_BLOCK_SIZE_1024BIT, CRYPTO_HASH_RESULT_SIZE_512BIT
+    ),
+    CRYPTO_HASH_TYPE_HMAC_SM3 = compat_hash_type(
+        CRYPTO_HMAC_TYPE, CRYPTO_HASH_ALG_SM3, CRYPTO_HASH_MODE_256, CRYPTO_HASH_MAX_MESSAGE_LEN_64BIT,
+        CRYPTO_HASH_BLOCK_SIZE_512BIT, CRYPTO_HASH_RESULT_SIZE_256BIT
+    ),
+
+    CRYPTO_HASH_TYPE_INVALID = 0xffffffff,
+} crypto_hash_type;
+
+typedef struct {
+    td_u8 *key;
+    td_u32 key_len;
+    td_handle drv_keyslot_handle;
+    crypto_hash_type hash_type;
+    td_bool is_keyslot;
+    td_bool is_long_term;
+} crypto_hash_attr;
+
+/* Structure for HASH. */
+#define CRYPTO_HASH_RESULT_SIZE_MAX 64              // for SHA-512
+#define CRYPTO_HASH_RESULT_SIZE_MAX_IN_WORD 16      // for SHA-512
+#define CRYPTO_HASH_BLOCK_SIZE_MAX 128              // for SHA-512
+
+typedef struct {
+    td_u32 length[2];
+    td_u32 state[CRYPTO_HASH_RESULT_SIZE_MAX_IN_WORD];
+    td_u32 tail_len;
+    crypto_hash_type hash_type;
+    td_u8 o_key_pad[CRYPTO_HASH_BLOCK_SIZE_MAX];
+    td_u8 i_key_pad[CRYPTO_HASH_BLOCK_SIZE_MAX];
+    td_u8 tail[CRYPTO_HASH_BLOCK_SIZE_MAX];
+} crypto_hash_clone_ctx;
+
+typedef struct {
+    crypto_hash_type hmac_type;
+    td_u8 *salt;
+    td_u32 salt_length;
+    td_u8 *ikm;
+    td_u32 ikm_length;
+} crypto_hkdf_extract_t;
+
+typedef struct {
+    crypto_hash_type hmac_type;
+    td_u8 *prk;
+    td_u32 prk_length;
+    td_u8 *info;
+    td_u32 info_length;
+} crypto_hkdf_expand_t;
+
+typedef struct {
+    crypto_hash_type hmac_type;
+    td_u8 *salt;
+    td_u32 salt_length;
+    td_u8 *ikm;
+    td_u32 ikm_length;
+    td_u8 *info;
+    td_u32 info_length;
+} crypto_hkdf_t;
+
+#endif
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_kdf_struct.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_kdf_struct.h
new file mode 100644
index 0000000..b6b9144
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_kdf_struct.h
@@ -0,0 +1,24 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto kdf struct header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef CRYPTO_KDF_STRUCT_H
+#define CRYPTO_KDF_STRUCT_H
+
+#include "crypto_common_struct.h"
+#include "crypto_hash_struct.h"
+
+typedef struct {
+    crypto_hash_type hash_type;
+    td_u8 *password;
+    td_u32 plen;
+    td_u8 *salt;
+    td_u32 slen;
+    td_u16 count;
+} crypto_kdf_pbkdf2_param;
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_km_struct.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_km_struct.h
new file mode 100644
index 0000000..436d776
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_km_struct.h
@@ -0,0 +1,480 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: km struct.
+ * Author: CompanyName
+ * Create: 2023-01-18
+*/
+#ifndef CRYPTO_KM_STRUCT_H
+#define CRYPTO_KM_STRUCT_H
+
+#include "crypto_common_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif  /* __cplusplus */
+
+typedef td_handle           crypto_handle;
+
+enum {
+    /* SBRK0, TEE Global Boot Root Key0, delivered from MRK1, soc_tee_enable and Hash of TEE Root Public Key */
+    KM_KLAD_KEY_TYPE_SBRK0  = 0x03000000,
+    /* SBRK1, TEE Global Boot Root Key1, delivered from MRK1, soc_tee_enable and Hash of TEE Root Public Key */
+    KM_KLAD_KEY_TYPE_SBRK1,
+    /* SBRK2, TEE Global Boot Root Key2, delivered from MRK1, soc_tee_enable and Hash of TEE Root Public Key */
+    KM_KLAD_KEY_TYPE_SBRK2,
+    /* ABRK0, REE Global Boot Root Key0, delivered from MRK1 */
+    KM_KLAD_KEY_TYPE_ABRK0,
+    /* ABRK1, REE Global Boot Root Key1, delivered from MRK1 */
+    KM_KLAD_KEY_TYPE_ABRK1,
+    /* ABRK2, REE Global Boot Root Key2, delivered from MRK1 */
+    KM_KLAD_KEY_TYPE_ABRK2,
+    /* DRK0, TEE unique data decryption root key, delivered from USK */
+    KM_KLAD_KEY_TYPE_DRK0,
+    /* DRK1, REE unique data decryption root key, delivered from USK */
+    KM_KLAD_KEY_TYPE_DRK1,
+    /* RDRK0, TEE random data decryption root key, delivered from RUSK */
+    KM_KLAD_KEY_TYPE_RDRK0,
+    /* RDRK1, REE random data decryption root key, delivered from RUSK */
+    KM_KLAD_KEY_TYPE_RDRK1,
+    /* PSK, delivered from MRK1 */
+    KM_KLAD_KEY_TYPE_PSK,
+    /* ODRK0, TEE flash online decryptin root key, delivered from MRK0/1,
+        soc_tee_enable and Hash of TEE Root Public Key */
+    KM_KLAD_KEY_TYPE_ODRK0,
+    /* OARK0  TEE flash online authentication root key, delivered from MRK0/1,
+        soc_tee_enable and Hash of TEE Root Public Key */
+    KM_KLAD_KEY_TYPE_OARK0,
+    /* ODRK1, REE flash online decryption root key, delivered from MRK1 */
+    KM_KLAD_KEY_TYPE_ODRK1,
+    /* MDRK0 */
+    KM_KLAD_KEY_TYPE_MDRK0,
+    /* MDRK1 */
+    KM_KLAD_KEY_TYPE_MDRK1,
+    /* MDRK2 */
+    KM_KLAD_KEY_TYPE_MDRK2,
+    /* MDRK3 */
+    KM_KLAD_KEY_TYPE_MDRK3,
+
+    KM_KLAD_KEY_TYPE_ABRK_REE,
+    KM_KLAD_KEY_TYPE_ABRK_TEE,
+    KM_KLAD_KEY_TYPE_RDRK_REE,
+    KM_KLAD_KEY_TYPE_RDRK_TEE,
+    KM_KLAD_KEY_TYPE_ERK_TEE,
+    KM_KLAD_KEY_TYPE_ERK_REE
+};
+
+typedef enum {
+    KM_KLAD_HMAC_SHA1 = 0x20, /* Do Not Recommend to Use */
+    KM_KLAD_HMAC_SHA224,      /* Software Kdf not support */
+    KM_KLAD_HMAC_SHA256,
+    KM_KLAD_HMAC_SHA384,
+    KM_KLAD_HMAC_SHA512,
+    KM_KLAD_HMAC_SM3 = 0x30,
+    KM_KLAD_HMAC_MAX,
+    KM_KLAD_HMAC_INVALID = 0xffffffff,
+} km_klad_hmac_type;
+
+/* Define the key security attribute. */
+typedef enum {
+    KM_KLAD_SEC_DISABLE = 0,
+    KM_KLAD_SEC_ENABLE,
+    KM_KLAD_SEC_MAX,
+    KM_KLAD_SEC_INVALID = 0xffffffff,
+} km_klad_sec;
+
+/* Define the keyladder level. */
+typedef enum {
+    KM_KLAD_LEVEL1 = 0,
+    KM_KLAD_LEVEL_MAX,
+    KM_KLAD_LEVEL_INVALID = 0xffffffff,
+} km_klad_level;
+
+/* Define the keyladder algorithm. */
+typedef enum {
+    KM_KLAD_ALG_TYPE_TDES = 0, /* Do Not Recommend to Use */
+    KM_KLAD_ALG_TYPE_AES,
+    KM_KLAD_ALG_TYPE_SM4,
+    KM_KLAD_ALG_TYPE_MAX,
+    KM_KLAD_ALG_TYPE_INVALID = 0xffffffff,
+} km_klad_alg_type;
+
+/* Define the algorithm of crypto engine. */
+typedef enum {
+    KM_CRYPTO_ALG_AES = 0x20,
+    KM_CRYPTO_ALG_LEA = 0x40,        /* Flash online decryption and Cipher offline encryption */
+    KM_CRYPTO_ALG_SM4 = 0x50,
+    KM_CRYPTO_ALG_TDES = 0x70,       /* Do Not Recommend to Use */
+    KM_CRYPTO_ALG_HMAC_SHA1 = 0xA0,  /* Do Not Recommend to Use */
+    KM_CRYPTO_ALG_HMAC_SHA2 = 0xA1,
+    KM_CRYPTO_ALG_HMAC_SM3 = 0xA2,
+    KM_CRYPTO_ALG_MAX,
+    KM_CRYPTO_ALG_INVALID = 0xffffffff,
+} km_crypto_alg;
+
+/* Define the destination type of keyladder. */
+typedef enum {
+    KM_KLAD_DEST_TYPE_MCIPHER = 0x00,   /* keyslot for mcipher */
+    KM_KLAD_DEST_TYPE_HMAC,             /* keyslot for hmac */
+    KM_KLAD_DEST_TYPE_FLASH,            /* flash controller, for flash on line decryption and authentication */
+    KM_KLAD_DEST_TYPE_NPU,              /* for NPU */
+    KM_KLAD_DEST_TYPE_MAX,
+    KM_KLAD_DEST_TYPE_INVALID = 0xffffffff,
+} km_klad_dest_type;
+
+/* Define the flash online decryption key type it's valid for non-TEE platform,  it's will be ignored on TEE platform */
+typedef enum {
+    KM_KLAD_FLASH_KEY_TYPE_REE_DEC = 0x00,  /* REE flash online decryption key */
+    KM_KLAD_FLASH_KEY_TYPE_TEE_DEC,         /* TEE flash online decryption key */
+    KM_KLAD_FLASH_KEY_TYPE_TEE_AUT,         /* TEE flash online authentication key */
+    KM_KLAD_FLASH_KEY_TYPE_MAX,
+    KM_KLAD_FLASH_KEY_TYPE_INVALID = 0xffffffff,
+} km_klad_flash_key_type;
+
+/* * Key parity, valid when key length is not more than 128bit */
+/* * CNcomment: Key Parity Attribute */
+typedef enum {
+    KM_KLAD_KEY_EVEN =  0x0,   /* *< even key  */
+    KM_KLAD_KEY_ODD  =  0x1,   /* *< odd key */
+    KM_KLAD_KEY_PARITY_MAX,
+    KM_KLAD_KEY_PARITY_INVALID = 0xffffffff,
+} km_klad_key_parity;
+
+/* Define the structure of keyladder configuration. */
+typedef struct {
+    td_u32 rootkey_type;  /* Keyladder rootkey type, KM_KLAD_KEY_TYPE_xxx. */
+} km_klad_config;
+
+/* Define the structure of content key security configurations. */
+/* when cipher work mode is CBC_MAC, dest_buf_sec_support and dest_buf_non_sec_support cannot be both false */
+typedef struct {
+    km_klad_sec key_sec; /* Secure key can only be used by TEE CPU and AIDSP locked cipher and hash channel */
+    /* Only the cipher or hash channel which is locked by same CPU as keyladder can use this key,
+    valid only for TEE CPU and AIDSP */
+    td_bool master_only_enable;
+    td_bool dest_buf_sec_support;     /* The destination buffer of target engine can be secure. */
+    td_bool dest_buf_non_sec_support; /* The destination buffer of target engine can be non-secure. */
+    td_bool src_buf_sec_support;      /* The source buffer of target engine can be secure. */
+    td_bool src_buf_non_sec_support;  /* The source buffer of target engine can be non-secure. */
+} km_klad_key_secure_config;
+
+/* Define the structure of content key configurations. */
+typedef struct {
+    km_crypto_alg engine; /* The content key can be used for which algorithm of the crypto engine. */
+    td_bool decrypt_support;  /* The content key can be used for decrypting. */
+    td_bool encrypt_support;  /* The content key can be used for encrypting. */
+} km_klad_key_config;
+
+/* Structure of keyladder extend attributes. */
+typedef struct {
+    km_klad_config klad_cfg;          /* The keyladder configuration, valid for harware key. */
+    km_klad_key_config key_cfg;       /* The content key configuration. */
+    km_klad_key_secure_config key_sec_cfg; /* The content key security configuration. */
+    td_u32 rkp_sw_cfg; /* The software configuration for NPU */
+} km_klad_attr;
+
+/* Structure of setting session key. */
+typedef struct {
+    km_klad_level level;              /* the level of session key. */
+    km_klad_alg_type alg;             /* the algorithm used to decrypt session key. */
+    td_u32 key_size;                      /* the size of session key, should be 16. */
+    td_u8 *key;   /* the session key. */
+} km_klad_session_key;
+
+/* Structure of setting content key. */
+typedef struct {
+    td_u32 key_size;                      /* The size of content key, should be 16 or 32. */
+    km_klad_alg_type alg;             /* The algorithm of the content key. */
+    km_klad_key_parity key_parity;    /* Odd or even key flag. */
+    td_u8 *key;                           /* The content key. */
+} km_klad_content_key;
+
+/* Structure of sending clear key. */
+typedef struct {
+    km_klad_hmac_type hmac_type;      /* hmac type, only send hmac key need to config. */
+    td_u32 key_size;                      /* The size of content key, 16 or 32 for cipher,
+                                             not more than block size for HMAC. */
+    td_u8 *key;                           /* The content key. */
+    km_klad_key_parity key_parity;    /* Odd or even key flag. */
+} km_klad_clear_key;
+
+/**
+ * @brief  KDF key derivation, hash algorithm selection when the hardware PBKDF2 algorithm is used.
+ */
+typedef enum {
+    CRYPTO_KDF_HARD_ALG_SHA256 = 0,
+    CRYPTO_KDF_HARD_ALG_SM3,
+    CRYPTO_KDF_HARD_ALG_MAX
+} crypto_kdf_hard_alg;
+
+/**
+ * @brief  Symmetric key length. Determines the length of the final working key.
+ */
+typedef enum {
+    CRYPTO_KLAD_KEY_SIZE_128BIT,
+    CRYPTO_KLAD_KEY_SIZE_192BIT,
+    CRYPTO_KLAD_KEY_SIZE_256BIT,
+} crypto_klad_key_size;
+
+typedef struct {
+    crypto_kdf_hard_alg kdf_hard_alg;
+    td_bool key_parity;
+    crypto_klad_key_size key_size;
+    td_u8 *salt;
+    td_u32 salt_length;
+    td_bool oneway;
+} km_klad_effective_key;
+
+/* soc keyslot */
+/* Define the keyslot type. */
+typedef enum {
+    KM_KEYSLOT_TYPE_MCIPHER = 0x00,
+    KM_KEYSLOT_TYPE_HMAC,
+    KM_KEYSLOT_TYPE_MAX,
+    KM_KEYSLOT_TYPE_INVALID = 0xffffffff,
+} km_keyslot_type;
+
+typedef enum {
+    CRYPTO_KDF_HARD_KEY_SIZE_128BIT = 0,
+    CRYPTO_KDF_HARD_KEY_SIZE_192BIT,
+    CRYPTO_KDF_HARD_KEY_SIZE_256BIT,
+} crypto_kdf_hard_key_size;
+
+
+/**
+ * @brief  Root key selection during KDF key derivation.
+ */
+typedef enum {
+    CRYPTO_KDF_OTP_KEY_MRK1 = 0,
+    CRYPTO_KDF_OTP_KEY_USK,
+    CRYPTO_KDF_OTP_KEY_RUSK,
+    CRYPTO_KDF_OTP_KEY_MAX
+} crypto_kdf_otp_key;
+ 
+/**
+ * @brief  Symmetric algorithm selection during KDF key derivation.
+ */
+typedef enum {
+    CRYPTO_KDF_UPDATE_ALG_AES = 0,
+    CRYPTO_KDF_UPDATE_ALG_SM4,
+    CRYPTO_KDF_UPDATE_ALG_MAX
+} crypto_kdf_update_alg;
+ 
+/**
+ * @brief  Hash algorithm selection when the software PBKDF2 algorithm is used.
+ */
+typedef enum {
+    CRYPTO_KDF_SW_ALG_SHA1 = 0,
+    CRYPTO_KDF_SW_ALG_SHA256,
+    CRYPTO_KDF_SW_ALG_SHA384,
+    CRYPTO_KDF_SW_ALG_SHA512,
+    CRYPTO_KDF_SW_ALG_SM3
+} crypto_kdf_sw_alg;
+ 
+/**
+ * @brief  Select the derived key type during KDF key derivation.
+ */
+typedef enum {
+    CRYPTO_KDF_HARD_KEY_TYPE_SBRK0  = 0x03000000,
+    CRYPTO_KDF_HARD_KEY_TYPE_SBRK1,
+    CRYPTO_KDF_HARD_KEY_TYPE_SBRK2,
+    CRYPTO_KDF_HARD_KEY_TYPE_ABRK0,
+    CRYPTO_KDF_HARD_KEY_TYPE_ABRK1,
+    CRYPTO_KDF_HARD_KEY_TYPE_ABRK2,
+    CRYPTO_KDF_HARD_KEY_TYPE_DRK0,
+    CRYPTO_KDF_HARD_KEY_TYPE_DRK1,
+    CRYPTO_KDF_HARD_KEY_TYPE_RDRK0,
+    CRYPTO_KDF_HARD_KEY_TYPE_RDRK1,
+    CRYPTO_KDF_HARD_KEY_TYPE_PSK,
+    CRYPTO_KDF_HARD_KEY_TYPE_ODRK0,
+    CRYPTO_KDF_HARD_KEY_TYPE_ODRK1,
+    CRYPTO_KDF_HARD_KEY_TYPE_OARK0,
+    CRYPTO_KDF_HARD_KEY_TYPE_MDRK0,
+    CRYPTO_KDF_HARD_KEY_TYPE_MDRK1,
+    CRYPTO_KDF_HARD_KEY_TYPE_MDRK2,
+    CRYPTO_KDF_HARD_KEY_TYPE_MDRK3,
+
+    CRYPTO_KDF_HARD_KEY_TYPE_ABRK_REE,
+    CRYPTO_KDF_HARD_KEY_TYPE_ABRK_TEE,
+    CRYPTO_KDF_HARD_KEY_TYPE_RDRK_REE,
+    CRYPTO_KDF_HARD_KEY_TYPE_RDRK_TEE,
+    CRYPTO_KDF_HARD_KEY_TYPE_ERK_TEE,
+    CRYPTO_KDF_HARD_KEY_TYPE_ERK_REE,
+    CRYPTO_KDF_HARD_KEY_TYPE_ERK1_REE,
+    CRYPTO_KDF_HARD_KEY_TYPE_ERK2_REE
+} crypto_kdf_hard_key_type;
+
+
+typedef struct {
+    crypto_kdf_hard_key_type hard_key_type;
+    crypto_kdf_hard_alg hard_alg;
+    crypto_kdf_hard_key_size hard_key_size;
+    td_u32 rkp_sw_cfg;
+    td_u8 *salt;
+    td_u32 salt_length;
+    td_bool is_oneway;
+} crypto_kdf_hard_calc_param;
+ 
+/**
+ * @brief  The klad target module's algorithm engine, determining the algorithm supported by the sent key.
+ */
+typedef enum {
+    CRYPTO_KLAD_ENGINE_AES = 0x20,
+    CRYPTO_KLAD_ENGINE_LEA = 0x40,
+    CRYPTO_KLAD_ENGINE_SM4 = 0x50,
+    CRYPTO_KLAD_ENGINE_TDES = 0x70,
+    CRYPTO_KLAD_ENGINE_SHA1_HMAC = 0xA0,
+    CRYPTO_KLAD_ENGINE_SHA2_HMAC = 0xA1,
+    CRYPTO_KLAD_ENGINE_SM3_HMAC = 0xA2,
+    CRYPTO_KLAD_ENGINE_MAX
+} crypto_klad_engine;
+
+/**
+ * @brief  The klad target module, determining the module to which the key is sent.
+ */
+typedef enum {
+    CRYPTO_KLAD_DEST_MCIPHER = 0,
+    CRYPTO_KLAD_DEST_HMAC,
+    CRYPTO_KLAD_DEST_FLASH,
+    CRYPTO_KLAD_DEST_NPU,
+    CRYPTO_KLAD_DEST_AIDSP,
+    CRYPTO_KLAD_DEST_MAX,
+} crypto_klad_dest;
+ 
+/**
+ * @brief  Flash online decryption mode, determining the mode used after the key is sent.
+ */
+typedef enum {
+    CRYPTO_KLAD_FLASH_KEY_TYPE_REE_DEC = 0x00,  /* REE flash online decryption key */
+    CRYPTO_KLAD_FLASH_KEY_TYPE_TEE_DEC,         /* TEE flash online decryption key */
+    CRYPTO_KLAD_FLASH_KEY_TYPE_TEE_AUT,         /* TEE flash online authentication key */
+    CRYPTO_KLAD_FLASH_KEY_TYPE_INVALID,
+} crypto_klad_flash_key_type;
+ 
+/**
+ * @brief  When the target engine is HMAC, determine the HAMC algorithm to be used.
+ */
+typedef enum {
+    CRYPTO_KLAD_HMAC_TYPE_SHA1 = 0x20, /* Insecure algorithm, not recommended. */
+    CRYPTO_KLAD_HMAC_TYPE_SHA224,
+    CRYPTO_KLAD_HMAC_TYPE_SHA256,
+    CRYPTO_KLAD_HMAC_TYPE_SHA384,
+    CRYPTO_KLAD_HMAC_TYPE_SHA512,
+    CRYPTO_KLAD_HMAC_TYPE_SM3 = 0x30,
+    CRYPTO_KLAD_HMAC_TYPE_MAX,
+    CRYPTO_KLAD_HMAC_TYPE_INVALID = 0xffffffff,
+} crypto_klad_hmac_type;
+ 
+/**
+ * @brief  Determines the current derived key level during klad key derivation.
+ */
+typedef enum {
+    CRYPTO_KLAD_LEVEL_SEL_FIRST = 0,
+    CRYPTO_KLAD_LEVEL_SEL_SECOND
+} crypto_klad_level_sel;
+ 
+/**
+ * @brief  Determines the symmetric algorithm used for derivation during klad key derivation.
+ */
+typedef enum {
+    CRYPTO_KLAD_ALG_SEL_TDES = 0,
+    CRYPTO_KLAD_ALG_SEL_AES,
+    CRYPTO_KLAD_ALG_SEL_SM4,
+    CRYPTO_KLAD_ALG_SEL_MAX,
+} crypto_klad_alg_sel;
+ 
+/**
+ * @brief  Clear key structure when klad sends a clear key.
+ */
+typedef struct {
+    crypto_klad_hmac_type hmac_type; /* Indicates the HMAC algorithm.
+                                            Valid only when the target is the HMAC algorithm engine. */
+    td_u32 key_length;  /* Length of the clear key, in bytes.
+                                For the symmetric algorithm, the value can only be 16, 24, or 32.
+                                For HMAC-SH1/SHA224/SHA256/SM3, the value cannot exceed 64.
+                                For HMAC-SHA384/SHA512, the value cannot exceed 128. */
+    td_u8 *key;     /* Clear key content. */
+    td_bool key_parity; /* Indicates the parity attribute of a key.
+                                Valid when the target is a symmetric algorithm engine and key_length is set to 16. */
+} crypto_klad_clear_key;
+
+/**
+ * @brief  Keyladder root key type selection.
+ */
+typedef struct {
+    crypto_kdf_hard_key_type rootkey_type;
+} crypto_klad_config;
+ 
+/**
+ * @brief  Keyladder working key attribute configuration.
+ */
+typedef struct {
+    crypto_klad_engine engine;  /* The working key can be used for which algorithm of the crypto engine. */
+    td_bool decrypt_support;    /* The working key can be used for decrypting. */
+    td_bool encrypt_support;    /* The working key can be used for encrypting. */
+} crypto_klad_key_config;
+ 
+/**
+ * @brief  Security attribute of the key.
+    when cipher work mode is CBC_MAC, dest_buf_sec_support and dest_buf_non_sec_support cannot be both false
+ */
+typedef struct {
+    td_bool key_sec;    /* Secure key can only be used by TEE CPU and AIDSP locked cipher and hash channel. */
+    td_bool master_only_enable; /* Only the cipher or hash channel which is locked by same CPU as keyladder
+                                        can use this key, valid only for TEE CPU and AIDSP. */
+    td_bool dest_buf_sec_support;   /* The destination buffer of target engine can be secure. */
+    td_bool dest_buf_non_sec_support; /* The destination buffer of target engine can be secure. */
+    td_bool src_buf_sec_support;      /* The destination buffer of target engine can be secure. */
+    td_bool src_buf_non_sec_support;  /* The destination buffer of target engine can be secure. */
+} crypto_klad_key_secure_config;
+ 
+/**
+ * @brief  Keyladder configuration attributes.
+ */
+typedef struct {
+    crypto_klad_config klad_cfg;    /* The keyladder configuration, valid for harware key. */
+    crypto_klad_key_config key_cfg; /* The working key configuration. */
+    crypto_klad_key_secure_config key_sec_cfg;  /* The working key security configuration. */
+    td_u32 rkp_sw_cfg;
+} crypto_klad_attr;
+
+typedef struct {
+    td_u8 key[16];
+    td_u32 key_length;
+    crypto_klad_level_sel level;
+    crypto_klad_alg_sel alg;
+} crypto_klad_session_key;
+
+typedef struct {
+    td_u32 key_length;
+    crypto_klad_alg_sel alg;
+    td_bool key_parity;
+    td_u8 key[32];
+} crypto_klad_content_key;
+
+typedef struct {
+    crypto_kdf_hard_alg kdf_hard_alg;
+    td_bool key_parity;
+    crypto_klad_key_size key_size;
+    td_u8 *salt;
+    td_u32 salt_length;
+    td_bool oneway;
+} crypto_klad_effective_key;
+
+/**
+ * @brief  Keyslot type selection.
+ */
+typedef enum {
+    CRYPTO_KEYSLOT_TYPE_MCIPHER = 0,
+    CRYPTO_KEYSLOT_TYPE_HMAC,
+    CRYPTO_KEYSLOT_TYPE_FLASH,
+} crypto_keyslot_type;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif  /* __cplusplus */
+
+#endif /* OT_KM_STRUCT_H */
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_pke_struct.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_pke_struct.h
new file mode 100644
index 0000000..b745464
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_pke_struct.h
@@ -0,0 +1,217 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto pke struct header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef CRYPTO_PKE_STRUCT_H
+#define CRYPTO_PKE_STRUCT_H
+
+#include "crypto_common_struct.h"
+
+typedef enum {
+    DRV_PKE_LEN_192 = 24,
+    DRV_PKE_LEN_224 = 32,
+    DRV_PKE_LEN_256 = 32,
+    DRV_PKE_LEN_384 = 48,
+    DRV_PKE_LEN_448 = 56,
+    DRV_PKE_LEN_512 = 64,
+    DRV_PKE_LEN_521 = 68,
+    DRV_PKE_LEN_576 = 72,
+    DRV_PKE_LEN_1024 = 128,
+    DRV_PKE_LEN_1536 = 192,
+    DRV_PKE_LEN_2048 = 256,
+    DRV_PKE_LEN_3072 = 384,
+    DRV_PKE_LEN_4096 = 512,
+    DRV_PKE_LEN_MAX,
+    DRV_PKE_LEN_INVALID = 0xffffffff,
+} drv_pke_len;
+
+/*
+ * Component of drv_pke_ecc_curve_type.
+ * reserved(22 bits) | curve_id(10 bits) | klen(10 bits)
+ */
+typedef enum {
+    RFC5639_P256_CURVE_ID = 0,
+    RFC5639_P384_CURVE_ID,
+    RFC5639_P512_CURVE_ID,
+    FIPS_P256K_CURVE_ID,
+    FIPS_P192R_CURVE_ID,
+    FIPS_P224R_CURVE_ID,
+    FIPS_P256R_CURVE_ID,
+    FIPS_P384R_CURVE_ID,
+    FIPS_P521R_CURVE_ID,
+    RFC7748_CURVE_ID,
+    RFC7748_448_CURVE_ID,
+    RFC8032_CURVE_ID,
+    SM2_CURVE_ID,
+    CURVE_ID_MAX,
+} drv_pke_curve_id;
+
+#define CRYPTO_PKE_CURVE_ID_MASK     0x000FFC00
+#define CRYPTO_PKE_CURVE_ID_SHIFT    10
+#define CRYPTO_PKE_KLEN_MASK        0x000003FF
+#define CRYPTO_PKE_KLEN_SHIFT       0
+
+#define crypto_pke_get_attr(value, mask, shift)         (((td_u32)(value) & (td_u32)(mask)) >> (shift))
+
+#define crypto_pke_get_klen(curve_type)              \
+    crypto_pke_get_attr(curve_type, CRYPTO_PKE_KLEN_MASK, CRYPTO_PKE_KLEN_SHIFT)
+#define compat_pke_curve_type(curve_id, klen)       \
+    ((((curve_id) & 0x3FF) << CRYPTO_PKE_CURVE_ID_SHIFT) | ((klen) & 0x3FF))
+
+typedef enum {
+    /* 0x20, RFC 5639 - Brainpool P256 */
+    DRV_PKE_ECC_TYPE_RFC5639_P256 = compat_pke_curve_type(RFC5639_P256_CURVE_ID, DRV_PKE_LEN_256),
+    /* 0x430, RFC 5639 - Brainpool P384 */
+    DRV_PKE_ECC_TYPE_RFC5639_P384 = compat_pke_curve_type(RFC5639_P384_CURVE_ID, DRV_PKE_LEN_384),
+    /* 0x840, RFC 5639 - Brainpool P512 */
+    DRV_PKE_ECC_TYPE_RFC5639_P512 = compat_pke_curve_type(RFC5639_P512_CURVE_ID, DRV_PKE_LEN_512),
+    /* 0xc20, RFC 5639 - Brainpool P512 */
+    DRV_PKE_ECC_TYPE_FIPS_P256K = compat_pke_curve_type(FIPS_P256K_CURVE_ID, DRV_PKE_LEN_256),
+    /* 0x1018, NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+    DRV_PKE_ECC_TYPE_FIPS_P192R = compat_pke_curve_type(FIPS_P192R_CURVE_ID, DRV_PKE_LEN_192),
+    /* 0x1420, NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+    DRV_PKE_ECC_TYPE_FIPS_P224R = compat_pke_curve_type(FIPS_P224R_CURVE_ID, DRV_PKE_LEN_224),
+    /* 0x1820, NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+    DRV_PKE_ECC_TYPE_FIPS_P256R = compat_pke_curve_type(FIPS_P256R_CURVE_ID, DRV_PKE_LEN_256),
+    /* 0x1c30, NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+    DRV_PKE_ECC_TYPE_FIPS_P384R = compat_pke_curve_type(FIPS_P384R_CURVE_ID, DRV_PKE_LEN_384),
+    /* 0x2048, NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+    DRV_PKE_ECC_TYPE_FIPS_P521R = compat_pke_curve_type(FIPS_P521R_CURVE_ID, DRV_PKE_LEN_576),
+    /* 0x2420, RFC 7748 - Curve25519 */
+    DRV_PKE_ECC_TYPE_RFC7748 = compat_pke_curve_type(RFC7748_CURVE_ID, DRV_PKE_LEN_256),
+    /* 0x2838, RFC 7748 - Curve448 */
+    DRV_PKE_ECC_TYPE_RFC7748_448 = compat_pke_curve_type(RFC7748_448_CURVE_ID, DRV_PKE_LEN_448),
+    /* 0x2c20, RFC 8032 - ED25519 */
+    DRV_PKE_ECC_TYPE_RFC8032 = compat_pke_curve_type(RFC8032_CURVE_ID, DRV_PKE_LEN_256),
+    /* 0x3020, GMT 0003.2-2012 */
+    DRV_PKE_ECC_TYPE_SM2 = compat_pke_curve_type(SM2_CURVE_ID, DRV_PKE_LEN_256),
+    DRV_PKE_ECC_TYPE_MAX,
+    DRV_PKE_ECC_TYPE_INVALID = 0xffffffff,
+} drv_pke_ecc_curve_type;
+
+typedef enum {
+    DRV_PKE_RSA_SCHEME_PKCS1_V15 = 0x00,  /* PKCS#1 V15 */
+    DRV_PKE_RSA_SCHEME_PKCS1_V21,         /* PKCS#1 V21, PSS for signning, OAEP for encryption */
+    DRV_PKE_RSA_SCHEME_MAX,
+    DRV_PKE_RSA_SCHEME_INVALID = 0xffffffff,
+} drv_pke_rsa_scheme;
+
+typedef enum {
+    DRV_PKE_HASH_TYPE_SHA1 = 0x00,   /* Suggest Not to use */
+    DRV_PKE_HASH_TYPE_SHA224,
+    DRV_PKE_HASH_TYPE_SHA256,
+    DRV_PKE_HASH_TYPE_SHA384,
+    DRV_PKE_HASH_TYPE_SHA512,
+    DRV_PKE_HASH_TYPE_SM3,
+    DRV_PKE_HASH_TYPE_MAX,
+    DRV_PKE_HASH_TYPE_INVALID = 0xffffffff,
+} drv_pke_hash_type;
+
+typedef enum {
+    DRV_PKE_BUF_NONSECURE = 0x00,
+    DRV_PKE_BUF_SECURE,
+    DRV_PKE_BUF_INVALID = 0xffffffff,
+} drv_pke_buffer_secure;
+
+typedef struct {
+    td_u32  length;
+    td_u8  *data;
+} drv_pke_data;
+
+/* * struct of ecc point */
+typedef struct {
+    td_u8 *x;   /* X coordinates of the generated public key, the caller ensures it is padded with leading
+                   zeros if the effective size of this key is smaller than ecc key size. */
+    td_u8 *y;   /* Y coordinates of the generated public key, the caller ensures it is padded with leading
+                   zeros if the effective size of this key is smaller than ecc key size. */
+    td_u32 length;
+} drv_pke_ecc_point;
+
+/* * struct of ecc signature */
+typedef struct {
+    td_u8 *r;   /* r component of the signature. */
+    td_u8 *s;   /* s component of the signature. */
+    td_u32 length;
+} drv_pke_ecc_sig;
+
+/* * struct of ecc curves parameters. */
+typedef struct {
+    const td_u8 *p;   /* prime specifying the base field. It is p (RFC5639), p (FIPS), p (RFC7748). */
+    const td_u8 *a;   /* Curve parameter a. It is A (RFC5639), c (FIPS), A24 (RFC7748), d(RFC8032). */
+    const td_u8 *b;   /* Curve parameter b. It is B (RFC5639), b (FIPS), N/A (RFC7748, RFC8032). */
+    const td_u8 *gx;  /* X coordinates of G which is a base point on the curve.
+                         It is x (RFC5639), Gx (FIPS), U(P) (RFC7748). */
+    const td_u8 *gy;  /* Y coordinates of G which is a base point on the curve.
+                         It is y (RFC5639), Gy (FIPS), N/A (RFC7748). */
+    const td_u8 *n;   /* Prime which is the order of G point. It is q (RFC5639), n (FIPS, RFC7748). */
+    td_u32 h;         /* Cofactor, which is the order of the elliptic curve divided by the order of the point G.
+                         It is h (RFC5639), h (FIPS), Cofactor (RFC7748). */
+    drv_pke_len ksize;         /* Ecc key size in bytes. It corresponds to the size in bytes of the prime. */
+    drv_pke_ecc_curve_type ecc_type; /* Type of ECC curve */
+} drv_pke_ecc_curve;
+
+typedef struct {
+    td_u32  length;
+    td_u8  *data;
+    drv_pke_buffer_secure buf_sec;
+} drv_pke_msg;
+
+/* * RSA private key struct */
+typedef struct {
+    td_u8 *n;          /* *< public modulus */
+    td_u8 *e;          /* *< public exponent */
+    td_u8 *d;          /* *< private exponent */
+    td_u8 *p;          /* *< 1st prime factor */
+    td_u8 *q;          /* *< 2nd prime factor */
+    td_u8 *dp;         /* *< D % (P - 1) */
+    td_u8 *dq;         /* *< D % (Q - 1) */
+    td_u8 *qp;         /* *< 1 / (Q % P) */
+    td_u16 n_len;      /* *< length of public modulus */
+    td_u16 e_len;      /* *< length of public exponent */
+    td_u16 d_len;      /* *< length of private exponent */
+    td_u16 p_len;      /* *< length of 1st prime factor,should be half of u16NLen */
+    td_u16 q_len;      /* *< length of 2nd prime factor,should be half of u16NLen */
+    td_u16 dp_len;     /* *< length of D % (P - 1),should be half of u16NLen */
+    td_u16 dq_len;     /* *< length of D % (Q - 1),should be half of u16NLen */
+    td_u16 qp_len;     /* *< length of 1 / (Q % P),should be half of u16NLen */
+} drv_pke_rsa_priv_key;
+
+/* * struct of RSA public key */
+typedef struct {
+    td_u8  *n;            /* point to public modulus */
+    td_u8  *e;            /* point to public exponent */
+    td_u16 len;           /* length of public modulus, max value is 512Byte */
+} drv_pke_rsa_pub_key;
+
+typedef struct {
+    const td_u8 *mont_a;    /* the montgomerized of parameter a(RFC5639, FIPS, SM2), a24(RFC7748), d(RFC8032). */
+    const td_u8 *mont_b;    /* the montgomerized of parameter b(RFC5639, FIPS, SM2), N/A(RFC7748), sqrt_m1(RFC8032). */
+    const td_u8 *mont_1_p;  /* the montgomerized of const value 1 (modp) */
+    const td_u8 *mont_1_n;  /* the montgomerized of const value 1 (modn) */
+    const td_u8 *rrp;  /* the montgomery parameter when modulur is p */
+    const td_u8 *rrn;  /* the montgomery parameter when modulur is n */
+    const td_u8 *const_1;
+    const td_u8 *const_0;
+    const td_u32 *mont_param_n;  /* the montgomerized parameter when the modulur is n. */
+    const td_u32 *mont_param_p;  /* the montgomerized parameter when the modulur is p. */
+    const td_u8 *n_minus_2;     /* the const value of n minus 2 */
+    const td_u8 *p_minus_2;     /* the const value of p minus 2 */
+} pke_ecc_init_param;
+
+typedef struct {
+    const drv_pke_ecc_curve *curve_param;
+    const pke_ecc_init_param *default_param;
+} pke_default_parameters;
+
+/* Here the ram should have been set into the address, and the instructions have shown which DRAM will be used for
+calculate. */
+typedef struct {
+    td_u32 instr_addr;     /* the start address for instructions, which is ROM or SRAM address. */
+    td_u32 instr_num;       /* the number of instructions from the instr_addr, which will be used for calculate. */
+} rom_lib;
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_symc_struct.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_symc_struct.h
new file mode 100644
index 0000000..01d435e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_symc_struct.h
@@ -0,0 +1,226 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto symc struct header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef CRYPTO_SYMC_STRUCT_H
+#define CRYPTO_SYMC_STRUCT_H
+
+#include "crypto_common_struct.h"
+
+/* Structure for SYMC Create. */
+typedef enum {
+    CRYPTO_SYMC_TYPE_NORMAL = 0x0,
+    CRYPTO_SYMC_TYPE_REG,
+    CRYPTO_SYMC_TYPE_MAX,
+    CRYPTO_SYMC_TYPE_INVALID = 0xffffffff,
+} crypto_symc_type;
+
+typedef enum {
+    CRYPTO_SYMC_ALG_TDES = 0x0,
+    CRYPTO_SYMC_ALG_AES = 0x1,
+    CRYPTO_SYMC_ALG_SM4 = 0x2,
+    CRYPTO_SYMC_ALG_LEA = 0x3,
+    CRYPTO_SYMC_ALG_DMA = 0x4,
+    CRYPTO_SYMC_ALG_MAX,
+    CRYPTO_SYMC_ALG_INVALID = 0xffffffff,
+} crypto_symc_alg;
+
+typedef enum {
+    CRYPTO_SYMC_WORK_MODE_ECB = 0x0,
+    CRYPTO_SYMC_WORK_MODE_CBC,
+    CRYPTO_SYMC_WORK_MODE_CTR,
+    CRYPTO_SYMC_WORK_MODE_OFB,
+    CRYPTO_SYMC_WORK_MODE_CFB,
+    CRYPTO_SYMC_WORK_MODE_CCM,
+    CRYPTO_SYMC_WORK_MODE_GCM,
+    CRYPTO_SYMC_WORK_MODE_CBC_MAC,
+    CRYPTO_SYMC_WORK_MODE_CMAC,
+    CRYPTO_SYMC_WORK_MODE_MAX,
+    CRYPTO_SYMC_WORK_MODE_INVALID = 0xffffffff,
+} crypto_symc_work_mode;
+
+typedef enum {
+    CRYPTO_SYMC_KEY_64BIT =  0x0,
+    CRYPTO_SYMC_KEY_128BIT = 0x1,
+    CRYPTO_SYMC_KEY_192BIT = 0x2,
+    CRYPTO_SYMC_KEY_256BIT = 0x3,
+    CRYPTO_SYMC_KEY_LENGTH_MAX,
+    CRYPTO_SYMC_KEY_LENGTH_INVALID = 0xffffffff,
+} crypto_symc_key_length;
+
+typedef enum {
+    CRYPTO_SYMC_KEY_EVEN =  0x0,
+    CRYPTO_SYMC_KEY_ODD  =  0x1,
+    CRYPTO_SYMC_KEY_PARITY_MAX,
+    CRYPTO_SYMC_KEY_PARITY_INVALID = 0xffffffff,
+} crypto_symc_key_parity;
+
+typedef enum {
+    CRYPTO_SYMC_BIT_WIDTH_1BIT = 0x0,
+    CRYPTO_SYMC_BIT_WIDTH_8BIT = 0x1,
+    CRYPTO_SYMC_BIT_WIDTH_64BIT = 0x2,
+    CRYPTO_SYMC_BIT_WIDTH_128BIT = 0x3,
+    CRYPTO_SYMC_BIT_WIDTH_MAX,
+    CRYPTO_SYMC_BIT_WIDTH_INVALID = 0xffffffff,
+} crypto_symc_bit_width;
+
+typedef enum {
+    CRYPTO_SYMC_IV_DO_NOT_CHANGE = 0,
+    CRYPTO_SYMC_IV_CHANGE_ONE_PKG,
+    CRYPTO_SYMC_IV_CHANGE_ALL_PKG,
+    /* GCM. */
+    CRYPTO_SYMC_GCM_IV_DO_NOT_CHANGE,
+    CRYPTO_SYMC_GCM_IV_CHANGE_START,
+    CRYPTO_SYMC_GCM_IV_CHANGE_UPDATE,
+    CRYPTO_SYMC_GCM_IV_CHANGE_FINISH,
+    /* CCM. */
+    CRYPTO_SYMC_CCM_IV_DO_NOT_CHANGE,
+    CRYPTO_SYMC_CCM_IV_CHANGE_START,
+    CRYPTO_SYMC_CCM_IV_CHANGE_UPDATE,
+    CRYPTO_SYMC_CCM_IV_CHANGE_FINISH,
+    CRYPTO_SYMC_IV_CHANGE_MAX,
+    CRYPTO_SYMC_IV_CHANGE_INVALID = 0xffffffff,
+} crypto_symc_iv_change_type;
+
+typedef struct {
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_type symc_type;
+    td_bool is_long_term;
+} crypto_symc_attr;
+
+typedef struct {
+    crypto_buf_attr buf_attr;
+    td_u32 length;
+} crypto_symc_pack;
+
+typedef struct {
+    td_u32 clear_header_len;
+    td_u32 payload_len;
+    td_u32 payload_pattern_encrypt_len;
+    td_u32 payload_pattern_clear_len;
+    td_u32 payload_pattern_offset_len;
+    td_bool iv_change;
+    td_u32 iv[CRYPTO_AES_IV_SIZE_IN_WORD];
+} crypto_symc_cenc_subsample;
+
+typedef struct {
+    td_bool use_odd_key;
+    td_u32 first_encrypt_offset;
+    crypto_symc_cenc_subsample *subsample;
+    td_u32 subsample_num;
+    crypto_symc_alg alg;
+    crypto_symc_work_mode work_mode;
+    td_u32 iv[CRYPTO_AES_IV_SIZE_IN_WORD];
+} crypto_symc_cenc_param;
+
+typedef struct {
+    td_u32 data_len;        /* For CCM/GCM. */
+    td_u32 processed_aad_len;
+    td_u32 total_aad_len;
+    td_u32 tag_len;
+    td_u8 ccm_cmac[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u8 ctr0[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    /* CCM CMAC. */
+    td_u8 cmac_tail_len;
+    td_u8 cmac_tail[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+} crypto_symc_ccm_ctx;
+
+typedef struct {
+    td_u32 kslot_handle;
+    crypto_symc_ccm_ctx store_ctx;
+    td_u32 data_len;        /* Crypto Data Length In Bytes. */
+    td_u32 tag_len;         /* Tag Length In Bytes. */
+    td_u32 total_aad_len;
+    td_u32 processed_aad_len;
+    td_u32 processed_data_len;
+    td_u8 iv[16];
+    td_u32 iv_length;
+    td_u8 key[32];
+    td_u32 key_len;
+    td_s32 is_decrypt; // flag of crypt
+    td_u64 phys_addr;
+    td_void *virt_addr;
+} mbedtls_ccm_context;
+
+typedef struct {
+    crypto_buf_attr aad_buf;
+    td_u32 aad_len;         /* Addition Data Length In Bytes at this time. */
+    td_u32 data_len;        /* Crypto Data Length In Bytes. */
+    td_u32 tag_len;         /* Tag Length In Bytes. */
+    td_u32 total_aad_len;   /* Total Addition Data Length In Bytes. */
+} crypto_symc_config_aes_ccm_gcm;
+
+typedef struct {
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    crypto_symc_key_parity key_parity;
+    crypto_symc_bit_width symc_bit_width;
+    crypto_symc_iv_change_type iv_change_flag;
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    td_void *param;
+} crypto_symc_ctrl_t;
+
+typedef struct {
+    td_u32 chn_id;                                         /* Channel number */
+    td_u32 open;                                           /* Open or closed */
+    td_u32 is_decrypt;                                     /* Decrypt or encrypt */
+    td_u32 alg;                                            /* Algorithm */
+    td_u32 mode;                                           /* Work mode */
+    td_u32 key_len;                                        /* Key length */
+    td_u32 key_source;                                     /* Hard or soft key */
+    td_u32 int_raw;                                        /* Raw intertupt */
+    td_u32 int_en;                                         /* Enable interrupt */
+    td_u32 int_status;                                     /* Status interrupt */
+    td_u32 owner;                                          /* Process PID of owner */
+    td_u32 is_secure;                                      /* Secure channel or not */
+    td_u32 smmu_enable;                                    /* Smmu enable */
+    td_u32 in_node_head;                                   /* In node list head */
+    td_u32 in_node_rptr;                                   /* In node list read index */
+    td_u32 in_node_wptr;                                   /* In node list write index */
+    td_u32 in_node_depth;                                  /* In node depth */
+    td_u32 out_node_head;                                  /* Out node list head */
+    td_u32 out_node_rptr;                                  /* Out node list read index */
+    td_u32 out_node_wptr;                                  /* Out node list write index */
+    td_u32 out_node_depth;                                 /* Out node depth */
+    td_u8 iv[CRYPTO_AES_IV_SIZE + CRYPTO_AES_IV_SIZE + 1]; /* Out iv */
+} crypto_symc_proc_info;
+
+typedef struct {
+    td_u32 allow_reset; /* allow reset CPU or not */
+    td_u32 sec_cpu;     /* secure CPU or not */
+    const char *name;   /* interrupt name */
+    td_u32 int_num;     /* interrupt number */
+    td_u32 int_en;      /* interrupt enable */
+    td_u32 smmu_base;   /* smmu base address */
+    td_u32 err_code;    /* error code */
+} crypto_symc_module_info;
+
+typedef struct {
+    td_bool is_long_term;
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    td_u32 keyslot_chn;
+} crypto_symc_mac_attr;
+
+typedef struct {
+    td_u8 key[32];
+    td_bool is_odd;
+    td_u32 klen;
+} crypto_symc_clear_key;
+
+typedef struct {
+    uint8_t mac[CRYPTO_AES_IV_SIZE];
+    uint32_t mac_len;
+    uint8_t left[CRYPTO_AES_IV_SIZE];
+    uint32_t left_len;
+} crypto_cmac_ctx;
+
+#endif
diff --git a/bsp/security_subsys/security_subsys_common/include/common_include/crypto_type.h b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_type.h
new file mode 100644
index 0000000..335fe7b
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/common_include/crypto_type.h
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: crypto type header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef CRYPTO_TYPE_H
+#define CRYPTO_TYPE_H
+
+#include "ot_type.h"
+#include "crypto_errno.h"
+#include "crypto_common_def.h"
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/drv_include/drv_hash.h b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_hash.h
new file mode 100644
index 0000000..5d46fc0
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_hash.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef DRV_HASH_H
+#define DRV_HASH_H
+
+#include "crypto_type.h"
+#include "crypto_hash_struct.h"
+#include "crypto_kdf_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 drv_cipher_hash_init(td_void);
+
+td_s32 drv_cipher_hash_deinit(td_void);
+
+td_s32 drv_cipher_hash_start(td_handle *drv_hash_handle, const crypto_hash_attr *hash_attr);
+
+td_s32 drv_cipher_hash_update(td_handle drv_hash_handle,  const crypto_buf_attr *src_buf, const td_u32 len);
+
+td_s32 drv_cipher_hash_finish(td_handle drv_hash_handle, td_u8 *out, td_u32 *out_len);
+
+td_s32 drv_cipher_hash_get(td_handle drv_hash_handle, crypto_hash_clone_ctx *hash_ctx);
+
+td_s32 drv_cipher_hash_set(td_handle drv_hash_handle, const crypto_hash_clone_ctx *hash_ctx);
+
+td_s32 drv_cipher_hash_destroy(td_handle drv_hash_handle);
+
+td_s32 drv_cipher_hash_finish_data(td_handle drv_hash_handle, td_u8 *out, td_u32 *out_len);
+
+td_s32 drv_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len);
+
+td_s32 drv_cipher_hmac256_block(const td_u8 *input_data, td_u32 data_len, td_u8 *hmac, td_u32 hmac_len);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/drv_include/drv_keyslot.h b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_keyslot.h
new file mode 100644
index 0000000..60fa1a4
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_keyslot.h
@@ -0,0 +1,35 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver keyslot header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef DRV_KEYSLOT_H
+#define DRV_KEYSLOT_H
+
+#include "crypto_type.h"
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 drv_keyslot_init(td_void);
+
+td_s32 drv_keyslot_deinit(td_void);
+
+td_s32 drv_keyslot_create(td_handle *keyslot_handle, crypto_keyslot_type keyslot_type);
+
+td_s32 drv_keyslot_destroy(td_handle keyslot_handle);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/drv_include/drv_klad.h b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_klad.h
new file mode 100644
index 0000000..61220d2
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_klad.h
@@ -0,0 +1,50 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver klad header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef DRV_KLAD_H
+#define DRV_KLAD_H
+
+#include "crypto_type.h"
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 drv_klad_create(td_handle *klad_handle);
+
+td_s32 drv_klad_destroy(td_handle klad_handle);
+
+td_s32 drv_klad_attach(td_handle klad_handle, crypto_klad_dest klad_dest, td_handle keyslot_handle);
+
+td_s32 drv_klad_detach(td_handle klad_handle, crypto_klad_dest klad_dest, td_handle keyslot_handle);
+
+td_s32 drv_klad_set_attr(td_handle klad_handle, const crypto_klad_attr *attr);
+
+td_s32 drv_klad_get_attr(td_handle klad_handle, crypto_klad_attr *attr);
+
+td_s32 drv_klad_set_clear_key(td_handle klad_handle, const crypto_klad_clear_key *clear_key);
+
+td_s32 drv_klad_set_session_key(td_handle klad_handle, const crypto_klad_session_key *session_key);
+
+td_s32 drv_klad_set_content_key(td_handle klad_handle, const crypto_klad_content_key *content_key);
+
+td_s32 drv_klad_set_effective_key(td_handle klad_handle, const crypto_klad_effective_key *content_key);
+
+td_s32 drv_kdf_update(crypto_kdf_otp_key otp_key, crypto_kdf_update_alg alg);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/drv_include/drv_otp.h b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_otp.h
new file mode 100644
index 0000000..1f51f64
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_otp.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef DRV_OTP_API_H
+#define DRV_OTP_API_H
+
+#include "crypto_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif  /* __cplusplus */
+
+/**
+\brief  otp word read.
+\attention \n
+N/A
+
+\param[in] addr: read address(0x00 ~ 0x1ff), requires 4 bytes align.
+\param[out] data: read word buffer(data is put in little endian).
+\param[in] check_word: the checksum of the parameters.
+\retval ::TD_SUCCESS  Call this API succussful.
+\retval ::TD_FAILURE  Call this API fails.
+
+\see \n
+N/A
+*/
+td_s32 drv_otp_read_word(const td_u32 addr, td_u32 *data);
+
+/**
+\brief  otp byte read.
+\attention \n
+N/A
+
+\param[in] addr: read address(0x00 ~ 0x1ff).
+\param[out] data: read byte buffer(data is put in little endian).
+\param[in] chech_word: the checksum of the parameters.
+\retval ::TD_SUCCESS  Call this API succussful.
+\retval ::TD_FAILURE  Call this API fails.
+
+\see \n
+N/A
+*/
+td_s32 drv_otp_read_byte(const td_u32 addr, td_u8 *data);
+
+/**
+\brief  otp byte write.
+\attention \n
+N/A
+
+\param[in] addr: write address(0x00 ~ 0x1ff).
+\param[in] data: write data.
+\param[in] chech_word: the checksum of the parameters.
+\retval ::TD_SUCCESS  Call this API succussful.
+\retval ::TD_FAILURE  Call this API fails.
+
+\see \n
+N/A
+*/
+td_s32 drv_otp_write_byte(const td_u32 addr, const td_u8 data);
+
+td_s32 drv_otp_get_die_id(td_u8 *die_id, const td_u32 len);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif
diff --git a/bsp/security_subsys/security_subsys_common/include/drv_include/drv_pke.h b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_pke.h
new file mode 100644
index 0000000..d8f479b
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_pke.h
@@ -0,0 +1,89 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver pke header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef DRV_PKE_H
+#define DRV_PKE_H
+
+#include "crypto_pke_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 drv_cipher_pke_init(void);
+
+td_s32 drv_cipher_pke_deinit(void);
+
+td_s32 drv_cipher_pke_rsa_gen_key(const drv_pke_data *input_e, drv_pke_rsa_priv_key *output_priv_key);
+
+td_s32 drv_cipher_pke_rsa_sign(const drv_pke_rsa_priv_key *priv_key, const drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign);
+
+td_s32 drv_cipher_pke_rsa_verify(const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    const drv_pke_hash_type hash_type, const drv_pke_data *input_hash, const drv_pke_data *sign);
+
+td_s32 drv_cipher_pke_rsa_public_encrypt(const drv_pke_rsa_scheme scheme, const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+td_s32 drv_cipher_pke_rsa_private_decrypt(const drv_pke_rsa_scheme scheme, const drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+td_s32 drv_cipher_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve);
+
+td_s32 drv_cipher_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key);
+
+td_s32 drv_cipher_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key);
+
+td_s32 drv_cipher_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 drv_cipher_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+#if defined(CONFIG_HI3516CV610)
+td_s32 drv_cipher_pke_sm2_sign(const drv_pke_data *priv_key, const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 drv_cipher_pke_sm2_verify(const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+#endif
+
+td_s32 drv_cipher_pke_eddsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 drv_cipher_pke_eddsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 drv_cipher_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash);
+
+td_s32 drv_cipher_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text);
+
+td_s32 drv_cipher_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text);
+
+td_s32 drv_cipher_pke_dh_gen_key(const drv_pke_data *g_data, const drv_pke_data *mod_n,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_priv_key, const drv_pke_data *output_pub_key);
+
+td_s32 drv_cipher_pke_dh_compute_key(const drv_pke_data *mod_n, const drv_pke_data  *input_priv_key,
+    const drv_pke_data  *input_pub_key, const drv_pke_data  *output_shared_key);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/drv_include/drv_pke_cal.h b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_pke_cal.h
new file mode 100644
index 0000000..7557f01
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_pke_cal.h
@@ -0,0 +1,50 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: big number API header file.
+ * Author: CompanyName
+ * Create: 2023-03-15
+*/
+
+#ifndef DRV_PKE_CAL_H
+#define DRV_PKE_CAL_H
+
+#include "crypto_pke_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 drv_cipher_pke_lock_secure(void);
+
+td_s32 drv_cipher_pke_unlock_secure(void);
+
+/*
+ * normal big number calculate function.
+ */
+td_s32 drv_cipher_pke_add_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_sub_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_mul_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_inv_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_mul(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *c);
+
+td_s32 drv_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif  /* DRV_PKE_CAL_H */
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/drv_include/drv_symc.h b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_symc.h
new file mode 100644
index 0000000..4718adf
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_symc.h
@@ -0,0 +1,76 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: cipher driver symc header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef DRV_SYMC_H
+#define DRV_SYMC_H
+
+#include "crypto_type.h"
+#include "crypto_symc_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 drv_cipher_symc_init(td_void);
+
+td_s32 drv_cipher_symc_deinit(td_void);
+
+td_s32 drv_cipher_symc_create(td_handle *symc_handle, const crypto_symc_attr *symc_attr);
+
+td_s32 drv_cipher_symc_destroy(td_handle symc_handle);
+
+td_s32 drv_cipher_symc_get_module_info(crypto_symc_module_info *module_info);
+
+td_s32 drv_cipher_symc_get_proc_info(td_handle symc_handle, crypto_symc_proc_info *proc_symc_info);
+
+td_s32 drv_cipher_symc_set_config(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 drv_cipher_symc_get_config(td_handle symc_handle, crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 drv_cipher_symc_attach(td_handle symc_handle, td_handle keyslot_handle);
+
+td_s32 drv_cipher_symc_get_keyslot_handle(td_handle symc_handle, td_handle *keyslot_handle);
+
+td_s32 drv_cipher_dma_copy(const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 drv_cipher_symc_encrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 drv_cipher_symc_decrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 drv_cipher_symc_encrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num);
+
+td_s32 drv_cipher_symc_decrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num);
+
+td_s32 drv_cipher_symc_cenc_decrypt(td_handle symc_handle, const crypto_symc_cenc_param *cenc_param,
+    const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 drv_cipher_symc_get_tag(td_handle symc_handle, td_u8 *tag, td_u32 tag_length);
+
+td_s32 drv_cipher_mac_start(td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr);
+
+td_s32 drv_cipher_mac_update(td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length);
+
+td_s32 drv_cipher_mac_finish(td_handle symc_handle, td_u8 *mac, td_u32 *mac_length);
+
+td_s32 drv_cipher_symc_set_clear_key(td_handle symc_handle, const crypto_symc_clear_key *key);
+
+td_void drv_cipher_debug_handle(td_handle symc_handle);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff --git a/bsp/security_subsys/security_subsys_common/include/drv_include/drv_trng.h b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_trng.h
new file mode 100644
index 0000000..a15635d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/drv_include/drv_trng.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef DRV_TRNG_H
+#define DRV_TRNG_H
+
+#include "crypto_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 drv_cipher_trng_init(td_void);
+
+td_s32 drv_cipher_trng_get_random(td_u32 *randnum);
+
+td_s32 drv_cipher_trng_get_multi_random(td_u32 size, td_u8 *randnum);
+
+td_s32 drv_cipher_trng_deinit(td_void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/hal_include/hal_hash.h b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_hash.h
new file mode 100644
index 0000000..78b6307
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_hash.h
@@ -0,0 +1,64 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal hash header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_HASH_H
+#define HAL_HASH_H
+
+#include "crypto_hash_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 hal_cipher_hash_init(td_void);
+
+td_s32 hal_cipher_hash_deinit(td_void);
+
+td_s32 hal_hash_lock(td_u32 chn_num);
+
+td_s32 hal_hash_unlock(td_u32 chn_num);
+
+td_s32 hal_cipher_hash_config(td_u32 chn_num, crypto_hash_type hash_type, const td_u32 *state);
+
+td_s32 hal_cipher_hash_attach(td_u32 chn_num, td_u32 keyslot_chn_num);
+
+td_s32 hal_cipher_hash_add_in_node(td_u32 chn_num, td_u64 data_phys, td_u32 data_len,
+    in_node_type_e in_node_type);
+
+td_s32 hal_cipher_hash_start(td_u32 chn_num, td_bool is_wait);
+
+td_s32 hal_cipher_hash_start_calc(td_u32 chn_num, td_u8 *data, td_u32 length);
+
+td_s32 hal_cipher_hash_wait_done(td_u32 chn_num, td_u32 *state, td_u32 state_size);
+
+td_s32 hal_cipher_hash_register_wait_func(td_u32 chn_num, td_void *wait,
+    crypto_wait_timeout_interruptible wait_func, td_u32 timeout_ms);
+
+td_s32 hal_cipher_hash_done_notify(td_u32 chn_num);
+
+td_u32 hal_cipher_hash_done_try(td_u32 chn_num);
+
+td_void hal_hash_debug(td_void);
+
+td_void hal_hash_debug_chn(td_u32 chn_num);
+
+td_s32 hal_cipher_hmac256_block(const td_u8 *input_data, td_u32 data_len, td_u8 *hmac, td_u32 hmac_len);
+
+td_s32 hal_cipher_hash_suspend(td_void);
+
+td_s32 hal_cipher_hash_resume(td_void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/hal_include/hal_keyslot.h b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_keyslot.h
new file mode 100644
index 0000000..ecb55bd
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_keyslot.h
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal keyslot header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_KEYSLOT_H
+#define HAL_KEYSLOT_H
+
+#include "crypto_type.h"
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 hal_keyslot_lock(td_u32 keyslot_num, crypto_keyslot_type keyslot_type);
+
+td_s32 hal_keyslot_unlock(td_u32 keyslot_num, crypto_keyslot_type keyslot_type);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/hal_include/hal_klad.h b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_klad.h
new file mode 100644
index 0000000..fe65fbd
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_klad.h
@@ -0,0 +1,57 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal klad header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_KLAD_H
+#define HAL_KLAD_H
+
+#include "crypto_type.h"
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 hal_klad_lock(td_void);
+
+td_s32 hal_klad_unlock(td_void);
+
+td_s32 hal_klad_set_key_crypto_cfg(td_bool encrypt_support, td_bool decrypt_support, crypto_klad_engine engine);
+
+td_s32 hal_klad_set_key_dest_cfg(crypto_klad_dest dest, crypto_klad_flash_key_type flash_key_type);
+
+td_s32 hal_klad_set_key_secure_cfg(const crypto_klad_key_secure_config *secure_cfg);
+
+td_s32 hal_klad_set_key_addr(crypto_klad_dest klad_dest, td_u32 keyslot_chn);
+
+td_s32 hal_klad_set_data(const td_u8 *data, td_u32 data_length);
+
+td_s32 hal_klad_start_clr_route(crypto_klad_dest klad_dest, const crypto_klad_clear_key *clear_key);
+
+td_s32 hal_klad_start_com_route(crypto_kdf_hard_key_type rk_type, const crypto_klad_effective_key *content_key,
+    crypto_klad_dest klad_dest);
+
+td_s32 hal_klad_com_start(crypto_klad_level_sel level, crypto_klad_alg_sel alg, crypto_klad_key_size key_size,
+    crypto_kdf_hard_key_type rk_type);
+
+td_s32 hal_klad_wait_com_route_done(td_void);
+
+td_void hal_klad_clear_data(td_void);
+
+td_void hal_klad_set_key_odd(td_bool odd);
+
+td_void hal_klad_debug(td_void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/hal_include/hal_pke_v4.h b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_pke_v4.h
new file mode 100644
index 0000000..3842072
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_pke_v4.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef HAL_PKE_H
+#define HAL_PKE_H
+
+
+#include "crypto_common_struct.h"
+
+#define ECC_SET_KEY_LEN  80 // varies from chip to chip
+
+#define RSA_KEY_LEN_2048 256
+#define RSA_KEY_LEN_3072 384
+#define RSA_KEY_LEN_4096 512
+
+#define ECC_MAX_KEY_LEN  72
+
+/* ! \Define the offset of reg */
+#define PKE_VERSION_DATE      0x0
+
+#define PKE_KEY_CRC           0x20
+#define PKE_MRAM              0x200
+#define PKE_PRAM              0x300
+#define PKE_NRAM              0x600
+#define PKE_KRAM              0xa00
+#define PKE_RRAM              0xe00
+
+#define PKE_MG_A24           (PKE_NRAM + 0x120)      // 0x720, for MG mul dot
+#define PKE_MG_K             (PKE_KRAM + 0x20)       // 0xa20, for MG mul dot
+#define PKE_ED_PD            (PKE_NRAM + 0x180)      // 0x780, for ED mul dot
+#define PKE_ED_K             (PKE_KRAM + 0x20)       // 0xa20, for ED mul dot
+#define PKE_ED_MRAM(i)       (PKE_MRAM + 0x20 * (i)) // 0x200 + 0x20 * i, for ED mul dot and ED add dot
+#define PKE_ED_RRAM(i)       (PKE_RRAM + 0x20 * (i)) // 0xe00 + 0x20 * i, for ED mul dot and ED add dot
+#define PKE_ED_NRAM(i)       (PKE_NRAM + 0x20 * (i)) // 0x600 + 0x20 * i, for ED add dot
+
+/* ! Define the length of zero padding for mul-dot */
+#define PKE_LEN_BLOCK_IN_WOED 0x02
+#define PKE_LEN_BLOCK_IN_BYTE 0x08
+
+#ifndef WORD_WIDTH
+#define WORD_WIDTH 4
+#endif
+
+typedef enum {
+    HAL_SET_KEY_LEN = 0,
+    HAL_RAM_SECTION_LEN,
+    HAL_ECC_512_LEN,
+    HAL_ECC_521_LEN,
+    HAL_ALIGN_LEN = 0xff,
+} diff_len_in_chips;
+
+typedef union {
+    td_u8 byte[PKE_LEN_BLOCK_IN_BYTE];
+    td_u32 word[PKE_LEN_BLOCK_IN_WOED];
+} pke_block;
+
+typedef enum {
+    HAL_PKE_MODE_CLR_RAM        = 0,
+    HAL_PKE_MODE_EXP_MOD,
+    HAL_PKE_MODE_MUL_DOT,
+    HAL_PKE_MODE_ADD_DOT,
+    HAL_PKE_MODE_TIMES_DOT,
+    HAL_PKE_MODE_MINV_MOD,
+    HAL_PKE_MODE_SUB_MOD,
+    HAL_PKE_MODE_MUL_MOD,
+    HAL_PKE_MODE_ADD_MOD,
+    HAL_PKE_MODE_MOD,
+    HAL_PKE_MODE_MUL,
+    HAL_PKE_MODE_MG_MUL_DOT,
+    HAL_PKE_MODE_ED_MUL_DOT,
+    HAL_PKE_MODE_ED_ADD_DOT,
+    HAL_PKE_MODE_KGEN_NO_E,
+    HAL_PKE_MODE_KGEN_WITH_E,
+    HAL_PKE_MODE_KTRANS
+} hal_pke_mode;
+
+typedef enum {
+    PKE_DATA_LEN_BYTE_32 = 4,
+    PKE_DATA_LEN_BYTE_48 = 6,
+    PKE_DATA_LEN_BYTE_64 = 8,
+    PKE_DATA_LEN_BYTE_72 = 9,
+    PKE_DATA_LEN_BYTE_128 = 16,
+    PKE_DATA_LEN_BYTE_256 = 32,
+    PKE_DATA_LEN_BYTE_384 = 48,
+    PKE_DATA_LEN_BYTE_512 = 64,
+} pke_data_len;
+
+typedef enum {
+    PKE_RAM_TYPE_MRAM = 0, /* 0x0200 ~ 0x05FF */
+    PKE_RAM_TYPE_NRAM,     /* 0x0600 ~ 0x09FF */
+    PKE_RAM_TYPE_KRAM,     /* 0x0a00 ~ 0x0dFF */
+    PKE_RAM_TYPE_RRAM,     /* 0x0e00 ~ 0x11FF */
+} pke_ram_type;
+
+
+td_s32 hal_pke_init(void);
+
+td_s32 hal_pke_deinit(void);
+
+td_s32 hal_pke_lock(void);
+
+td_s32 hal_pke_unlock(void);
+
+td_s32 hal_pke_wait_free(void);
+
+td_void hal_pke_start(void);
+
+td_u32 hal_pke_done_try(void);
+
+td_void hal_pke_done_notify(void);
+
+td_s32 hal_pke_wait_done(void);
+
+td_s32 hal_pke_set_mode(hal_pke_mode mode, td_u32 len);
+
+td_void hal_pke_set_ram(td_u32 addr, const td_u8 *ram, td_u32 data_len, td_u32 padded_len);
+
+td_void hal_pke_get_ram(td_u32 addr, td_u8 *ram, td_u32 klen);
+
+td_void hal_pke_set_key(const td_u8 *inkey, td_u8 *outkey, td_u32 klen, pke_block *random, td_u32 pad_len);
+
+td_s32 hal_pke_align_len(td_u32 a_len, td_u32 *a_len_aligned, diff_len_in_chips len);
+
+td_void hal_pke_secure(td_bool enable);
+
+td_s32 hal_cipher_pke_register_wait_func(td_void *wait,
+    crypto_wait_timeout_interruptible wait_func, td_u32 timeout_ms);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/hal_include/hal_pke_v5.h b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_pke_v5.h
new file mode 100644
index 0000000..b2d71e0
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_pke_v5.h
@@ -0,0 +1,195 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2022. All rights reserved.
+ * Description: Head file of pke HAL API and logical algorithm API
+ * Author: CompanyName
+ * Create: 2022-08-09
+*/
+
+#ifndef HAL_PEK_V5_H
+#define HAL_PEK_V5_H
+
+#include "crypto_security.h"
+#include "crypto_pke_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+typedef enum {
+    PKE_SINGLE_INSTR0 = 0x0,
+    PKE_SINGLE_INSTR1 = 0x1,
+    PKE_BATCH_INSTR = 0x2
+} pke_mode;
+
+typedef enum {
+    PKE_192_BIT_WORK_LEN = 0x3,
+    PKE_224_BIT_WORK_LEN = 0x4,
+    PKE_256_BIT_WORK_LEN = 0x4,
+    PKE_384_BIT_WORK_LEN = 0x6,
+    PKE_BRAINPOOL_512_BIT_WORK_LEN = 0x8,
+    PKE_512_BIT_WORK_LEN = 0x9,
+    PKE_2048_BIT_WORK_LEN = 0x20,
+    PKE_3072_BIT_WORK_LEN = 0x30,
+    PKE_4096_BIT_WORK_LEN = 0x40,
+} pke_data_work_len;
+
+extern td_u32 g_pke_initialize;
+
+/************************************************** hal outter API start************************************/
+td_s32 hal_pke_init(void);
+td_s32 hal_pke_deinit(void);
+
+td_s32 hal_pke_lock(void);
+void hal_pke_unlock(void);
+
+void hal_pke_enable_noise(void);
+void hal_pke_disable_noise(void);
+
+td_void hal_pke_secure(td_bool is_secure);
+
+/**
+ * @brief set mask random into registerfor set_ram and get_ram.
+ *
+ * @return td_s32
+ */
+td_s32 hal_pke_pre_process(void);
+
+void hal_pke_set_wait_event(void *wait, const crypto_wait_timeout_interruptible wait_func,
+    const td_u32 timeout_ms, const td_bool wait_done);
+
+/**
+ * @brief check PKE busy, if success, then do next steps.
+ *
+ * @return td_s32 TD_SUCCESS or other.
+ */
+td_s32 hal_pke_check_free(void);
+
+/**
+ * @brief set data to PKE DRAM.
+ *
+ * @param ram_section the address of offset block in DRAM for data to write into.
+ * @param data the data value.
+ * @param data_len  the effective length of data in byte.
+ * @param aligned_len the aligned length of data in byte when participate in calculate. In old IP, this is the klen,
+ * such as 32(256bit), 48(384bit), 64(512bit), 68(521bit), etc. This API mainly used in RSA calculate, for ecc, the
+ * input curve parameters are aligned, no need to process.
+ * @param CIPHER_CHECK_WORD ifdef SEC_ENHANCE, the value is XOR result of parameters, otherwise it doesn't exist.
+ * @return td_void
+ */
+td_void hal_pke_set_ram(td_u32 ram_section, const td_u8 *data, td_u32 data_len, td_u32 aligned_len CIPHER_CHECK_WORD);
+
+td_void hal_pke_set_ram_const_1(td_u32 addr, td_u32 data_len);
+
+/**
+ * @brief get result data in PKE DRAM
+ *
+ * @param ram_section the address of offset block in DRAM for data to get out.
+ * @param data the data value.
+ * @param data_len the effective length of data in byte.
+ * @param CIPHER_CHECK_WORD ifdef SEC_ENHANCE, the value is XOR result of parameters, otherwise it doesn't exist.
+ */
+td_void hal_pke_get_ram(td_u32 ram_section, td_u8 *data, td_u32 data_len CIPHER_CHECK_WORD);
+
+/**
+ * @brief clear the data in DRAM as random value. Only need to clear at the last calculate.
+ *
+ * @return td_s32
+ */
+td_s32 hal_pke_clean_ram(void);
+
+/**
+ * @brief set calculate mode, work_len and instr to register.
+ *
+ * @param mode calculation mode, see pke_mode.
+ * @param single_instr If the mode is PKE_SINGLE_INSTR0 or PKE_SINGLE_INSTR1, then set this. Otherwise, set it 0.
+ * @param batch_instr If the mode is PKE_BATCH_INSTR, then set this. Otherwise, set it TD_NULL.
+ * @param work_len work_len=ceiling(width/64), width is the data aligned bit width length,
+ * or work_len=ceiling(aligned_len/8).
+ * @param CIPHER_CHECK_WORD ifdef SEC_ENHANCE, the value is XOR result of parameters, otherwise it doesn't exist.
+ * @return td_s32 TD_SUCCESS or others.
+ */
+td_s32 hal_pke_set_mode(pke_mode mode, td_u32 single_instr, const rom_lib *batch_instr,
+    pke_data_work_len work_len CIPHER_CHECK_WORD);
+
+/**
+ * @brief start PKE calculate
+ *
+ * @param mode SINGLE_INSTR or BATCH_INSTR
+ * @param CIPHER_CHECK_WORD ifdef SEC_ENHANCE, the value is XOR result of parameters, otherwise it doesn't exist.
+ * @return td_s32 TD_SUCCESS or others.
+ */
+td_s32 hal_pke_start(pke_mode mode CIPHER_CHECK_WORD);
+
+/**
+ * @brief PKE wait calculation finish
+ *
+ * @return td_s32
+ */
+td_s32 hal_pke_wait_done(void);
+
+/**
+ * @brief Get the align val object of PKE, which depending on the chip version.
+ *
+ * @param len the input data len.
+ * @param aligned_len the aligned length used to calculate.
+ */
+td_s32 hal_pke_get_align_val(const td_u32 len, td_u32 *aligned_len);
+
+/**
+ * @brief Set the montgomery parameter for modular multiplication.
+ *
+ * @param low_bit the low 32bit data.
+ * @param high_bit the high 32bit data.
+ * @param CIPHER_CHECK_WORD ifdef SEC_ENHANCE, the value is XOR result of parameters, otherwise it doesn't exist.
+ * @return td_s32 TD_SUCCESS or others.
+ */
+td_s32 hal_pke_set_mont_para(td_u32 low_bit, td_u32 high_bit CIPHER_CHECK_WORD);
+
+/**
+ * @brief set the initial parameters into DRAM const region for curve.
+ *
+ * @param init_param the initial parameters.
+ * @param ecc_curve the ecc curve type.
+ * @return td_s32 TD_SUCCESS or others.
+ */
+td_s32 hal_pke_set_curve_param(const pke_ecc_init_param *init_param, const drv_pke_ecc_curve *ecc_curve);
+
+#ifdef PKE_ED25519_SUPPORT
+/**
+ * @brief set the initial parameters into DRAM const region for ed curve.
+ *
+ * @param init_param the initial parameters.
+ * @param ecc_curve the ecc curve type.
+ * @return td_s32 TD_SUCCESS or others.
+ */
+td_s32 hal_pke_set_ed_param(const pke_ecc_init_param *init_param, const drv_pke_ecc_curve *ecc_curve);
+#endif
+
+/**
+ * @brief set the initial parameters into DRAM const region for ecc curve.
+ *
+ * @param init_param the initial parameters.
+ * @param ecc_curve the ecc curve type.
+ * @return td_s32 TD_SUCCESS or others.
+ */
+td_s32 hal_pke_set_ecc_param(const pke_ecc_init_param *init_param, const drv_pke_ecc_curve *ecc_curve);
+
+/**
+ * @brief set the initial parameters into DRAM.
+ *
+ * @param init_param the initial parameters.
+ * @param ecc_curve the ecc curve type.
+ * @return td_s32 TD_SUCCESS or others.
+ */
+td_s32 hal_pke_set_init_param(const pke_ecc_init_param *init_param, const drv_pke_ecc_curve *ecc_curve);
+/************************************************** hal outter API end************************************/
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/hal_include/hal_rkp.h b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_rkp.h
new file mode 100644
index 0000000..522448e
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_rkp.h
@@ -0,0 +1,53 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal rkp header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_RKP_H
+#define HAL_RKP_H
+
+#include "crypto_type.h"
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 hal_rkp_lock(td_void);
+
+td_s32 hal_rkp_unlock(td_void);
+
+td_s32 hal_rkp_deob_update(crypto_kdf_otp_key otp_key, crypto_kdf_update_alg alg);
+
+td_s32 hal_rkp_kdf_set_val(const td_u8 *kdf_val, td_u32 val_length);
+
+td_s32 hal_rkp_kdf_get_val(td_u8 *kdf_val, td_u32 val_length);
+
+td_s32 hal_rkp_kdf_set_padding_salt(const td_u8 *padding_salt, td_u32 salt_length);
+
+td_s32 hal_rkp_kdf_set_padding_key(const td_u8 *padding_key, td_u32 key_length);
+
+td_s32 hal_rkp_clear_reg_key(td_void);
+
+td_s32 hal_rkp_kdf_sw_start(crypto_kdf_sw_alg sw_alg, td_u32 count, td_bool is_wait);
+
+td_s32 hal_rkp_deob_wait_done(td_void);
+
+td_s32 hal_rkp_kdf_wait_done(td_void);
+
+td_s32 hal_rkp_kdf_hard_calculation(const crypto_kdf_hard_calc_param *param);
+
+td_void hal_rkp_debug(td_void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/hal_include/hal_symc.h b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_symc.h
new file mode 100644
index 0000000..649da15
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_symc.h
@@ -0,0 +1,119 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal symc header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_SYMC_H
+#define HAL_SYMC_H
+
+#include "crypto_symc_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 hal_cipher_symc_init(td_void);
+
+td_s32 hal_cipher_symc_deinit(td_void);
+
+td_s32 hal_cipher_symc_low_power_set(td_bool flag);
+
+td_s32 hal_cipher_symc_lock_chn(td_u32 chn_num);
+
+td_s32 hal_cipher_symc_unlock_chn(td_u32 chn_num);
+
+td_s32 hal_cipher_symc_attach(td_u32 symc_chn_num, td_u32 keyslot_chn_num);
+
+td_s32 hal_cipher_symc_set_iv(td_u32 chn_num, const td_u8 *iv, td_u32 iv_len);
+
+td_s32 hal_cipher_symc_get_iv(td_u32 chn_num, td_u8 *iv, td_u32 iv_len);
+
+typedef struct {
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    crypto_symc_bit_width symc_bit_width;
+    td_bool is_decrypt;
+    crypto_symc_iv_change_type iv_change_flag;
+} hal_symc_config_t;
+
+td_s32 hal_cipher_symc_set_flag(td_u32 chn_num, td_bool is_decrypt);
+
+td_s32 hal_cipher_symc_config(td_u32 chn_num, const hal_symc_config_t *symc_config);
+
+td_s32 hal_cipher_symc_get_module_info(crypto_symc_module_info *module_info);
+
+td_s32 hal_cipher_symc_get_proc_info(td_u32 chn_num, crypto_symc_proc_info *proc_symc_info);
+
+td_s32 hal_cipher_symc_get_config(td_u32 chn_num, hal_symc_config_t *symc_config);
+
+td_s32 hal_cipher_symc_add_in_node(td_u32 chn_num, td_u64 data_phys_addr, td_u32 data_len,
+    in_node_type_e in_node_type);
+
+td_s32 hal_cipher_symc_add_out_node(td_u32 chn_num, td_u64 data_phys_addr, td_u32 data_len);
+
+td_s32 hal_cipher_symc_enable_cenc_node(td_u32 chn_num, td_u32 is_head,
+    td_u32 c_num, td_u32 e_num, td_u32 offset_len);
+
+td_s32 hal_cipher_symc_get_tag(td_u32 chn_num, td_u8 *tag, td_u32 tag_len);
+
+td_s32 hal_cipher_symc_start(td_u32 chn_num);
+
+td_s32 hal_cipher_symc_wait_done(td_u32 chn_num, td_bool is_wait);
+
+td_s32 hal_cipher_symc_done_try(td_u32 chn_num);
+
+td_s32 hal_cipher_symc_done_notify(td_u32 chn_num);
+
+td_s32 hal_cipher_symc_register_wait_func(td_u32 chn_num, td_void *wait,
+    crypto_wait_timeout_interruptible wait_func, td_u32 timeout_ms);
+
+td_s32 hal_cipher_symc_debug(td_void);
+
+td_s32 hal_cipher_symc_debug_chn(td_u32 chn_num);
+
+td_s32 hal_cipher_symc_set_key(td_u32 chn_num, td_u8 *key, td_u32 key_len);
+
+td_void hal_cipher_set_chn_secure(td_u32 chn_num, td_bool dest_sec, td_bool src_sec);
+
+td_s32 hal_cipher_symc_suspend(td_void);
+
+td_s32 hal_cipher_symc_resume(td_void);
+
+int32_t hal_cipher_symc_cmac_update(uint32_t chn_num, uint64_t data_phys_addr, uint32_t data_len, crypto_cmac_ctx *ctx);
+
+int32_t hal_cipher_symc_cmac_finish(uint32_t chn_num, crypto_cmac_ctx *ctx);
+
+int32_t hal_cipher_symc_cbc_mac_update(uint32_t chn_num, uint64_t data_phys_addr, uint32_t data_len,
+    uint8_t *cbc_mac, uint32_t cbc_mac_len);
+
+/* For CCM CMAC. */
+int32_t hal_cipher_ccm_cmac_update(uint32_t chn_num, uint64_t data_phys_addr, uint32_t data_len,
+    uint8_t *cmac, uint32_t cmac_len);
+
+int32_t hal_cipher_ccm_compute_s0(uint32_t chn_num, const uint8_t *ctr0, uint32_t ctr0_len,
+    uint8_t *s0, uint32_t s0_len);
+
+/* For GCM ghash */
+int32_t hal_cipher_gcm_compute_j0(uint32_t chn_num, const uint8_t *gcm_iv, uint32_t gcm_iv_len,
+    uint8_t *j0, uint32_t j0_len);
+
+int32_t hal_cipher_gcm_ghash_update(uint32_t chn_num, uint64_t data_phys_addr, uint32_t data_len,
+    uint8_t *ghash, uint32_t ghash_len);
+
+int32_t hal_cipher_gcm_compute_tag(uint32_t chn_num, const uint8_t *ghash, uint32_t ghash_len,
+    const uint8_t *j0, uint32_t j0_len,
+    uint8_t *tag, uint32_t tag_len);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
diff --git a/bsp/security_subsys/security_subsys_common/include/hal_include/hal_trng.h b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_trng.h
new file mode 100644
index 0000000..5d9645d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/hal_include/hal_trng.h
@@ -0,0 +1,32 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: hal trng header. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+#ifndef HAL_TRNG_H
+#define HAL_TRNG_H
+
+#include "crypto_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 hal_cipher_trng_init(td_void);
+
+td_s32 hal_cipher_trng_get_random(td_u32 *randnum);
+
+td_s32 hal_cipher_trng_deinit(td_void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/ioctl_include/crypto_ioctl.h b/bsp/security_subsys/security_subsys_common/include/ioctl_include/crypto_ioctl.h
new file mode 100644
index 0000000..98bcff7
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/ioctl_include/crypto_ioctl.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef CRYPTO_IOCTL_H
+#define CRYPTO_IOCTL_H
+
+#define CRYPTO_IOC_NA           0U
+#define CRYPTO_IOC_W            1U
+#define CRYPTO_IOC_R            2U
+#define CRYPTO_IOC_RW           3U
+
+/* Ioctl definitions */
+#define CRYPTO_IOC(dir, type, nr, size) (((dir) << 30) | ((size) << 16) | ((type) << 8) | ((nr) << 0))
+
+#define CRYPTO_IOC_DIR(cmd)       (((cmd) >> 30) & 0x03)
+#define CRYPTO_IOC_TYPE(cmd)      (((cmd) >> 8) & 0xFF)
+#define CRYPTO_IOC_NR(cmd)        (((cmd) >> 0) & 0xFF)
+#define CRYPTO_IOC_SIZE(cmd)      (((cmd) >> 16) & 0x3FFF)
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/ioctl_include/crypto_ioctl_cmd.h b/bsp/security_subsys/security_subsys_common/include/ioctl_include/crypto_ioctl_cmd.h
new file mode 100644
index 0000000..6a3f102
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/ioctl_include/crypto_ioctl_cmd.h
@@ -0,0 +1,613 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef CRYPTO_IOCTL_CMD_H
+#define CRYPTO_IOCTL_CMD_H
+
+#include "crypto_ioctl.h"
+
+#include "crypto_hash_struct.h"
+#include "crypto_symc_struct.h"
+#include "crypto_pke_struct.h"
+#include "crypto_common_def.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define CRYPTO_CIPHER_DEV_NAME      "soc_cipher"
+
+typedef struct {
+    crypto_compat_addr key;
+    td_u32 key_len;
+    td_u32 kapi_hash_handle;
+    td_handle drv_keyslot_handle;
+    td_bool is_keyslot;
+    td_bool is_long_term;
+    crypto_hash_type hash_type;
+} hash_start_ctl_t;
+
+typedef struct {
+    crypto_hash_clone_ctx ctx;
+    crypto_hash_type hash_type;
+} hash_start_impl_ctl_t;
+
+typedef struct {
+    crypto_compat_addr src_buf;
+    td_u32 len;
+    td_handle kapi_hash_handle;
+} hash_update_ctl_t;
+
+typedef struct {
+    crypto_hash_clone_ctx ctx;
+    crypto_compat_addr data;
+    td_u32 data_len;
+} hash_update_impl_ctl_t;
+
+typedef struct {
+    crypto_compat_addr out;
+    td_u32 out_len;
+    td_handle kapi_hash_handle;
+} hash_finish_ctl_t;
+
+typedef struct {
+    crypto_hash_clone_ctx ctx;
+    crypto_compat_addr out;
+    td_u32 out_len;
+} hash_finish_impl_ctl_t;
+
+typedef struct {
+    crypto_compat_addr password;
+    crypto_compat_addr salt;
+    crypto_compat_addr out;
+    td_u32 plen;
+    td_u32 slen;
+    td_u32 out_len;
+    td_u16 count;
+    crypto_hash_type hash_type;
+} pbkdf2_ctl_t;
+
+typedef struct {
+    crypto_compat_addr hash_clone_ctx;
+    td_u32 ctx_size;
+    td_handle kapi_hash_handle;
+} hash_clone_ctl_t;
+
+typedef struct {
+    td_handle kapi_hash_handle;
+} hash_handle_ctl_t;
+
+typedef struct {
+    td_u32 randnum;
+} trng_ctl_t;
+
+typedef struct {
+    td_u32 size;
+    crypto_compat_addr randnum;
+} trng_multi_ctl_t;
+
+typedef struct {
+    td_handle symc_handle;
+    crypto_symc_attr symc_attr;
+} symc_create_t;
+
+typedef struct {
+    td_handle symc_handle;
+} symc_destroy_t;
+
+typedef struct {
+    td_handle symc_handle;
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    crypto_symc_key_parity key_parity;
+    crypto_symc_bit_width symc_bit_width;
+    crypto_symc_iv_change_type iv_change_flag;
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    td_u32 aad_len;
+    td_u32 data_len;
+    td_u32 tag_len;
+    td_u32 total_aad_len;
+    unsigned long long aad_mem_handle;
+    unsigned long long aad_phys_addr;
+    crypto_compat_addr aad;
+} symc_config_t;
+
+typedef struct {
+    td_handle symc_handle;
+    td_handle keyslot_handle;
+} symc_get_keyslot_t;
+
+typedef struct {
+    td_handle symc_handle;
+    td_handle keyslot_handle;
+} symc_attach_t;
+
+typedef struct {
+    td_handle symc_handle;
+    td_u8 key[CRYPTO_256_KEY_LEN];
+    td_u32 key_len;
+} symc_set_key_t;
+
+typedef struct {
+    td_handle symc_handle;
+    unsigned long long src_mem_handle;
+    td_u64 src_phys_addr;
+    crypto_buffer_secure src_buf_sec;
+    unsigned long long src_addr_offset;
+    unsigned long long dst_mem_handle;
+    td_u64 dst_phys_addr;
+    crypto_buffer_secure dst_buf_sec;
+    unsigned long long dst_addr_offset;
+    td_u32 length;
+} symc_crypto_t;
+
+typedef struct {
+    crypto_symc_ctrl_t symc_ctrl;
+    symc_crypto_t crypto_info;
+    td_bool is_decrypt;
+    td_handle keyslot_handle;
+}symc_crypto_impl_t;
+
+typedef struct {
+    crypto_symc_ccm_ctx store_ctx;
+    td_handle keyslot_handle;
+    td_u32 processed_aad_len;
+    td_u32 total_aad_len;
+    td_u32 data_len;
+    td_u32 tag_len;
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    crypto_compat_addr add;
+    td_u32 add_len;
+    td_phys_addr_t phys_addr;
+    crypto_compat_addr vir_addr;
+    crypto_symc_key_length symc_key_length;
+}symc_ccm_update_ad_impl_t;
+
+typedef struct {
+    crypto_symc_ccm_ctx store_ctx;
+    td_handle keyslot_handle;
+    td_u32 processed_aad_len;
+    td_u32 total_aad_len;
+    td_u32 data_len;
+    td_u32 tag_len;
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    symc_crypto_t crypto_info;
+    crypto_symc_key_length symc_key_length;
+    td_bool is_decrypt;
+}symc_ccm_update_impl_t;
+
+typedef struct {
+    crypto_symc_ccm_ctx store_ctx;
+    td_handle keyslot_handle;
+    td_u32 total_aad_len;
+    td_u32 data_len;
+    td_u32 tag_len;
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    crypto_compat_addr tag;
+    crypto_symc_key_length symc_key_length;
+}symc_ccm_finish_impl_t;
+
+typedef struct {
+    unsigned long long uapi_mem_handle;
+    td_u64 phys_addr;
+    td_u32 length;
+    crypto_buffer_secure buf_sec;           /* NONSECURE or SECURE */
+} crypto_mem_pack;
+
+typedef struct {
+    td_handle symc_handle;
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    crypto_symc_key_parity key_parity;
+    crypto_symc_bit_width symc_bit_width;
+    crypto_symc_iv_change_type iv_change_flag;
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    crypto_compat_addr src_pack_addr;
+    crypto_compat_addr dst_pack_addr;
+    td_u32 pack_num;
+} crypto_symc_multi_t;
+
+typedef struct {
+    td_handle symc_handle;
+    crypto_symc_alg alg;
+    crypto_symc_work_mode work_mode;
+    td_u32 iv[CRYPTO_AES_IV_SIZE_IN_WORD];
+    td_bool use_odd_key;
+    td_u32 first_encrypt_offset;
+    td_u32 subsample_num;
+    crypto_compat_addr subsample_addr;
+    unsigned long long src_mem_handle;
+    crypto_buffer_secure src_buf_sec;
+    unsigned long long dst_mem_handle;
+    crypto_buffer_secure dst_buf_sec;
+    td_u32 length;
+} crypto_symc_cenc_t;
+
+typedef struct {
+    td_handle symc_handle;
+    td_u8 tag[CRYPTO_AES_MAX_TAG_LEN];
+    td_u32 tag_length;
+} symc_get_tag_t;
+
+typedef struct {
+    td_handle symc_handle;
+    crypto_symc_mac_attr mac_attr;
+} symc_mac_start_t;
+
+typedef struct {
+    td_handle symc_handle;
+    crypto_compat_addr src_buf;
+    td_u32 length;
+} symc_mac_update_t;
+
+typedef struct {
+    td_handle symc_handle;
+    td_u8 mac[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    td_u32 mac_length;
+} symc_mac_finish_t;
+
+typedef struct {
+    crypto_compat_addr data;
+    td_u32  length;
+} drv_pke_data_t;
+
+typedef struct {
+    td_u32  length;
+    crypto_compat_addr data;
+    drv_pke_buffer_secure buf_sec;
+} drv_pke_msg_t;
+
+typedef struct {
+    crypto_compat_addr x;
+    crypto_compat_addr y;
+    td_u32 length;
+} drv_pke_ecc_point_t;
+
+/* * struct of ecc signature */
+typedef struct {
+    crypto_compat_addr r;   /* r component of the signature. */
+    crypto_compat_addr s;   /* s component of the signature. */
+    td_u32 length;
+} drv_pke_ecc_sig_t;
+
+typedef struct {
+    drv_pke_ecc_curve_type curve_type;
+    drv_pke_data_t input_priv_key;
+    drv_pke_data_t output_priv_key;
+    drv_pke_ecc_point_t output_pub_key;
+} pke_ecc_gen_key_ctl_t;
+
+typedef struct {
+    drv_pke_ecc_curve_type curve_type;
+    drv_pke_ecc_point_t input_pub_key;
+    drv_pke_data_t input_priv_key;
+    drv_pke_data_t output_shared_key;
+} pke_ecc_gen_ecdh_key_ctl_t;
+
+typedef struct {
+    drv_pke_ecc_curve_type curve_type;
+    drv_pke_data_t priv_key;
+    drv_pke_data_t hash;
+    drv_pke_ecc_sig_t sig;
+} pke_ecdsa_sign_ctl_t;
+
+typedef struct {
+    drv_pke_ecc_curve_type curve_type;
+    drv_pke_ecc_point_t pub_key;
+    drv_pke_data_t hash;
+    drv_pke_ecc_sig_t sig;
+    crypto_compat_addr v;
+} pke_ecdsa_verify_ctl_t;
+
+typedef struct {
+    drv_pke_ecc_curve_type curve_type;
+    drv_pke_data_t priv_key;
+    drv_pke_msg_t msg;
+    drv_pke_ecc_sig_t sig;
+} pke_eddsa_sign_ctl_t;
+
+typedef struct {
+    drv_pke_ecc_curve_type curve_type;
+    drv_pke_ecc_point_t pub_key;
+    drv_pke_msg_t msg;
+    drv_pke_ecc_sig_t sig;
+} pke_eddsa_verify_ctl_t;
+
+typedef struct {
+    drv_pke_ecc_curve_type curve_type;
+    drv_pke_ecc_point_t pub_key;
+    td_bool is_on_curve;
+} pke_check_dot_on_curve_ctl_t;
+
+typedef struct pke_sm2_dsa_hash_ctl {
+    drv_pke_data_t sm2_id;
+    drv_pke_ecc_point_t pub_key;
+    drv_pke_msg_t msg;
+    drv_pke_data_t hash;
+} pke_sm2_dsa_hash_ctl_t;
+
+typedef struct pke_sm2_public_encrypt_ctl {
+    drv_pke_ecc_point_t pub_key;
+    drv_pke_data_t plain_text;
+    drv_pke_data_t cipher_text;
+} pke_sm2_public_encrypt_ctl_t;
+
+typedef struct {
+    drv_pke_data_t priv_key;
+    drv_pke_data_t cipher_text;
+    drv_pke_data_t plain_text;
+} pke_sm2_private_decrypt_ctl_t;
+
+/* * RSA private key struct */
+typedef struct {
+    crypto_compat_addr n;          /* *< public modulus */
+    crypto_compat_addr e;          /* *< public exponent */
+    crypto_compat_addr d;          /* *< private exponent */
+    crypto_compat_addr p;          /* *< 1st prime factor */
+    crypto_compat_addr q;          /* *< 2nd prime factor */
+    crypto_compat_addr dp;         /* *< D % (P - 1) */
+    crypto_compat_addr dq;         /* *< D % (Q - 1) */
+    crypto_compat_addr qp;         /* *< 1 / (Q % P) */
+    td_u16 n_len;      /* *< length of public modulus */
+    td_u16 e_len;      /* *< length of public exponent */
+    td_u16 d_len;      /* *< length of private exponent */
+    td_u16 p_len;      /* *< length of 1st prime factor,should be half of u16NLen */
+    td_u16 q_len;      /* *< length of 2nd prime factor,should be half of u16NLen */
+    td_u16 dp_len;     /* *< length of D % (P - 1),should be half of u16NLen */
+    td_u16 dq_len;     /* *< length of D % (Q - 1),should be half of u16NLen */
+    td_u16 qp_len;     /* *< length of 1 / (Q % P),should be half of u16NLen */
+} drv_pke_rsa_priv_key_t;
+
+/* * struct of RSA public key */
+typedef struct {
+    crypto_compat_addr n;            /* point to public modulus */
+    crypto_compat_addr e;            /* point to public exponent */
+    td_u16 len;           /* length of public modulus, max value is 512Byte */
+} drv_pke_rsa_pub_key_t;
+
+typedef struct {
+    drv_pke_data_t a;
+    drv_pke_data_t p;
+    drv_pke_data_t c;
+} pke_mod_ctl_t;
+
+typedef struct {
+    drv_pke_data_t n;
+    drv_pke_data_t k;
+    drv_pke_data_t in;
+    drv_pke_data_t out;
+} pke_exp_mod_ctl_t;
+
+typedef struct {
+    drv_pke_data_t input_e;
+    drv_pke_rsa_priv_key_t priv_key;
+} pke_rsa_gen_key_ctl_t;
+
+typedef struct {
+    drv_pke_rsa_priv_key_t priv_key;
+    drv_pke_rsa_scheme scheme;
+    drv_pke_hash_type hash_type;
+    drv_pke_data_t input_hash;
+    drv_pke_data_t sig;
+} pke_rsa_sign_ctl_t;
+
+typedef struct {
+    drv_pke_rsa_pub_key_t pub_key;
+    drv_pke_rsa_scheme scheme;
+    drv_pke_hash_type hash_type;
+    drv_pke_data_t input_hash;
+    drv_pke_data_t sig;
+    drv_pke_data_t output_hash;
+} pke_rsa_verify_ctl_t;
+
+typedef struct {
+    drv_pke_rsa_scheme scheme;
+    drv_pke_hash_type hash_type;
+    drv_pke_rsa_pub_key_t pub_key;
+    drv_pke_data_t input;
+    drv_pke_data_t label;
+    drv_pke_data_t output;
+} pke_rsa_pub_crypto_ctl_t;
+
+typedef struct {
+    drv_pke_rsa_scheme scheme;
+    drv_pke_hash_type hash_type;
+    drv_pke_rsa_priv_key_t priv_key;
+    drv_pke_data_t input;
+    drv_pke_data_t label;
+    drv_pke_data_t output;
+} pke_rsa_priv_crypto_ctl_t;
+
+#define HDCP_AES_GCM_IV_LEN            16
+#define HDCP_AES_GCM_TAG_LEN           16
+#define HDCP_AES_GCM_AAD_LEN           16
+typedef struct {
+    td_u32 ram_sel;
+    td_u32 ram_num;
+    td_u32 key_sel;
+    td_u32 key_slot;
+    crypto_symc_alg alg;
+    crypto_symc_work_mode mode;
+    td_u8 aad[HDCP_AES_GCM_AAD_LEN];
+    td_u8 iv[HDCP_AES_GCM_IV_LEN];
+    td_u8 tag[HDCP_AES_GCM_TAG_LEN];
+    crypto_compat_addr in;
+    crypto_compat_addr out;
+    td_u32 len;
+    td_bool is_decrypt;
+} hdcp_encrypt_ctl_t;
+
+#define HASH_BLOCK_SIZE         64
+
+#define CRYPTO_IO(nr)           CRYPTO_IOC(CRYPTO_IOC_NA, SOC_ID_CIPHER, (nr), 0)
+#define CRYPTO_IOR(nr, size)    CRYPTO_IOC(CRYPTO_IOC_R, SOC_ID_CIPHER, (nr), size)
+#define CRYPTO_IOW(nr, size)    CRYPTO_IOC(CRYPTO_IOC_W, SOC_ID_CIPHER, (nr), size)
+#define CRYPTO_IOWR(nr, size)   CRYPTO_IOC(CRYPTO_IOC_RW, SOC_ID_CIPHER, (nr), size)
+
+enum {
+    /* Hash. */
+    CRYPTO_CMD_HASH_INIT_NR     = 0x0,
+    CRYPTO_CMD_HASH_DEINIT_NR,
+    CRYPTO_CMD_HASH_START_NR,
+    CRYPTO_CMD_HASH_UPDATE_NR,
+    CRYPTO_CMD_HASH_FINISH_NR,
+    CRYPTO_CMD_HASH_GET_NR,
+    CRYPTO_CMD_HASH_SET_NR,
+    CRYPTO_CMD_HASH_DESTROY_NR,
+    CRYPTO_CMD_PBKDF2_NR,
+    CRYPTO_CMD_TRNG_GET_RANDOM_NR,
+    CRYPTO_CMD_TRNG_GET_MULTI_RANDOM_NR,
+
+    /* Cipher. */
+    CRYPTO_CMD_CIPHER_INIT_NR,
+    CRYPTO_CMD_CIPHER_DEINIT_NR,
+    CRYPTO_CMD_CIPHER_CREATE_NR,
+    CRYPTO_CMD_CIPHER_DESTROY_NR,
+    CRYPTO_CMD_CIPHER_SET_CONFIG_NR,
+    CRYPTO_CMD_CIPHER_GET_CONFIG_NR,
+    CRYPTO_CMD_CIPHER_ATTACH_NR,
+    CRYPTO_CMD_CIPHER_GET_KEYSLOT_HANDLE_NR,
+    CRYPTO_CMD_CIPHER_SET_KEY_NR,
+    CRYPTO_CMD_CIPHER_ENCRYPT_NR,
+    CRYPTO_CMD_CIPHER_DECRYPT_NR,
+    CRYPTO_CMD_CIPHER_ENCRYPT_MULTI_NR,
+    CRYPTO_CMD_CIPHER_DECRYPT_MULTI_NR,
+    CRYPTO_CMD_CIPHER_CENC_DECRYPT_NR,
+    CRYPTO_CMD_CIPHER_GET_TAG_NR,
+    CRYPTO_CMD_CIPHER_MAC_START_NR,
+    CRYPTO_CMD_CIPHER_MAC_UPDATE_NR,
+    CRYPTO_CMD_CIPHER_MAC_FINISH_NR,
+
+    /* PKE. ECC */
+    CRYPTO_CMD_PKE_ECC_GEN_KEY_NR,
+    CRYPTO_CMD_PKE_ECC_GEN_ECDH_KEY_NR,
+    CRYPTO_CMD_PKE_ECDSA_SIGN_NR,
+    CRYPTO_CMD_PKE_ECDSA_VERIFY_NR,
+    CRYPTO_CMD_PKE_EDDSA_SIGN_NR,
+    CRYPTO_CMD_PKE_EDDSA_VERIFY_NR,
+    CRYPTO_CMD_PKE_CHECK_DOT_ON_CURVE_NR,
+    CRYPTO_CMD_PKE_SM2_DSA_HASH_NR,
+    CRYPTO_CMD_PKE_SM2_PUBLIC_ENCRYPT_NR,
+    CRYPTO_CMD_PKE_SM2_PRIVATE_DECRYPT_NR,
+    /* PKE. BIGNUM */
+    CRYPTO_CMD_PKE_MOD_NR,
+    CRYPTO_CMD_PKE_EXP_MOD_NR,
+    /* PKE. RSA. */
+    CRYPTO_CMD_PKE_RSA_GEN_KEY_NR,
+    CRYPTO_CMD_PKE_RSA_SIGN_NR,
+    CRYPTO_CMD_PKE_RSA_VERIFY_NR,
+    CRYPTO_CMD_PKE_RSA_PUBLIC_ENCRYPT_NR,
+    CRYPTO_CMD_PKE_RSA_PRIVATE_DECRYPT_NR,
+    /* HDCP */
+    CRYPTO_CMD_HDCP_ENCRYPT_NR,
+    /* HARDEN SUPPORT */
+    CRYPTO_CMD_HASH_START_IMPL_NR,
+    CRYPTO_CMD_HASH_UPDATE_IMPL_NR,
+    CRYPTO_CMD_HASH_FINISH_IMPL_NR,
+    CRYPTO_CMD_SYMC_CRYPT_IMPL_NR,
+    CRYPTO_CMD_CCM_UPDATE_AD_IMPL_NR,
+    CRYPTO_CMD_CCM_UPDATE_IMPL_NR,
+    CRYPTO_CMD_CCM_FINISH_IMPL_NR,
+    CRYPTO_CMD_COUNT,
+};
+
+#define CRYPTO_CMD_HDCP_ENCRYPT                CRYPTO_IOWR(CRYPTO_CMD_HDCP_ENCRYPT_NR, sizeof(hdcp_encrypt_ctl_t))
+
+#define CRYPTO_CMD_HASH_INIT                   CRYPTO_IO(CRYPTO_CMD_HASH_INIT_NR)
+#define CRYPTO_CMD_HASH_DEINIT                 CRYPTO_IO(CRYPTO_CMD_HASH_DEINIT_NR)
+#define CRYPTO_CMD_HASH_START                  CRYPTO_IOWR(CRYPTO_CMD_HASH_START_NR, sizeof(hash_start_ctl_t))
+#define CRYPTO_CMD_HASH_UPDATE                 CRYPTO_IOWR(CRYPTO_CMD_HASH_UPDATE_NR, sizeof(hash_update_ctl_t))
+#define CRYPTO_CMD_HASH_FINISH                 CRYPTO_IOWR(CRYPTO_CMD_HASH_FINISH_NR, sizeof(hash_finish_ctl_t))
+#define CRYPTO_CMD_HASH_GET                    CRYPTO_IOWR(CRYPTO_CMD_HASH_GET_NR, sizeof(hash_clone_ctl_t))
+#define CRYPTO_CMD_HASH_SET                    CRYPTO_IOWR(CRYPTO_CMD_HASH_SET_NR, sizeof(hash_clone_ctl_t))
+#define CRYPTO_CMD_HASH_DESTROY                CRYPTO_IOWR(CRYPTO_CMD_HASH_DESTROY_NR, sizeof(hash_handle_ctl_t))
+#define CRYPTO_CMD_PBKDF2                      CRYPTO_IOWR(CRYPTO_CMD_PBKDF2_NR, sizeof(pbkdf2_ctl_t))
+#define CRYPTO_CMD_TRNG_GET_RANDOM             CRYPTO_IOWR(CRYPTO_CMD_TRNG_GET_RANDOM_NR, sizeof(trng_ctl_t))
+#define CRYPTO_CMD_TRNG_GET_MULTI_RANDOM      CRYPTO_IOWR(CRYPTO_CMD_TRNG_GET_MULTI_RANDOM_NR, sizeof(trng_multi_ctl_t))
+
+#define CRYPTO_CMD_SYMC_INIT                   CRYPTO_IO(CRYPTO_CMD_CIPHER_INIT_NR)
+#define CRYPTO_CMD_SYMC_DEINIT                 CRYPTO_IO(CRYPTO_CMD_CIPHER_DEINIT_NR)
+#define CRYPTO_CMD_SYMC_CREATE                 CRYPTO_IOWR(CRYPTO_CMD_CIPHER_CREATE_NR, sizeof(symc_create_t))
+#define CRYPTO_CMD_SYMC_DESTROY                CRYPTO_IOWR(CRYPTO_CMD_CIPHER_DESTROY_NR, sizeof(symc_destroy_t))
+#define CRYPTO_CMD_SYMC_SET_CONFIG             CRYPTO_IOWR(CRYPTO_CMD_CIPHER_SET_CONFIG_NR, sizeof(symc_config_t))
+#define CRYPTO_CMD_SYMC_GET_CONFIG             CRYPTO_IOWR(CRYPTO_CMD_CIPHER_GET_CONFIG_NR, sizeof(symc_config_t))
+#define CRYPTO_CMD_SYMC_ATTACH                 CRYPTO_IOWR(CRYPTO_CMD_CIPHER_ATTACH_NR, sizeof(symc_attach_t))
+#define CRYPTO_CMD_SYMC_GET_KEYSLOT_HANDLE     \
+            CRYPTO_IOWR(CRYPTO_CMD_CIPHER_GET_KEYSLOT_HANDLE_NR, sizeof(symc_get_keyslot_t))
+#define CRYPTO_CMD_SYMC_SET_KEY                CRYPTO_IOWR(CRYPTO_CMD_CIPHER_SET_KEY_NR, sizeof(symc_set_key_t))
+#define CRYPTO_CMD_SYMC_ENCRYPT                CRYPTO_IOWR(CRYPTO_CMD_CIPHER_ENCRYPT_NR, sizeof(symc_crypto_t))
+#define CRYPTO_CMD_SYMC_DECRYPT                CRYPTO_IOWR(CRYPTO_CMD_CIPHER_DECRYPT_NR, sizeof(symc_crypto_t))
+#define CRYPTO_CMD_SYMC_ENCRYPT_MULTI          \
+            CRYPTO_IOWR(CRYPTO_CMD_CIPHER_ENCRYPT_MULTI_NR, sizeof(crypto_symc_multi_t))
+#define CRYPTO_CMD_SYMC_DECRYPT_MULTI          \
+            CRYPTO_IOWR(CRYPTO_CMD_CIPHER_DECRYPT_MULTI_NR, sizeof(crypto_symc_multi_t))
+#define CRYPTO_CMD_SYMC_CENC_DECRYPT           \
+            CRYPTO_IOWR(CRYPTO_CMD_CIPHER_CENC_DECRYPT_NR, sizeof(crypto_symc_cenc_t))
+
+#define CRYPTO_CMD_SYMC_GET_TAG                CRYPTO_IOWR(CRYPTO_CMD_CIPHER_GET_TAG_NR, sizeof(symc_get_tag_t))
+#define CRYPTO_CMD_SYMC_MAC_START              CRYPTO_IOWR(CRYPTO_CMD_CIPHER_MAC_START_NR, sizeof(symc_mac_start_t))
+#define CRYPTO_CMD_SYMC_MAC_UPDATE             CRYPTO_IOWR(CRYPTO_CMD_CIPHER_MAC_UPDATE_NR, sizeof(symc_mac_update_t))
+#define CRYPTO_CMD_SYMC_MAC_FINISH             CRYPTO_IOWR(CRYPTO_CMD_CIPHER_MAC_FINISH_NR, sizeof(symc_mac_finish_t))
+
+#define CRYPTO_CMD_PKE_MOD                     CRYPTO_IOWR(CRYPTO_CMD_PKE_MOD_NR, sizeof(pke_mod_ctl_t))
+#define CRYPTO_CMD_PKE_EXP_MOD                 CRYPTO_IOWR(CRYPTO_CMD_PKE_EXP_MOD_NR, sizeof(pke_exp_mod_ctl_t))
+
+#define CRYPTO_CMD_PKE_ECC_GEN_KEY             \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_ECC_GEN_KEY_NR, sizeof(pke_ecc_gen_key_ctl_t))
+#define CRYPTO_CMD_PKE_ECC_GEN_ECDH_KEY        \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_ECC_GEN_ECDH_KEY_NR, sizeof(pke_ecc_gen_ecdh_key_ctl_t))
+#define CRYPTO_CMD_PKE_ECDSA_SIGN              \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_ECDSA_SIGN_NR, sizeof(pke_ecdsa_sign_ctl_t))
+#define CRYPTO_CMD_PKE_ECDSA_VERIFY            \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_ECDSA_VERIFY_NR, sizeof(pke_ecdsa_verify_ctl_t))
+#define CRYPTO_CMD_PKE_EDDSA_SIGN              \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_EDDSA_SIGN_NR, sizeof(pke_eddsa_sign_ctl_t))
+#define CRYPTO_CMD_PKE_EDDSA_VERIFY            \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_EDDSA_VERIFY_NR, sizeof(pke_eddsa_verify_ctl_t))
+#define CRYPTO_CMD_PKE_CHECK_DOT_ON_CURVE      \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_CHECK_DOT_ON_CURVE_NR, sizeof(pke_check_dot_on_curve_ctl_t))
+#define CRYPTO_CMD_PKE_SM2_DSA_HASH            \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_SM2_DSA_HASH_NR, sizeof(pke_sm2_dsa_hash_ctl_t))
+#define CRYPTO_CMD_PKE_SM2_PUBLIC_ENCRYPT      \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_SM2_PUBLIC_ENCRYPT_NR, sizeof(pke_sm2_public_encrypt_ctl_t))
+#define CRYPTO_CMD_PKE_SM2_PRIVATE_DECRYPT     \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_SM2_PRIVATE_DECRYPT_NR, sizeof(pke_sm2_private_decrypt_ctl_t))
+
+#define CRYPTO_CMD_PKE_RSA_GEN_KEY             \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_RSA_GEN_KEY_NR, sizeof(pke_rsa_gen_key_ctl_t))
+#define CRYPTO_CMD_PKE_RSA_SIGN                \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_RSA_SIGN_NR, sizeof(pke_rsa_sign_ctl_t))
+#define CRYPTO_CMD_PKE_RSA_VERIFY              \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_RSA_VERIFY_NR, sizeof(pke_rsa_verify_ctl_t))
+#define CRYPTO_CMD_PKE_RSA_PUBLIC_ENCRYPT      \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_RSA_PUBLIC_ENCRYPT_NR, sizeof(pke_rsa_pub_crypto_ctl_t))
+#define CRYPTO_CMD_PKE_RSA_PRIVATE_DECRYPT     \
+            CRYPTO_IOWR(CRYPTO_CMD_PKE_RSA_PRIVATE_DECRYPT_NR, sizeof(pke_rsa_priv_crypto_ctl_t))
+
+#define CRYPTO_CMD_HASH_START_IMPL             \
+            CRYPTO_IOWR(CRYPTO_CMD_HASH_START_IMPL_NR, sizeof(hash_start_impl_ctl_t))
+#define CRYPTO_CMD_HASH_UPDATE_IMPL            \
+            CRYPTO_IOWR(CRYPTO_CMD_HASH_UPDATE_IMPL_NR, sizeof(hash_update_impl_ctl_t))
+#define CRYPTO_CMD_HASH_FINISH_IMPL            \
+            CRYPTO_IOWR(CRYPTO_CMD_HASH_FINISH_IMPL_NR, sizeof(hash_finish_impl_ctl_t))
+#define CRYPTO_CMD_SYMC_CRYPT_IMPL             \
+            CRYPTO_IOWR(CRYPTO_CMD_SYMC_CRYPT_IMPL_NR, sizeof(symc_crypto_impl_t))
+#define CRYPTO_CMD_CCM_UPDATE_AD_IMPL          \
+            CRYPTO_IOWR(CRYPTO_CMD_CCM_UPDATE_AD_IMPL_NR, sizeof(symc_ccm_update_ad_impl_t))
+#define CRYPTO_CMD_CCM_UPDATE_IMPL          \
+            CRYPTO_IOWR(CRYPTO_CMD_CCM_UPDATE_IMPL_NR, sizeof(symc_ccm_update_impl_t))
+#define CRYPTO_CMD_CCM_FINISH_IMPL          \
+            CRYPTO_IOWR(CRYPTO_CMD_CCM_FINISH_IMPL_NR, sizeof(symc_ccm_finish_impl_t))
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* End of #ifndef CRYPTO_IOCTL_CMD_H */
diff --git a/bsp/security_subsys/security_subsys_common/include/ioctl_include/ioctl_km.h b/bsp/security_subsys/security_subsys_common/include/ioctl_include/ioctl_km.h
new file mode 100644
index 0000000..1be9972
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/ioctl_include/ioctl_km.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef OT_KM_IOCTL_CMD_H
+#define OT_KM_IOCTL_CMD_H
+#include "crypto_ioctl.h"
+#include "crypto_common_struct.h"
+#include "crypto_km_struct.h"
+
+#define IOC_TYPE_KM    'n'
+
+typedef enum {
+    /* Keyslot. */
+    KM_KEYSLOT_IOC_NR_CREATE_HANDLE,
+    KM_KEYSLOT_IOC_NR_DESTROY_HANDLE,
+    /* Klad. */
+    KM_KLAD_IOC_NR_CREATE_HANDLE,
+    KM_KLAD_IOC_NR_DESTROY_HANDLE,
+    KM_KLAD_IOC_NR_ATTACH,
+    KM_KLAD_IOC_NR_DETACH,
+    KM_KLAD_IOC_NR_SET_ATTR,
+    KM_KLAD_IOC_NR_GET_ATTR,
+    KM_KLAD_IOC_NR_SET_SESSION_KEY,
+    KM_KLAD_IOC_NR_SET_CONTENT_KEY,
+    KM_KLAD_IOC_NR_SET_CLEAR_KEY,
+    KM_KLAD_IOC_NR_SET_EFFECTIVE_KEY,
+    /* kdf. */
+    KM_KDF_IOC_NR_PBKDF2,
+    KM_IOC_NR_CREATE_KEY,
+    KM_IOC_NR_SET_KEY,
+    KM_IOC_NR_DESTROY_KEY,
+    KM_IOC_NR_BUTT,
+} km_ioc_nr;
+
+/* Keyslot. */
+typedef struct {
+    td_handle kapi_keyslot_handle;
+    crypto_keyslot_type keyslot_type;
+} keyslot_create_ctl_t;
+
+typedef struct {
+    td_handle kapi_keyslot_handle;
+} keyslot_destroy_ctl_t;
+
+/* Klad. */
+typedef struct {
+    td_handle kapi_klad_handle;
+} klad_handle_ctl_t;
+
+typedef struct {
+    td_handle kapi_klad_handle;
+    crypto_klad_dest klad_type;
+    td_handle kapi_keyslot_handle;
+} klad_attach_ctl_t;
+
+typedef struct klad_attr_ctl {
+    td_handle kapi_klad_handle;
+    crypto_klad_attr attr;
+} klad_attr_ctl_t;
+
+typedef struct klad_set_session_key_ctl {
+    td_handle kapi_klad_handle;
+    crypto_klad_level_sel level;
+    crypto_klad_alg_sel alg;
+    td_u32 key_size;
+    crypto_compat_addr key;
+} klad_set_session_key_ctl_t;
+
+typedef struct klad_set_content_key_ctl {
+    td_handle kapi_klad_handle;
+    crypto_klad_alg_sel alg;
+    td_bool key_parity;
+    td_u32 key_size;
+    crypto_compat_addr key;
+} klad_set_content_key_ctl_t;
+
+typedef struct klad_set_clear_key_ctl {
+    td_handle kapi_klad_handle;
+    crypto_klad_hmac_type hmac_type;
+    td_bool key_parity;
+    td_u32 key_size;
+    crypto_compat_addr key;
+} klad_set_clear_key_ctl_t;
+
+typedef struct km_create_key_impl_ctl_t {
+    td_handle kapi_kslot_handle;
+} km_create_key_impl_ctl_t;
+
+typedef struct km_set_impl_ctl_t {
+    td_handle kapi_kslot_handle;
+    td_bool tee_open;
+    td_u32 key_size;
+    crypto_compat_addr key;
+} km_set_impl_ctl_t;
+
+typedef struct km_destroy_key_impl_ctl_t {
+    td_handle kapi_keyslot_handle;
+} km_destroy_key_impl_ctl_t;
+
+typedef struct klad_set_effective_key_ctl {
+    td_handle kapi_klad_handle;
+    crypto_kdf_hard_alg kdf_hard_alg;
+    td_bool key_parity;
+    crypto_klad_key_size key_size;
+    td_u8 *salt;
+    td_u32 salt_length;
+    td_bool oneway;
+} klad_set_effective_key_ctl_t;
+
+#define KM_IOWR(nr, struct_name)           CRYPTO_IOC(CRYPTO_IOC_RW, IOC_TYPE_KM, (nr), sizeof(struct_name))
+
+/* Keyslot. */
+#define CMD_KEYSLOT_CREATE_HANDLE       KM_IOWR(KM_KEYSLOT_IOC_NR_CREATE_HANDLE, keyslot_create_ctl_t)
+#define CMD_KEYSLOT_DESTROY_HANDLE      KM_IOWR(KM_KEYSLOT_IOC_NR_DESTROY_HANDLE, keyslot_destroy_ctl_t)
+
+/* Klad. */
+#define CMD_KLAD_CREATE_HANDLE          KM_IOWR(KM_KLAD_IOC_NR_CREATE_HANDLE, klad_handle_ctl_t)
+#define CMD_KLAD_DESTROY_HANDLE         KM_IOWR(KM_KLAD_IOC_NR_DESTROY_HANDLE, klad_handle_ctl_t)
+#define CMD_KLAD_ATTACH                 KM_IOWR(KM_KLAD_IOC_NR_ATTACH, klad_attach_ctl_t)
+#define CMD_KLAD_DETACH                 KM_IOWR(KM_KLAD_IOC_NR_DETACH, klad_attach_ctl_t)
+#define CMD_KLAD_SET_ATTR               KM_IOWR(KM_KLAD_IOC_NR_SET_ATTR, klad_attr_ctl_t)
+#define CMD_KLAD_GET_ATTR               KM_IOWR(KM_KLAD_IOC_NR_GET_ATTR, klad_attr_ctl_t)
+#define CMD_KLAD_SET_SESSION_KEY        KM_IOWR(KM_KLAD_IOC_NR_SET_SESSION_KEY, klad_set_session_key_ctl_t)
+#define CMD_KLAD_SET_CONTENT_KEY        KM_IOWR(KM_KLAD_IOC_NR_SET_CONTENT_KEY, klad_set_content_key_ctl_t)
+#define CMD_KLAD_SET_CLEAR_KEY          KM_IOWR(KM_KLAD_IOC_NR_SET_CLEAR_KEY, klad_set_clear_key_ctl_t)
+#define CMD_KLAD_SET_EFFECTVE_KEY       KM_IOWR(KM_KLAD_IOC_NR_SET_EFFECTIVE_KEY, klad_set_effective_key_ctl_t)
+#define CMD_KM_CREATE_KEY_IMPL          KM_IOWR(KM_IOC_NR_CREATE_KEY, km_create_key_impl_ctl_t)
+#define CMD_KM_SET_KEY_IMPL             KM_IOWR(KM_IOC_NR_SET_KEY, km_set_impl_ctl_t)
+#define CMD_KM_DESTROY_KEY_IMPL         KM_IOWR(KM_IOC_NR_DESTROY_KEY, km_destroy_key_impl_ctl_t)
+
+#define CMD_KM_MAX_NUM                  KM_IOC_NR_BUTT
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/ioctl_include/ioctl_otp.h b/bsp/security_subsys/security_subsys_common/include/ioctl_include/ioctl_otp.h
new file mode 100644
index 0000000..de598ac
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/ioctl_include/ioctl_otp.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef IOCTL_CMD_OTP_H
+#define IOCTL_CMD_OTP_H
+
+#include "crypto_ioctl.h"
+#include "crypto_type.h"
+
+#define IOC_TYPE_OTP    'm'
+
+typedef enum {
+    /* OTP. */
+    OTP_IOC_NR_READ_WORD,
+    OTP_IOC_NR_READ_BYTE,
+    OTP_IOC_NR_WRITE_BYTE,
+    OTP_IOC_NR_BUTT,
+} otp_ioc_nr;
+
+typedef struct {
+    td_u32 addr;
+    td_u32 word;
+} otp_word_ctl_t;
+
+typedef struct {
+    td_u32 addr;
+    td_u8 byte;
+} otp_byte_ctl_t;
+
+#define OTP_IOWR(nr, struct_name)           CRYPTO_IOC(CRYPTO_IOC_RW, IOC_TYPE_OTP, (nr), sizeof(struct_name))
+
+#define CMD_OTP_READ_WORD           OTP_IOWR(OTP_IOC_NR_READ_WORD, otp_word_ctl_t)
+#define CMD_OTP_READ_BYTE           OTP_IOWR(OTP_IOC_NR_READ_BYTE, otp_byte_ctl_t)
+#define CMD_OTP_WRITE_BYTE          OTP_IOWR(OTP_IOC_NR_WRITE_BYTE, otp_byte_ctl_t)
+
+#define CMD_OTP_MAX_NUM              OTP_IOC_NR_BUTT
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_hash.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_hash.h
new file mode 100644
index 0000000..c5d94be
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_hash.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef KAPI_HASH_H
+#define KAPI_HASH_H
+
+#include "crypto_type.h"
+#include "crypto_hash_struct.h"
+#include "crypto_kdf_struct.h"
+#include "crypto_drv_common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_void kapi_cipher_hash_process_release(td_void);
+
+td_s32 kapi_cipher_hash_init(td_void);
+
+td_s32 kapi_cipher_hash_deinit(td_void);
+
+td_s32 kapi_cipher_hash_start(td_handle *kapi_hash_handle, const crypto_hash_attr *hash_attr);
+
+td_s32 kapi_cipher_hash_update(td_handle kapi_hash_handle,  const crypto_buf_attr *src_buf, const td_u32 len);
+
+td_s32 kapi_cipher_hash_finish(td_handle kapi_hash_handle, td_u8 *out, td_u32 *out_len);
+
+td_s32 kapi_cipher_hash_get(td_handle kapi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx);
+
+td_s32 kapi_cipher_hash_set(td_handle kapi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx);
+
+td_s32 kapi_cipher_hash_destroy(td_handle kapi_hash_handle);
+
+td_s32 kapi_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len);
+
+td_s32 kapi_cipher_hkdf_extract(crypto_hkdf_extract_t *extract_param, td_u8 *prk, td_u32 *prk_length);
+
+td_s32 kapi_cipher_hkdf_expand(const crypto_hkdf_expand_t *expand_param, td_u8 *okm, td_u32 okm_length);
+
+td_s32 kapi_cipher_hkdf(crypto_hkdf_t *hkdf_param, td_u8 *okm, td_u32 okm_length);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_hash_impl.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_hash_impl.h
new file mode 100644
index 0000000..8464a2c
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_hash_impl.h
@@ -0,0 +1,34 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: mbedtls hash harden implement long term.
+ * Author: @CompanyNameTag
+ * Create: 2023-12-23
+*/
+
+#ifndef KAPI_HASH_IMPL_H
+#define KAPI_HASH_IMPL_H
+#include "crypto_hash_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 kapi_hash_start_impl(crypto_hash_clone_ctx *clone_ctx, crypto_hash_type hash_type);
+
+td_s32 kapi_hash_update_impl(crypto_hash_clone_ctx *clone_ctx, const td_u8 *data, td_u32 data_len);
+
+td_s32 kapi_hash_finish_impl(crypto_hash_clone_ctx *clone_ctx, td_u8 *out, td_u32 *out_len);
+
+td_s32 kapi_hash_init_impl(td_void);
+
+td_void kapi_hash_deinit_impl(td_void);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* KAPI_HASH_IMPL_H */
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_km.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_km.h
new file mode 100644
index 0000000..94a6fc1
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_km.h
@@ -0,0 +1,54 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: key manager kernel API header file.
+ * Author: @CompanyNameTag
+ * Create: 2023-05-26
+*/
+
+#ifndef KAPI_KM_H
+#define KAPI_KM_H
+
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 kapi_km_env_init(td_void);
+td_s32 kapi_km_env_deinit(td_void);
+td_s32 kapi_km_deinit(td_void);
+
+/* Keyslot. */
+td_s32 kapi_keyslot_create(td_handle *kapi_keyslot_handle, crypto_keyslot_type keyslot_type);
+td_s32 kapi_keyslot_destroy(td_handle kapi_keyslot_handle);
+td_void kapi_keyslot_release_process(td_void);
+
+/* Klad. */
+td_s32 kapi_klad_create(td_handle *kapi_klad_handle);
+td_s32 kapi_klad_destroy(td_handle kapi_klad_handle);
+
+td_s32 kapi_klad_attach(td_handle kapi_klad_handle, crypto_klad_dest klad_type,
+    td_handle kapi_keyslot_handle);
+td_s32 kapi_klad_detach(td_handle kapi_klad_handle, crypto_klad_dest klad_type,
+    td_handle kapi_keyslot_handle);
+
+td_s32 kapi_klad_set_attr(td_handle kapi_klad_handle, const crypto_klad_attr *attr);
+td_s32 kapi_klad_get_attr(td_handle kapi_klad_handle, crypto_klad_attr *attr);
+
+td_s32 kapi_klad_set_session_key(td_handle kapi_klad_handle, const crypto_klad_session_key *key);
+td_s32 kapi_klad_set_content_key(td_handle kapi_klad_handle, const crypto_klad_content_key *key);
+
+td_s32 kapi_klad_set_clear_key(td_handle kapi_klad_handle, const crypto_klad_clear_key *key);
+td_s32 kapi_klad_set_effective_key(td_handle kapi_klad_handle, const crypto_klad_effective_key *key);
+
+td_s32 kapi_kdf_update(crypto_kdf_otp_key otp_key, crypto_kdf_update_alg alg);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_km_impl.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_km_impl.h
new file mode 100644
index 0000000..cfa3445
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_km_impl.h
@@ -0,0 +1,34 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: public key cryptographic algorithm kernel API header file.
+ * Author: @CompanyNameTag
+ * Create: 2023-05-26
+*/
+
+#ifndef KAPI_KM_IMPL_H
+#define KAPI_KM_IMPL_H
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 kapi_km_init_impl(td_void);
+
+td_void kapi_km_deinit_impl(td_void);
+
+td_s32 kapi_km_create_key_impl(td_handle *kapi_keyslot_handle);
+
+td_s32 kapi_km_set_key_impl(td_handle kapi_keyslot_handle, const td_u8 *key, td_u32 key_len, td_bool tee_open);
+
+td_s32 kapi_km_desroy_key_impl(td_handle kapi_keyslot_handle);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* KAPI_KM_IMPL_H */
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_otp.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_otp.h
new file mode 100644
index 0000000..10b9527
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_otp.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef KAPI_OTP_H
+#define KAPI_OTP_H
+
+#include "crypto_type.h"
+
+td_s32 kapi_otp_init(td_void);
+
+td_s32 kapi_otp_deinit(td_void);
+
+td_s32 kapi_otp_read_word(td_u32 addr, td_u32 *data);
+
+td_s32 kapi_otp_read_byte(td_u32 addr, td_u8 *data);
+
+td_s32 kapi_otp_write_byte(td_u32 addr, td_u8 data);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_pke.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_pke.h
new file mode 100644
index 0000000..b6f2f7a
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_pke.h
@@ -0,0 +1,80 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: public key cryptographic algorithm kernel API header file.
+ * Author: @CompanyNameTag
+ * Create: 2023-05-26
+*/
+
+#ifndef KAPI_PKE_H
+#define KAPI_PKE_H
+
+#include "crypto_type.h"
+#include "crypto_pke_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 kapi_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key);
+
+td_s32 kapi_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 kapi_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 kapi_pke_eddsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 kapi_pke_eddsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 kapi_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key);
+
+td_s32 kapi_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve);
+
+td_s32 kapi_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash);
+
+td_s32 kapi_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text);
+
+td_s32 kapi_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text);
+
+/* RSA. */
+td_s32 kapi_pke_rsa_gen_key(const drv_pke_data *input_e, drv_pke_rsa_priv_key *output_priv_key);
+
+td_s32 kapi_pke_rsa_sign(const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign);
+
+td_s32 kapi_pke_rsa_verify(const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, drv_pke_data *input_hash, const drv_pke_data *sig);
+
+td_s32 kapi_pke_rsa_public_encrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+td_s32 kapi_pke_rsa_private_decrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+td_s32 kapi_pke_dh_gen_key(const drv_pke_data *g_data, const drv_pke_data *mod_n,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_priv_key, const drv_pke_data *output_pub_key);
+
+td_s32 kapi_pke_dh_compute_key(const drv_pke_data *mod_n, const drv_pke_data  *input_priv_key,
+    const drv_pke_data  *input_pub_key, const drv_pke_data  *output_shared_key);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_pke_cal.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_pke_cal.h
new file mode 100644
index 0000000..78ad158
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_pke_cal.h
@@ -0,0 +1,48 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: big number calculate header file.
+ * Author: CompanyName
+ * Create: 2023-03-25
+*/
+
+#ifndef KAPI_PKE_HAL_H
+#define KAPI_PKE_HAL_H
+
+#include "crypto_type.h"
+#include "crypto_pke_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/*
+ * normal big number calculate function.
+ */
+td_s32 kapi_cipher_pke_add_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c);
+
+td_s32 kapi_cipher_pke_sub_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c);
+
+td_s32 kapi_cipher_pke_mul_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c);
+
+td_s32 kapi_cipher_pke_inv_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c);
+
+td_s32 kapi_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c);
+
+td_s32 kapi_cipher_pke_mul(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *c);
+
+td_s32 kapi_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_symc.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_symc.h
new file mode 100644
index 0000000..ba604dd
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_symc.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef KAPI_SYMC_H
+#define KAPI_SYMC_H
+
+#include "crypto_type.h"
+#include "crypto_symc_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_void kapi_cipher_symc_process_release(td_void);
+
+td_void kapi_cipher_symc_release_all(td_void);
+
+td_s32 kapi_cipher_symc_init(td_void);
+
+td_s32 kapi_cipher_symc_deinit(td_void);
+
+td_s32 kapi_cipher_symc_create(td_handle *kapi_symc_handle, const crypto_symc_attr *symc_attr);
+
+td_s32 kapi_cipher_symc_destroy(td_handle kapi_symc_handle);
+
+td_s32 kapi_cipher_symc_set_config(td_handle kapi_symc_handle, const crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 kapi_cipher_symc_get_config(td_handle kapi_symc_handle, crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 kapi_cipher_symc_attach(td_handle kapi_symc_handle, td_handle keyslot_handle);
+
+td_s32 kapi_cipher_symc_get_keyslot_handle(td_handle symc_handle, td_handle *keyslot_handle);
+
+td_s32 kapi_cipher_symc_detach(td_handle kapi_symc_handle, td_handle keyslot_handle);
+
+td_s32 kapi_cipher_symc_set_key(td_handle kapi_symc_handle, td_u8 *key, td_u32 key_len);
+
+td_s32 kapi_cipher_symc_encrypt(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 kapi_cipher_symc_decrypt(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 kapi_cipher_symc_encrypt_multi(td_handle kapi_symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num);
+
+td_s32 kapi_cipher_symc_decrypt_multi(td_handle kapi_symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num);
+
+td_s32 kapi_cipher_symc_cenc_decrypt(td_handle kapi_symc_handle, const crypto_symc_cenc_param *cenc_param,
+    const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 kapi_cipher_dma_copy(const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 kapi_cipher_symc_get_tag(td_handle kapi_symc_handle, td_u8 *tag, td_u32 tag_length);
+
+td_s32 kapi_cipher_mac_start(td_handle *kapi_symc_handle, const crypto_symc_mac_attr *mac_attr);
+
+td_s32 kapi_cipher_mac_update(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf, td_u32 length);
+
+td_s32 kapi_cipher_mac_finish(td_handle kapi_symc_handle, td_u8 *mac, td_u32 *mac_length);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_symc_impl.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_symc_impl.h
new file mode 100644
index 0000000..768c919
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_symc_impl.h
@@ -0,0 +1,42 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: public key cryptographic algorithm kernel API header file.
+ * Author: @CompanyNameTag
+ * Create: 2023-05-26
+*/
+
+#ifndef KAPI_SYMC_IMPL_H
+#define KAPI_SYMC_IMPL_H
+#include "crypto_symc_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 kapi_cipher_symc_crypt_impl(crypto_symc_ctrl_t *symc_ctrl, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 data_len, td_handle keyslot_handle, td_bool is_decrypt);
+
+td_s32 kapi_cipher_ccm_update_ad_impl(crypto_symc_ctrl_t *symc_ctrl,
+    crypto_symc_ccm_ctx *ccm_ctx, td_handle keyslot_handle);
+
+td_s32 kapi_cipher_ccm_update_impl(crypto_symc_ctrl_t *symc_ctrl, crypto_symc_ccm_ctx *ccm_ctx,
+    const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 data_len, td_handle keyslot_handle,
+    td_bool is_decrypt);
+
+td_s32 kapi_cipher_ccm_finish_impl(crypto_symc_ctrl_t *symc_ctrl, crypto_symc_ccm_ctx *ccm_ctx,
+    td_handle keyslot_handle, td_u8 *tag, td_u32 tag_len);
+
+td_s32 kapi_symc_init_impl(td_void);
+
+td_void kapi_symc_destroy_impl(td_void);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* KAPI_HASH_IMPL_H */
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_trng.h b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_trng.h
new file mode 100644
index 0000000..58b7fcf
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/kapi_include/kapi_trng.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef KAPI_TRNG_H
+#define KAPI_TRNG_H
+
+#include "crypto_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 kapi_cipher_trng_get_random(td_u32 *randnum);
+
+td_s32 kapi_cipher_trng_get_multi_random(td_u32 size, td_u8 *randnum);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_hash.h b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_hash.h
new file mode 100644
index 0000000..0b6edb9
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_hash.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef UAPI_HASH_H
+#define UAPI_HASH_H
+
+#include "crypto_type.h"
+#include "crypto_hash_struct.h"
+
+td_s32 unify_uapi_cipher_hash_init(td_void);
+
+td_s32 unify_uapi_cipher_hash_deinit(td_void);
+
+td_s32 unify_uapi_cipher_hash_start(td_handle *uapi_hash_handle, const crypto_hash_attr *hash_attr);
+
+td_s32 unify_uapi_cipher_hash_update(td_handle uapi_hash_handle, const crypto_buf_attr *src_buf, const td_u32 len);
+
+td_s32 unify_uapi_cipher_hash_finish(td_handle uapi_hash_handle, td_u8 *out, td_u32 *out_len);
+
+td_s32 unify_uapi_cipher_hash_get(td_handle uapi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx);
+
+td_s32 unify_uapi_cipher_hash_set(td_handle uapi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx);
+
+td_s32 unify_uapi_cipher_hash_destroy(td_handle uapi_hash_handle);
+
+td_s32 unify_uapi_cipher_hash_start_impl(crypto_hash_clone_ctx *clone_ctx, crypto_hash_type hash_type);
+
+td_s32 unify_uapi_cipher_hash_update_impl(crypto_hash_clone_ctx *clone_ctx, const td_u8 *data, td_u32 data_len);
+
+td_s32 unify_uapi_cipher_hash_finish_impl(crypto_hash_clone_ctx *clone_ctx, td_u8 *out, td_u32 *out_len);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_kdf.h b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_kdf.h
new file mode 100644
index 0000000..2f6b220
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_kdf.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef UAPI_KDF_H
+#define UAPI_KDF_H
+
+#include "crypto_type.h"
+#include "crypto_kdf_struct.h"
+
+td_s32 unify_uapi_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_km.h b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_km.h
new file mode 100644
index 0000000..bd794d3
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_km.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef UAPI_KM_H
+#define UAPI_KM_H
+
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 uapi_km_init(td_void);
+td_s32 uapi_km_deinit(td_void);
+
+/* Keyslot. */
+td_s32 uapi_keyslot_create(td_handle *mpi_keyslot_handle, crypto_keyslot_type keyslot_type);
+td_s32 uapi_keyslot_destroy(td_handle mpi_keyslot_handle);
+
+/* Klad. */
+td_s32 uapi_klad_create(td_handle *mpi_klad_handle);
+td_s32 uapi_klad_destroy(td_handle mpi_klad_handle);
+
+td_s32 uapi_klad_attach(td_handle mpi_klad_handle, crypto_klad_dest klad_type,
+    td_handle mpi_keyslot_handle);
+td_s32 uapi_klad_detach(td_handle mpi_klad_handle, crypto_klad_dest klad_type,
+    td_handle mpi_keyslot_handle);
+
+td_s32 uapi_klad_set_attr(td_handle mpi_klad_handle, const crypto_klad_attr *attr);
+td_s32 uapi_klad_get_attr(td_handle mpi_klad_handle, crypto_klad_attr *attr);
+
+td_s32 uapi_klad_set_session_key(td_handle mpi_klad_handle, const crypto_klad_session_key *key);
+td_s32 uapi_klad_set_content_key(td_handle mpi_klad_handle, const crypto_klad_content_key *key);
+
+td_s32 uapi_klad_set_clear_key(td_handle mpi_klad_handle, const crypto_klad_clear_key *key);
+td_s32 uapi_klad_set_effective_key(td_handle mpi_klad_handle, const crypto_klad_effective_key *key);
+
+td_s32 uapi_km_create_key_impl(td_handle *keyslot_handle);
+td_s32 uapi_km_set_key_impl(td_handle keyslot_handle, const td_u8 *key, td_u32 key_len, td_bool tee_open);
+td_s32 uapi_km_destroy_key_impl(td_handle keyslot_handle);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_otp.h b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_otp.h
new file mode 100644
index 0000000..eccab5d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_otp.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef UAPI_OTP_H
+#define UAPI_OTP_H
+
+#include "ot_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 uapi_otp_init(td_void);
+
+td_s32 uapi_otp_deinit(td_void);
+
+td_s32 uapi_otp_read_word(td_u32 offset, td_u32 *data);
+
+td_s32 uapi_otp_read_byte(td_u32 offset, td_u8 *data);
+
+td_s32 uapi_otp_write_byte(td_u32 offset, td_u8 data);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_pke.h b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_pke.h
new file mode 100644
index 0000000..8bd4e11
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_pke.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef UAPI_CIPHER_PKE_H
+#define UAPI_CIPHER_PKE_H
+
+#include "crypto_type.h"
+#include "crypto_pke_struct.h"
+
+td_s32 unify_uapi_cipher_pke_init(td_void);
+td_s32 unify_uapi_cipher_pke_deinit(td_void);
+
+/*
+ * input_priv_key: Could be NULL.
+ */
+td_s32 unify_uapi_cipher_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key);
+
+td_s32 unify_uapi_cipher_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key);
+
+td_s32 unify_uapi_cipher_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 unify_uapi_cipher_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 unify_uapi_cipher_pke_eddsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 unify_uapi_cipher_pke_eddsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 unify_uapi_cipher_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve);
+
+td_s32 unify_uapi_cipher_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash);
+
+td_s32 unify_uapi_cipher_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text);
+
+td_s32 unify_uapi_cipher_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text);
+
+td_s32 unify_uapi_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c);
+
+td_s32 unify_uapi_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k,
+    const drv_pke_data *in, const drv_pke_data *out);
+
+/* RSA. */
+td_s32 unify_uapi_cipher_pke_rsa_gen_key(const drv_pke_data *input_e, drv_pke_rsa_priv_key *priv_key);
+
+td_s32 unify_uapi_cipher_pke_rsa_sign(const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign);
+
+td_s32 unify_uapi_cipher_pke_rsa_verify(const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash, const drv_pke_data *sig);
+
+td_s32 unify_uapi_cipher_pke_rsa_public_encrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+td_s32 unify_uapi_cipher_pke_rsa_private_decrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_symc.h b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_symc.h
new file mode 100644
index 0000000..b207de2
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_symc.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef UAPI_SYMC_H
+#define UAPI_SYMC_H
+
+#include "crypto_type.h"
+#include "crypto_symc_struct.h"
+
+td_s32 unify_uapi_cipher_symc_init(td_void);
+
+td_s32 unify_uapi_cipher_symc_deinit(td_void);
+
+td_s32 unify_uapi_cipher_symc_create(td_handle *symc_handle, const crypto_symc_attr *symc_attr);
+
+td_s32 unify_uapi_cipher_symc_destroy(td_handle symc_handle);
+
+td_s32 unify_uapi_cipher_symc_set_config(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 unify_uapi_cipher_symc_get_config(td_handle symc_handle, crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 unify_uapi_cipher_symc_attach(td_handle symc_handle, td_handle keyslot_handle);
+
+td_s32 unify_uapi_cipher_symc_get_keyslot_handle(td_handle symc_handle, td_handle *keyslot_handle);
+
+td_s32 unify_uapi_cipher_symc_set_key(td_handle symc_handle, td_u8 *key, td_u32 key_len);
+
+td_s32 unify_uapi_cipher_symc_encrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 unify_uapi_cipher_symc_decrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 unify_uapi_cipher_symc_encrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num);
+
+td_s32 unify_uapi_cipher_symc_decrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num);
+
+td_s32 unify_uapi_cipher_symc_cenc_decrypt(td_handle symc_handle, const crypto_symc_cenc_param *cenc_param,
+    const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 unify_uapi_cipher_symc_crypt_impl(crypto_symc_ctrl_t *symc_ctrl, td_handle keyslot_handle,
+    const crypto_buf_attr *src, const crypto_buf_attr *dst, td_u32 data_len, td_bool is_decrypt);
+
+td_s32 unify_uapi_cipher_ccm_upadte_ad_impl(mbedtls_ccm_context *ctx,  crypto_symc_key_length key_len,
+    const td_u8 *add, td_u32 add_len);
+
+td_s32 unify_uapi_cipher_ccm_upadte_impl(mbedtls_ccm_context *ctx, crypto_symc_key_length key_len,
+    const crypto_buf_attr *src, const crypto_buf_attr *dst, td_u32 process_len);
+
+td_s32 unify_uapi_cipher_ccm_finish_impl(mbedtls_ccm_context *ctx, unsigned int key_len,
+    unsigned char *tag, unsigned int tag_buf_len);
+
+td_s32 unify_uapi_cipher_symc_get_tag(td_handle symc_handle, td_u8 *tag, td_u32 tag_length);
+
+td_s32 unify_uapi_cipher_mac_start(td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr);
+
+td_s32 unify_uapi_cipher_mac_update(td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length);
+
+td_s32 unify_uapi_cipher_mac_finish(td_handle symc_handle, td_u8 *mac, td_u32 *mac_length);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_trng.h b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_trng.h
new file mode 100644
index 0000000..e9ad389
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/include/uapi_include/uapi_trng.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef UAPI_TRNG_H
+#define UAPI_TRNG_H
+
+#include "crypto_type.h"
+
+td_s32 unify_uapi_cipher_trng_get_random(td_u32 *randnum);
+
+td_s32 unify_uapi_cipher_trng_get_multi_random(td_u32 size, td_u8 *randnum);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_hash_impl.c b/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_hash_impl.c
new file mode 100644
index 0000000..96fb565
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_hash_impl.c
@@ -0,0 +1,110 @@
+/*
+  Copyright (c), 2001-2024, Shenshu Tech. Co., Ltd.
+ */
+#if defined(CONFIG_HASH_HARDEN_INTERFACE_SUPPORT)
+#include "kapi_hash_impl.h"
+#include "drv_hash.h"
+#include "drv_hash_inner.h"
+#include "crypto_drv_common.h"
+
+#define HASH_INIT_SHA_MAX_LENGTH                    64
+#define INVALID_HANDLE      0xFFFFFFFF
+static td_handle g_mbedtls_hash_handle = INVALID_HANDLE;
+static crypto_mutex g_mbedtls_hash_lock;
+
+td_s32 kapi_hash_start_impl(crypto_hash_clone_ctx *clone_ctx, crypto_hash_type hash_type)
+{
+    int ret = TD_FAILURE;
+    crypto_drv_func_enter();
+
+    crypto_chk_return(clone_ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "clone_ctx is NULL\n");
+
+    (void)memset_s(clone_ctx, sizeof(crypto_hash_clone_ctx), 0, sizeof(crypto_hash_clone_ctx));
+
+    ret = drv_hash_get_state_iv((crypto_hash_type)hash_type, NULL, clone_ctx->state, sizeof(clone_ctx->state));
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_hash_get_state_iv failed\n");
+
+    clone_ctx->hash_type = hash_type;
+    crypto_drv_func_exit();
+    return 0;
+}
+
+td_s32 kapi_hash_update_impl(crypto_hash_clone_ctx *clone_ctx,
+    const td_u8 *data, td_u32 data_len)
+{
+    int ret;
+    crypto_buf_attr src_buf;
+    crypto_drv_func_enter();
+
+    crypto_chk_return(clone_ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "clone_ctx is NULL\n");
+    crypto_chk_return(data == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "update data is NULL\n");
+
+    src_buf.virt_addr = (unsigned char *)data;
+
+    ret = crypto_mutex_lock(&g_mbedtls_hash_lock);
+    crypto_chk_return(ret != 0, ret, "crypto_mutex_lock failed\n");
+
+    ret = drv_cipher_hash_set(g_mbedtls_hash_handle, clone_ctx);
+    crypto_chk_goto(ret != 0, exit_mutex_unlock, "drv_cipher_hash_set failed\n");
+
+    ret = drv_cipher_hash_update(g_mbedtls_hash_handle, &src_buf, data_len);
+    crypto_chk_goto(ret != 0, exit_mutex_unlock, "drv_cipher_hash_update failed\n");
+
+    ret = drv_cipher_hash_get(g_mbedtls_hash_handle, clone_ctx);
+    crypto_chk_goto(ret != 0, exit_mutex_unlock, "drv_cipher_hash_get failed\n");
+
+exit_mutex_unlock:
+    crypto_mutex_unlock(&g_mbedtls_hash_lock);
+    crypto_drv_func_exit();
+    return ret;
+}
+
+td_s32 kapi_hash_finish_impl(crypto_hash_clone_ctx *clone_ctx, td_u8 *out, td_u32 *out_len)
+{
+    int ret;
+    crypto_drv_func_enter();
+
+    crypto_chk_return(clone_ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "clone_ctx is NULL\n");
+    crypto_chk_return(out == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "out is NULL\n");
+    crypto_chk_return(out_len == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "out_len is NULL\n");
+
+    ret = crypto_mutex_lock(&g_mbedtls_hash_lock);
+    crypto_chk_return(ret != 0, ret, "crypto_mutex_lock failed\n");
+
+    ret = drv_cipher_hash_set(g_mbedtls_hash_handle, clone_ctx);
+    crypto_chk_goto(ret != 0, exit_mutex_unlock, "drv_cipher_hash_set failed\n");
+
+    ret = drv_cipher_hash_finish_data(g_mbedtls_hash_handle, out, out_len);
+    crypto_chk_goto(ret != 0, exit_mutex_unlock, "drv_cipher_hash_finish_data failed\n");
+
+exit_mutex_unlock:
+    crypto_mutex_unlock(&g_mbedtls_hash_lock);
+    crypto_drv_func_exit();
+
+    return 0;
+}
+
+td_s32 kapi_hash_init_impl(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_hash_attr hash_attr = {0};
+
+    if (g_mbedtls_hash_handle == INVALID_HANDLE) {
+        hash_attr.hash_type = CRYPTO_HASH_TYPE_SHA256;
+        (void)drv_cipher_hash_start(&g_mbedtls_hash_handle, &hash_attr);
+    }
+
+    ret = crypto_mutex_init(&g_mbedtls_hash_lock);
+    crypto_chk_return(ret != TD_SUCCESS, HASH_COMPAT_ERRNO(ERROR_MUTEX_INIT), "crypto_mutex_lock init failed\n");
+    return ret;
+}
+
+td_void kapi_hash_deinit_impl(td_void)
+{
+    if (g_mbedtls_hash_handle != INVALID_HANDLE) {
+        (void)drv_cipher_hash_destroy(g_mbedtls_hash_handle);
+        g_mbedtls_hash_handle = INVALID_HANDLE;
+    }
+    crypto_mutex_destroy(&g_mbedtls_hash_lock);
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_km_impl.c b/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_km_impl.c
new file mode 100644
index 0000000..b039a02
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_km_impl.c
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+#include "kapi_km_impl.h"
+#include "drv_klad.h"
+#include "drv_keyslot.h"
+#include "crypto_drv_common.h"
+
+#define KM_COMPAT_ERRNO(err_code)     KAPI_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+#define CRYPTO_MCIPHER_KEYSLOT_NUM      8
+static crypto_mutex g_harden_km_lock;
+
+typedef struct {
+    crypto_owner owner;
+    td_bool is_open;
+    td_handle keyslot_handle;
+} crypto_keyslot_ctx_impl;
+
+static crypto_keyslot_ctx_impl g_kslot_ctx_arr[CRYPTO_MCIPHER_KEYSLOT_NUM] = {0};
+
+static td_s32 inner_occupy_kslot_channel(td_handle keyslot_handle)
+{
+    int i;
+    for (i = 0; i < CRYPTO_MCIPHER_KEYSLOT_NUM; i++) {
+        if (g_kslot_ctx_arr[i].is_open == TD_FALSE) {
+            break;
+        }
+    }
+    if (i >= CRYPTO_MCIPHER_KEYSLOT_NUM) {
+        crypto_log_err("kslot channel overflow\n");
+        return KM_COMPAT_ERRNO(ERROR_CHN_BUSY);
+    }
+    crypto_get_owner(&g_kslot_ctx_arr[i].owner);
+    g_kslot_ctx_arr[i].keyslot_handle = keyslot_handle;
+    g_kslot_ctx_arr[i].is_open = TD_TRUE;
+    return TD_SUCCESS;
+}
+
+static td_bool inner_check_kslot_channel_exit(td_handle keyslot_handle)
+{
+    int i;
+    crypto_owner owner  = {0};
+    crypto_get_owner(&owner);
+    for (i = 0; i < CRYPTO_MCIPHER_KEYSLOT_NUM; i++) {
+        if (g_kslot_ctx_arr[i].keyslot_handle == keyslot_handle && g_kslot_ctx_arr[i].owner == owner
+            && g_kslot_ctx_arr[i].is_open == TD_TRUE) {
+            return TD_TRUE;
+        }
+    }
+    return TD_FALSE;
+}
+
+static td_void inner_release_kslot_channel(td_handle keyslot_handle)
+{
+    int i;
+    crypto_owner owner = {0};
+    crypto_get_owner(&owner);
+    for (i = 0; i < CRYPTO_MCIPHER_KEYSLOT_NUM; i++) {
+        if (g_kslot_ctx_arr[i].keyslot_handle == keyslot_handle && g_kslot_ctx_arr[i].owner == owner
+            && g_kslot_ctx_arr[i].is_open == TD_TRUE) {
+            (td_void)memset_s(&g_kslot_ctx_arr[i], sizeof(crypto_keyslot_ctx_impl), 0, sizeof(crypto_keyslot_ctx_impl));
+        }
+    }
+}
+
+static td_s32 inner_klad_key_set(td_handle keyslot_handle, const td_u8 *key, td_u32 key_len, td_bool tee_open)
+{
+    td_s32 ret;
+    td_handle klad_handle = 0;
+    crypto_klad_clear_key clear_key = {
+        .key = (td_u8 *)key,
+        .key_length = key_len
+    };
+    crypto_klad_attr klad_attr = {
+        .key_cfg = {
+            .engine = CRYPTO_KLAD_ENGINE_AES,
+            .decrypt_support = TD_TRUE,
+            .encrypt_support = TD_TRUE
+        },
+        .key_sec_cfg = {
+            .key_sec = TD_TRUE,
+            .master_only_enable = TD_TRUE,
+            .dest_buf_sec_support = TD_TRUE,
+            .dest_buf_non_sec_support = TD_FALSE,
+            .src_buf_sec_support = TD_TRUE,
+            .src_buf_non_sec_support = TD_FALSE
+        }
+    };
+
+    if (tee_open == TD_TRUE) {
+        klad_attr.key_sec_cfg.key_sec = TD_TRUE;
+        klad_attr.key_sec_cfg.master_only_enable = TD_FALSE;
+        klad_attr.key_sec_cfg.dest_buf_sec_support = TD_TRUE;
+        klad_attr.key_sec_cfg.src_buf_sec_support = TD_TRUE;
+        klad_attr.key_sec_cfg.dest_buf_non_sec_support = TD_TRUE;
+        klad_attr.key_sec_cfg.src_buf_non_sec_support = TD_TRUE;
+    }
+
+    ret = drv_klad_create(&klad_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_klad_create failed\n");
+
+    ret = drv_klad_attach(klad_handle, CRYPTO_KLAD_DEST_MCIPHER, keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, klad_destroy, "drv_klad_attach failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_set_attr(klad_handle, &klad_attr);
+    crypto_chk_goto(ret != TD_SUCCESS, klad_detach, "drv_klad_set_attr failed\n");
+
+    ret = drv_klad_set_clear_key(klad_handle, &clear_key);
+    crypto_chk_goto(ret != TD_SUCCESS, klad_detach, "drv_klad_set_clear_key failed\n");
+klad_detach:
+    drv_klad_detach(klad_handle, CRYPTO_KLAD_DEST_MCIPHER, keyslot_handle);
+klad_destroy:
+    drv_klad_destroy(klad_handle);
+    return ret;
+}
+
+td_s32 kapi_km_create_key_impl(td_handle *kapi_keyslot_handle)
+{
+    td_s32 ret;
+    td_handle kslot_handle;
+
+    km_null_ptr_chk(kapi_keyslot_handle);
+
+    ret = crypto_mutex_lock(&g_harden_km_lock);
+    crypto_chk_return(ret != OSAL_SUCCESS, KM_COMPAT_ERRNO(ERROR_MUTEX_LOCK), "crypto_mutex_lock failed\n");
+
+    ret = drv_keyslot_create(&kslot_handle, CRYPTO_KEYSLOT_TYPE_MCIPHER);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "drv_keyslot_create failed\n");
+
+    ret = inner_occupy_kslot_channel(kslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, kslot_destroy, "inner_occupy_kslot_channel failed\n");
+
+    *kapi_keyslot_handle = kslot_handle;
+    crypto_mutex_unlock(&g_harden_km_lock);
+    return TD_SUCCESS;
+kslot_destroy:
+    drv_keyslot_destroy(kslot_handle);
+exit_unlock:
+    crypto_mutex_unlock(&g_harden_km_lock);
+    return ret;
+}
+
+td_s32 kapi_km_set_key_impl(td_handle kapi_keyslot_handle, const td_u8 *key, td_u32 key_len, td_bool tee_open)
+{
+    td_s32 ret;
+
+    ret = crypto_mutex_lock(&g_harden_km_lock);
+    crypto_chk_return(ret != OSAL_SUCCESS, KM_COMPAT_ERRNO(ERROR_MUTEX_LOCK), "crypto_mutex_lock failed\n");
+
+    if (inner_check_kslot_channel_exit(kapi_keyslot_handle) != TD_TRUE) {
+        crypto_log_err("inner_check_kslot_channel_exit check failed\n");
+        ret = TD_FAILURE;
+        goto exit_unlock;
+    }
+
+    ret = inner_klad_key_set(kapi_keyslot_handle, key, key_len, tee_open);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "inner_klad_key_set failed\n");
+exit_unlock:
+    crypto_mutex_unlock(&g_harden_km_lock);
+    return ret;
+}
+
+td_s32 kapi_km_desroy_key_impl(td_handle kapi_keyslot_handle)
+{
+    td_s32 ret;
+    ret = crypto_mutex_lock(&g_harden_km_lock);
+    crypto_chk_return(ret != OSAL_SUCCESS, KM_COMPAT_ERRNO(ERROR_MUTEX_LOCK), "crypto_mutex_lock failed\n");
+
+    ret = drv_keyslot_destroy(kapi_keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "drv_keyslot_destroy failed\n");
+
+    inner_release_kslot_channel(kapi_keyslot_handle);
+exit_unlock:
+    crypto_mutex_unlock(&g_harden_km_lock);
+    return ret;
+}
+
+td_s32 kapi_km_init_impl(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    ret = crypto_mutex_init(&g_harden_km_lock);
+    crypto_chk_return(ret != TD_SUCCESS, KM_COMPAT_ERRNO(ERROR_MUTEX_INIT),
+        "priv_symc_handle_check failed, ret is 0x%x\n", ret);
+    return TD_SUCCESS;
+}
+
+td_void kapi_km_deinit_impl(td_void)
+{
+    (void)crypto_mutex_destroy(&g_harden_km_lock);
+}
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_symc_impl.c b/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_symc_impl.c
new file mode 100644
index 0000000..928fa50
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/harden_support_longterm/kapi_symc_impl.c
@@ -0,0 +1,80 @@
+/*
+  Copyright (c), 2001-2024, Shenshu Tech. Co., Ltd.
+ */
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+#include "kapi_symc_impl.h"
+#include "kapi_symc_inner.h"
+#include "drv_symc.h"
+#include "drv_symc_outer.h"
+#include "crypto_drv_common.h"
+
+#define SYMC_COMPAT_ERRNO(err_code)     KAPI_COMPAT_ERRNO(ERROR_MODULE_SYMC, err_code)
+
+#define INVALID_HANDLE      0xFFFFFFFF
+static td_handle g_symc_handle = INVALID_HANDLE;
+static crypto_mutex g_harden_symc_lock;
+
+td_s32 kapi_symc_init_impl(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_symc_attr symc_attr = {0};
+
+    ret = drv_cipher_symc_create(&g_symc_handle, &symc_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_symc_create failed, ret is 0x%x\n", ret);
+
+    ret = crypto_mutex_init(&g_harden_symc_lock);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_release, "crypto_mutex_init failed, ret is 0x%x\n", ret);
+
+    return TD_SUCCESS;
+symc_release:
+    drv_cipher_symc_destroy(g_symc_handle);
+    g_symc_handle = INVALID_HANDLE;
+    return ret;
+}
+
+td_void kapi_symc_destroy_impl(td_void)
+{
+    if (g_symc_handle != INVALID_HANDLE) {
+        drv_cipher_symc_destroy(g_symc_handle);
+        g_symc_handle = INVALID_HANDLE;
+    }
+ 
+    (void)crypto_mutex_destroy(&g_harden_symc_lock);
+}
+#endif
+
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+td_s32 kapi_cipher_symc_crypt_impl(crypto_symc_ctrl_t *symc_ctrl, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 data_len, td_handle keyslot_handle, td_bool is_decrypt)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    symc_null_ptr_chk(symc_ctrl);
+    symc_null_ptr_chk(src_buf);
+    symc_null_ptr_chk(dst_buf);
+    crypto_chk_return(g_symc_handle == INVALID_HANDLE, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "handle is not created\n");
+
+    ret = crypto_mutex_lock(&g_harden_symc_lock);
+    crypto_chk_return(ret != 0, ret, "crypto_mutex_lock failed\n");
+
+    ret = drv_cipher_symc_attach(g_symc_handle, keyslot_handle);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_unlock, "drv_cipher_symc_set_key failed\n");
+
+    ret = drv_cipher_symc_set_config(g_symc_handle, symc_ctrl);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_unlock, "drv_cipher_symc_set_config failed\n");
+
+    if (is_decrypt == TD_FALSE) {
+        ret = drv_cipher_symc_encrypt(g_symc_handle, src_buf, dst_buf, data_len);
+    } else {
+        ret = drv_cipher_symc_decrypt(g_symc_handle, src_buf, dst_buf, data_len);
+    }
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_unlock, "drv_cipher_symc_crypto failed\n");
+
+    ret = drv_cipher_symc_get_config(g_symc_handle, symc_ctrl);
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_unlock, "drv_cipher_symc_get_config failed\n");
+
+exit_unlock:
+    crypto_mutex_unlock(&g_harden_symc_lock);
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_hash_simple.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_hash_simple.c
new file mode 100644
index 0000000..a429838
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_hash_simple.c
@@ -0,0 +1,481 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: hash kernel API function implementation.
+ * Author: @CompanyNameTag
+ * Create: 2023-12-23
+*/
+
+#include <securec.h>
+#include "kapi_hash.h"
+#include "kapi_inner.h"
+
+#include "drv_hash.h"
+#include "crypto_common_macro.h"
+#include "crypto_common_def.h"
+#include "crypto_errno.h"
+#include "crypto_hash_common.h"
+
+#define INVALID_HANDLE      0xFFFFFFFF
+
+#define HASH_COMPAT_ERRNO(err_code)     KAPI_COMPAT_ERRNO(ERROR_MODULE_HASH, err_code)
+
+#define HASH_DMA_ADD_LEN 128
+
+typedef struct {
+    crypto_hash_clone_ctx clone_ctx;
+    crypto_owner owner;
+    td_handle drv_hash_handle;
+    unsigned char *dma_buf;
+    unsigned int dma_buf_len;
+    unsigned char tail_len; /* not large than 128. */
+    unsigned int is_keyslot         : 1;
+    unsigned int is_long_term       : 1;
+} kapi_hash_context;
+
+static kapi_hash_context *g_hash_ctx[CONFIG_HASH_VIRT_CHN_NUM];
+
+#define kapi_hash_lock() do {                   \
+    hash_common_lock();           \
+} while (0)
+#define kapi_hash_unlock() do {                 \
+    hash_common_unlock();         \
+} while (0)
+
+static td_s32 inner_kapi_hash_handle_check(td_handle kapi_hash_handle)
+{
+    crypto_chk_return(kapi_get_module_id(kapi_hash_handle) != KAPI_HASH_MODULE_ID,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "Invalid Hash Handle! 0x%x\n", kapi_hash_handle);
+    crypto_chk_return(kapi_get_ctx_idx(kapi_hash_handle) >= CONFIG_HASH_VIRT_CHN_NUM,
+        HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "Invalid Hash Handle! 0x%x\n", kapi_hash_handle);
+    return TD_SUCCESS;
+}
+
+static kapi_hash_context *inner_kapi_get_hash_ctx(td_handle hash_handle)
+{
+    unsigned int idx = kapi_get_ctx_idx(hash_handle);
+    crypto_owner owner = {0};
+
+    if (inner_kapi_hash_handle_check(hash_handle) != TD_SUCCESS) {
+        return NULL;
+    }
+    if (g_hash_ctx[idx] == NULL) {
+        return NULL;
+    }
+    crypto_get_owner(&owner);
+    if (memcmp(&g_hash_ctx[idx]->owner, &owner, sizeof(crypto_owner)) != 0) {
+        return NULL;
+    }
+    return g_hash_ctx[idx];
+}
+
+static int inner_kapi_alloc_hash_ctx(td_handle *hash_handle, kapi_hash_context **hash_ctx)
+{
+    int ret = TD_FAILURE;
+    unsigned int i;
+    kapi_hash_lock();
+    for (i = 0; i < CONFIG_HASH_VIRT_CHN_NUM; i++) {
+        if (g_hash_ctx[i] == NULL) {
+            break;
+        }
+    }
+    if (i >= CONFIG_HASH_VIRT_CHN_NUM) {
+        crypto_log_err("All hash contexts are busy!\n");
+        ret = HASH_COMPAT_ERRNO(ERROR_CHN_BUSY);
+        goto exit_unlock;
+    }
+
+    *hash_ctx = crypto_malloc(sizeof(kapi_hash_context));
+    crypto_chk_goto_with_ret(ret, *hash_ctx == NULL, exit_unlock,
+        HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+    (void)memset_s(*hash_ctx, sizeof(kapi_hash_context), 0, sizeof(kapi_hash_context));
+
+    (*hash_ctx)->dma_buf = crypto_malloc_mmz(CONFIG_HASH_KAPI_DMA_BUF_LEN + HASH_DMA_ADD_LEN, "hash_dma_buf");
+    if ((*hash_ctx)->dma_buf == NULL) {
+        crypto_free(*hash_ctx);
+        crypto_log_err("crypto_malloc failed\n");
+        ret = HASH_COMPAT_ERRNO(ERROR_MALLOC);
+        goto exit_unlock;
+    }
+
+    (*hash_ctx)->dma_buf_len = CONFIG_HASH_KAPI_DMA_BUF_LEN;
+
+    g_hash_ctx[i] = *hash_ctx;
+    crypto_get_owner(&(g_hash_ctx[i]->owner));
+    *hash_handle = synthesize_kapi_handle(KAPI_HASH_MODULE_ID, i);
+    ret = CRYPTO_SUCCESS;
+exit_unlock:
+    kapi_hash_unlock();
+    return ret;
+}
+
+static int inner_kapi_free_hash_ctx(td_handle hash_handle)
+{
+    kapi_hash_context *hash_ctx = NULL;
+    unsigned int idx;
+
+    if (inner_kapi_hash_handle_check(hash_handle) != TD_SUCCESS) {
+        return HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE);
+    }
+    idx = kapi_get_ctx_idx(hash_handle);
+    hash_ctx = inner_kapi_get_hash_ctx(hash_handle);
+    crypto_chk_return(hash_ctx == NULL, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_kapi_get_hash_ctx failed\n");
+    kapi_hash_lock();
+    if (hash_ctx->dma_buf != NULL) {
+        crypto_free_coherent(hash_ctx->dma_buf);
+        hash_ctx->dma_buf = NULL;
+    }
+    crypto_free(hash_ctx);
+    g_hash_ctx[idx] = NULL;
+    hash_ctx = NULL;
+    kapi_hash_unlock();
+    return CRYPTO_SUCCESS;
+}
+
+static td_s32 inner_drv_lock_start(kapi_hash_context *hash_ctx, const crypto_hash_attr *hash_attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    kapi_hash_lock();
+    ret = drv_cipher_hash_start(&hash_ctx->drv_hash_handle, hash_attr);
+    kapi_hash_unlock();
+    return ret;
+}
+
+td_s32 kapi_cipher_hash_env_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+
+    ret = drv_cipher_hash_init();
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("drv_cipher_hash_init failed\n");
+        return ret;
+    }
+
+    ret = hash_mutex_init();
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("crypto_mutex_init failed\n");
+        ret = HASH_COMPAT_ERRNO(ERROR_MUTEX_INIT);
+        goto error_hash_deinit;
+    }
+
+    crypto_kapi_func_exit();
+    return ret;
+
+error_hash_deinit:
+    drv_cipher_hash_deinit();
+    return ret;
+}
+
+td_s32 kapi_cipher_hash_env_deinit(td_void)
+{
+    unsigned int i;
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+    for (i = 0; i < CONFIG_HASH_VIRT_CHN_NUM; i++) {
+        if (g_hash_ctx[i] == NULL) {
+            continue;
+        }
+        if (g_hash_ctx[i]->dma_buf != NULL) {
+            crypto_free_coherent(g_hash_ctx[i]->dma_buf);
+            g_hash_ctx[i]->dma_buf = NULL;
+        }
+        crypto_free(g_hash_ctx[i]);
+        g_hash_ctx[i] = NULL;
+    }
+    hash_mutex_destroy();
+    drv_cipher_hash_deinit();
+    crypto_kapi_func_exit();
+    return ret;
+}
+
+td_void kapi_cipher_hash_process_release(td_void)
+{
+    unsigned int i;
+    crypto_owner owner = {0};
+
+    crypto_get_owner(&owner);
+    kapi_hash_lock();
+    for (i = 0; i < CONFIG_HASH_VIRT_CHN_NUM; i++) {
+        if (g_hash_ctx[i] == NULL) {
+            continue;
+        }
+        if (memcmp(&g_hash_ctx[i]->owner, &owner, sizeof(crypto_owner)) != 0) {
+            continue;
+        }
+        if (g_hash_ctx[i]->is_long_term) {
+            (void)drv_cipher_hash_destroy(g_hash_ctx[i]->drv_hash_handle);
+        }
+        if (g_hash_ctx[i]->dma_buf != NULL) {
+            crypto_free_coherent(g_hash_ctx[i]->dma_buf);
+            g_hash_ctx[i]->dma_buf = NULL;
+        }
+        crypto_free(g_hash_ctx[i]);
+        g_hash_ctx[i] = NULL;
+    }
+    kapi_hash_unlock();
+}
+
+td_s32 kapi_cipher_hash_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_hash_init);
+
+td_s32 kapi_cipher_hash_deinit(td_void)
+{
+    crypto_kapi_func_enter();
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_hash_deinit);
+
+td_s32 kapi_cipher_hash_start(td_handle *kapi_hash_handle, const crypto_hash_attr *hash_attr)
+{
+    int ret = TD_FAILURE;
+    kapi_hash_context *hash_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    hash_null_ptr_chk(kapi_hash_handle);
+    hash_null_ptr_chk(hash_attr);
+
+    ret = inner_kapi_alloc_hash_ctx(kapi_hash_handle, &hash_ctx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_alloc_hash_ctx failed\n");
+
+    if (crypto_hash_is_hmac(hash_attr->hash_type) == TD_TRUE) {
+        ret = inner_drv_lock_start(hash_ctx, hash_attr);
+        crypto_chk_goto(ret != TD_SUCCESS, error_free_ctx, "inner_drv_lock_start failed\n");
+        hash_ctx->is_keyslot = hash_attr->is_keyslot;
+        hash_ctx->is_long_term = TD_TRUE;
+        crypto_kapi_func_exit();
+        return CRYPTO_SUCCESS;
+    }
+
+    (void)memset_s(&hash_ctx->clone_ctx, sizeof(hash_ctx->clone_ctx), 0, sizeof(hash_ctx->clone_ctx));
+
+    ret = drv_hash_get_state_iv(hash_attr->hash_type, TD_NULL,
+        hash_ctx->clone_ctx.state, sizeof(hash_ctx->clone_ctx.state));
+    crypto_chk_goto(ret != CRYPTO_SUCCESS, error_free_ctx, "drv_hash_get_state_iv failed\n");
+
+    hash_ctx->clone_ctx.hash_type = hash_attr->hash_type;
+    crypto_kapi_func_exit();
+
+    return 0;
+error_free_ctx:
+    inner_kapi_free_hash_ctx(*kapi_hash_handle);
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_hash_start);
+
+
+static td_s32 inner_kapi_cipher_hash_update(td_handle kapi_hash_handle,  const crypto_buf_attr *src_buf,
+    const td_u32 len)
+{
+    int ret;
+    td_handle hash_handle = INVALID_HANDLE;
+    crypto_hash_attr hash_attr = {0};
+    kapi_hash_context *hash_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    hash_ctx = inner_kapi_get_hash_ctx(kapi_hash_handle);
+    crypto_chk_return(hash_ctx == NULL, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_kapi_get_hash_ctx failed\n");
+
+    if (hash_ctx->is_long_term == TD_TRUE) {
+        ret = drv_cipher_hash_update(hash_ctx->drv_hash_handle, src_buf, len);
+        crypto_chk_return(ret != 0, ret, "drv_cipher_hash_update failed\n");
+
+        return CRYPTO_SUCCESS;
+    }
+
+    kapi_hash_lock();
+    hash_attr.hash_type = hash_ctx->clone_ctx.hash_type;
+    hash_attr.is_keyslot = hash_ctx->is_keyslot;
+    ret = drv_cipher_hash_start(&hash_handle, &hash_attr);
+    crypto_chk_goto(ret != 0, exit_mutex_unlock, "drv_cipher_hash_set failed\n");
+
+    ret = drv_cipher_hash_set(hash_handle, &hash_ctx->clone_ctx);
+    crypto_chk_goto(ret != 0, exit_hash_destroy, "drv_cipher_hash_set failed\n");
+
+    ret = drv_cipher_hash_update(hash_handle, src_buf, len);
+    crypto_chk_goto(ret != 0, exit_hash_destroy, "drv_cipher_hash_update failed\n");
+
+    ret = drv_cipher_hash_get(hash_handle, &hash_ctx->clone_ctx);
+    crypto_chk_goto(ret != 0, exit_hash_destroy, "drv_cipher_hash_get failed\n");
+
+exit_hash_destroy:
+    (void)drv_cipher_hash_destroy(hash_handle);
+exit_mutex_unlock:
+    kapi_hash_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+#define HASH_MMZ_LENGTH     (64 * 1024)
+td_s32 kapi_cipher_hash_update(td_handle kapi_hash_handle,  const crypto_buf_attr *src_buf, const td_u32 len)
+{
+    int ret;
+    crypto_buf_attr new_buf;
+    unsigned char *mmz_buf = NULL;
+    unsigned int left = len;
+    unsigned int processing_len = 0;
+    unsigned int processed_len = 0;
+
+    hash_null_ptr_chk(src_buf);
+    if (crypto_get_phys_addr(src_buf->virt_addr) != 0) {
+        return inner_kapi_cipher_hash_update(kapi_hash_handle, src_buf, len);
+    }
+
+    mmz_buf = crypto_malloc_coherent(HASH_MMZ_LENGTH, "kapi_hash_buf");
+    crypto_chk_return(mmz_buf == NULL, HASH_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_coherent failed\n");
+
+    new_buf.virt_addr = mmz_buf;
+    while (left > 0) {
+        processing_len = crypto_min(left, HASH_MMZ_LENGTH);
+        ret = memcpy_s(mmz_buf, HASH_MMZ_LENGTH, src_buf->virt_addr + processed_len, processing_len);
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_free, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = inner_kapi_cipher_hash_update(kapi_hash_handle, &new_buf, processing_len);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_free, "inner_kapi_cipher_hash_update failed\n");
+
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+
+    ret = CRYPTO_SUCCESS;
+exit_free:
+    crypto_free_coherent(mmz_buf);
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_hash_update);
+
+td_s32 kapi_cipher_hash_finish(td_handle kapi_hash_handle, td_u8 *out, td_u32 *out_len)
+{
+    int ret;
+    td_handle hash_handle = INVALID_HANDLE;
+    crypto_hash_attr hash_attr;
+    kapi_hash_context *hash_ctx = NULL;
+    crypto_buf_attr src_buf;
+    crypto_kapi_func_enter();
+
+    hash_ctx = inner_kapi_get_hash_ctx(kapi_hash_handle);
+    crypto_chk_return(hash_ctx == NULL, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_kapi_get_hash_ctx failed\n");
+
+    kapi_hash_lock();
+
+    if (hash_ctx->is_long_term == TD_TRUE) {
+        if (hash_ctx->tail_len != 0) {
+            src_buf.virt_addr = hash_ctx->dma_buf;
+            ret = drv_cipher_hash_update(hash_ctx->drv_hash_handle, &src_buf, hash_ctx->tail_len);
+            crypto_chk_goto(ret != 0, exit_hash_destroy, "drv_cipher_hash_update failed\n");
+        }
+        ret = drv_cipher_hash_finish(hash_ctx->drv_hash_handle, out, out_len);
+        if (ret != TD_SUCCESS) {
+            crypto_log_err("drv_cipher_hash_finish failed\n");
+            goto exit_hash_destroy;
+        }
+        ret = CRYPTO_SUCCESS;
+        goto exit_mutex_unlock;
+    }
+
+    hash_attr.hash_type = hash_ctx->clone_ctx.hash_type;
+    hash_attr.is_keyslot = hash_ctx->is_keyslot;
+    ret = drv_cipher_hash_start(&hash_handle, &hash_attr);
+    crypto_chk_goto(ret != 0, exit_mutex_unlock, "drv_cipher_hash_start failed\n");
+
+    ret = drv_cipher_hash_set(hash_handle, &hash_ctx->clone_ctx);
+    crypto_chk_goto(ret != 0, exit_hash_destroy, "drv_cipher_hash_set failed\n");
+
+    ret = drv_cipher_hash_finish(hash_handle, out, out_len);
+    crypto_chk_goto(ret != 0, exit_hash_destroy, "drv_cipher_hash_finish failed\n");
+    hash_handle = INVALID_HANDLE;
+
+exit_hash_destroy:
+    if (hash_handle != INVALID_HANDLE) {
+        (void)drv_cipher_hash_destroy(hash_handle);
+    }
+exit_mutex_unlock:
+    kapi_hash_unlock();
+    inner_kapi_free_hash_ctx(kapi_hash_handle);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_hash_finish);
+
+td_s32 kapi_cipher_hash_get(td_handle kapi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx)
+{
+    int ret;
+    kapi_hash_context *hash_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    hash_ctx = inner_kapi_get_hash_ctx(kapi_hash_handle);
+    crypto_chk_return(hash_ctx == NULL, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_kapi_get_hash_ctx failed\n");
+
+    if (hash_ctx->is_long_term == TD_TRUE) {
+        ret = drv_cipher_hash_get(hash_ctx->drv_hash_handle, hash_clone_ctx);
+        crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_hash_get failed\n");
+    } else {
+        ret = memcpy_s(hash_clone_ctx, sizeof(crypto_hash_clone_ctx),
+            &hash_ctx->clone_ctx, sizeof(crypto_hash_clone_ctx));
+        crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    }
+
+    crypto_kapi_func_exit();
+    return 0;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_hash_get);
+
+td_s32 kapi_cipher_hash_set(td_handle kapi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx)
+{
+    int ret;
+    kapi_hash_context *hash_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    hash_ctx = inner_kapi_get_hash_ctx(kapi_hash_handle);
+    crypto_chk_return(hash_ctx == NULL, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_kapi_get_hash_ctx failed\n");
+
+    if (hash_ctx->is_long_term == TD_TRUE) {
+        ret = drv_cipher_hash_set(hash_ctx->drv_hash_handle, hash_clone_ctx);
+        crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_hash_get failed\n");
+    } else {
+        ret = memcpy_s(&hash_ctx->clone_ctx, sizeof(crypto_hash_clone_ctx),
+            hash_clone_ctx, sizeof(crypto_hash_clone_ctx));
+        crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    }
+
+    crypto_kapi_func_exit();
+    return 0;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_hash_set);
+
+td_s32 kapi_cipher_hash_destroy(td_handle kapi_hash_handle)
+{
+    int ret;
+    kapi_hash_context *hash_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    hash_ctx = inner_kapi_get_hash_ctx(kapi_hash_handle);
+    crypto_chk_return(hash_ctx == NULL, HASH_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_kapi_get_hash_ctx failed\n");
+
+    if (hash_ctx->is_long_term == TD_TRUE) {
+        (void)drv_cipher_hash_destroy(hash_ctx->drv_hash_handle);
+    }
+    ret = inner_kapi_free_hash_ctx(kapi_hash_handle);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_hash_destroy);
+
+td_s32 kapi_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+
+    kapi_hash_lock();
+    ret = drv_cipher_pbkdf2(param, out, out_len);
+    kapi_hash_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_pbkdf2);
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_init.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_init.c
new file mode 100644
index 0000000..d6b9bb8
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_init.c
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "kapi_inner.h"
+
+#include "crypto_drv_common.h"
+
+td_s32 kapi_env_init(td_void)
+{
+    td_s32 ret;
+    /* KAPI Init. */
+    ret = kapi_cipher_hash_env_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "kapi_cipher_hash_env_init failed, ret is 0x%x.\n", ret);
+
+    ret = kapi_cipher_trng_env_init();
+    crypto_chk_goto(ret != TD_SUCCESS, error_kapi_hash_env_deinit,
+        "kapi_cipher_trng_env_init failed, ret is 0x%x.\n", ret);
+
+    ret = kapi_cipher_symc_env_init();
+    crypto_chk_goto(ret != TD_SUCCESS, error_kapi_trng_env_deinit,
+        "kapi_cipher_symc_env_init failed, ret is 0x%x.\n", ret);
+
+    ret = kapi_cipher_pke_env_init();
+    crypto_chk_goto(ret != TD_SUCCESS, error_kapi_symc_env_deinit,
+        "kapi_cipher_pke_env_init failed, ret is 0x%x.\n", ret);
+
+    return ret;
+error_kapi_symc_env_deinit:
+    kapi_cipher_symc_env_deinit();
+error_kapi_trng_env_deinit:
+    kapi_cipher_trng_env_deinit();
+error_kapi_hash_env_deinit:
+    kapi_cipher_hash_env_deinit();
+    return ret;
+}
+
+td_void kapi_env_deinit(td_void)
+{
+    kapi_cipher_pke_env_deinit();
+    kapi_cipher_symc_env_deinit();
+    kapi_cipher_trng_env_deinit();
+    kapi_cipher_hash_env_deinit();
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_inner.h b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_inner.h
new file mode 100644
index 0000000..a01b476
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_inner.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef KAPI_INNER_H
+#define KAPI_INNER_H
+
+#include "crypto_type.h"
+#include "crypto_hash_struct.h"
+#include "crypto_drv_common.h"
+
+typedef struct {
+    td_u32 tid;
+    td_bool is_open;
+    td_bool is_long_term;
+    td_handle drv_hash_handle;
+    crypto_hash_clone_ctx hash_clone_ctx;
+    td_u8 *dma_buf;     /* tail(128) + dma_buf. */
+    td_u8 tail_len;
+    td_u32 dma_buf_len;
+} crypto_kapi_hash_ctx;
+
+typedef struct {
+    td_u32 pid;
+    crypto_owner owner;
+    crypto_kapi_hash_ctx hash_ctx_list[CONFIG_HASH_VIRT_CHN_NUM];
+    crypto_mutex hash_ctx_mutex[CONFIG_HASH_VIRT_CHN_NUM];
+    td_u32 ctx_num;
+    td_u32 init_counter;
+    td_bool is_used;
+} crypto_kapi_hash_process;
+
+#if defined(CONFIG_KAPI_TRNG_SUPPORT)
+td_s32 kapi_cipher_trng_env_init(td_void);
+td_s32 kapi_cipher_trng_env_deinit(td_void);
+#else
+#define kapi_cipher_trng_env_init(...)        CRYPTO_SUCCESS
+#define kapi_cipher_trng_env_deinit(...)        CRYPTO_SUCCESS
+#endif
+
+#if defined(CONFIG_KAPI_HASH_SUPPORT)
+td_s32 kapi_cipher_hash_env_init(td_void);
+td_s32 kapi_cipher_hash_env_deinit(td_void);
+#else
+#define kapi_cipher_hash_env_init(...)        CRYPTO_SUCCESS
+#define kapi_cipher_hash_env_deinit(...)        CRYPTO_SUCCESS
+#endif
+
+#if defined(CONFIG_KAPI_SYMC_SUPPORT)
+td_s32 kapi_cipher_symc_env_init(td_void);
+td_s32 kapi_cipher_symc_env_deinit(td_void);
+#else
+#define kapi_cipher_symc_env_init(...)        CRYPTO_SUCCESS
+#define kapi_cipher_symc_env_deinit(...)        CRYPTO_SUCCESS
+#endif
+
+#if defined(CONFIG_KAPI_PKE_SUPPORT)
+td_s32 kapi_cipher_pke_env_init(td_void);
+td_s32 kapi_cipher_pke_env_deinit(td_void);
+#else
+#define kapi_cipher_pke_env_init(...)        CRYPTO_SUCCESS
+#define kapi_cipher_pke_env_deinit(...)        CRYPTO_SUCCESS
+#endif
+
+#if defined(CONFIG_KAPI_KM_SUPPORT)
+td_s32 kapi_km_env_init(td_void);
+td_s32 kapi_km_env_deinit(td_void);
+#else
+#define kapi_km_env_init(...)        CRYPTO_SUCCESS
+#define kapi_km_env_deinit(...)        CRYPTO_SUCCESS
+#endif
+
+td_s32 kapi_env_init(td_void);
+
+td_void kapi_env_deinit(td_void);
+
+td_void inner_kapi_trng_lock(td_void);
+
+td_void inner_kapi_trng_unlock(td_void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_km.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_km.c
new file mode 100644
index 0000000..4b23931
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_km.c
@@ -0,0 +1,783 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: key manager kernel API function implementation.
+ * Author: @CompanyNameTag
+ * Create: 2023-05-26
+*/
+
+#include "kapi_km.h"
+
+#include "crypto_common_def.h"
+#include "crypto_common_macro.h"
+#include "crypto_drv_common.h"
+#include "drv_klad.h"
+#include "drv_keyslot.h"
+
+#if defined(CONFIG_KAPI_KM_PARAM_TRACE_ENABLE)
+#define kapi_km_param_trace            crypto_param_trace
+#else
+#define kapi_km_param_trace(...)
+#endif
+
+typedef struct {
+    crypto_owner owner;
+    td_bool is_open;
+    td_handle keyslot_handle;
+    crypto_keyslot_type type;
+} crypto_kapi_keyslot_ctx;
+
+typedef struct {
+    crypto_owner owner;
+    td_bool is_attached;
+    td_bool is_set_attr;
+    td_bool is_set_session_key;
+    td_handle drv_klad_handle;
+    td_handle drv_keyslot_handle;
+    crypto_klad_dest klad_type;
+    crypto_klad_attr klad_attr;
+    crypto_klad_session_key session_key;
+    td_handle keyslot_handle;
+} crypto_kapi_klad_ctx;
+
+crypto_mutex g_klad_mutex;
+crypto_mutex g_keyslot_mutex;
+
+#define CRYPTO_MCIPHER_KEYSLOT_NUM      8
+#define CRYPTO_HMAC_KEYSLOT_NUM         2
+#define CRYPTO_KLAD_VIRT_NUM            16
+
+static crypto_kapi_keyslot_ctx g_keyslot_symc_ctx_list[CRYPTO_MCIPHER_KEYSLOT_NUM] = {0};
+static crypto_kapi_keyslot_ctx g_keyslot_hmac_ctx_list[CRYPTO_HMAC_KEYSLOT_NUM] = {0};
+
+static crypto_kapi_klad_ctx *g_klad_ctx_list[CRYPTO_KLAD_VIRT_NUM];
+
+#define kapi_klad_mutex_lock() do {          \
+    crypto_log_trace("klad mutext lock");   \
+    crypto_mutex_lock(&g_klad_mutex);            \
+} while (0)
+
+#define kapi_klad_mutex_unlock() do {        \
+    crypto_log_trace("klad mutext unlock");   \
+    crypto_mutex_unlock(&g_klad_mutex);          \
+} while (0)
+
+#define kapi_keyslot_mutex_lock() do {          \
+    crypto_log_trace("keyslot mutext lock");   \
+    crypto_mutex_lock(&g_keyslot_mutex);            \
+} while (0)
+
+#define kapi_keyslot_mutex_unlock() do {        \
+    crypto_log_trace("keyslot mutext unlock");   \
+    crypto_mutex_unlock(&g_keyslot_mutex);          \
+} while (0)
+
+#define KM_COMPAT_ERRNO(err_code)     KAPI_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+static td_void inner_kapi_release_all_hardware_resource(td_void)
+{
+    td_s32 i;
+    crypto_kapi_keyslot_ctx *keyslot_ctx = TD_NULL;
+    /* mcipher keyslot. */
+    for (i = 0; i < CRYPTO_MCIPHER_KEYSLOT_NUM; i++) {
+        keyslot_ctx = &g_keyslot_symc_ctx_list[i];
+        if (keyslot_ctx->is_open == TD_TRUE) {
+            (td_void)drv_keyslot_destroy(keyslot_ctx->keyslot_handle);
+        }
+    }
+    /* hmac keyslot. */
+    for (i = 0; i < CRYPTO_HMAC_KEYSLOT_NUM; i++) {
+        keyslot_ctx = &g_keyslot_hmac_ctx_list[i];
+        if (keyslot_ctx->is_open == TD_TRUE) {
+            (td_void)drv_keyslot_destroy(keyslot_ctx->keyslot_handle);
+        }
+    }
+}
+
+td_s32 kapi_km_env_init(td_void)
+{
+    td_s32 ret;
+    crypto_kapi_func_enter();
+
+    ret = crypto_mutex_init(&g_klad_mutex);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_mutex_init failed, ret is 0x%x\n", ret);
+
+    ret = crypto_mutex_init(&g_keyslot_mutex);
+    crypto_chk_goto(ret != TD_SUCCESS, klad_mutex_destroy_exit, "crypto_mutex_init failed, ret is 0x%x\n", ret);
+
+    ret = drv_keyslot_init();
+    crypto_chk_goto(ret != TD_SUCCESS, keyslot_mutex_destroy_exit, "drv_keyslot_init failed, ret is 0x%x\n", ret);
+
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+
+keyslot_mutex_destroy_exit:
+    crypto_mutex_destroy(&g_keyslot_mutex);
+klad_mutex_destroy_exit:
+    crypto_mutex_destroy(&g_klad_mutex);
+    return TD_FAILURE;
+}
+
+td_s32 kapi_km_env_deinit(td_void)
+{
+    unsigned int i;
+    crypto_kapi_func_enter();
+
+    crypto_mutex_destroy(&g_keyslot_mutex);
+    crypto_mutex_destroy(&g_klad_mutex);
+
+    inner_kapi_release_all_hardware_resource();
+    (td_void)memset_s(g_keyslot_symc_ctx_list, sizeof(g_keyslot_symc_ctx_list), 0, sizeof(g_keyslot_symc_ctx_list));
+    (td_void)memset_s(g_keyslot_hmac_ctx_list, sizeof(g_keyslot_hmac_ctx_list), 0, sizeof(g_keyslot_hmac_ctx_list));
+
+    (td_void)drv_keyslot_deinit();
+
+    for (i = 0; i < crypto_array_size(g_klad_ctx_list); i++) {
+        if (g_klad_ctx_list[i] != NULL) {
+            crypto_free(g_klad_ctx_list[i]);
+            g_klad_ctx_list[i] = NULL;
+        }
+    }
+
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 kapi_km_deinit(td_void)
+{
+    td_s32 i;
+    crypto_owner owner = {0};
+    crypto_kapi_keyslot_ctx *keyslot_ctx = TD_NULL;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    crypto_kapi_func_exit();
+
+    crypto_get_owner(&owner);
+    kapi_keyslot_mutex_lock();
+    /* mcipher keyslot. */
+    for (i = 0; i < CRYPTO_MCIPHER_KEYSLOT_NUM; i++) {
+        keyslot_ctx = &g_keyslot_symc_ctx_list[i];
+        if (memcmp(&owner, &keyslot_ctx->owner, sizeof(crypto_owner)) == 0 && keyslot_ctx->is_open == TD_TRUE) {
+            (td_void)drv_keyslot_destroy(keyslot_ctx->keyslot_handle);
+            (td_void)memset_s(keyslot_ctx, sizeof(crypto_kapi_keyslot_ctx), 0, sizeof(crypto_kapi_keyslot_ctx));
+        }
+    }
+    /* hmac keyslot. */
+    for (i = 0; i < CRYPTO_HMAC_KEYSLOT_NUM; i++) {
+        keyslot_ctx = &g_keyslot_hmac_ctx_list[i];
+        if (memcmp(&owner, &keyslot_ctx->owner, sizeof(crypto_owner)) == 0 && keyslot_ctx->is_open == TD_TRUE) {
+            (td_void)drv_keyslot_destroy(keyslot_ctx->keyslot_handle);
+            (td_void)memset_s(keyslot_ctx, sizeof(crypto_kapi_keyslot_ctx), 0, sizeof(crypto_kapi_keyslot_ctx));
+        }
+    }
+    kapi_keyslot_mutex_unlock();
+
+    /* klad. */
+    kapi_klad_mutex_lock();
+    for (i = 0; i < CRYPTO_KLAD_VIRT_NUM; i++) {
+        klad_ctx = g_klad_ctx_list[i];
+        if (klad_ctx == NULL) {
+            continue;
+        }
+        if (memcmp(&owner, &klad_ctx->owner, sizeof(crypto_owner)) == 0) {
+            crypto_free(g_klad_ctx_list[i]);
+            g_klad_ctx_list[i] = NULL;
+        }
+    }
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+
+static crypto_kapi_keyslot_ctx *inner_keyslot_get_ctx(td_handle keyslot_handle)
+{
+    td_u32 i = 0;
+    crypto_owner owner = {0};
+    crypto_kapi_keyslot_ctx *keyslot_ctx;
+    crypto_get_owner(&owner);
+    /* check mcipher keyslot. */
+    for (i = 0; i < CRYPTO_MCIPHER_KEYSLOT_NUM; i++) {
+        keyslot_ctx = &g_keyslot_symc_ctx_list[i];
+        if (memcmp(&owner, &keyslot_ctx->owner, sizeof(crypto_owner)) == 0 && keyslot_ctx->is_open == TD_TRUE &&
+            keyslot_handle == keyslot_ctx->keyslot_handle) {
+            return keyslot_ctx;
+        }
+    }
+    /* check hmac keyslot. */
+    for (i = 0; i < CRYPTO_HMAC_KEYSLOT_NUM; i++) {
+        keyslot_ctx = &g_keyslot_hmac_ctx_list[i];
+        if (memcmp(&owner, &keyslot_ctx->owner, sizeof(crypto_owner)) == 0 && keyslot_ctx->is_open == TD_TRUE &&
+            keyslot_handle == keyslot_ctx->keyslot_handle) {
+            return keyslot_ctx;
+        }
+    }
+    crypto_log_err("invalid keyslot_handle\n");
+    return TD_NULL;
+}
+
+static td_s32 inner_klad_handle_chk(td_handle klad_handle)
+{
+    td_u32 idx = 0;
+    if (kapi_get_module_id(klad_handle) != KAPI_KLAD_MODULE_ID) {
+        crypto_log_err("invalid module id\n");
+        return KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE);
+    }
+    idx = kapi_get_ctx_idx(klad_handle);
+    crypto_chk_return(idx >= CRYPTO_KLAD_VIRT_NUM, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE),
+        "idx overflow for klad\n");
+    
+    return TD_SUCCESS;
+}
+
+static crypto_kapi_klad_ctx *inner_kapi_get_klad_ctx(td_handle kapi_klad_handle)
+{
+    int ret;
+    unsigned int idx;
+    crypto_owner owner = {0};
+
+    crypto_get_owner(&owner);
+
+    ret = inner_klad_handle_chk(kapi_klad_handle);
+    if (ret != CRYPTO_SUCCESS) {
+        return NULL;
+    }
+
+    idx = kapi_get_ctx_idx(kapi_klad_handle);
+    if (g_klad_ctx_list[idx] == NULL) {
+        return NULL;
+    }
+    if (memcmp(&g_klad_ctx_list[idx]->owner, &owner, sizeof(owner)) != 0) {
+        crypto_log_err("invalid owner\n");
+        return NULL;
+    }
+    return g_klad_ctx_list[idx];
+}
+
+/* Keyslot. Long-term occupation by default */
+td_s32 kapi_keyslot_create(td_handle *kapi_keyslot_handle, crypto_keyslot_type keyslot_type)
+{
+    td_u32 i;
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_keyslot_ctx *ctx_list = TD_NULL;
+    crypto_kapi_keyslot_ctx *current_ctx = TD_NULL;
+    td_u32 ctx_num = 0;
+
+    kapi_km_param_trace("keyslot_type is 0x%x\n", keyslot_type);
+
+    km_null_ptr_chk(kapi_keyslot_handle);
+    if (keyslot_type == CRYPTO_KEYSLOT_TYPE_MCIPHER) {
+        ctx_list = g_keyslot_symc_ctx_list;
+        ctx_num = crypto_array_size(g_keyslot_symc_ctx_list);
+    } else if (keyslot_type == CRYPTO_KEYSLOT_TYPE_HMAC) {
+        ctx_list = g_keyslot_hmac_ctx_list;
+        ctx_num = crypto_array_size(g_keyslot_hmac_ctx_list);
+    } else {
+        crypto_log_err("invalid keyslot_type\n");
+        return KM_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    kapi_keyslot_mutex_lock();
+    for (i = 0; i < ctx_num; i++) {
+        if (ctx_list[i].is_open == TD_FALSE) {
+            current_ctx = &ctx_list[i];
+            break;
+        }
+    }
+    if (current_ctx == TD_NULL) {
+        crypto_log_err("all keyslot contexts are busy\n");
+        ret = KM_COMPAT_ERRNO(ERROR_CHN_BUSY);
+        goto exit_unlock;
+    }
+
+    ret = drv_keyslot_create(&current_ctx->keyslot_handle, (crypto_keyslot_type)keyslot_type);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "drv_keyslot_create failed, ret is 0x%x\n", ret);
+
+    current_ctx->type = (crypto_keyslot_type)keyslot_type;
+    current_ctx->is_open = TD_TRUE;
+    crypto_get_owner(&current_ctx->owner);
+
+    *kapi_keyslot_handle = current_ctx->keyslot_handle;
+
+    kapi_km_param_trace("create kapi_keyslot_handle is 0x%x\n", *kapi_keyslot_handle);
+
+exit_unlock:
+    kapi_keyslot_mutex_unlock();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_keyslot_create);
+
+td_s32 kapi_keyslot_destroy(td_handle kapi_keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_owner owner = {0};
+    crypto_kapi_keyslot_ctx *current_ctx = TD_NULL;
+
+    current_ctx = inner_keyslot_get_ctx(kapi_keyslot_handle);
+    crypto_chk_return(current_ctx == TD_NULL, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_keyslot_get_ctx failed\n");
+
+    kapi_keyslot_mutex_lock();
+    if (current_ctx->is_open == TD_FALSE) {
+        ret = TD_SUCCESS;
+        goto exit_unlock;
+    }
+
+    crypto_get_owner(&owner);
+    if (memcmp(&owner, &current_ctx->owner, sizeof(crypto_owner)) != 0) {
+        crypto_log_err("invalid process\n");
+        ret = KM_COMPAT_ERRNO(ERROR_INVALID_PROCESS);
+        goto exit_unlock;
+    }
+
+    ret = drv_keyslot_destroy(current_ctx->keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "drv_keyslot_destroy failed, ret is 0x%x\n", ret);
+
+    (td_void)memset_s(current_ctx, sizeof(crypto_kapi_keyslot_ctx), 0, sizeof(crypto_kapi_keyslot_ctx));
+
+exit_unlock:
+    kapi_keyslot_mutex_unlock();
+
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_keyslot_destroy);
+
+/* Klad. Short-term occupation by default */
+td_s32 kapi_klad_create(td_handle *kapi_klad_handle)
+{
+    td_s32 i;
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_klad_ctx *ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    km_null_ptr_chk(kapi_klad_handle);
+
+    kapi_klad_mutex_lock();
+    for (i = 0; i < CRYPTO_KLAD_VIRT_NUM; i++) {
+        if (g_klad_ctx_list[i] == NULL) {
+            break;
+        }
+    }
+    if (i >= CRYPTO_KLAD_VIRT_NUM) {
+        ret = KM_COMPAT_ERRNO(ERROR_CHN_BUSY);
+        goto exit_unlock;
+    }
+    ctx = crypto_malloc(sizeof(crypto_kapi_klad_ctx));
+    if (ctx == TD_NULL) {
+        ret = KM_COMPAT_ERRNO(ERROR_MALLOC);
+        goto exit_unlock;
+    }
+    (void)memset_s(ctx, sizeof(crypto_kapi_klad_ctx), 0, sizeof(crypto_kapi_klad_ctx));
+
+    crypto_get_owner(&ctx->owner);
+    g_klad_ctx_list[i] = ctx;
+    *kapi_klad_handle = synthesize_kapi_handle(KAPI_KLAD_MODULE_ID, i);
+
+    kapi_km_param_trace("create kapi_klad_handle is 0x%x\n", *kapi_klad_handle);
+
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_create);
+
+td_s32 kapi_klad_destroy(td_handle kapi_klad_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 idx = 0;
+    crypto_kapi_klad_ctx *ctx = TD_NULL;
+    crypto_owner owner = {0};
+    crypto_kapi_func_enter();
+
+    kapi_km_param_trace("destroy kapi_klad_handle is 0x%x\n", kapi_klad_handle);
+
+    ret = inner_klad_handle_chk(kapi_klad_handle);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_klad_handle_chk failed\n");
+
+    idx = kapi_get_ctx_idx(kapi_klad_handle);
+    ctx = g_klad_ctx_list[idx];
+    if (ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+    kapi_klad_mutex_lock();
+
+    crypto_get_owner(&owner);
+    if (memcmp(&owner, &ctx->owner, sizeof(crypto_owner)) != 0) {
+        crypto_log_err("invalid process\n");
+        ret = KM_COMPAT_ERRNO(ERROR_INVALID_PROCESS);
+        goto exit_unlock;
+    }
+    (td_void)memset_s(ctx, sizeof(crypto_kapi_klad_ctx), 0, sizeof(crypto_kapi_klad_ctx));
+    crypto_free(ctx);
+    g_klad_ctx_list[idx] = NULL;
+
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_destroy);
+
+td_s32 kapi_klad_attach(td_handle kapi_klad_handle, crypto_klad_dest klad_type,
+    td_handle kapi_keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    crypto_kapi_keyslot_ctx *keyslot_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    crypto_chk_return (klad_type >= CRYPTO_KLAD_DEST_MAX, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "Invalid klad_dest_type\n");
+
+    klad_ctx = inner_kapi_get_klad_ctx(kapi_klad_handle);
+    if (klad_ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+
+    kapi_klad_mutex_lock();
+    if (klad_type != CRYPTO_KLAD_DEST_NPU) {
+        keyslot_ctx = inner_keyslot_get_ctx(kapi_keyslot_handle);
+        crypto_chk_goto_with_ret(ret, keyslot_ctx == TD_NULL, exit_unlock, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE),
+            "inner_keyslot_get_ctx failed\n");
+        if (memcmp(&klad_ctx->owner, &keyslot_ctx->owner, sizeof(crypto_owner)) != 0) {
+            crypto_log_err("invalid owner\n");
+            ret = KM_COMPAT_ERRNO(ERROR_INVALID_PROCESS);
+            goto exit_unlock;
+        }
+        klad_ctx->keyslot_handle = keyslot_ctx->keyslot_handle;
+    } else {
+        klad_ctx->keyslot_handle = kapi_keyslot_handle;
+    }
+
+    klad_ctx->is_attached = TD_TRUE;
+    klad_ctx->klad_type = (crypto_klad_dest)klad_type;
+
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_attach);
+
+td_s32 kapi_klad_detach(td_handle kapi_klad_handle, crypto_klad_dest klad_type,
+    td_handle kapi_keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    crypto_kapi_keyslot_ctx *keyslot_ctx = TD_NULL;
+
+    crypto_chk_return (klad_type >= CRYPTO_KLAD_DEST_MAX, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "Invalid klad_dest_type\n");
+
+    klad_ctx = inner_kapi_get_klad_ctx(kapi_klad_handle);
+    if (klad_ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+    kapi_klad_mutex_lock();
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_attached == TD_FALSE, exit_unlock, KM_COMPAT_ERRNO(ERROR_NOT_ATTACHED),
+        "call klad_attach first\n");
+
+    crypto_chk_goto_with_ret(ret, klad_ctx->klad_type != (crypto_klad_dest)klad_type, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "invalid klad_type\n");
+    if (klad_type != CRYPTO_KLAD_DEST_NPU) {
+        keyslot_ctx = inner_keyslot_get_ctx(kapi_keyslot_handle);
+        crypto_chk_goto_with_ret(ret, keyslot_ctx == TD_NULL, exit_unlock, KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE),
+            "inner_keyslot_get_ctx failed\n");
+        crypto_chk_goto_with_ret(ret, keyslot_ctx->keyslot_handle != klad_ctx->keyslot_handle, exit_unlock,
+            KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid keyslot_handle\n");
+    } else {
+        crypto_chk_goto_with_ret(ret, klad_ctx->keyslot_handle != kapi_keyslot_handle, exit_unlock,
+            KM_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "invalid npu keyslot_handle\n");
+    }
+
+    klad_ctx->is_attached = TD_FALSE;
+    klad_ctx->keyslot_handle = 0;
+    klad_ctx->klad_type = 0;
+
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_detach);
+
+td_s32 kapi_klad_set_attr(td_handle kapi_klad_handle, const crypto_klad_attr *attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    km_null_ptr_chk(attr);
+
+    klad_ctx = inner_kapi_get_klad_ctx(kapi_klad_handle);
+    if (klad_ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+    kapi_klad_mutex_lock();
+    (void)memcpy_s(&klad_ctx->klad_attr, sizeof(crypto_klad_attr), attr, sizeof(crypto_klad_attr));
+
+    klad_ctx->is_set_attr = TD_TRUE;
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_set_attr);
+
+td_s32 kapi_klad_get_attr(td_handle kapi_klad_handle, crypto_klad_attr *attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    km_null_ptr_chk(attr);
+    klad_ctx = inner_kapi_get_klad_ctx(kapi_klad_handle);
+    if (klad_ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+
+    kapi_klad_mutex_lock();
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_set_attr == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG), "call klad_set_attr first\n");
+
+    (void)memcpy_s(attr, sizeof(crypto_klad_attr), &klad_ctx->klad_attr, sizeof(crypto_klad_attr));
+
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_get_attr);
+
+td_s32 kapi_klad_set_clear_key(td_handle kapi_klad_handle, const crypto_klad_clear_key *key)
+{
+#if defined(CONFIG_KM_CLEAR_KEY_SUPPORT)
+    td_s32 ret = TD_SUCCESS;
+    td_handle hard_klad_handle;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    crypto_klad_clear_key clear_key;
+    crypto_kapi_func_enter();
+
+    km_null_ptr_chk(key);
+    klad_ctx = inner_kapi_get_klad_ctx(kapi_klad_handle);
+    if (klad_ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+
+    clear_key.key = key->key;
+    clear_key.key_parity = key->key_parity;
+    clear_key.key_length = key->key_length;
+    clear_key.hmac_type = key->hmac_type;
+
+    kapi_klad_mutex_lock();
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_attached == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_ATTACHED), "call klad_attach first\n");
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_set_attr == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG), "call klad_set_attr first\n");
+
+    ret = drv_klad_create(&hard_klad_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "drv_klad_create failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_set_attr(hard_klad_handle, &klad_ctx->klad_attr);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_destroy, "drv_klad_set_attr failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_attach(hard_klad_handle, klad_ctx->klad_type, klad_ctx->keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_destroy, "drv_klad_attach failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_set_clear_key(hard_klad_handle, &clear_key);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_detach, "drv_klad_set_clear_key failed, ret is 0x%x\n", ret);
+
+exit_detach:
+    drv_klad_detach(hard_klad_handle, klad_ctx->klad_type, klad_ctx->keyslot_handle);
+exit_destroy:
+    drv_klad_destroy(hard_klad_handle);
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+#else
+    crypto_unused(kapi_klad_handle);
+    crypto_unused(key);
+    return ERROR_UNSUPPORT;
+#endif
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_set_clear_key);
+
+#if defined(CONFIG_KM_SESSION_KEY_SUPPORT)
+td_s32 kapi_klad_set_session_key(td_handle kapi_klad_handle, const crypto_klad_session_key *key)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    km_null_ptr_chk(key);
+    km_null_ptr_chk(key->key);
+    crypto_chk_return(key->key_length != CRYPTO_128_KEY_LEN, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "Session key's size is invalid\n");
+    crypto_chk_return(key->alg >= CRYPTO_KLAD_ALG_SEL_MAX, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "session_key.alg >= CRYPTO_KLAD_ALG_SEL_MAX\n");
+    crypto_chk_return(key->level >= CRYPTO_KLAD_LEVEL_SEL_SECOND, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "session_key.level >= CRYPTO_KLAD_LEVEL_SEL_SECOND\n");
+
+    klad_ctx = inner_kapi_get_klad_ctx(kapi_klad_handle);
+    if (klad_ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+    kapi_klad_mutex_lock();
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_attached == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_ATTACHED), "call klad_attach first\n");
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_set_attr == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG), "call klad_set_attr first\n");
+
+    ret = memcpy_s(klad_ctx->session_key.key, sizeof(klad_ctx->session_key.key), key->key, key->key_length);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_unlock, KM_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    klad_ctx->is_set_session_key = TD_TRUE;
+    klad_ctx->session_key.level = (crypto_klad_level_sel)key->level;
+    klad_ctx->session_key.alg = (crypto_klad_alg_sel)key->alg;
+    klad_ctx->session_key.key_length = key->key_length;
+
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_set_session_key);
+#endif
+
+#if defined(CONFIG_KM_CONTENT_KEY_SUPPORT)
+td_s32 kapi_klad_set_content_key(td_handle kapi_klad_handle, const crypto_klad_content_key *key)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    td_handle hard_klad_handle = 0;
+    crypto_klad_content_key content_key = {0};
+    crypto_kapi_func_enter();
+
+    km_null_ptr_chk(key);
+    km_null_ptr_chk(key->key);
+
+    klad_ctx = inner_kapi_get_klad_ctx(kapi_klad_handle);
+    if (klad_ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+    crypto_chk_return(key->key_length != CRYPTO_128_KEY_LEN && key->key_length != CRYPTO_256_KEY_LEN,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "Content key's size is invalid\n");
+    crypto_chk_return(key->alg >= CRYPTO_KLAD_ALG_SEL_MAX, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "content_key.alg >= CRYPTO_KLAD_ALG_SEL_MAX\n");
+    crypto_chk_return(key->key_parity >= (td_bool)KM_KLAD_KEY_PARITY_MAX, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "content_key.key_parity >= KM_KLAD_KEY_PARITY_MAX\n");
+
+    kapi_klad_mutex_lock();
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_attached == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_ATTACHED), "call klad_attach first\n");
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_set_attr == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG), "call klad_set_attr first\n");
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_set_session_key == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_SET_SESSION_KEY), "call klad_set_session_key first\n");
+
+    content_key.key_length = key->key_length;
+    content_key.alg = (crypto_klad_alg_sel)key->alg;
+    content_key.key_parity = (td_bool)key->key_parity;
+    ret = memcpy_s(content_key.key, sizeof(content_key.key), key->key, key->key_length);
+    crypto_chk_goto_with_ret(ret, ret != EOK, exit_unlock, KM_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    ret = drv_klad_create(&hard_klad_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "drv_klad_create failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_set_attr(hard_klad_handle, (crypto_klad_attr *)&klad_ctx->klad_attr);
+    crypto_chk_goto(ret != TD_SUCCESS, destroy_exit, "drv_klad_set_attr failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_attach(hard_klad_handle, klad_ctx->klad_type, klad_ctx->keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, destroy_exit, "drv_klad_attach failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_set_session_key(hard_klad_handle, &klad_ctx->session_key);
+    crypto_chk_goto(ret != TD_SUCCESS, detach_exit, "drv_klad_set_session_key failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_set_content_key(hard_klad_handle, &content_key);
+    crypto_chk_goto(ret != TD_SUCCESS, detach_exit, "drv_klad_set_content_key failed, ret is 0x%x\n", ret);
+detach_exit:
+    drv_klad_detach(hard_klad_handle, klad_ctx->klad_type, klad_ctx->keyslot_handle);
+destroy_exit:
+    drv_klad_destroy(hard_klad_handle);
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_set_content_key);
+#endif
+
+#define CRYPTO_EFFECTIVE_KEY_SALT_LENGTH_MAX 28
+td_s32 kapi_klad_set_effective_key(td_handle kapi_klad_handle, const crypto_klad_effective_key *key)
+{
+#if defined(CONFIG_KM_EFFECTIVE_KEY_SUPPORT)
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_klad_ctx *klad_ctx = TD_NULL;
+    td_handle hard_klad_handle = 0;
+    crypto_klad_effective_key effective_key = {0};
+    crypto_kapi_func_enter();
+
+    km_null_ptr_chk(key);
+    km_null_ptr_chk(key->salt);
+    crypto_chk_return(key->salt_length > CRYPTO_EFFECTIVE_KEY_SALT_LENGTH_MAX,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "effective_key.kdf_hard_alg >= CRYPTO_KDF_HARD_ALG_MAX\n");
+    crypto_chk_return(key->kdf_hard_alg >= CRYPTO_KDF_HARD_ALG_MAX, KM_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "effective_key.kdf_hard_alg >= CRYPTO_KDF_HARD_ALG_MAX\n");
+    crypto_chk_return(key->key_size < CRYPTO_KLAD_KEY_SIZE_128BIT ||
+        key->key_size > CRYPTO_KLAD_KEY_SIZE_256BIT,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "effective key's size is invalid\n");
+
+    klad_ctx = inner_kapi_get_klad_ctx(kapi_klad_handle);
+    if (klad_ctx == NULL) {
+        return KM_COMPAT_ERRNO(ERROR_CTX_CLOSED);
+    }
+
+    effective_key.kdf_hard_alg = key->kdf_hard_alg;
+    effective_key.key_parity = key->key_parity;
+    effective_key.key_size = key->key_size;
+    effective_key.oneway = key->oneway;
+    effective_key.salt_length = key->salt_length;
+    effective_key.salt = key->salt;
+
+    kapi_klad_mutex_lock();
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_attached == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_ATTACHED), "call klad_attach first\n");
+    crypto_chk_goto_with_ret(ret, klad_ctx->is_set_attr == TD_FALSE, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG), "call klad_set_attr first\n");
+    crypto_chk_goto_with_ret(ret, klad_ctx->klad_attr.klad_cfg.rootkey_type == CRYPTO_KDF_HARD_KEY_TYPE_ODRK1 &&
+        effective_key.key_size != CRYPTO_KLAD_KEY_SIZE_128BIT, exit_unlock,
+        KM_COMPAT_ERRNO(ERROR_INVALID_PARAM), "ODRK1 only support 128 key_size\n");
+
+    ret = drv_klad_create(&hard_klad_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "drv_klad_create failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_set_attr(hard_klad_handle, (crypto_klad_attr *)&klad_ctx->klad_attr);
+    crypto_chk_goto(ret != TD_SUCCESS, destroy_exit, "drv_klad_set_attr failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_attach(hard_klad_handle, klad_ctx->klad_type, klad_ctx->keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, destroy_exit, "drv_klad_attach failed, ret is 0x%x\n", ret);
+
+    ret = drv_klad_set_effective_key(hard_klad_handle, &effective_key);
+    crypto_chk_goto(ret != TD_SUCCESS, detach_exit, "drv_klad_set_effective_key failed, ret is 0x%x\n", ret);
+detach_exit:
+    drv_klad_detach(hard_klad_handle, klad_ctx->klad_type, klad_ctx->keyslot_handle);
+destroy_exit:
+    drv_klad_destroy(hard_klad_handle);
+exit_unlock:
+    kapi_klad_mutex_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+#else
+    crypto_unused(kapi_klad_handle);
+    crypto_unused(key);
+
+    return ERROR_UNSUPPORT;
+#endif
+}
+CRYPTO_EXPORT_SYMBOL(kapi_klad_set_effective_key);
+
+#if defined(CONFIG_KM_KDF_UPDATE_SUPPORT)
+td_s32 kapi_kdf_update(crypto_kdf_otp_key otp_key, crypto_kdf_update_alg alg)
+{
+    crypto_unused(otp_key);
+    crypto_unused(alg);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_otp.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_otp.c
new file mode 100644
index 0000000..a25cf29
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_otp.c
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "kapi_otp.h"
+
+#include "drv_otp.h"
+#include "crypto_drv_common.h"
+#include "crypto_common_macro.h"
+
+crypto_mutex g_otp_mutex;
+
+#define kapi_otp_mutex_lock() do {          \
+    crypto_mutex_lock(&g_otp_mutex);            \
+} while (0)
+
+#define kapi_otp_mutex_unlock() do {        \
+    crypto_mutex_unlock(&g_otp_mutex);          \
+} while (0)
+
+td_s32 kapi_otp_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+
+    ret = crypto_mutex_init(&g_otp_mutex);
+    crypto_chk_print(ret != TD_SUCCESS, "crypto_mutex_init failed, ret is 0x%x\n", ret);
+    crypto_kapi_func_exit();
+
+    return ret;
+}
+
+td_s32 kapi_otp_deinit(td_void)
+{
+    crypto_kapi_func_enter();
+    crypto_mutex_destroy(&g_otp_mutex);
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 kapi_otp_read_word(td_u32 offset, td_u32 *data)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+
+    kapi_otp_mutex_lock();
+    ret = drv_otp_read_word(offset, data);
+    crypto_chk_print(ret != TD_SUCCESS, "drv_otp_read_word failed, ret is 0x%x\n", ret);
+    kapi_otp_mutex_unlock();
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_otp_read_word);
+
+#if defined(CONFIG_OTP_READ_BYTE_SUPPORT)
+td_s32 kapi_otp_read_byte(td_u32 offset, td_u8 *data)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+
+    kapi_otp_mutex_lock();
+    ret = drv_otp_read_byte(offset, data);
+    crypto_chk_print(ret != TD_SUCCESS, "drv_otp_read_byte failed, ret is 0x%x\n", ret);
+    kapi_otp_mutex_unlock();
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+#else
+td_s32 kapi_otp_read_byte(td_u32 offset, td_u8 *data)
+{
+    crypto_unused(offset);
+    crypto_unused(data);
+
+    crypto_log_err("otp read byte unsupport\n");
+    return ERROR_UNSUPPORT;
+}
+#endif
+CRYPTO_EXPORT_SYMBOL(kapi_otp_read_byte);
+
+#if defined(CONFIG_OTP_WRITE_BYTE_SUPPORT)
+td_s32 kapi_otp_write_byte(td_u32 offset, td_u8 data)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+
+    kapi_otp_mutex_lock();
+    ret = drv_otp_write_byte(offset, data);
+    crypto_chk_print(ret != TD_SUCCESS, "drv_otp_write_byte failed, ret is 0x%x\n", ret);
+    kapi_otp_mutex_unlock();
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+#else
+td_s32 kapi_otp_write_byte(td_u32 offset, td_u8 data)
+{
+    crypto_unused(offset);
+    crypto_unused(data);
+
+    crypto_log_err("otp write byte unsupport\n");
+    return ERROR_UNSUPPORT;
+}
+#endif
+CRYPTO_EXPORT_SYMBOL(kapi_otp_write_byte);
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_pke.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_pke.c
new file mode 100644
index 0000000..a052b35
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_pke.c
@@ -0,0 +1,322 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: public key cryptographic algorithm kernel API function implementation
+ * Author: @CompanyNameTag
+ * Create: 2023-05-26
+*/
+
+#include "kapi_pke.h"
+#include "crypto_drv_common.h"
+#include "drv_pke.h"
+
+crypto_mutex g_pke_mutex;
+
+#define kapi_pke_mutex_lock() do {          \
+    crypto_mutex_lock(&g_pke_mutex);            \
+} while (0)
+
+#define kapi_pke_mutex_unlock() do {        \
+    crypto_mutex_unlock(&g_pke_mutex);          \
+} while (0)
+
+td_s32 kapi_cipher_pke_env_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    ret = drv_cipher_pke_init();
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("drv_cipher_hash_init failed\n");
+        return ret;
+    }
+    ret = crypto_mutex_init(&g_pke_mutex);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("crypto_mutex_init failed\n");
+        goto error_hash_deinit;
+    }
+    return ret;
+
+error_hash_deinit:
+    drv_cipher_pke_deinit();
+    return ret;
+}
+
+td_s32 kapi_cipher_pke_env_deinit(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_mutex_destroy(&g_pke_mutex);
+    drv_cipher_pke_deinit();
+    return ret;
+}
+
+td_s32 kapi_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_ecc_gen_key(curve_type, input_priv_key, output_priv_key, output_pub_key);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_ecc_gen_key failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+
+    return ret;
+}
+
+td_s32 kapi_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+
+#if defined(CONFIG_HI3516CV610)
+    if (curve_type == DRV_PKE_ECC_TYPE_SM2) {
+#if defined(CONFIG_PKE_ECC_SM2_SIGN_SUPPORT)
+        kapi_pke_mutex_lock();
+        ret = drv_cipher_pke_sm2_sign(priv_key, hash, sig);
+        kapi_pke_mutex_unlock();
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_sm2_sign failed, ret is 0x%x\n", ret);
+        return ret;
+#else
+        crypto_log_err("sm2 sign unsupport!\n");
+        return ERROR_UNSUPPORT;
+#endif
+    }
+#endif
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_ecdsa_sign(curve_type, priv_key, hash, sig);
+    kapi_pke_mutex_unlock();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_ecdsa_sign failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+
+td_s32 kapi_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+
+#if defined(CONFIG_HI3516CV610)
+    if (curve_type == DRV_PKE_ECC_TYPE_SM2) {
+#if defined(CONFIG_PKE_ECC_SM2_VERIFY_SUPPORT)
+        kapi_pke_mutex_lock();
+        ret = drv_cipher_pke_sm2_verify(pub_key, hash, sig);
+        kapi_pke_mutex_unlock();
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_sm2_verify failed, ret is 0x%x\n", ret);
+        return ret;
+#else
+        crypto_log_err("sm2 verify unsupport!\n");
+        return ERROR_UNSUPPORT;
+#endif
+    }
+#endif
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_ecdsa_verify(curve_type, pub_key, hash, sig);
+    kapi_pke_mutex_unlock();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_ecdsa_verify failed, ret is 0x%x\n", ret);
+
+    return ret;
+}
+
+#if defined(CONFIG_PKE_ECC_EDDSA_SIGN_SUPPORT)
+td_s32 kapi_pke_eddsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_eddsa_sign(curve_type, priv_key, msg, sig);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_eddsa_sign failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_PKE_ECC_EDDSA_VERIFY_SUPPORT)
+td_s32 kapi_pke_eddsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_eddsa_verify(curve_type, pub_key, msg, sig);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_eddsa_verify failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+#endif
+
+td_s32 kapi_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_ecc_gen_ecdh_key(curve_type, input_pub_key, input_priv_key, output_shared_key);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_ecc_gen_ecdh_key failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+td_s32 kapi_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_check_dot_on_curve(curve_type, pub_key, is_on_curve);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_pke_check_don_curve failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+td_s32 kapi_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_sm2_dsa_hash(sm2_id, pub_key, msg, hash);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_sm2_dsa_hash failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+td_s32 kapi_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_sm2_public_encrypt(pub_key, plain_text, cipher_text);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_sm2_public_encrypt failed, ret is 0x%x\n", ret);
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+td_s32 kapi_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_sm2_private_decrypt(priv_key, cipher_text, plain_text);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_sm2_private_decrypt failed, ret is 0x%x\n", ret);
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+/* RSA. */
+#if defined(CONFIG_PKE_RSA_GEN_KEY_SUPPORT)
+td_s32 kapi_pke_rsa_gen_key(const drv_pke_data *input_e, drv_pke_rsa_priv_key *output_priv_key)
+{
+    td_s32 ret = TD_SUCCESS;
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_rsa_gen_key(input_e, output_priv_key);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_rsa_gen_key failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+#endif
+
+td_s32 kapi_pke_rsa_sign(const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_rsa_sign(priv_key, scheme, hash_type, input_hash, sign);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_rsa_sign failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+td_s32 kapi_pke_rsa_verify(const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, drv_pke_data *input_hash, const drv_pke_data *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_rsa_verify(pub_key, scheme, hash_type, input_hash, sig);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_rsa_verify failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+td_s32 kapi_pke_rsa_public_encrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_rsa_public_encrypt(scheme, hash_type, pub_key, input, label, output);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_rsa_public_encrypt failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+td_s32 kapi_pke_rsa_private_decrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_rsa_private_decrypt(scheme, hash_type, priv_key, input, label, output);
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_rsa_private_decrypt failed, ret is 0x%x\n", ret);
+
+unlock_exit:
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+#if defined(CONFIG_PKE_DH_SUPPORT)
+td_s32 kapi_pke_dh_gen_key(const drv_pke_data *g_data, const drv_pke_data *mod_n,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_priv_key, const drv_pke_data *output_pub_key)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_dh_gen_key(g_data, mod_n, input_priv_key, output_priv_key, output_pub_key);
+    crypto_chk_print(ret != TD_SUCCESS, "drv_cipher_pke_dh_gen_key failed, ret is 0x%x\n", ret);
+
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+
+td_s32 kapi_pke_dh_compute_key(const drv_pke_data *mod_n, const drv_pke_data  *input_priv_key,
+    const drv_pke_data  *input_pub_key, const drv_pke_data  *output_shared_key)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    kapi_pke_mutex_lock();
+    ret = drv_cipher_pke_dh_compute_key(mod_n, input_priv_key, input_pub_key, output_shared_key);
+    crypto_chk_print(ret != TD_SUCCESS, "drv_cipher_pke_dh_compute_key failed, ret is 0x%x\n", ret);
+
+    kapi_pke_mutex_unlock();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_pke_cal.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_pke_cal.c
new file mode 100644
index 0000000..833826d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_pke_cal.c
@@ -0,0 +1,131 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved.
+ * Description: public key cryptographic algorithm kernel API function implementation
+ * Author: @CompanyNameTag
+ * Create: 2023-05-26
+*/
+
+#include "kapi_pke_cal.h"
+#include "drv_pke_cal.h"
+#include "crypto_drv_common.h"
+
+#if defined(CONFIG_PKE_ADD_MOD_SUPPORT)
+td_s32 kapi_cipher_pke_add_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c)
+{
+    crypto_unused(a);
+    crypto_unused(b);
+    crypto_unused(p);
+    crypto_unused(c);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_PKE_SUB_MOD_SUPPORT)
+td_s32 kapi_cipher_pke_sub_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c)
+{
+    crypto_unused(a);
+    crypto_unused(b);
+    crypto_unused(p);
+    crypto_unused(c);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_PKE_MUL_MOD_SUPPORT)
+td_s32 kapi_cipher_pke_mul_mod(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *p,
+    const drv_pke_data *c)
+{
+    crypto_unused(a);
+    crypto_unused(b);
+    crypto_unused(p);
+    crypto_unused(c);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_PKE_INV_MOD_SUPPORT)
+td_s32 kapi_cipher_pke_inv_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    crypto_unused(a);
+    crypto_unused(p);
+    crypto_unused(c);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_PKE_MOD_SUPPORT)
+td_s32 kapi_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    td_s32 ret = TD_SUCCESS;
+
+#if defined(CONFIG_HI3519DV500)
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+#endif
+    ret = drv_cipher_pke_mod(a, p, c);
+#if defined(CONFIG_HI3519DV500)
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_mod failed, ret is 0x%x\n", ret);
+unlock_exit:
+    (void)drv_cipher_pke_unlock_secure();
+#endif
+
+    return ret;
+}
+#else
+td_s32 kapi_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    crypto_unused(a);
+    crypto_unused(p);
+    crypto_unused(c);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_PKE_MUL_SUPPORT)
+td_s32 kapi_cipher_pke_mul(const drv_pke_data *a, const drv_pke_data *b, const drv_pke_data *c)
+{
+    crypto_unused(a);
+    crypto_unused(b);
+    crypto_unused(c);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_PKE_EXP_MOD_SUPPORT)
+td_s32 kapi_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out)
+{
+    td_s32 ret = TD_SUCCESS;
+
+#if defined(CONFIG_HI3519DV500)
+    ret = drv_cipher_pke_lock_secure();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_pke_lock_secure failed, ret is 0x%x\n", ret);
+#endif
+    ret = drv_cipher_pke_exp_mod(n, k, in, out);
+#if defined(CONFIG_HI3519DV500)
+    crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "drv_cipher_pke_exp_mod failed, ret is 0x%x\n", ret);
+unlock_exit:
+    (void)drv_cipher_pke_unlock_secure();
+#endif
+    return ret;
+}
+#else
+td_s32 kapi_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k, const drv_pke_data *in,
+    const drv_pke_data *out)
+{
+    crypto_unused(n);
+    crypto_unused(k);
+    crypto_unused(in);
+    crypto_unused(out);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc.c
new file mode 100755
index 0000000..1a7925d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc.c
@@ -0,0 +1,683 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "kapi_symc.h"
+#include "kapi_inner.h"
+
+#include "drv_symc.h"
+#include "drv_symc_outer.h"
+#include "crypto_drv_common.h"
+#include "kapi_symc_inner.h"
+
+#define CRYPTO_KAPI_DMA_SIZE_ONE_PROCESS    (CONFIG_DRV_AAD_SIZE * CONFIG_SYMC_VIRT_CHN_NUM)
+#define CRYPTO_KAPI_TOTAL_DMA_SIZE          (CRYPTO_KAPI_DMA_SIZE_ONE_PROCESS * CONFIG_MAX_PROCESS_NUM)
+#define CRYPTO_SYMC_INIT_MAX_NUM            0xffffffff
+
+static td_u8 *g_kapi_dma_addr = TD_NULL;
+
+static crypto_kapi_symc_process g_kapi_symc_channel[CONFIG_MAX_PROCESS_NUM];
+
+static crypto_mutex g_symc_mutex;
+
+#define kapi_symc_lock() do {                   \
+    crypto_mutex_lock(&g_symc_mutex);           \
+} while (0)
+#define kapi_symc_unlock() do {                 \
+    crypto_mutex_unlock(&g_symc_mutex);         \
+} while (0)
+
+void inner_kapi_symc_lock(void)
+{
+    crypto_mutex_lock(&g_symc_mutex);
+}
+
+void inner_kapi_symc_unlock(void)
+{
+    crypto_mutex_unlock(&g_symc_mutex);
+}
+
+static td_s32 priv_symc_handle_check(td_handle kapi_symc_handle)
+{
+    crypto_chk_return(kapi_get_module_id(kapi_symc_handle) != KAPI_SYMC_MODULE_ID,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "Invalid Symc Handle! 0x%x\n", kapi_symc_handle);
+    crypto_chk_return(kapi_get_ctx_idx(kapi_symc_handle) >= CONFIG_SYMC_VIRT_CHN_NUM,  \
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "Invalid Symc Handle! 0x%x\n", kapi_symc_handle);
+    return TD_SUCCESS;
+}
+
+crypto_kapi_symc_process *inner_get_current_symc_channel(td_void)
+{
+    td_u32 i;
+    crypto_owner owner = {0};
+    if (crypto_get_owner(&owner) != CRYPTO_SUCCESS) {
+        return TD_NULL;
+    }
+    for (i = 0; i < CONFIG_MAX_PROCESS_NUM; i++) {
+        if (memcmp(&owner, &g_kapi_symc_channel[i].owner, sizeof(crypto_owner)) == 0) {
+            return &g_kapi_symc_channel[i];
+        }
+    }
+    return TD_NULL;
+}
+
+crypto_kapi_symc_ctx *priv_occupy_symc_soft_chn(crypto_kapi_symc_process *symc_channel, td_u32 *idx)
+{
+    td_u32 i;
+    td_u32 tid = crypto_gettid();
+    crypto_kapi_symc_ctx *symc_ctx_list = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+
+    kapi_symc_lock();
+
+    symc_ctx_list = symc_channel->symc_ctx_list;
+    for (i = 0; i < CONFIG_SYMC_VIRT_CHN_NUM; i++) {
+        if (symc_ctx_list[i].is_open == TD_FALSE) {
+            break;
+        }
+    }
+    if (i >= CONFIG_SYMC_VIRT_CHN_NUM) {
+        crypto_log_err("All Symc Channels are busy!\n");
+        goto exit_unlock;
+    }
+    symc_ctx = &symc_channel->symc_ctx_list[i];
+    (td_void)memset_s(symc_ctx, sizeof(crypto_kapi_symc_ctx), 0, sizeof(crypto_kapi_symc_ctx));
+    symc_ctx->is_open = TD_TRUE;
+    symc_ctx->tid = tid;
+
+    *idx = i;
+
+exit_unlock:
+    kapi_symc_unlock();
+    return symc_ctx;
+}
+
+td_void priv_release_symc_soft_chn(crypto_kapi_symc_ctx *symc_ctx)
+{
+    kapi_symc_lock();
+    (td_void)memset_s(symc_ctx, sizeof(crypto_kapi_symc_ctx), 0, sizeof(crypto_kapi_symc_ctx));
+    kapi_symc_unlock();
+}
+
+static td_bool priv_check_is_init(crypto_owner *owner)
+{
+    td_u32 i;
+    for (i = 0; i < CONFIG_MAX_PROCESS_NUM; i++) {
+        if (memcmp(owner, &g_kapi_symc_channel[i].owner, sizeof(crypto_owner)) == 0) {
+            return TD_TRUE;
+        }
+    }
+    return TD_FALSE;
+}
+
+static td_s32 priv_process_symc_init(td_void)
+{
+    td_u32 i;
+    td_u32 ret = TD_SUCCESS;
+    crypto_owner owner = {0};
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+
+    crypto_kapi_func_enter();
+    kapi_symc_lock();
+    ret = crypto_get_owner(&owner);
+    crypto_chk_goto_with_ret(ret, ret != CRYPTO_SUCCESS, exit_unlock, SYMC_COMPAT_ERRNO(ERROR_GET_OWNER),
+        "crypto_get_owner failed\n");
+    if (priv_check_is_init(&owner) == TD_TRUE) {
+        symc_channel = inner_get_current_symc_channel();
+        if (symc_channel->init_counter >= CRYPTO_SYMC_INIT_MAX_NUM) {
+            ret = SYMC_COMPAT_ERRNO(ERROR_COUNT_OVERFLOW);
+        } else {
+            ret = TD_SUCCESS;
+            ++(symc_channel->init_counter);
+        }
+        goto exit_unlock;
+    }
+    for (i = 0; i < CONFIG_MAX_PROCESS_NUM; i++) {
+        if (g_kapi_symc_channel[i].is_used == TD_FALSE) {
+            break;
+        }
+    }
+    if (i >= CONFIG_MAX_PROCESS_NUM) {
+        crypto_log_err("Process Num is More Than %u\n", CONFIG_MAX_PROCESS_NUM);
+        ret = SYMC_COMPAT_ERRNO(ERROR_MAX_PROCESS);
+        goto exit_unlock;
+    }
+    symc_channel = &g_kapi_symc_channel[i];
+    (td_void)memset_s(symc_channel, sizeof(crypto_kapi_symc_process), 0, sizeof(crypto_kapi_symc_process));
+    /* Alloc dma memory. */
+    symc_channel->dma_addr = g_kapi_dma_addr + i * CRYPTO_KAPI_DMA_SIZE_ONE_PROCESS;
+    for (i = 0; i < CONFIG_SYMC_VIRT_CHN_NUM; ++i) {
+        ret = crypto_mutex_init(&symc_channel->symc_ctx_mutex[i]);
+        crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, exit_destroy, SYMC_COMPAT_ERRNO(ERROR_MUTEX_INIT),
+            "symc ctx mutex init failed at chn: %u\n", i);
+    }
+    (td_void)memcpy_s(&symc_channel->owner, sizeof(crypto_owner), &owner, sizeof(crypto_owner));
+    symc_channel->is_used = TD_TRUE;
+    symc_channel->ctx_num = CONFIG_SYMC_VIRT_CHN_NUM;
+    ++(symc_channel->init_counter);
+    (td_void)memset_s(symc_channel->symc_ctx_list, sizeof(crypto_kapi_symc_ctx) * CONFIG_SYMC_VIRT_CHN_NUM,
+        0, sizeof(crypto_kapi_symc_ctx) * CONFIG_SYMC_VIRT_CHN_NUM);
+    kapi_symc_unlock();
+
+    crypto_kapi_func_exit();
+    return ret;
+
+exit_destroy:
+    for (i = 0; i < CONFIG_SYMC_VIRT_CHN_NUM; ++i) {
+        crypto_mutex_destroy(&symc_channel->symc_ctx_mutex[i]);
+    }
+exit_unlock:
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+
+td_s32 inner_kapi_drv_symc_create_lock(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_attr *symc_attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    kapi_symc_lock();
+    ret = drv_cipher_symc_create(&symc_ctx->drv_symc_handle, symc_attr);
+    kapi_symc_unlock();
+    return ret;
+}
+
+static td_void priv_drv_lock_destroy(td_handle drv_symc_handle)
+{
+    kapi_symc_lock();
+    (td_void)drv_cipher_symc_destroy(drv_symc_handle);
+    kapi_symc_unlock();
+}
+
+td_void inner_kapi_drv_symc_destroy_lock(td_handle drv_symc_handle)
+{
+    kapi_symc_lock();
+    (td_void)drv_cipher_symc_destroy(drv_symc_handle);
+    kapi_symc_unlock();
+}
+
+static td_void priv_process_release(crypto_kapi_symc_process *symc_channel)
+{
+    td_u32 i;
+    for (i = 0; i < CONFIG_SYMC_VIRT_CHN_NUM; ++i) {
+        crypto_mutex_destroy(&symc_channel->symc_ctx_mutex[i]);
+        if (symc_channel->symc_ctx_list[i].is_open == TD_TRUE &&
+            symc_channel->symc_ctx_list[i].symc_attr.is_long_term == TD_TRUE) {
+            (td_void)drv_cipher_symc_destroy(symc_channel->symc_ctx_list[i].drv_symc_handle);
+        }
+    }
+    (td_void)memset_s(symc_channel, sizeof(crypto_kapi_symc_process), 0, sizeof(crypto_kapi_symc_process));
+}
+
+static td_void priv_process_symc_deinit(td_void)
+{
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_func_enter();
+    kapi_symc_lock();
+    symc_channel = inner_get_current_symc_channel();
+    if (symc_channel == TD_NULL) {
+        kapi_symc_unlock();
+        return;
+    }
+    if (symc_channel->init_counter > 1) {
+        --(symc_channel->init_counter);
+        kapi_symc_unlock();
+        return;
+    }
+    priv_process_release(symc_channel);
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+}
+
+crypto_kapi_symc_ctx *inner_kapi_get_symc_ctx(td_handle symc_handle, td_u32 *idx)
+{
+    td_s32 ret;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+
+    ret =  priv_symc_handle_check(symc_handle);
+    crypto_chk_return(ret != TD_SUCCESS, NULL, "priv_symc_handle_check failed, ret is 0x%x\n", ret);
+
+    *idx = kapi_get_ctx_idx(symc_handle);
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, NULL, "inner_get_current_symc_channel failed\n");
+
+    return &symc_channel->symc_ctx_list[*idx];
+}
+
+td_void kapi_cipher_symc_process_release(td_void)
+{
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_func_enter();
+    kapi_symc_lock();
+    symc_channel = inner_get_current_symc_channel();
+    if (symc_channel == TD_NULL) {
+        kapi_symc_unlock();
+        return;
+    }
+    priv_process_release(symc_channel);
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+}
+
+td_s32 kapi_cipher_symc_env_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+    ret = drv_cipher_symc_init();
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("drv_cipher_symc_init failed\n");
+        return ret;
+    }
+
+    (td_void)memset_s(&g_kapi_symc_channel, sizeof(g_kapi_symc_channel), 0, sizeof(g_kapi_symc_channel));
+    ret = crypto_mutex_init(&g_symc_mutex);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("crypto_mutex_init failed\n");
+        ret = SYMC_COMPAT_ERRNO(ERROR_MUTEX_INIT);
+        goto error_symc_deinit;
+    }
+
+    g_kapi_dma_addr = crypto_malloc_coherent(CRYPTO_KAPI_TOTAL_DMA_SIZE, "crypto_kapi_symc_dma_buffer");
+    crypto_chk_goto_with_ret(ret, g_kapi_dma_addr == TD_NULL, error_mutex_destroy, SYMC_COMPAT_ERRNO(ERROR_MALLOC),
+        "crypto_malloc_coherent failed\n");
+
+    crypto_kapi_func_exit();
+    return ret;
+
+error_mutex_destroy:
+    crypto_mutex_destroy(&g_symc_mutex);
+error_symc_deinit:
+    drv_cipher_symc_deinit();
+    return ret;
+}
+
+td_s32 kapi_cipher_symc_env_deinit(td_void)
+{
+    td_u32 i, j;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    if (g_kapi_dma_addr != TD_NULL) {
+        (td_void)memset_s(g_kapi_dma_addr, CRYPTO_KAPI_TOTAL_DMA_SIZE, 0, CRYPTO_KAPI_TOTAL_DMA_SIZE);
+        crypto_free_coherent(g_kapi_dma_addr);
+        g_kapi_dma_addr = TD_NULL;
+    }
+
+    for (i = 0; i < CONFIG_MAX_PROCESS_NUM; i++) {
+        symc_channel = &g_kapi_symc_channel[i];
+        if (symc_channel->is_used == TD_FALSE) {
+            continue;
+        }
+        for (j = 0; j < CONFIG_SYMC_VIRT_CHN_NUM; j++) {
+            symc_ctx = &symc_channel->symc_ctx_list[j];
+            if (symc_ctx->is_open == TD_FALSE) {
+                continue;
+            }
+            priv_release_symc_soft_chn(symc_ctx);
+            symc_ctx->is_open = TD_FALSE;
+        }
+        symc_channel->is_used = TD_FALSE;
+    }
+    crypto_mutex_destroy(&g_symc_mutex);
+    (td_void)memset_s(&g_kapi_symc_channel, sizeof(g_kapi_symc_channel), 0, sizeof(g_kapi_symc_channel));
+    drv_cipher_symc_deinit();
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 kapi_cipher_symc_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_func_enter();
+
+    ret = priv_process_symc_init();
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("symc priv_process_symc_init failed\n");
+        return ret;
+    }
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_init);
+
+td_s32 kapi_cipher_symc_deinit(td_void)
+{
+    crypto_kapi_func_enter();
+    priv_process_symc_deinit();
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_deinit);
+
+td_s32 kapi_cipher_symc_create(td_handle *kapi_symc_handle, const crypto_symc_attr *symc_attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    td_u32 idx;
+
+    crypto_kapi_func_enter();
+    symc_null_ptr_chk(kapi_symc_handle);
+    symc_null_ptr_chk(symc_attr);
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+
+    symc_ctx = priv_occupy_symc_soft_chn(symc_channel, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_CHN_BUSY), "all symc soft chns are busy\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_attr->is_long_term == TD_TRUE) {
+        ret = inner_kapi_symc_create_long_term(symc_ctx, symc_attr);
+        crypto_chk_goto(ret != TD_SUCCESS, error_unlock_symc_ctx,
+            "inner_kapi_symc_create_long_term failed, ret is 0x%x\n", ret);
+    } else {
+        ret = inner_kapi_symc_create_short_term(symc_ctx, symc_attr);
+        crypto_chk_goto(ret != TD_SUCCESS, error_unlock_symc_ctx,
+            "inner_kapi_symc_create_short_term failed, ret is 0x%x\n", ret);
+    }
+
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    *kapi_symc_handle = synthesize_kapi_handle(KAPI_SYMC_MODULE_ID, idx);
+    crypto_kapi_func_exit();
+    return ret;
+
+error_unlock_symc_ctx:
+    priv_release_symc_soft_chn(symc_ctx);
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_create);
+
+td_s32 kapi_cipher_symc_destroy(td_handle kapi_symc_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_ctx->symc_attr.is_long_term == TD_TRUE) {
+        priv_drv_lock_destroy(symc_ctx->drv_symc_handle);
+    }
+    priv_release_symc_soft_chn(symc_ctx);
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_destroy);
+
+td_s32 kapi_cipher_symc_set_config(td_handle kapi_symc_handle, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    symc_null_ptr_chk(symc_ctrl);
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_ctx->symc_attr.is_long_term == TD_TRUE) {
+        ret = inner_kapi_symc_set_config_long_term(symc_ctx, symc_ctrl);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_symc_set_config_long_term failed\n");
+    } else {
+        ret = inner_kapi_symc_set_config_short_term(symc_ctx, symc_ctrl);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_symc_set_config_short_term failed\n");
+    }
+    symc_ctx->is_set_config = TD_TRUE;
+
+unlock_exit:
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_set_config);
+
+td_s32 kapi_cipher_symc_get_config(td_handle kapi_symc_handle, crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    symc_null_ptr_chk(symc_ctrl);
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(symc_ctx->is_set_config == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG),
+        "set config first\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_ctx->symc_attr.is_long_term == TD_TRUE) {
+        ret = inner_kapi_symc_get_config_long_term(symc_ctx, symc_ctrl);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_symc_get_config_long_term failed\n");
+    } else {
+        ret = inner_kapi_symc_get_config_short_term(symc_ctx, symc_ctrl);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_symc_get_config_short_term failed\n");
+    }
+    (td_void)memcpy_s(symc_ctrl, sizeof(crypto_symc_ctrl_t), &symc_ctx->symc_ctrl, sizeof(crypto_symc_ctrl_t));
+    if (symc_ctrl->work_mode == CRYPTO_SYMC_WORK_MODE_CCM || symc_ctrl->work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        crypto_chk_goto_with_ret(ret, symc_ctrl->param == TD_NULL, unlock_exit, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL),
+            "symc_ctrl->param is null\n");
+        (td_void)memcpy_s(symc_ctrl->param, sizeof(crypto_symc_config_aes_ccm_gcm),
+            &symc_ctx->ccm_gcm_config, sizeof(crypto_symc_config_aes_ccm_gcm));
+    }
+
+unlock_exit:
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_get_config);
+
+td_s32 kapi_cipher_symc_attach(td_handle kapi_symc_handle, td_handle keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_ctx->symc_attr.is_long_term == TD_TRUE) {
+        ret = inner_kapi_symc_attach_long_term(symc_ctx, keyslot_handle);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_symc_attach_long_term failed, ret is 0x%x\n", ret);
+    } else {
+        ret = inner_kapi_symc_attach_short_term(symc_ctx, keyslot_handle);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_symc_attach_short_term failed, ret is 0x%x\n", ret);
+    }
+
+    symc_ctx->is_attached = TD_TRUE;
+
+unlock_exit:
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_attach);
+
+#if defined(CONFIG_SYMC_DETACH_SUPPORT)
+td_s32 kapi_cipher_symc_detach(td_handle kapi_symc_handle, td_handle keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    crypto_unused(keyslot_handle);
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    if (symc_ctx->is_attached == TD_FALSE) {
+        return TD_SUCCESS;
+    }
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    symc_ctx->keyslot_handle = 0;
+    symc_ctx->is_attached = TD_FALSE;
+
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_detach);
+#endif
+
+static td_s32 kapi_cipher_symc_crypto(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length, td_u32 crypto_type)
+{
+    td_s32 ret;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(symc_ctx->is_set_config == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG),
+        "set_config first\n");
+    crypto_chk_return(symc_ctx->is_attached == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_ATTACHED), "attach first\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_ctx->symc_attr.is_long_term == TD_TRUE) {
+        ret = inner_kapi_symc_crypto_long_term(symc_ctx, src_buf, dst_buf, length, crypto_type);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit,
+            "inner_kapi_symc_crypto_long_term for Encrypt failed, ret is 0x%x\n", ret);
+    } else {
+        ret = inner_kapi_symc_crypto_short_term(symc_ctx, src_buf, dst_buf, length, crypto_type);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_symc_crypto_short_term failed, ret is 0x%x\n", ret);
+    }
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+
+    symc_ctx->processed_length += length;
+    return ret;
+
+unlock_exit:
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    return ret;
+}
+
+td_s32 kapi_cipher_symc_encrypt(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    td_s32 ret;
+    crypto_kapi_func_enter();
+
+    /* Param Check. */
+    symc_null_ptr_chk(src_buf);
+    symc_null_ptr_chk(dst_buf);
+    crypto_chk_return(crypto_data_buf_check(src_buf, length) == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS),
+        "src_buf access refused\n");
+    crypto_chk_return(crypto_data_buf_check(dst_buf, length) == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS),
+        "dst_buf access refused\n");
+
+    ret = kapi_cipher_symc_crypto(kapi_symc_handle, src_buf, dst_buf, length, CRYPTO_TYPE_ENCRYPT);
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_encrypt);
+
+td_s32 kapi_cipher_symc_decrypt(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    td_s32 ret;
+    crypto_kapi_func_enter();
+
+    /* Param Check. */
+    symc_null_ptr_chk(src_buf);
+    symc_null_ptr_chk(dst_buf);
+    crypto_chk_return(crypto_data_buf_check(src_buf, length) == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS),
+        "src_buf access refused\n");
+    crypto_chk_return(crypto_data_buf_check(dst_buf, length) == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS),
+        "dst_buf access refused\n");
+
+    ret = kapi_cipher_symc_crypto(kapi_symc_handle, src_buf, dst_buf, length, CRYPTO_TYPE_DECRYPT);
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_decrypt);
+
+td_s32 kapi_cipher_symc_get_tag(td_handle kapi_symc_handle, td_u8 *tag, td_u32 tag_length)
+{
+    td_s32 ret;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    symc_null_ptr_chk(tag);
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "Invalid Process!\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first!\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(symc_ctx->is_set_config == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_SET_CONFIG),
+        "set_config first\n");
+    crypto_chk_return(symc_ctx->is_attached == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_ATTACHED), "attach first\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_ctx->symc_attr.is_long_term == TD_TRUE) {
+        ret = inner_kapi_symc_get_tag_long_term(symc_ctx, tag, tag_length);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_unlock_mutex, "inner_kapi_symc_get_tag_long_term failed\n");
+    } else {
+        ret = inner_kapi_symc_get_tag_short_term(symc_ctx, tag, tag_length);
+        crypto_chk_goto(ret != TD_SUCCESS, exit_unlock_mutex, "inner_kapi_symc_get_tag_short_term failed\n");
+    }
+
+exit_unlock_mutex:
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_get_tag);
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_inner.h b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_inner.h
new file mode 100644
index 0000000..fca0ccf
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_inner.h
@@ -0,0 +1,116 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: kapi symc inner. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#ifndef KAPI_SYMC_INNER_H
+#define KAPI_SYMC_INNER_H
+
+#include "drv_symc_outer.h"
+#include "crypto_symc_struct.h"
+#include "crypto_drv_common.h"
+
+typedef struct {
+    td_bool is_open;
+    td_bool is_mac;
+    td_bool is_multi_pack;
+    td_u32 tid;
+    td_handle drv_symc_handle;
+    crypto_symc_attr symc_attr;
+    crypto_symc_work_mode work_mode;
+    td_handle keyslot_handle;
+    td_bool is_attached;
+    td_bool is_set_config;
+    td_bool is_long_term;
+    td_u8 *aad_buf;
+    td_u32 aad_buf_size;
+    crypto_symc_ctrl_t symc_ctrl;
+    crypto_symc_config_aes_ccm_gcm ccm_gcm_config;
+    td_u8 tag[CRYPTO_AES_MAX_TAG_SIZE];
+    /* The length should be processed. */
+    td_u32 data_length;
+    /* The length has been processd. */
+    td_u32 processed_length;
+    /* iv_mac for ccm, iv_ghash for gcm. */
+    td_u8 iv_mac[16];
+    /* s0 for ccm, j0 for gcm. */
+    td_u8 iv0[16];
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+    td_u32 ctr_offset;
+    td_u8 ctr_last_block[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+#endif
+    drv_symc_ccm_ctx ccm_ctx;
+    drv_symc_gcm_ctx gcm_ctx;
+    crypto_symc_mac_attr mac_attr;
+    crypto_symc_mac_ctx mac_ctx;
+    td_u8 *dma_buf;
+    td_u32 dma_buf_len;
+    crypto_cmac_ctx cmac_ctx;
+} crypto_kapi_symc_ctx;
+
+typedef struct {
+    crypto_owner owner;
+    crypto_kapi_symc_ctx symc_ctx_list[CONFIG_SYMC_VIRT_CHN_NUM];
+    crypto_mutex symc_ctx_mutex[CONFIG_SYMC_VIRT_CHN_NUM];
+    td_u32 ctx_num;
+    td_bool is_used;
+    td_u32 init_counter;
+    td_u8 *dma_addr;
+} crypto_kapi_symc_process;
+
+#define SYMC_COMPAT_ERRNO(err_code)     KAPI_COMPAT_ERRNO(ERROR_MODULE_SYMC, err_code)
+
+/* Common. */
+crypto_kapi_symc_ctx *inner_kapi_get_symc_ctx(td_handle symc_handle, td_u32 *idx);
+
+td_s32 inner_get_symc_mutex(crypto_mutex *symc_mutex);
+
+td_s32 inner_get_symc_handle(td_handle *symc_handle);
+
+td_s32 inner_kapi_drv_symc_create_lock(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_attr *symc_attr);
+
+td_void inner_kapi_drv_symc_destroy_lock(td_handle drv_symc_handle);
+
+void inner_kapi_symc_lock(void);
+
+void inner_kapi_symc_unlock(void);
+
+crypto_kapi_symc_process *inner_get_current_symc_channel(td_void);
+
+crypto_kapi_symc_ctx *priv_occupy_symc_soft_chn(crypto_kapi_symc_process *symc_channel, td_u32 *idx);
+
+td_void priv_release_symc_soft_chn(crypto_kapi_symc_ctx *symc_ctx);
+
+/* Long Term. */
+td_s32 inner_kapi_symc_create_long_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_attr *symc_attr);
+
+td_s32 inner_kapi_symc_set_config_long_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 inner_kapi_symc_get_config_long_term(crypto_kapi_symc_ctx *symc_ctx, crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 inner_kapi_symc_attach_long_term(crypto_kapi_symc_ctx *symc_ctx, td_handle keyslot_handle);
+
+td_s32 inner_kapi_symc_crypto_long_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length, td_u32 crypto_type);
+
+td_s32 inner_kapi_symc_get_tag_long_term(crypto_kapi_symc_ctx *symc_ctx, td_u8 *tag, td_u32 tag_length);
+
+/* Short Term. */
+td_s32 inner_kapi_symc_create_short_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_attr *symc_attr);
+
+td_s32 inner_kapi_symc_set_config_short_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 inner_kapi_symc_get_config_short_term(crypto_kapi_symc_ctx *symc_ctx, crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 inner_kapi_symc_attach_short_term(crypto_kapi_symc_ctx *symc_ctx, td_handle keyslot_handle);
+
+td_s32 inner_kapi_symc_crypto_short_term(crypto_kapi_symc_ctx *symc_ctx,
+    const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length, td_u32 crypto_type);
+
+td_s32 inner_kapi_symc_get_tag_short_term(crypto_kapi_symc_ctx *symc_ctx, td_u8 *tag, td_u32 tag_length);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_long_term.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_long_term.c
new file mode 100755
index 0000000..f20e3fb
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_long_term.c
@@ -0,0 +1,49 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: kapi symc long term. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "kapi_symc_inner.h"
+#include "drv_symc.h"
+
+td_s32 inner_kapi_symc_create_long_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_attr *symc_attr)
+{
+    symc_ctx->symc_attr.is_long_term = TD_TRUE;
+    return inner_kapi_drv_symc_create_lock(symc_ctx, symc_attr);
+}
+
+td_s32 inner_kapi_symc_set_config_long_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    return drv_cipher_symc_set_config(symc_ctx->drv_symc_handle, symc_ctrl);
+}
+
+td_s32 inner_kapi_symc_get_config_long_term(crypto_kapi_symc_ctx *symc_ctx, crypto_symc_ctrl_t *symc_ctrl)
+{
+    return drv_cipher_symc_get_config(symc_ctx->drv_symc_handle, symc_ctrl);
+}
+
+td_s32 inner_kapi_symc_attach_long_term(crypto_kapi_symc_ctx *symc_ctx, td_handle keyslot_handle)
+{
+    return drv_cipher_symc_attach(symc_ctx->drv_symc_handle, keyslot_handle);
+}
+
+td_s32 inner_kapi_symc_crypto_long_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length, td_u32 crypto_type)
+{
+    td_s32 ret;
+    if (crypto_type == CRYPTO_TYPE_ENCRYPT) {
+        ret = drv_cipher_symc_encrypt(symc_ctx->drv_symc_handle, src_buf, dst_buf, length);
+    } else {
+        ret = drv_cipher_symc_decrypt(symc_ctx->drv_symc_handle, src_buf, dst_buf, length);
+    }
+    return ret;
+}
+
+td_s32 inner_kapi_symc_get_tag_long_term(crypto_kapi_symc_ctx *symc_ctx, td_u8 *tag, td_u32 tag_length)
+{
+    return drv_cipher_symc_get_tag(symc_ctx->drv_symc_handle, tag, tag_length);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_mac.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_mac.c
new file mode 100755
index 0000000..3afc250
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_mac.c
@@ -0,0 +1,344 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+#if defined(CONFIG_SYMC_CMAC_SUPPORT) || defined(CONFIG_SYMC_CBC_MAC_SUPPORT)
+
+#include "kapi_symc.h"
+#include "kapi_inner.h"
+
+#include "drv_symc.h"
+#include "drv_symc_outer.h"
+#include "crypto_drv_common.h"
+#include "kapi_symc_inner.h"
+static td_s32 inner_kapi_mac_process(crypto_kapi_symc_ctx *ctx, const td_u8 *data, td_u32 data_len);
+
+static td_s32 priv_drv_lock_mac_start(td_handle *kapi_symc_handle, const crypto_symc_mac_attr *mac_attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    inner_kapi_symc_lock();
+    ret = drv_cipher_mac_start(kapi_symc_handle, mac_attr);
+    inner_kapi_symc_unlock();
+    return ret;
+}
+
+static td_s32 priv_drv_lock_mac_finish(td_handle kapi_symc_handle, td_u8 *mac, td_u32 *mac_length)
+{
+    td_s32 ret;
+    inner_kapi_symc_lock();
+    ret = drv_cipher_mac_finish(kapi_symc_handle, mac, mac_length);
+    inner_kapi_symc_unlock();
+    return ret;
+}
+
+static td_s32 inner_kapi_mac_start_long_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_mac_attr *mac_attr)
+{
+    return priv_drv_lock_mac_start(&symc_ctx->drv_symc_handle, mac_attr);
+}
+
+static td_s32 inner_kapi_mac_start_short_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_mac_attr *mac_attr)
+{
+    td_s32 ret;
+    ret = memcpy_s(&symc_ctx->mac_attr, sizeof(crypto_symc_mac_attr), mac_attr, sizeof(crypto_symc_mac_attr));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return TD_SUCCESS;
+}
+
+static td_s32 inner_kapi_mac_update_long_term(crypto_kapi_symc_ctx *symc_ctx,
+    const crypto_buf_attr *src_buf, td_u32 length)
+{
+    return inner_kapi_mac_process(symc_ctx, src_buf->virt_addr, length);
+}
+
+static td_s32 inner_kapi_mac_update_short_term(crypto_kapi_symc_ctx *symc_ctx,
+    const crypto_buf_attr *src_buf, td_u32 length)
+{
+    td_s32 ret;
+
+    ret = priv_drv_lock_mac_start(&symc_ctx->drv_symc_handle, &symc_ctx->mac_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_drv_lock_mac_start failed, ret is 0x%x\n", ret);
+
+    ret = inner_drv_symc_cbc_mac_set_ctx(symc_ctx->drv_symc_handle, symc_ctx->mac_ctx.mac,
+        sizeof(symc_ctx->mac_ctx.mac));
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "inner_drv_symc_cbc_mac_set_ctx failed, ret is 0x%x\n", ret);
+
+    ret = inner_drv_mac_set_ctx(symc_ctx->drv_symc_handle, &symc_ctx->cmac_ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "inner_drv_mac_set_ctx failed, ret is 0x%x\n", ret);
+
+    ret = inner_kapi_mac_process(symc_ctx, src_buf->virt_addr, length);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "inner_kapi_mac_process failed, ret is 0x%x\n", ret);
+
+    if (symc_ctx->work_mode == CRYPTO_SYMC_WORK_MODE_CBC_MAC) {
+        symc_ctx->mac_ctx.mac_length = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+        ret = drv_cipher_mac_finish(symc_ctx->drv_symc_handle, symc_ctx->mac_ctx.mac, &symc_ctx->mac_ctx.mac_length);
+        crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "drv_cipher_mac_update failed, ret is 0x%x\n", ret);
+    } else {
+        ret = inner_drv_mac_get_ctx(symc_ctx->drv_symc_handle, &symc_ctx->cmac_ctx);
+        crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "drv_cipher_mac_update failed, ret is 0x%x\n", ret);
+
+        (td_void)drv_cipher_symc_destroy(symc_ctx->drv_symc_handle);
+    }
+
+    return ret;
+error_symc_destroy:
+    (td_void)drv_cipher_symc_destroy(symc_ctx->drv_symc_handle);
+    return ret;
+}
+
+static td_s32 inner_kapi_mac_finish_long_term(crypto_kapi_symc_ctx *symc_ctx, td_u8 *mac, td_u32 *mac_length)
+{
+    td_s32 ret;
+    crypto_buf_attr src_buf;
+
+    if ((symc_ctx->work_mode == CRYPTO_SYMC_WORK_MODE_CMAC) && (symc_ctx->mac_ctx.tail_length != 0)) {
+        src_buf.virt_addr = symc_ctx->dma_buf;
+        ret = memcpy_s(src_buf.virt_addr, symc_ctx->dma_buf_len, symc_ctx->mac_ctx.tail, symc_ctx->mac_ctx.tail_length);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = drv_cipher_mac_update(symc_ctx->drv_symc_handle, &src_buf, symc_ctx->mac_ctx.tail_length);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_mac_update failed\n");
+    }
+    ret = priv_drv_lock_mac_finish(symc_ctx->drv_symc_handle, mac, mac_length);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_drv_lock_mac_finish failed\n");
+
+    return ret;
+}
+
+static td_s32 inner_kapi_cmac_finish_short_term(crypto_kapi_symc_ctx *symc_ctx)
+{
+    td_s32 ret;
+    crypto_buf_attr src_buf;
+
+    ret = priv_drv_lock_mac_start(&symc_ctx->drv_symc_handle, &symc_ctx->mac_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_drv_lock_mac_start failed, ret is 0x%x\n", ret);
+
+    ret = inner_drv_mac_set_ctx(symc_ctx->drv_symc_handle, &symc_ctx->cmac_ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "inner_drv_mac_set_ctx failed, ret is 0x%x\n", ret);
+
+    if (symc_ctx->mac_ctx.tail_length != 0) {
+        src_buf.virt_addr = symc_ctx->dma_buf;
+        ret = memcpy_s(src_buf.virt_addr, symc_ctx->dma_buf_len, symc_ctx->mac_ctx.tail, symc_ctx->mac_ctx.tail_length);
+        crypto_chk_goto_with_ret(ret, ret != EOK, error_symc_destroy,
+            SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = drv_cipher_mac_update(symc_ctx->drv_symc_handle, &src_buf, symc_ctx->mac_ctx.tail_length);
+        crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "drv_cipher_mac_update failed\n");
+    }
+
+    symc_ctx->mac_ctx.mac_length = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    ret = drv_cipher_mac_finish(symc_ctx->drv_symc_handle, symc_ctx->mac_ctx.mac, &symc_ctx->mac_ctx.mac_length);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "drv_cipher_mac_update failed, ret is 0x%x\n", ret);
+
+    return ret;
+error_symc_destroy:
+    (td_void)drv_cipher_symc_destroy(symc_ctx->drv_symc_handle);
+    return ret;
+}
+
+static td_s32 inner_kapi_mac_finish_short_term(crypto_kapi_symc_ctx *symc_ctx, td_u8 *mac, td_u32 *mac_length)
+{
+    td_s32 ret;
+
+    if (symc_ctx->work_mode == CRYPTO_SYMC_WORK_MODE_CMAC) {
+        ret = inner_kapi_cmac_finish_short_term(symc_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_kapi_cmac_finish_short_term failed\n");
+    }
+
+    ret = memcpy_s(mac, *mac_length, symc_ctx->mac_ctx.mac, symc_ctx->mac_ctx.mac_length);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return ret;
+}
+
+td_s32 kapi_cipher_mac_start(td_handle *kapi_symc_handle, const crypto_symc_mac_attr *mac_attr)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    td_u32 idx;
+
+    crypto_kapi_func_enter();
+    symc_null_ptr_chk(kapi_symc_handle);
+    symc_null_ptr_chk(mac_attr);
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first\n");
+
+    symc_ctx = priv_occupy_symc_soft_chn(symc_channel, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_CHN_BUSY), "all symc soft chns are busy\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    symc_ctx->dma_buf = crypto_malloc_mmz(CONFIG_SYMC_KAPI_DMA_BUF_LEN, "symc_dma_buf");
+    crypto_chk_goto_with_ret(ret, symc_ctx->dma_buf == TD_NULL, error_unlock_symc_ctx,
+        SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc_mmz failed\n");
+    symc_ctx->dma_buf_len = CONFIG_SYMC_KAPI_DMA_BUF_LEN;
+
+    if (mac_attr->is_long_term == TD_TRUE) {
+        ret = inner_kapi_mac_start_long_term(symc_ctx, mac_attr);
+        crypto_chk_goto(ret != TD_SUCCESS, error_free, "inner_kapi_mac_start_long_term failed, ret is 0x%x\n", ret);
+    } else {
+        ret = inner_kapi_mac_start_short_term(symc_ctx, mac_attr);
+        crypto_chk_goto(ret != TD_SUCCESS, error_free, "inner_kapi_mac_start_short_term failed, ret is 0x%x\n", ret);
+    }
+    symc_ctx->is_mac = TD_TRUE;
+    symc_ctx->is_long_term = mac_attr->is_long_term;
+    symc_ctx->work_mode = mac_attr->work_mode;
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    *kapi_symc_handle = synthesize_kapi_handle(KAPI_SYMC_MODULE_ID, idx);
+    crypto_kapi_func_exit();
+    return ret;
+
+error_free:
+    crypto_free_coherent(symc_ctx->dma_buf);
+error_unlock_symc_ctx:
+    priv_release_symc_soft_chn(symc_ctx);
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_mac_start);
+
+static td_s32 inner_kapi_mac_process(crypto_kapi_symc_ctx *ctx, const td_u8 *data, td_u32 data_len)
+{
+    td_s32 ret;
+    td_u8 *dma_buf = ctx->dma_buf;
+    td_u32 dma_buf_len = ctx->dma_buf_len;
+    td_u8 *tail = ctx->mac_ctx.tail;
+    td_u32 tail_len = ctx->mac_ctx.tail_length;
+    td_u32 block_size = sizeof(ctx->mac_ctx.tail);
+    td_u32 processing_len = 0;
+    td_u32 processed_len = 0;
+    td_u32 left = data_len;
+    crypto_buf_attr src_buf;
+
+    src_buf.virt_addr = dma_buf;
+    if ((tail_len + data_len) < block_size) {
+        ret = memcpy_s(tail + tail_len, block_size - tail_len, data, data_len);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+        ctx->mac_ctx.tail_length += data_len;
+        return CRYPTO_SUCCESS;
+    }
+    if (tail_len != 0) {
+        processing_len = block_size - tail_len;
+        ret = memcpy_s(tail + tail_len, processing_len, data, processing_len);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+        ret = memcpy_s(dma_buf, block_size, tail, block_size);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = drv_cipher_mac_update(ctx->drv_symc_handle, &src_buf, block_size);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_mac_update failed\n");
+
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+    while (left >= block_size) {
+        if (left >= dma_buf_len) {
+            processing_len = dma_buf_len;
+        } else {
+            processing_len = left - left % block_size;
+        }
+        ret = memcpy_s(dma_buf, dma_buf_len, data + processed_len, processing_len);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = drv_cipher_mac_update(ctx->drv_symc_handle, &src_buf, processing_len);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_mac_update failed\n");
+
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+    if (left != 0) {
+        ret = memcpy_s(tail, block_size, data + processed_len, left);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    }
+    ctx->mac_ctx.tail_length = left;
+
+    return ret;
+}
+
+td_s32 kapi_cipher_mac_update(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf, td_u32 length)
+{
+    td_s32 ret;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_CHN_BUSY), "all symc soft chns are busy\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(symc_ctx->is_mac == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_MAC_START), "call mac_start first\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_ctx->is_long_term == TD_TRUE) {
+        ret = inner_kapi_mac_update_long_term(symc_ctx, src_buf, length);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_mac_update_long_term failed, ret is 0x%x\n", ret);
+    } else {
+        ret = inner_kapi_mac_update_short_term(symc_ctx, src_buf, length);
+        crypto_chk_goto(ret != TD_SUCCESS, unlock_exit, "inner_kapi_mac_update_short_term failed, ret is 0x%x\n", ret);
+    }
+
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+
+unlock_exit:
+    if (symc_ctx->dma_buf != TD_NULL) {
+        crypto_free_coherent(symc_ctx->dma_buf);
+        symc_ctx->dma_buf = TD_NULL;
+    }
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_mac_update);
+
+td_s32 kapi_cipher_mac_finish(td_handle kapi_symc_handle, td_u8 *mac, td_u32 *mac_length)
+{
+    td_s32 ret;
+    td_u32 idx = 0;
+    crypto_kapi_symc_process *symc_channel = TD_NULL;
+    crypto_kapi_symc_ctx *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    symc_null_ptr_chk(mac);
+    symc_null_ptr_chk(mac_length);
+
+    crypto_chk_return(*mac_length < CRYPTO_AES_BLOCK_SIZE_IN_BYTES, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "mac_length is not enough\n");
+
+    symc_channel = inner_get_current_symc_channel();
+    crypto_chk_return(symc_channel == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_NOT_INIT), "call init first\n");
+
+    symc_ctx = inner_kapi_get_symc_ctx(kapi_symc_handle, &idx);
+    crypto_chk_return(symc_ctx == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_CHN_BUSY), "all symc soft chns are busy\n");
+    crypto_chk_return(symc_ctx->is_open == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_CTX_CLOSED), "ctx is closed\n");
+    crypto_chk_return(symc_ctx->is_mac == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_NOT_MAC_START), "call mac_start first\n");
+
+    crypto_mutex_lock(&symc_channel->symc_ctx_mutex[idx]);
+
+    if (symc_ctx->is_long_term == TD_TRUE) {
+        ret = inner_kapi_mac_finish_long_term(symc_ctx, mac, mac_length);
+        crypto_chk_goto(ret != TD_SUCCESS, error_exit, "inner_kapi_mac_finish_long_term failed, ret is 0x%x\n", ret);
+    } else {
+        ret = inner_kapi_mac_finish_short_term(symc_ctx, mac, mac_length);
+        crypto_chk_goto(ret != TD_SUCCESS, error_exit, "inner_kapi_mac_finish_short_term failed, ret is 0x%x\n", ret);
+    }
+
+error_exit:
+    if (symc_ctx->dma_buf != TD_NULL) {
+        crypto_free_coherent(symc_ctx->dma_buf);
+        symc_ctx->dma_buf = TD_NULL;
+    }
+    priv_release_symc_soft_chn(symc_ctx);
+    crypto_mutex_unlock(&symc_channel->symc_ctx_mutex[idx]);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_mac_finish);
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_short_term.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_short_term.c
new file mode 100755
index 0000000..de5a54d
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_short_term.c
@@ -0,0 +1,198 @@
+/**
+ * Copyright (c) @CompanyNameMagicTag 2023-2023. All rights reserved. \n
+ *
+ * Description: kapi symc short term. \n
+ * Author: @CompanyNameTag \n
+ * History: \n
+ * 2023-03-22, Create file. \n
+ */
+
+#include "kapi_symc_inner.h"
+#include "drv_symc_outer.h"
+#include "drv_symc.h"
+
+td_s32 inner_kapi_symc_create_short_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_attr *symc_attr)
+{
+    td_s32 ret;
+
+    ret = memcpy_s(&symc_ctx->symc_attr, sizeof(crypto_symc_attr), symc_attr, sizeof(crypto_symc_attr));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return CRYPTO_SUCCESS;
+}
+
+static td_s32 inner_kapi_symc_set_ctx(crypto_kapi_symc_ctx *symc_ctx)
+{
+    int ret;
+    crypto_symc_work_mode work_mode = symc_ctx->symc_ctrl.work_mode;
+
+    if (work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        ret = inner_drv_symc_ccm_set_ctx(symc_ctx->drv_symc_handle, &symc_ctx->ccm_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_ccm_set_ctx failed, ret is 0x%x\n", ret);
+    } else if (work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        ret = inner_drv_symc_gcm_set_ctx(symc_ctx->drv_symc_handle, &symc_ctx->gcm_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_gcm_set_ctx failed, ret is 0x%x\n", ret);
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+static td_s32 inner_kapi_symc_get_ctx(crypto_kapi_symc_ctx *symc_ctx)
+{
+    int ret;
+    crypto_symc_work_mode work_mode = symc_ctx->symc_ctrl.work_mode;
+
+    if (work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        ret = inner_drv_symc_ccm_get_ctx(symc_ctx->drv_symc_handle, &symc_ctx->ccm_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_ccm_get_ctx failed, ret is 0x%x\n", ret);
+    } else if (work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        ret = inner_drv_symc_gcm_get_ctx(symc_ctx->drv_symc_handle, &symc_ctx->gcm_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_gcm_get_ctx failed, ret is 0x%x\n", ret);
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+static td_s32 inner_kapi_symc_set_config_ex_short_term(crypto_kapi_symc_ctx *symc_ctx,
+    const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    symc_null_ptr_chk(symc_ctrl->param);
+
+    ret = inner_kapi_drv_symc_create_lock(symc_ctx, &symc_ctx->symc_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_kapi_drv_symc_create_lock failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_symc_attach(symc_ctx->drv_symc_handle, symc_ctx->keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit,
+        "drv_cipher_symc_attach failed, ret is 0x%x\n", ret);
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_UPDATE ||
+        symc_ctrl->iv_change_flag == CRYPTO_SYMC_GCM_IV_CHANGE_UPDATE) {
+        ret = inner_kapi_symc_set_ctx(symc_ctx);
+        crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "inner_kapi_symc_set_ctx failed, ret is 0x%x\n", ret);
+    }
+
+    ret = drv_cipher_symc_set_config(symc_ctx->drv_symc_handle, symc_ctrl);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "drv_cipher_symc_set_config failed, ret is 0x%x\n", ret);
+
+    ret = inner_kapi_symc_get_ctx(symc_ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "inner_kapi_symc_get_ctx failed, ret is 0x%x\n", ret);
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_START ||
+        symc_ctrl->iv_change_flag == CRYPTO_SYMC_GCM_IV_CHANGE_START) {
+        ret = inner_drv_symc_get_iv(symc_ctx->drv_symc_handle, symc_ctx->symc_ctrl.iv, sizeof(symc_ctx->symc_ctrl.iv));
+        crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "inner_drv_symc_get_iv failed, ret is 0x%x\n", ret);
+    }
+
+symc_destroy_exit:
+    inner_kapi_drv_symc_destroy_lock(symc_ctx->drv_symc_handle);
+    return ret;
+}
+
+td_s32 inner_kapi_symc_set_config_short_term(crypto_kapi_symc_ctx *symc_ctx, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    crypto_symc_work_mode work_mode = symc_ctrl->work_mode;
+
+    if (work_mode == CRYPTO_SYMC_WORK_MODE_CCM || work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        symc_ctx->symc_ctrl.symc_alg = symc_ctrl->symc_alg;
+        symc_ctx->symc_ctrl.work_mode = symc_ctrl->work_mode;
+        symc_ctx->symc_ctrl.symc_key_length = symc_ctrl->symc_key_length;
+        symc_ctx->symc_ctrl.symc_bit_width = symc_ctrl->symc_bit_width;
+        return inner_kapi_symc_set_config_ex_short_term(symc_ctx, symc_ctrl);
+    } else {
+        ret = memcpy_s(&symc_ctx->symc_ctrl, sizeof(crypto_symc_ctrl_t), symc_ctrl, sizeof(crypto_symc_ctrl_t));
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+        symc_ctx->symc_ctrl.param = NULL;
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 inner_kapi_symc_get_config_short_term(crypto_kapi_symc_ctx *symc_ctx, crypto_symc_ctrl_t *symc_ctrl)
+{
+    crypto_unused(symc_ctx);
+    crypto_unused(symc_ctrl);
+
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 inner_kapi_symc_attach_short_term(crypto_kapi_symc_ctx *symc_ctx, td_handle keyslot_handle)
+{
+    symc_ctx->keyslot_handle = keyslot_handle;
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 inner_kapi_symc_crypto_short_term(crypto_kapi_symc_ctx *symc_ctx,
+    const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length, td_u32 crypto_type)
+{
+    td_s32 ret;
+
+    ret = inner_kapi_drv_symc_create_lock(symc_ctx, &symc_ctx->symc_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_kapi_drv_symc_create_lock failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_symc_attach(symc_ctx->drv_symc_handle, symc_ctx->keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit,
+        "drv_cipher_symc_attach for crypto failed, ret is 0x%x\n", ret);
+
+    if (symc_ctx->symc_ctrl.work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        symc_ctx->symc_ctrl.iv_change_flag = CRYPTO_SYMC_CCM_IV_CHANGE_FINISH;
+    } else if (symc_ctx->symc_ctrl.work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        symc_ctx->symc_ctrl.iv_change_flag = CRYPTO_SYMC_GCM_IV_CHANGE_FINISH;
+    }
+    ret = drv_cipher_symc_set_config(symc_ctx->drv_symc_handle, &symc_ctx->symc_ctrl);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit,
+        "drv_cipher_symc_set_config for crypto failed, ret is 0x%x\n", ret);
+
+    ret = inner_drv_symc_set_iv(symc_ctx->drv_symc_handle, symc_ctx->symc_ctrl.iv, sizeof(symc_ctx->symc_ctrl.iv));
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "inner_drv_symc_set_iv failed, ret is 0x%x\n", ret);
+
+    ret = inner_kapi_symc_set_ctx(symc_ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "inner_kapi_symc_set_ctx failed, ret is 0x%x\n", ret);
+
+    if (crypto_type == CRYPTO_TYPE_ENCRYPT) {
+        ret = drv_cipher_symc_encrypt(symc_ctx->drv_symc_handle, src_buf, dst_buf, length);
+    } else {
+        ret = drv_cipher_symc_decrypt(symc_ctx->drv_symc_handle, src_buf, dst_buf, length);
+    }
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit,
+        "inner_kapi_cipher_symc_crypto for crypto failed, ret is 0x%x\n", ret);
+
+    /* Update iv after crypto. */
+    ret = inner_drv_symc_get_iv(symc_ctx->drv_symc_handle, symc_ctx->symc_ctrl.iv, sizeof(symc_ctx->symc_ctrl.iv));
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit,
+        "inner_drv_symc_get_iv for crypto failed, ret is 0x%x\n", ret);
+
+    ret = inner_kapi_symc_get_ctx(symc_ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "inner_kapi_symc_get_ctx failed, ret is 0x%x\n", ret);
+
+symc_destroy_exit:
+    inner_kapi_drv_symc_destroy_lock(symc_ctx->drv_symc_handle);
+    return ret;
+}
+
+td_s32 inner_kapi_symc_get_tag_short_term(crypto_kapi_symc_ctx *symc_ctx, td_u8 *tag, td_u32 tag_len)
+{
+    td_s32 ret;
+
+    ret = inner_kapi_drv_symc_create_lock(symc_ctx, &symc_ctx->symc_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "inner_kapi_drv_symc_create_lock failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_symc_attach(symc_ctx->drv_symc_handle, symc_ctx->keyslot_handle);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit,
+        "drv_cipher_symc_attach for crypto failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_symc_set_config(symc_ctx->drv_symc_handle, &symc_ctx->symc_ctrl);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit,
+        "drv_cipher_symc_set_config for crypto failed, ret is 0x%x\n", ret);
+
+    ret = inner_kapi_symc_set_ctx(symc_ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "inner_kapi_symc_set_ctx failed, ret is 0x%x\n", ret);
+
+    ret = drv_cipher_symc_get_tag(symc_ctx->drv_symc_handle, tag, tag_len);
+    crypto_chk_goto(ret != TD_SUCCESS, symc_destroy_exit, "drv_cipher_symc_get_tag failed\n");
+
+symc_destroy_exit:
+    inner_kapi_drv_symc_destroy_lock(symc_ctx->drv_symc_handle);
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_simple.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_simple.c
new file mode 100644
index 0000000..1cbdc73
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_symc_simple.c
@@ -0,0 +1,819 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "kapi_symc.h"
+#include "kapi_inner.h"
+
+#include "drv_symc.h"
+#include "drv_symc_outer.h"
+#include "crypto_drv_common.h"
+#include "kapi_symc_inner.h"
+
+#define CRYPTO_KAPI_DMA_SIZE_ONE_PROCESS    (CONFIG_DRV_AAD_SIZE * CONFIG_SYMC_VIRT_CHN_NUM)
+#define CRYPTO_KAPI_TOTAL_DMA_SIZE          (CRYPTO_KAPI_DMA_SIZE_ONE_PROCESS * CONFIG_MAX_PROCESS_NUM)
+#define CRYPTO_SYMC_INIT_MAX_NUM            0xffffffff
+
+typedef struct {
+    crypto_owner owner;
+    crypto_symc_ctrl_t symc_ctrl;
+    td_handle keyslot_handle;
+    td_u32 processed_length;
+    union {
+        drv_symc_ccm_ctx ccm_ctx;
+        drv_symc_gcm_ctx gcm_ctx;
+        crypto_cmac_ctx cmac_ctx;
+    };
+#if defined(CONFIG_SYMC_CMAC_SUPPORT) || defined(CONFIG_SYMC_CBC_MAC_SUPPORT)
+    td_u8 *dma_buf;
+    td_u32 dma_buf_len;
+    crypto_symc_mac_attr mac_attr;
+    unsigned char tail[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+    unsigned int tail_len;
+#endif
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+    td_u32 ctr_offset;
+    td_u8 ctr_last_block[CRYPTO_AES_BLOCK_SIZE_IN_BYTES];
+#endif
+    td_u32 is_attached  : 1;
+} kapi_symc_context;
+
+static kapi_symc_context *g_kapi_symc_ctx_list[CONFIG_SYMC_VIRT_CHN_NUM];
+static crypto_mutex g_symc_mutex;
+static td_handle g_drv_symc_handle;
+
+#define kapi_symc_lock() do {                   \
+    crypto_log_trace("symc mutext lock");   \
+    crypto_mutex_lock(&g_symc_mutex);           \
+} while (0)
+#define kapi_symc_unlock() do {                 \
+    crypto_log_trace("symc mutext unlock");   \
+    crypto_mutex_unlock(&g_symc_mutex);         \
+} while (0)
+
+static td_s32 inner_kapi_symc_handle_check(td_handle kapi_symc_handle)
+{
+    crypto_chk_return(kapi_get_module_id(kapi_symc_handle) != KAPI_SYMC_MODULE_ID,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "Invalid Symc Handle! 0x%x\n", kapi_symc_handle);
+    crypto_chk_return(kapi_get_ctx_idx(kapi_symc_handle) >= CONFIG_SYMC_VIRT_CHN_NUM,  \
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "Invalid Symc Handle! 0x%x\n", kapi_symc_handle);
+    return CRYPTO_SUCCESS;
+}
+
+static kapi_symc_context *inner_get_symc_ctx(td_handle symc_handle)
+{
+    unsigned int idx = kapi_get_ctx_idx(symc_handle);
+    crypto_owner owner  = {0};
+
+    if (inner_kapi_symc_handle_check(symc_handle) != TD_SUCCESS) {
+        return NULL;
+    }
+    if (g_kapi_symc_ctx_list[idx] == NULL) {
+        return NULL;
+    }
+    crypto_get_owner(&owner);
+    if (memcmp(&g_kapi_symc_ctx_list[idx]->owner, &owner, sizeof(crypto_owner)) != 0) {
+        return NULL;
+    }
+
+    return g_kapi_symc_ctx_list[idx];
+}
+
+static int inner_kapi_alloc_symc_ctx(td_handle *symc_handle, kapi_symc_context **symc_ctx)
+{
+    int ret = TD_FAILURE;
+    unsigned int i;
+    kapi_symc_lock();
+    for (i = 0; i < crypto_array_size(g_kapi_symc_ctx_list); i++) {
+        if (g_kapi_symc_ctx_list[i] == NULL) {
+            break;
+        }
+    }
+    if (i >= crypto_array_size(g_kapi_symc_ctx_list)) {
+        ret = SYMC_COMPAT_ERRNO(ERROR_CHN_BUSY);
+        goto exit_unlock;
+    }
+    *symc_ctx = crypto_malloc(sizeof(kapi_symc_context));
+    crypto_chk_goto_with_ret(ret, *symc_ctx == NULL, exit_unlock,
+        SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    (void)memset_s(*symc_ctx, sizeof(kapi_symc_context), 0, sizeof(kapi_symc_context));
+
+    g_kapi_symc_ctx_list[i] = *symc_ctx;
+    crypto_get_owner(&(g_kapi_symc_ctx_list[i]->owner));
+    *symc_handle = synthesize_kapi_handle(KAPI_SYMC_MODULE_ID, i);
+
+    ret = CRYPTO_SUCCESS;
+exit_unlock:
+    kapi_symc_unlock();
+    return ret;
+}
+
+static int inner_kapi_free_symc_ctx(td_handle symc_handle)
+{
+    kapi_symc_context *symc_ctx = NULL;
+    unsigned int idx;
+
+    if (inner_kapi_symc_handle_check(symc_handle) != CRYPTO_SUCCESS) {
+        return SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE);
+    }
+    idx = kapi_get_ctx_idx(symc_handle);
+    symc_ctx = inner_get_symc_ctx(symc_handle);
+    crypto_chk_return(symc_ctx == NULL, SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed!\n");
+    
+    kapi_symc_lock();
+    if (symc_ctx->dma_buf != NULL) {
+        crypto_free_coherent(symc_ctx->dma_buf);
+        symc_ctx->dma_buf = NULL;
+    }
+    crypto_free(symc_ctx);
+    g_kapi_symc_ctx_list[idx] = NULL;
+    symc_ctx = NULL;
+    kapi_symc_unlock();
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 inner_get_symc_handle(td_handle *symc_handle)
+{
+    *symc_handle = g_drv_symc_handle;
+
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 inner_get_symc_mutex(crypto_mutex *symc_mutex)
+{
+    symc_mutex->mutex = g_symc_mutex.mutex;
+    if (symc_mutex->mutex == NULL) {
+        crypto_log_err("symc_mutex->mutex is NULL\n");
+        return CRYPTO_FAILURE;
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+td_s32 kapi_cipher_symc_env_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_symc_attr symc_attr;
+
+    crypto_kapi_func_enter();
+    ret = drv_cipher_symc_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_symc_init failed\n");
+
+    ret = crypto_mutex_init(&g_symc_mutex);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, error_symc_deinit, SYMC_COMPAT_ERRNO(ERROR_MUTEX_INIT),
+        "crypto_mutex_init failed\n");
+
+    ret = drv_cipher_symc_create(&g_drv_symc_handle, &symc_attr);
+    crypto_chk_goto(ret != TD_SUCCESS, error_mutex_destroy, "drv_cipher_symc_create failed\n");
+
+    crypto_kapi_func_exit();
+    return ret;
+
+error_mutex_destroy:
+    crypto_mutex_destroy(&g_symc_mutex);
+error_symc_deinit:
+    drv_cipher_symc_deinit();
+    return ret;
+}
+
+td_s32 kapi_cipher_symc_env_deinit(td_void)
+{
+    crypto_kapi_func_enter();
+
+    crypto_mutex_destroy(&g_symc_mutex);
+    drv_cipher_symc_destroy(g_drv_symc_handle);
+    drv_cipher_symc_deinit();
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+
+td_s32 kapi_cipher_symc_init(td_void)
+{
+    crypto_kapi_func_enter();
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_init);
+
+td_s32 kapi_cipher_symc_deinit(td_void)
+{
+    crypto_kapi_func_enter();
+    crypto_kapi_func_exit();
+    return TD_SUCCESS;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_deinit);
+
+td_void kapi_cipher_symc_process_release(td_void)
+{
+    unsigned int i;
+    crypto_owner owner  = {0};
+    crypto_get_owner(&owner);
+    crypto_kapi_func_enter();
+    kapi_symc_lock();
+    for (i = 0; i < crypto_array_size(g_kapi_symc_ctx_list); i++) {
+        if (g_kapi_symc_ctx_list[i] == NULL) {
+            continue;
+        }
+        if (memcmp(&(g_kapi_symc_ctx_list[i]->owner), &owner, sizeof(crypto_owner)) == 0) {
+            if (g_kapi_symc_ctx_list[i]->dma_buf != NULL) {
+                crypto_free_coherent(g_kapi_symc_ctx_list[i]->dma_buf);
+                g_kapi_symc_ctx_list[i]->dma_buf = NULL;
+            }
+            crypto_free(g_kapi_symc_ctx_list[i]);
+            g_kapi_symc_ctx_list[i] = NULL;
+        }
+    }
+
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+}
+
+td_s32 kapi_cipher_symc_create(td_handle *kapi_symc_handle, const crypto_symc_attr *symc_attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    kapi_symc_context *symc_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    ret = inner_kapi_alloc_symc_ctx(kapi_symc_handle, &symc_ctx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_alloc_symc_ctx failed\n");
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_create);
+
+td_s32 kapi_cipher_symc_destroy(td_handle kapi_symc_handle)
+{
+    int ret;
+    crypto_kapi_func_enter();
+    ret = inner_kapi_free_symc_ctx(kapi_symc_handle);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_destroy);
+
+#if defined(CONFIG_SYMC_CCM_SUPPORT) || defined(CONFIG_SYMC_GCM_SUPPORT)
+static td_s32 inner_kapi_symc_set_ctx(kapi_symc_context *symc_ctx)
+{
+    int ret;
+    crypto_symc_work_mode work_mode = symc_ctx->symc_ctrl.work_mode;
+
+    if (work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        ret = inner_drv_symc_ccm_set_ctx(g_drv_symc_handle, &symc_ctx->ccm_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_ccm_set_ctx failed, ret is 0x%x\n", ret);
+    } else if (work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        ret = inner_drv_symc_gcm_set_ctx(g_drv_symc_handle, &symc_ctx->gcm_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_gcm_set_ctx failed, ret is 0x%x\n", ret);
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+static td_s32 inner_kapi_symc_get_ctx(kapi_symc_context *symc_ctx)
+{
+    int ret;
+    crypto_symc_work_mode work_mode = symc_ctx->symc_ctrl.work_mode;
+
+    if (work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        ret = inner_drv_symc_ccm_get_ctx(g_drv_symc_handle, &symc_ctx->ccm_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_ccm_get_ctx failed, ret is 0x%x\n", ret);
+    } else if (work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        ret = inner_drv_symc_gcm_get_ctx(g_drv_symc_handle, &symc_ctx->gcm_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_drv_symc_gcm_get_ctx failed, ret is 0x%x\n", ret);
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+static td_s32 inner_kapi_symc_set_config_ex(kapi_symc_context *symc_ctx,
+    const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret;
+    symc_null_ptr_chk(symc_ctrl->param);
+
+    ret = drv_cipher_symc_attach(g_drv_symc_handle, symc_ctx->keyslot_handle);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_symc_attach failed\n");
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_UPDATE ||
+        symc_ctrl->iv_change_flag == CRYPTO_SYMC_GCM_IV_CHANGE_UPDATE) {
+        ret = inner_kapi_symc_set_ctx(symc_ctx);
+        crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_symc_set_ctx failed\n");
+    }
+
+    ret = drv_cipher_symc_set_config(g_drv_symc_handle, symc_ctrl);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_symc_set_config failed\n");
+
+    ret = inner_kapi_symc_get_ctx(symc_ctx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_symc_get_ctx failed\n");
+
+    if (symc_ctrl->iv_change_flag == CRYPTO_SYMC_CCM_IV_CHANGE_START ||
+        symc_ctrl->iv_change_flag == CRYPTO_SYMC_GCM_IV_CHANGE_START) {
+        ret = inner_drv_symc_get_iv(g_drv_symc_handle, symc_ctx->symc_ctrl.iv, sizeof(symc_ctx->symc_ctrl.iv));
+        crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_symc_get_iv failed\n");
+    }
+
+    return ret;
+}
+#else
+static td_s32 inner_kapi_symc_set_config_ex(kapi_symc_context *symc_ctx,
+    const crypto_symc_ctrl_t *symc_ctrl)
+{
+    crypto_unused(symc_ctx);
+    crypto_unused(symc_ctrl);
+    return SYMC_COMPAT_ERRNO(ERROR_UNSUPPORT);
+}
+
+static td_s32 inner_kapi_symc_set_ctx(const kapi_symc_context *symc_ctx)
+{
+    crypto_unused(symc_ctx);
+
+    return CRYPTO_SUCCESS;
+}
+
+static td_s32 inner_kapi_symc_get_ctx(kapi_symc_context *symc_ctx)
+{
+    crypto_unused(symc_ctx);
+
+    return CRYPTO_SUCCESS;
+}
+#endif
+
+td_s32 kapi_cipher_symc_set_config(td_handle kapi_symc_handle, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    int ret;
+    crypto_symc_work_mode work_mode;
+    kapi_symc_context *symc_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    symc_null_ptr_chk(symc_ctrl);
+    work_mode = symc_ctrl->work_mode;
+
+    kapi_symc_lock();
+    symc_ctx = inner_get_symc_ctx(kapi_symc_handle);
+    crypto_chk_goto_with_ret(ret, symc_ctx == NULL, exit_unlock,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed\n");
+
+    if (work_mode == CRYPTO_SYMC_WORK_MODE_CCM || work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        symc_ctx->symc_ctrl.symc_alg = symc_ctrl->symc_alg;
+        symc_ctx->symc_ctrl.work_mode = symc_ctrl->work_mode;
+        symc_ctx->symc_ctrl.symc_key_length = symc_ctrl->symc_key_length;
+        symc_ctx->symc_ctrl.symc_bit_width = symc_ctrl->symc_bit_width;
+        ret = inner_kapi_symc_set_config_ex(symc_ctx, symc_ctrl);
+        crypto_chk_goto(ret != CRYPTO_SUCCESS, exit_unlock, "inner_kapi_symc_set_config_ex failed\n");
+    } else {
+        ret = memcpy_s(&symc_ctx->symc_ctrl, sizeof(crypto_symc_ctrl_t), symc_ctrl, sizeof(crypto_symc_ctrl_t));
+        crypto_chk_goto_with_ret(ret, ret != EOK, exit_unlock,
+            SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+        symc_ctx->symc_ctrl.param = NULL;
+    }
+
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+    symc_ctx->ctr_offset = 0;
+    (void)memset_s(symc_ctx->ctr_last_block, sizeof(symc_ctx->ctr_last_block), 0, sizeof(symc_ctx->ctr_last_block));
+#endif
+    ret = CRYPTO_SUCCESS;
+exit_unlock:
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_set_config);
+
+td_s32 kapi_cipher_symc_get_config(td_handle kapi_symc_handle, crypto_symc_ctrl_t *symc_ctrl)
+{
+    crypto_unused(kapi_symc_handle);
+    crypto_unused(symc_ctrl);
+
+    return CRYPTO_SUCCESS;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_get_config);
+
+td_s32 kapi_cipher_symc_attach(td_handle kapi_symc_handle, td_handle keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    kapi_symc_context *symc_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    kapi_symc_lock();
+    symc_ctx = inner_get_symc_ctx(kapi_symc_handle);
+    crypto_chk_goto_with_ret(ret, symc_ctx == NULL, exit_unlock,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed\n");
+
+    symc_ctx->keyslot_handle = keyslot_handle;
+    symc_ctx->is_attached = TD_TRUE;
+
+exit_unlock:
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_attach);
+
+td_s32 kapi_cipher_symc_detach(td_handle kapi_symc_handle, td_handle keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    kapi_symc_context *symc_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    kapi_symc_lock();
+    symc_ctx = inner_get_symc_ctx(kapi_symc_handle);
+    crypto_chk_goto_with_ret(ret, symc_ctx == NULL, exit_unlock,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed\n");
+
+    symc_ctx->keyslot_handle = 0xFFFFFFFF;
+    symc_ctx->is_attached = TD_FALSE;
+
+exit_unlock:
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_detach);
+
+td_s32 inner_kapi_symc_crypto(kapi_symc_context *symc_ctx,
+    const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length, td_u32 crypto_type)
+{
+    td_s32 ret;
+
+    ret = drv_cipher_symc_attach(g_drv_symc_handle, symc_ctx->keyslot_handle);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_symc_attach failed\n");
+
+    if (symc_ctx->symc_ctrl.work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        symc_ctx->symc_ctrl.iv_change_flag = CRYPTO_SYMC_CCM_IV_CHANGE_FINISH;
+    } else if (symc_ctx->symc_ctrl.work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        symc_ctx->symc_ctrl.iv_change_flag = CRYPTO_SYMC_GCM_IV_CHANGE_FINISH;
+    }
+    ret = drv_cipher_symc_set_config(g_drv_symc_handle, &symc_ctx->symc_ctrl);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_symc_attach failed\n");
+
+    ret = inner_drv_symc_set_iv(g_drv_symc_handle, symc_ctx->symc_ctrl.iv, sizeof(symc_ctx->symc_ctrl.iv));
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_symc_set_iv failed\n");
+
+    ret = inner_kapi_symc_set_ctx(symc_ctx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_symc_set_ctx failed\n");
+
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+    ret = inner_drv_symc_set_ctr_block(g_drv_symc_handle, symc_ctx->ctr_last_block,
+        sizeof(symc_ctx->ctr_last_block), symc_ctx->ctr_offset);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_symc_set_ctr_block failed\n");
+#endif
+
+    if (crypto_type == CRYPTO_TYPE_ENCRYPT) {
+        ret = drv_cipher_symc_encrypt(g_drv_symc_handle, src_buf, dst_buf, length);
+    } else {
+        ret = drv_cipher_symc_decrypt(g_drv_symc_handle, src_buf, dst_buf, length);
+    }
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_cipher_symc_crypto for crypto failed\n");
+
+#if defined(CONFIG_SYMC_CTR_NON_ALIGN_SUPPORT)
+    ret = inner_drv_symc_get_ctr_block(g_drv_symc_handle, symc_ctx->ctr_last_block,
+        sizeof(symc_ctx->ctr_last_block), &symc_ctx->ctr_offset);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_symc_get_ctr_block failed\n");
+#endif
+
+    /* Update iv after crypto. */
+    ret = inner_drv_symc_get_iv(g_drv_symc_handle, symc_ctx->symc_ctrl.iv, sizeof(symc_ctx->symc_ctrl.iv));
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_drv_symc_get_iv failed\n");
+
+    ret = inner_kapi_symc_get_ctx(symc_ctx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_symc_get_ctx failed\n");
+
+    return ret;
+}
+
+static td_s32 kapi_cipher_symc_crypto(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length, td_u32 crypto_type)
+{
+    td_s32 ret;
+    kapi_symc_context *symc_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    kapi_symc_lock();
+    symc_ctx = inner_get_symc_ctx(kapi_symc_handle);
+    crypto_chk_goto_with_ret(ret, symc_ctx == NULL, exit_unlock,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed\n");
+
+    ret = inner_kapi_symc_crypto(symc_ctx, src_buf, dst_buf, length, crypto_type);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "inner_kapi_symc_crypto failed, ret is 0x%x\n", ret);
+
+    symc_ctx->processed_length += length;
+
+exit_unlock:
+    kapi_symc_unlock();
+    return ret;
+}
+
+td_s32 kapi_cipher_symc_encrypt(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    td_s32 ret;
+    crypto_kapi_func_enter();
+
+    /* Param Check. */
+    symc_null_ptr_chk(src_buf);
+    symc_null_ptr_chk(dst_buf);
+    crypto_chk_return(crypto_data_buf_check(src_buf, length) == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS),
+        "src_buf access refused\n");
+    crypto_chk_return(crypto_data_buf_check(dst_buf, length) == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS),
+        "dst_buf access refused\n");
+
+    ret = kapi_cipher_symc_crypto(kapi_symc_handle, src_buf, dst_buf, length, CRYPTO_TYPE_ENCRYPT);
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_encrypt);
+
+td_s32 kapi_cipher_symc_decrypt(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    td_s32 ret;
+    crypto_kapi_func_enter();
+
+    /* Param Check. */
+    symc_null_ptr_chk(src_buf);
+    symc_null_ptr_chk(dst_buf);
+    crypto_chk_return(crypto_data_buf_check(src_buf, length) == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS),
+        "src_buf access refused\n");
+    crypto_chk_return(crypto_data_buf_check(dst_buf, length) == TD_FALSE, SYMC_COMPAT_ERRNO(ERROR_MEMORY_ACCESS),
+        "dst_buf access refused\n");
+
+    ret = kapi_cipher_symc_crypto(kapi_symc_handle, src_buf, dst_buf, length, CRYPTO_TYPE_DECRYPT);
+
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_decrypt);
+
+#if defined(CONFIG_SYMC_CCM_SUPPORT) || defined(CONFIG_SYMC_GCM_SUPPORT)
+td_s32 inner_kapi_symc_get_tag(kapi_symc_context *symc_ctx, td_u8 *tag, td_u32 tag_len)
+{
+    td_s32 ret;
+
+    ret = drv_cipher_symc_attach(g_drv_symc_handle, symc_ctx->keyslot_handle);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_symc_attach failed\n");
+
+    ret = drv_cipher_symc_set_config(g_drv_symc_handle, &symc_ctx->symc_ctrl);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_symc_set_config failed\n");
+
+    ret = inner_kapi_symc_set_ctx(symc_ctx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_symc_set_ctx failed\n");
+
+    ret = drv_cipher_symc_get_tag(g_drv_symc_handle, tag, tag_len);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "drv_cipher_symc_get_tag failed\n");
+
+    return ret;
+}
+
+td_s32 kapi_cipher_symc_get_tag(td_handle kapi_symc_handle, td_u8 *tag, td_u32 tag_length)
+{
+    td_s32 ret;
+    kapi_symc_context *symc_ctx = TD_NULL;
+    crypto_kapi_func_enter();
+
+    symc_null_ptr_chk(tag);
+    kapi_symc_lock();
+    symc_ctx = inner_get_symc_ctx(kapi_symc_handle);
+    crypto_chk_goto_with_ret(ret, symc_ctx == NULL, exit_unlock,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed\n");
+
+    if (symc_ctx->symc_ctrl.work_mode == CRYPTO_SYMC_WORK_MODE_CCM) {
+        symc_ctx->symc_ctrl.iv_change_flag = CRYPTO_SYMC_CCM_IV_CHANGE_FINISH;
+    } else if (symc_ctx->symc_ctrl.work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        symc_ctx->symc_ctrl.iv_change_flag = CRYPTO_SYMC_GCM_IV_CHANGE_FINISH;
+    }
+
+    ret = inner_kapi_symc_get_tag(symc_ctx, tag, tag_length);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "inner_kapi_symc_get_tag failed\n");
+
+exit_unlock:
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_symc_get_tag);
+#endif
+#if defined(CONFIG_SYMC_CMAC_SUPPORT) || defined(CONFIG_SYMC_CBC_MAC_SUPPORT)
+static td_s32 inner_kapi_mac_process(kapi_symc_context *ctx, td_handle mac_handle, const td_u8 *data, td_u32 data_len);
+
+static td_s32 inner_kapi_mac_update(kapi_symc_context *symc_ctx, const crypto_buf_attr *src_buf, td_u32 length)
+{
+    td_s32 ret;
+    td_handle mac_handle;
+
+    ret = drv_cipher_mac_start(&mac_handle, &symc_ctx->mac_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_mac_start failed, ret is 0x%x\n", ret);
+
+    ret = inner_drv_mac_set_ctx(mac_handle, &symc_ctx->cmac_ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "inner_drv_mac_set_ctx failed, ret is 0x%x\n", ret);
+
+    ret = inner_kapi_mac_process(symc_ctx, mac_handle, src_buf->virt_addr, length);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "inner_kapi_mac_process failed, ret is 0x%x\n", ret);
+
+    if (symc_ctx->mac_attr.work_mode == CRYPTO_SYMC_WORK_MODE_CBC_MAC) {
+        symc_ctx->cmac_ctx.mac_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+        ret = drv_cipher_mac_finish(mac_handle, symc_ctx->cmac_ctx.mac, &symc_ctx->cmac_ctx.mac_len);
+        crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "drv_cipher_mac_finish failed, ret is 0x%x\n", ret);
+    } else {
+        ret = inner_drv_mac_get_ctx(mac_handle, &symc_ctx->cmac_ctx);
+        crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "inner_drv_mac_get_ctx failed, ret is 0x%x\n", ret);
+
+        (td_void)drv_cipher_symc_destroy(mac_handle);
+    }
+    return CRYPTO_SUCCESS;
+error_symc_destroy:
+    (td_void)drv_cipher_symc_destroy(mac_handle);
+    return ret;
+}
+
+static td_s32 inner_kapi_cmac_finish(kapi_symc_context *symc_ctx)
+{
+    td_s32 ret;
+    crypto_buf_attr src_buf;
+    td_handle mac_handle;
+
+    ret = drv_cipher_mac_start(&mac_handle, &symc_ctx->mac_attr);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_mac_start failed, ret is 0x%x\n", ret);
+
+    ret = inner_drv_mac_set_ctx(mac_handle, &symc_ctx->cmac_ctx);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "inner_drv_mac_set_ctx failed, ret is 0x%x\n", ret);
+
+    if (symc_ctx->tail_len != 0) {
+        src_buf.virt_addr = symc_ctx->dma_buf;
+        ret = memcpy_s(src_buf.virt_addr, symc_ctx->dma_buf_len, symc_ctx->tail, symc_ctx->tail_len);
+        crypto_chk_goto_with_ret(ret, ret != EOK, error_symc_destroy, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S),
+            "memcpy_s failed\n");
+
+        ret = drv_cipher_mac_update(mac_handle, &src_buf, symc_ctx->tail_len);
+        crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "drv_cipher_mac_update failed\n");
+    }
+
+    symc_ctx->cmac_ctx.mac_len = CRYPTO_AES_BLOCK_SIZE_IN_BYTES;
+    ret = drv_cipher_mac_finish(mac_handle, symc_ctx->cmac_ctx.mac, &symc_ctx->cmac_ctx.mac_len);
+    crypto_chk_goto(ret != TD_SUCCESS, error_symc_destroy, "drv_cipher_mac_update failed, ret is 0x%x\n", ret);
+
+    return ret;
+error_symc_destroy:
+    (td_void)drv_cipher_symc_destroy(mac_handle);
+    return ret;
+}
+
+static td_s32 inner_kapi_mac_finish(kapi_symc_context *symc_ctx, td_u8 *mac, td_u32 *mac_length)
+{
+    td_s32 ret;
+
+    if (symc_ctx->mac_attr.work_mode == CRYPTO_SYMC_WORK_MODE_CMAC) {
+        ret = inner_kapi_cmac_finish(symc_ctx);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "inner_kapi_cmac_finish failed\n");
+    }
+
+    ret = memcpy_s(mac, *mac_length, symc_ctx->cmac_ctx.mac, symc_ctx->cmac_ctx.mac_len);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return ret;
+}
+
+td_s32 kapi_cipher_mac_start(td_handle *kapi_symc_handle, const crypto_symc_mac_attr *mac_attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    kapi_symc_context *symc_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    symc_null_ptr_chk(kapi_symc_handle);
+    symc_null_ptr_chk(mac_attr);
+
+    ret = inner_kapi_alloc_symc_ctx(kapi_symc_handle, &symc_ctx);
+    crypto_chk_return(ret != CRYPTO_SUCCESS, ret, "inner_kapi_alloc_symc_ctx failed\n");
+
+    symc_ctx->dma_buf = crypto_malloc_mmz(CONFIG_SYMC_KAPI_DMA_BUF_LEN, "symc_dma_buf");
+    crypto_chk_goto_with_ret(ret, symc_ctx->dma_buf == TD_NULL, error_free_ctx, SYMC_COMPAT_ERRNO(ERROR_MALLOC),
+        "crypto_malloc_mmz failed\n");
+    symc_ctx->dma_buf_len = CONFIG_SYMC_KAPI_DMA_BUF_LEN;
+
+    ret = memcpy_s(&symc_ctx->mac_attr, sizeof(crypto_symc_mac_attr), mac_attr, sizeof(crypto_symc_mac_attr));
+    crypto_chk_goto_with_ret(ret, ret != EOK, error_free, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S),
+        "crypto_malloc_mmz failed\n");
+
+    crypto_kapi_func_exit();
+    return CRYPTO_SUCCESS;
+error_free:
+    crypto_free_coherent(symc_ctx->dma_buf);
+    symc_ctx->dma_buf = TD_NULL;
+error_free_ctx:
+    inner_kapi_free_symc_ctx(*kapi_symc_handle);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_mac_start);
+
+static td_s32 inner_kapi_mac_process(kapi_symc_context *ctx, td_handle mac_handle, const td_u8 *data, td_u32 data_len)
+{
+    td_s32 ret;
+    td_u8 *dma_buf = ctx->dma_buf;
+    td_u32 dma_buf_len = ctx->dma_buf_len;
+    td_u8 *tail = ctx->tail;
+    td_u32 tail_len = ctx->tail_len;
+    td_u32 block_size = sizeof(ctx->tail);
+    td_u32 processing_len = 0;
+    td_u32 processed_len = 0;
+    td_u32 left = data_len;
+    crypto_buf_attr src_buf;
+
+    src_buf.virt_addr = dma_buf;
+    if ((tail_len + data_len) < block_size) {
+        ret = memcpy_s(tail + tail_len, block_size - tail_len, data, data_len);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+        ctx->tail_len += data_len;
+        return CRYPTO_SUCCESS;
+    }
+    if (tail_len != 0) {
+        processing_len = block_size - tail_len;
+        ret = memcpy_s(tail + tail_len, processing_len, data, processing_len);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+        ret = memcpy_s(dma_buf, block_size, tail, block_size);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = drv_cipher_mac_update(mac_handle, &src_buf, block_size);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_mac_update failed\n");
+
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+    while (left >= block_size) {
+        if (left >= dma_buf_len) {
+            processing_len = dma_buf_len;
+        } else {
+            processing_len = left - left % block_size;
+        }
+        ret = memcpy_s(dma_buf, dma_buf_len, data + processed_len, processing_len);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+        ret = drv_cipher_mac_update(mac_handle, &src_buf, processing_len);
+        crypto_chk_return(ret != TD_SUCCESS, ret, "drv_cipher_mac_update failed\n");
+
+        left -= processing_len;
+        processed_len += processing_len;
+    }
+    if (left != 0) {
+        ret = memcpy_s(tail, block_size, data + processed_len, left);
+        crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    }
+    ctx->tail_len = left;
+
+    return ret;
+}
+
+td_s32 kapi_cipher_mac_update(td_handle kapi_symc_handle, const crypto_buf_attr *src_buf, td_u32 length)
+{
+    td_s32 ret;
+    kapi_symc_context *symc_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    kapi_symc_lock();
+    symc_ctx = inner_get_symc_ctx(kapi_symc_handle);
+    crypto_chk_goto_with_ret(ret, symc_ctx == NULL, exit_unlock,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed\n");
+
+    ret = inner_kapi_mac_update(symc_ctx, src_buf, length);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "inner_kapi_mac_update failed, ret is 0x%x\n", ret);
+
+exit_unlock:
+    kapi_symc_unlock();
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_mac_update);
+
+td_s32 kapi_cipher_mac_finish(td_handle kapi_symc_handle, td_u8 *mac, td_u32 *mac_length)
+{
+    td_s32 ret;
+    kapi_symc_context *symc_ctx = NULL;
+    crypto_kapi_func_enter();
+
+    symc_null_ptr_chk(mac);
+    symc_null_ptr_chk(mac_length);
+
+    crypto_chk_return(*mac_length < CRYPTO_AES_BLOCK_SIZE_IN_BYTES, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "mac_length is not enough\n");
+
+    kapi_symc_lock();
+    symc_ctx = inner_get_symc_ctx(kapi_symc_handle);
+    crypto_chk_goto_with_ret(ret, symc_ctx == NULL, exit_unlock,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_HANDLE), "inner_get_symc_ctx failed\n");
+
+    ret = inner_kapi_mac_finish(symc_ctx, mac, mac_length);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_unlock, "inner_kapi_mac_finish failed, ret is 0x%x\n", ret);
+
+    if (symc_ctx->dma_buf != TD_NULL) {
+        crypto_free_coherent(symc_ctx->dma_buf);
+        symc_ctx->dma_buf = TD_NULL;
+    }
+exit_unlock:
+    kapi_symc_unlock();
+    inner_kapi_free_symc_ctx(kapi_symc_handle);
+    crypto_kapi_func_exit();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_mac_finish);
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/kapi_code/kapi_trng.c b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_trng.c
new file mode 100644
index 0000000..b5ab3cb
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/kapi_code/kapi_trng.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "kapi_trng.h"
+#include "kapi_inner.h"
+
+#include "drv_trng.h"
+#include "crypto_drv_common.h"
+
+#define TRNG_COMPAT_ERRNO(err_code)     KAPI_COMPAT_ERRNO(ERROR_MODULE_TRNG, err_code)
+
+crypto_mutex g_trng_mutex;
+
+#define kapi_trng_mutex_lock() do {          \
+    crypto_mutex_lock(&g_trng_mutex);            \
+} while (0)
+
+#define kapi_trng_mutex_unlock() do {        \
+    crypto_mutex_unlock(&g_trng_mutex);          \
+} while (0)
+
+td_s32 kapi_cipher_trng_env_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    ret = drv_cipher_trng_init();
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("drv_cipher_trng_init failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    ret = crypto_mutex_init(&g_trng_mutex);
+    if (ret != TD_SUCCESS) {
+        crypto_log_err("crypto_mutex_init failed\n");
+        goto error_trng_deinit;
+    }
+
+error_trng_deinit:
+    return ret;
+}
+
+td_s32 kapi_cipher_trng_env_deinit(td_void)
+{
+    crypto_mutex_destroy(&g_trng_mutex);
+    drv_cipher_trng_deinit();
+    return TD_SUCCESS;
+}
+
+td_void inner_kapi_trng_lock(td_void)
+{
+    kapi_trng_mutex_lock();
+}
+
+td_void inner_kapi_trng_unlock(td_void)
+{
+    kapi_trng_mutex_unlock();
+}
+
+td_s32 kapi_cipher_trng_get_random(td_u32 *randnum)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_chk_return(randnum == TD_NULL, TRNG_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "randnum is NULL\n");
+    inner_kapi_trng_lock();
+    ret = drv_cipher_trng_get_random(randnum);
+    inner_kapi_trng_unlock();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_trng_get_random);
+
+td_s32 kapi_cipher_trng_get_multi_random(td_u32 size, td_u8 *randnum)
+{
+    td_s32 ret = TD_FAILURE;
+    crypto_chk_return(randnum == TD_NULL, TRNG_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "randnum is NULL\n");
+    inner_kapi_trng_lock();
+    ret = drv_cipher_trng_get_multi_random(size, randnum);
+    inner_kapi_trng_unlock();
+    return ret;
+}
+CRYPTO_EXPORT_SYMBOL(kapi_cipher_trng_get_multi_random);
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/linux/ot_mpi_utils.h b/bsp/security_subsys/security_subsys_common/ot_mpi/linux/ot_mpi_utils.h
new file mode 100644
index 0000000..c0a01af
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/linux/ot_mpi_utils.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef OT_MPI_UTILS
+#define OT_MPI_UTILS
+
+#include "uapi_hash.h"
+#include "uapi_kdf.h"
+#include "uapi_km.h"
+#include "uapi_otp.h"
+#include "uapi_pke.h"
+#include "uapi_symc.h"
+#include "uapi_trng.h"
+#include "crypto_osal_user_lib.h"
+// hash
+#define UNIFY_MPI_HASH_INIT     unify_uapi_cipher_hash_init
+#define UNIFY_MPI_HASH_DEINIT   unify_uapi_cipher_hash_deinit
+#define UNIFY_MPI_HASH_START    unify_uapi_cipher_hash_start
+#define UNIFY_MPI_HASH_UPDATE   unify_uapi_cipher_hash_update
+#define UNIFY_MPI_HASH_FINISH   unify_uapi_cipher_hash_finish
+#define UNIFY_MPI_HASH_GET      unify_uapi_cipher_hash_get
+#define UNIFY_MPI_HASH_SET      unify_uapi_cipher_hash_set
+#define UNIFY_MPI_HASH_DESTROY  unify_uapi_cipher_hash_destroy
+// pbkdf2
+#define UNIFY_MPI_PBKDF2        unify_uapi_cipher_pbkdf2
+// km
+#define UNIFY_MPI_KM_INIT                uapi_km_init
+#define UNIFY_MPI_KM_DEINIT              uapi_km_deinit
+#define UNIFY_MPI_KEYSLOT_CREATE         uapi_keyslot_create
+#define UNIFY_MPI_KEYSLOT_DESTROY        uapi_keyslot_destroy
+#define UNIFY_MPI_KLAD_CREATE            uapi_klad_create
+#define UNIFY_MPI_KLAD_DESTROY           uapi_klad_destroy
+#define UNIFY_MPI_KLAD_ATTACH            uapi_klad_attach
+#define UNIFY_MPI_KLAD_DETACH            uapi_klad_detach
+#define UNIFY_MPI_SET_ATTR               uapi_klad_set_attr
+#define UNIFY_MPI_GET_ATTR               uapi_klad_get_attr
+#define UNIFY_MPI_SESSION_KEY            uapi_klad_set_session_key
+#define UNIFY_MPI_CONTENT_KEY            uapi_klad_set_content_key
+#define UNIFY_MPI_CLEAR_KEY              uapi_klad_set_clear_key
+#define UNIFY_MPI_EFFECTIVE_KEY          uapi_klad_set_effective_key
+// otp
+#define UNIFY_MPI_OTP_INIT                uapi_otp_init
+#define UNIFY_MPI_OTP_DEINIT              uapi_otp_deinit
+#define UNIFY_MPI_OTP_READ_WORD           uapi_otp_read_word
+#define UNIFY_MPI_OTP_READ_BYTE           uapi_otp_read_byte
+#define UNIFY_MPI_OTP_WRITE_BYTE          uapi_otp_write_byte
+// pke
+#define UNIFY_MPI_PKE_INIT              unify_uapi_cipher_pke_init
+#define UNIFY_MPI_PKE_DEINIT            unify_uapi_cipher_pke_deinit
+#define UNIFY_MPI_ECC_GEN_KEY           unify_uapi_cipher_pke_ecc_gen_key
+#define UNIFY_MPI_ECDH_GEN_KEY          unify_uapi_cipher_pke_ecc_gen_ecdh_key
+#define UNIFY_MPI_ECDSA_SIGN            unify_uapi_cipher_pke_ecdsa_sign
+#define UNIFY_MPI_ECDSA_VERIFY          unify_uapi_cipher_pke_ecdsa_verify
+#define UNIFY_MPI_EDDSA_SIGN            unify_uapi_cipher_pke_eddsa_sign
+#define UNIFY_MPI_EDDSA_VERIFY          unify_uapi_cipher_pke_eddsa_verify
+#define UNIFY_MPI_CHCEK_DOT_ON_CURVE    unify_uapi_cipher_pke_check_dot_on_curve
+#define UNIFY_MPI_SM2_DSA_HASH          unify_uapi_cipher_pke_sm2_dsa_hash
+#define UNIFY_MPI_SM2_PUB_ENCRYPT       unify_uapi_cipher_pke_sm2_public_encrypt
+#define UNIFY_MPI_SM2_PRIV_DECRYPT      unify_uapi_cipher_pke_sm2_private_decrypt
+#define UNIFY_MPI_RSA_SIGN              unify_uapi_cipher_pke_rsa_sign
+#define UNIFY_MPI_RSA_VERIFY            unify_uapi_cipher_pke_rsa_verify
+#define UNIFY_MPI_RSA_PUB_ENCRYPT       unify_uapi_cipher_pke_rsa_public_encrypt
+#define UNIFY_MPI_RSA_PRIV_DECRYPT      unify_uapi_cipher_pke_rsa_private_decrypt
+// symc
+#define UNIFY_MPI_SYMC_INIT              unify_uapi_cipher_symc_init
+#define UNIFY_MPI_SYMC_DEINIT            unify_uapi_cipher_symc_deinit
+#define UNIFY_MPI_SYMC_CREATE            unify_uapi_cipher_symc_create
+#define UNIFY_MPI_SYMC_DESTROY           unify_uapi_cipher_symc_destroy
+#define UNIFY_MPI_SYMC_SET_CONFIG        unify_uapi_cipher_symc_set_config
+#define UNIFY_MPI_SYMC_ATTACH            unify_uapi_cipher_symc_attach
+#define UNIFY_MPI_SYMC_ENCRYPT           unify_uapi_cipher_symc_encrypt
+#define UNIFY_MPI_SYMC_DECRYPT           unify_uapi_cipher_symc_decrypt
+#define UNIFY_MPI_SYMC_GET_TAG           unify_uapi_cipher_symc_get_tag
+#define UNIFY_MPI_MAC_START              unify_uapi_cipher_mac_start
+#define UNIFY_MPI_MAC_UPDATE             unify_uapi_cipher_mac_update
+#define UNIFY_MPI_MAC_FINISH             unify_uapi_cipher_mac_finish
+#define UNIFY_MPI_SYMC_MULTI_ENCRYPT     unify_uapi_cipher_symc_encrypt_multi
+#define UNIFY_MPI_SYMC_MULTI_DECRYPT     unify_uapi_cipher_symc_decrypt_multi
+// trng
+#define UNIFY_MPI_TRNG_RANDOM            unify_uapi_cipher_trng_get_random
+#define UNIFY_MPI_TRNG_MULTI_RANDOM      unify_uapi_cipher_trng_get_multi_random
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/optee/ot_mpi_utils.h b/bsp/security_subsys/security_subsys_common/ot_mpi/optee/ot_mpi_utils.h
new file mode 100644
index 0000000..c0a01af
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/optee/ot_mpi_utils.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef OT_MPI_UTILS
+#define OT_MPI_UTILS
+
+#include "uapi_hash.h"
+#include "uapi_kdf.h"
+#include "uapi_km.h"
+#include "uapi_otp.h"
+#include "uapi_pke.h"
+#include "uapi_symc.h"
+#include "uapi_trng.h"
+#include "crypto_osal_user_lib.h"
+// hash
+#define UNIFY_MPI_HASH_INIT     unify_uapi_cipher_hash_init
+#define UNIFY_MPI_HASH_DEINIT   unify_uapi_cipher_hash_deinit
+#define UNIFY_MPI_HASH_START    unify_uapi_cipher_hash_start
+#define UNIFY_MPI_HASH_UPDATE   unify_uapi_cipher_hash_update
+#define UNIFY_MPI_HASH_FINISH   unify_uapi_cipher_hash_finish
+#define UNIFY_MPI_HASH_GET      unify_uapi_cipher_hash_get
+#define UNIFY_MPI_HASH_SET      unify_uapi_cipher_hash_set
+#define UNIFY_MPI_HASH_DESTROY  unify_uapi_cipher_hash_destroy
+// pbkdf2
+#define UNIFY_MPI_PBKDF2        unify_uapi_cipher_pbkdf2
+// km
+#define UNIFY_MPI_KM_INIT                uapi_km_init
+#define UNIFY_MPI_KM_DEINIT              uapi_km_deinit
+#define UNIFY_MPI_KEYSLOT_CREATE         uapi_keyslot_create
+#define UNIFY_MPI_KEYSLOT_DESTROY        uapi_keyslot_destroy
+#define UNIFY_MPI_KLAD_CREATE            uapi_klad_create
+#define UNIFY_MPI_KLAD_DESTROY           uapi_klad_destroy
+#define UNIFY_MPI_KLAD_ATTACH            uapi_klad_attach
+#define UNIFY_MPI_KLAD_DETACH            uapi_klad_detach
+#define UNIFY_MPI_SET_ATTR               uapi_klad_set_attr
+#define UNIFY_MPI_GET_ATTR               uapi_klad_get_attr
+#define UNIFY_MPI_SESSION_KEY            uapi_klad_set_session_key
+#define UNIFY_MPI_CONTENT_KEY            uapi_klad_set_content_key
+#define UNIFY_MPI_CLEAR_KEY              uapi_klad_set_clear_key
+#define UNIFY_MPI_EFFECTIVE_KEY          uapi_klad_set_effective_key
+// otp
+#define UNIFY_MPI_OTP_INIT                uapi_otp_init
+#define UNIFY_MPI_OTP_DEINIT              uapi_otp_deinit
+#define UNIFY_MPI_OTP_READ_WORD           uapi_otp_read_word
+#define UNIFY_MPI_OTP_READ_BYTE           uapi_otp_read_byte
+#define UNIFY_MPI_OTP_WRITE_BYTE          uapi_otp_write_byte
+// pke
+#define UNIFY_MPI_PKE_INIT              unify_uapi_cipher_pke_init
+#define UNIFY_MPI_PKE_DEINIT            unify_uapi_cipher_pke_deinit
+#define UNIFY_MPI_ECC_GEN_KEY           unify_uapi_cipher_pke_ecc_gen_key
+#define UNIFY_MPI_ECDH_GEN_KEY          unify_uapi_cipher_pke_ecc_gen_ecdh_key
+#define UNIFY_MPI_ECDSA_SIGN            unify_uapi_cipher_pke_ecdsa_sign
+#define UNIFY_MPI_ECDSA_VERIFY          unify_uapi_cipher_pke_ecdsa_verify
+#define UNIFY_MPI_EDDSA_SIGN            unify_uapi_cipher_pke_eddsa_sign
+#define UNIFY_MPI_EDDSA_VERIFY          unify_uapi_cipher_pke_eddsa_verify
+#define UNIFY_MPI_CHCEK_DOT_ON_CURVE    unify_uapi_cipher_pke_check_dot_on_curve
+#define UNIFY_MPI_SM2_DSA_HASH          unify_uapi_cipher_pke_sm2_dsa_hash
+#define UNIFY_MPI_SM2_PUB_ENCRYPT       unify_uapi_cipher_pke_sm2_public_encrypt
+#define UNIFY_MPI_SM2_PRIV_DECRYPT      unify_uapi_cipher_pke_sm2_private_decrypt
+#define UNIFY_MPI_RSA_SIGN              unify_uapi_cipher_pke_rsa_sign
+#define UNIFY_MPI_RSA_VERIFY            unify_uapi_cipher_pke_rsa_verify
+#define UNIFY_MPI_RSA_PUB_ENCRYPT       unify_uapi_cipher_pke_rsa_public_encrypt
+#define UNIFY_MPI_RSA_PRIV_DECRYPT      unify_uapi_cipher_pke_rsa_private_decrypt
+// symc
+#define UNIFY_MPI_SYMC_INIT              unify_uapi_cipher_symc_init
+#define UNIFY_MPI_SYMC_DEINIT            unify_uapi_cipher_symc_deinit
+#define UNIFY_MPI_SYMC_CREATE            unify_uapi_cipher_symc_create
+#define UNIFY_MPI_SYMC_DESTROY           unify_uapi_cipher_symc_destroy
+#define UNIFY_MPI_SYMC_SET_CONFIG        unify_uapi_cipher_symc_set_config
+#define UNIFY_MPI_SYMC_ATTACH            unify_uapi_cipher_symc_attach
+#define UNIFY_MPI_SYMC_ENCRYPT           unify_uapi_cipher_symc_encrypt
+#define UNIFY_MPI_SYMC_DECRYPT           unify_uapi_cipher_symc_decrypt
+#define UNIFY_MPI_SYMC_GET_TAG           unify_uapi_cipher_symc_get_tag
+#define UNIFY_MPI_MAC_START              unify_uapi_cipher_mac_start
+#define UNIFY_MPI_MAC_UPDATE             unify_uapi_cipher_mac_update
+#define UNIFY_MPI_MAC_FINISH             unify_uapi_cipher_mac_finish
+#define UNIFY_MPI_SYMC_MULTI_ENCRYPT     unify_uapi_cipher_symc_encrypt_multi
+#define UNIFY_MPI_SYMC_MULTI_DECRYPT     unify_uapi_cipher_symc_decrypt_multi
+// trng
+#define UNIFY_MPI_TRNG_RANDOM            unify_uapi_cipher_trng_get_random
+#define UNIFY_MPI_TRNG_MULTI_RANDOM      unify_uapi_cipher_trng_get_multi_random
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_hash.c b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_hash.c
new file mode 100644
index 0000000..cb6d977
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_hash.c
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "ot_mpi_cipher.h"
+#include "ot_mpi_utils.h"
+
+td_s32 ot_mpi_cipher_hash_init(td_void)
+{
+    return UNIFY_MPI_HASH_INIT();
+}
+
+td_s32 ot_mpi_cipher_hash_deinit(td_void)
+{
+    return UNIFY_MPI_HASH_DEINIT();
+}
+
+td_s32 ot_mpi_cipher_hash_create(td_handle *mpi_hash_handle, const crypto_hash_attr *hash_attr)
+{
+    return UNIFY_MPI_HASH_START(mpi_hash_handle, hash_attr);
+}
+
+td_s32 ot_mpi_cipher_hash_update(td_handle mpi_hash_handle, const crypto_buf_attr *src_buf, const td_u32 len)
+{
+    return UNIFY_MPI_HASH_UPDATE(mpi_hash_handle, src_buf, len);
+}
+
+td_s32 ot_mpi_cipher_hash_finish(td_handle mpi_hash_handle, td_u8 *virt_addr, td_u32 buffer_len, td_u32 *result_len)
+{
+    td_s32 ret;
+
+    crypto_chk_return_only(result_len == NULL, UAPI_COMPAT_ERRNO(ERROR_MODULE_HASH, ERROR_PARAM_IS_NULL));
+    *result_len = buffer_len;
+    ret = UNIFY_MPI_HASH_FINISH(mpi_hash_handle, virt_addr, result_len);
+    return ret;
+}
+
+td_s32 ot_mpi_cipher_hash_get(td_handle mpi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx)
+{
+    return UNIFY_MPI_HASH_GET(mpi_hash_handle, hash_clone_ctx);
+}
+
+td_s32 ot_mpi_cipher_hash_set(td_handle mpi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx)
+{
+    return UNIFY_MPI_HASH_SET(mpi_hash_handle, hash_clone_ctx);
+}
+
+td_s32 ot_mpi_cipher_hash_destroy(td_handle mpi_hash_handle)
+{
+    return UNIFY_MPI_HASH_DESTROY(mpi_hash_handle);
+}
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_kdf.c b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_kdf.c
new file mode 100644
index 0000000..c40d453
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_kdf.c
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "ot_mpi_cipher.h"
+#include "ot_mpi_utils.h"
+
+td_s32 ot_mpi_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len)
+{
+    return UNIFY_MPI_PBKDF2(param, out, out_len);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_km.c b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_km.c
new file mode 100644
index 0000000..b3bef67
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_km.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "ot_mpi_km.h"
+#include "ot_mpi_utils.h"
+#include "crypto_km_struct.h"
+#include "securec.h"
+
+/* Init */
+td_s32 ot_mpi_km_init(td_void)
+{
+    return UNIFY_MPI_KM_INIT();
+}
+
+td_s32 ot_mpi_km_deinit(td_void)
+{
+    return UNIFY_MPI_KM_DEINIT();
+}
+
+/* Keyslot. */
+td_s32 ot_mpi_keyslot_create(td_handle *mpi_keyslot_handle, km_keyslot_type keyslot_type)
+{
+    return UNIFY_MPI_KEYSLOT_CREATE(mpi_keyslot_handle, (crypto_keyslot_type)keyslot_type);
+}
+
+td_s32 ot_mpi_keyslot_destroy(td_handle mpi_keyslot_handle)
+{
+    return UNIFY_MPI_KEYSLOT_DESTROY(mpi_keyslot_handle);
+}
+
+/* Klad. */
+td_s32 ot_mpi_klad_create(td_handle *mpi_klad_handle)
+{
+    return UNIFY_MPI_KLAD_CREATE(mpi_klad_handle);
+}
+
+td_s32 ot_mpi_klad_destroy(td_handle mpi_klad_handle)
+{
+    return UNIFY_MPI_KLAD_DESTROY(mpi_klad_handle);
+}
+
+td_s32 ot_mpi_klad_attach(td_handle mpi_klad_handle, km_klad_dest_type klad_type,
+    td_handle mpi_keyslot_handle)
+{
+    return UNIFY_MPI_KLAD_ATTACH(mpi_klad_handle, (crypto_klad_dest)klad_type, mpi_keyslot_handle);
+}
+
+td_s32 ot_mpi_klad_detach(td_handle mpi_klad_handle, km_klad_dest_type klad_type,
+    td_handle mpi_keyslot_handle)
+{
+    return UNIFY_MPI_KLAD_DETACH(mpi_klad_handle, (crypto_klad_dest)klad_type, mpi_keyslot_handle);
+}
+
+td_s32 ot_mpi_klad_set_attr(td_handle mpi_klad_handle, const km_klad_attr *attr)
+{
+    return UNIFY_MPI_SET_ATTR(mpi_klad_handle, (const crypto_klad_attr *)attr);
+}
+
+td_s32 ot_mpi_klad_get_attr(td_handle mpi_klad_handle, km_klad_attr *attr)
+{
+    return UNIFY_MPI_GET_ATTR(mpi_klad_handle, (crypto_klad_attr *)attr);
+}
+
+td_s32 ot_mpi_klad_set_session_key(td_handle mpi_klad_handle, const km_klad_session_key *key)
+{
+    int ret;
+    crypto_klad_session_key tmp_key;
+    if (key == NULL || key->key == NULL) {
+        return ERROR_PARAM_IS_NULL;
+    }
+    tmp_key.level = (crypto_klad_level_sel)key->level;
+    tmp_key.alg = (crypto_klad_alg_sel)key->alg;
+    tmp_key.key_length = key->key_size;
+    ret = memcpy_s(tmp_key.key, sizeof(tmp_key.key), key->key, key->key_size);
+    crypto_chk_return(ret != EOK, ERROR_MEMCPY_S, "memcpy_s failed\n");
+
+    ret = UNIFY_MPI_SESSION_KEY(mpi_klad_handle, &tmp_key);
+    (void)memset_s(&tmp_key, sizeof(crypto_klad_session_key), 0, sizeof(crypto_klad_session_key));
+
+    return ret;
+}
+
+td_s32 ot_mpi_klad_set_content_key(td_handle mpi_klad_handle, const km_klad_content_key *key)
+{
+    int ret;
+    crypto_klad_content_key tmp_key;
+    if (key == NULL || key->key == NULL) {
+        return ERROR_PARAM_IS_NULL;
+    }
+    tmp_key.alg = (crypto_klad_alg_sel)key->alg;
+    tmp_key.key_length = key->key_size;
+    tmp_key.key_parity = (td_bool)key->key_parity;
+    ret = memcpy_s(tmp_key.key, sizeof(tmp_key.key), key->key, key->key_size);
+    crypto_chk_return(ret != EOK, ERROR_MEMCPY_S, "memcpy_s failed\n");
+
+    ret = UNIFY_MPI_CONTENT_KEY(mpi_klad_handle, &tmp_key);
+    (void)memset_s(&tmp_key, sizeof(crypto_klad_content_key), 0, sizeof(crypto_klad_content_key));
+
+    return ret;
+}
+
+td_s32 ot_mpi_klad_set_clear_key(td_handle mpi_klad_handle, const km_klad_clear_key *key)
+{
+    return UNIFY_MPI_CLEAR_KEY(mpi_klad_handle, (const crypto_klad_clear_key *)key);
+}
+
+td_s32 ot_mpi_klad_set_effective_key(td_handle mpi_klad_handle, const km_klad_effective_key *key)
+{
+    return UNIFY_MPI_EFFECTIVE_KEY(mpi_klad_handle, (const crypto_klad_effective_key *)key);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_otp.c b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_otp.c
new file mode 100644
index 0000000..6ba2928
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_otp.c
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "ot_mpi_otp.h"
+#include "ot_mpi_utils.h"
+
+td_s32 ot_mpi_otp_init(td_void)
+{
+    return UNIFY_MPI_OTP_INIT();
+}
+
+td_s32 ot_mpi_otp_deinit(td_void)
+{
+    return UNIFY_MPI_OTP_DEINIT();
+}
+
+td_s32 ot_mpi_otp_read_word(td_u32 offset, td_u32 *data)
+{
+    return UNIFY_MPI_OTP_READ_WORD(offset, data);
+}
+
+td_s32 ot_mpi_otp_read_byte(td_u32 offset, td_u8 *data)
+{
+    return UNIFY_MPI_OTP_READ_BYTE(offset, data);
+}
+
+td_s32 ot_mpi_otp_write_byte(td_u32 offset, td_u8 data)
+{
+    return UNIFY_MPI_OTP_WRITE_BYTE(offset, data);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_pke.c b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_pke.c
new file mode 100644
index 0000000..5d9b5b9
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_pke.c
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "ot_mpi_cipher.h"
+#include "ot_mpi_utils.h"
+
+td_s32 ot_mpi_cipher_pke_init(td_void)
+{
+    return UNIFY_MPI_PKE_INIT();
+}
+
+td_s32 ot_mpi_cipher_pke_deinit(td_void)
+{
+    return UNIFY_MPI_PKE_DEINIT();
+}
+
+td_s32 ot_mpi_cipher_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key)
+{
+    return UNIFY_MPI_ECC_GEN_KEY(curve_type, input_priv_key, output_priv_key, output_pub_key);
+}
+
+td_s32 ot_mpi_cipher_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key)
+{
+    return UNIFY_MPI_ECDH_GEN_KEY(curve_type, input_pub_key, input_priv_key, output_shared_key);
+}
+
+td_s32 ot_mpi_cipher_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    return UNIFY_MPI_ECDSA_SIGN(curve_type, priv_key, hash, sig);
+}
+
+td_s32 ot_mpi_cipher_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    return UNIFY_MPI_ECDSA_VERIFY(curve_type, pub_key, hash, sig);
+}
+
+td_s32 ot_mpi_cipher_pke_eddsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig)
+{
+    return UNIFY_MPI_EDDSA_SIGN(curve_type, priv_key, msg, sig);
+}
+
+td_s32 ot_mpi_cipher_pke_eddsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig)
+{
+    return UNIFY_MPI_EDDSA_VERIFY(curve_type, pub_key, msg, sig);
+}
+
+td_s32 ot_mpi_cipher_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve)
+{
+    return UNIFY_MPI_CHCEK_DOT_ON_CURVE(curve_type, pub_key, is_on_curve);
+}
+
+td_s32 ot_mpi_cipher_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash)
+{
+    return UNIFY_MPI_SM2_DSA_HASH(sm2_id, pub_key, msg, hash);
+}
+
+td_s32 ot_mpi_cipher_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text)
+{
+    return UNIFY_MPI_SM2_PUB_ENCRYPT(pub_key, plain_text, cipher_text);
+}
+
+
+td_s32 ot_mpi_cipher_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text)
+{
+    return UNIFY_MPI_SM2_PRIV_DECRYPT(priv_key, cipher_text, plain_text);
+}
+
+/* RSA. */
+td_s32 ot_mpi_cipher_pke_rsa_sign(const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign)
+{
+    return UNIFY_MPI_RSA_SIGN(priv_key, scheme, hash_type, input_hash, sign);
+}
+
+td_s32 ot_mpi_cipher_pke_rsa_verify(const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, drv_pke_data *input_hash, const drv_pke_data *sig)
+{
+    return UNIFY_MPI_RSA_VERIFY(pub_key, scheme, hash_type, input_hash, sig);
+}
+
+td_s32 ot_mpi_cipher_pke_rsa_public_encrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    return UNIFY_MPI_RSA_PUB_ENCRYPT(scheme, hash_type, pub_key, input, label, output);
+}
+
+td_s32 ot_mpi_cipher_pke_rsa_private_decrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    return UNIFY_MPI_RSA_PRIV_DECRYPT(scheme, hash_type, priv_key, input, label, output);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_symc.c b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_symc.c
new file mode 100644
index 0000000..2cc0a65
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_symc.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "ot_mpi_cipher.h"
+#include "ot_mpi_utils.h"
+
+td_s32 ot_mpi_cipher_symc_init(td_void)
+{
+    return UNIFY_MPI_SYMC_INIT();
+}
+
+td_s32 ot_mpi_cipher_symc_deinit(td_void)
+{
+    return UNIFY_MPI_SYMC_DEINIT();
+}
+
+td_s32 ot_mpi_cipher_symc_create(td_handle *symc_handle, const crypto_symc_attr *symc_attr)
+{
+    return UNIFY_MPI_SYMC_CREATE(symc_handle, symc_attr);
+}
+
+td_s32 ot_mpi_cipher_symc_destroy(td_handle symc_handle)
+{
+    return UNIFY_MPI_SYMC_DESTROY(symc_handle);
+}
+
+td_s32 ot_mpi_cipher_symc_set_config(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    return UNIFY_MPI_SYMC_SET_CONFIG(symc_handle, symc_ctrl);
+}
+
+td_s32 ot_mpi_cipher_symc_attach(td_handle symc_handle, td_handle keyslot_handle)
+{
+    return UNIFY_MPI_SYMC_ATTACH(symc_handle, keyslot_handle);
+}
+
+td_s32 ot_mpi_cipher_symc_encrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    return UNIFY_MPI_SYMC_ENCRYPT(symc_handle, src_buf, dst_buf, length);
+}
+
+td_s32 ot_mpi_cipher_symc_decrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    return UNIFY_MPI_SYMC_DECRYPT(symc_handle, src_buf, dst_buf, length);
+}
+
+td_s32 ot_mpi_cipher_symc_get_tag(td_handle symc_handle, td_u8 *tag, td_u32 tag_length)
+{
+    return UNIFY_MPI_SYMC_GET_TAG(symc_handle, tag, tag_length);
+}
+
+td_s32 ot_mpi_cipher_mac_start(td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr)
+{
+    return UNIFY_MPI_MAC_START(symc_handle, mac_attr);
+}
+
+td_s32 ot_mpi_cipher_mac_update(td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length)
+{
+    return UNIFY_MPI_MAC_UPDATE(symc_handle, src_buf, length);
+}
+
+td_s32 ot_mpi_cipher_mac_finish(td_handle symc_handle, td_u8 *mac, td_u32 *mac_length)
+{
+    return UNIFY_MPI_MAC_FINISH(symc_handle, mac, mac_length);
+}
+
+td_s32 ot_mpi_cipher_symc_encrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num)
+{
+    return UNIFY_MPI_SYMC_MULTI_ENCRYPT(symc_handle, symc_ctrl, src_buf_pack, dst_buf_pack, pack_num);
+}
+
+td_s32 ot_mpi_cipher_symc_decrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num)
+{
+    return UNIFY_MPI_SYMC_MULTI_DECRYPT(symc_handle, symc_ctrl, src_buf_pack, dst_buf_pack, pack_num);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_trng.c b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_trng.c
new file mode 100644
index 0000000..6e15f42
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi/ot_mpi_trng.c
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "ot_mpi_cipher.h"
+#include "ot_mpi_utils.h"
+
+td_s32 ot_mpi_cipher_trng_get_random(td_u32 *randnum)
+{
+    return UNIFY_MPI_TRNG_RANDOM(randnum);
+}
+
+td_s32 ot_mpi_cipher_trng_get_multi_random(td_u32 size, td_u8 *randnum)
+{
+    return UNIFY_MPI_TRNG_MULTI_RANDOM(size, randnum);
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_cipher.h b/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_cipher.h
new file mode 100644
index 0000000..1395df6
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_cipher.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef OT_MPI_CIPHER_H
+#define OT_MPI_CIPHER_H
+
+#include "crypto_type.h"
+#include "crypto_hash_struct.h"
+#include "crypto_kdf_struct.h"
+#include "crypto_pke_struct.h"
+#include "crypto_symc_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+/* HASH */
+td_s32 ot_mpi_cipher_hash_init(td_void);
+
+td_s32 ot_mpi_cipher_hash_deinit(td_void);
+
+td_s32 ot_mpi_cipher_hash_create(td_handle *mpi_hash_handle, const crypto_hash_attr *hash_attr);
+
+td_s32 ot_mpi_cipher_hash_update(td_handle mpi_hash_handle, const crypto_buf_attr *src_buf, const td_u32 len);
+
+td_s32 ot_mpi_cipher_hash_finish(td_handle mpi_hash_handle, td_u8 *virt_addr, td_u32 buffer_len, td_u32 *result_len);
+
+td_s32 ot_mpi_cipher_hash_get(td_handle mpi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx);
+
+td_s32 ot_mpi_cipher_hash_set(td_handle mpi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx);
+
+td_s32 ot_mpi_cipher_hash_destroy(td_handle mpi_hash_handle);
+
+/* PBKDF2 */
+td_s32 ot_mpi_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len);
+
+/* PKE */
+td_s32 ot_mpi_cipher_pke_init(td_void);
+
+td_s32 ot_mpi_cipher_pke_deinit(td_void);
+
+td_s32 ot_mpi_cipher_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key);
+
+td_s32 ot_mpi_cipher_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key);
+
+td_s32 ot_mpi_cipher_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 ot_mpi_cipher_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig);
+
+td_s32 ot_mpi_cipher_pke_eddsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 ot_mpi_cipher_pke_eddsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig);
+
+td_s32 ot_mpi_cipher_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve);
+
+td_s32 ot_mpi_cipher_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash);
+
+td_s32 ot_mpi_cipher_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text);
+
+td_s32 ot_mpi_cipher_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text);
+
+td_s32 ot_mpi_cipher_pke_rsa_sign(const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign);
+
+td_s32 ot_mpi_cipher_pke_rsa_verify(const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, drv_pke_data *input_hash, const drv_pke_data *sig);
+
+td_s32 ot_mpi_cipher_pke_rsa_public_encrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+td_s32 ot_mpi_cipher_pke_rsa_private_decrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output);
+
+/* SYMC */
+td_s32 ot_mpi_cipher_symc_init(td_void);
+
+td_s32 ot_mpi_cipher_symc_deinit(td_void);
+
+td_s32 ot_mpi_cipher_symc_create(td_handle *symc_handle, const crypto_symc_attr *symc_attr);
+
+td_s32 ot_mpi_cipher_symc_destroy(td_handle symc_handle);
+
+td_s32 ot_mpi_cipher_symc_set_config(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl);
+
+td_s32 ot_mpi_cipher_symc_attach(td_handle symc_handle, td_handle keyslot_handle);
+
+td_s32 ot_mpi_cipher_symc_encrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 ot_mpi_cipher_symc_decrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length);
+
+td_s32 ot_mpi_cipher_symc_encrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num);
+
+td_s32 ot_mpi_cipher_symc_decrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num);
+
+td_s32 ot_mpi_cipher_symc_get_tag(td_handle symc_handle, td_u8 *tag, td_u32 tag_length);
+
+td_s32 ot_mpi_cipher_mac_start(td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr);
+
+td_s32 ot_mpi_cipher_mac_update(td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length);
+
+td_s32 ot_mpi_cipher_mac_finish(td_handle symc_handle, td_u8 *mac, td_u32 *mac_length);
+
+/* TRNG */
+td_s32 ot_mpi_cipher_trng_get_random(td_u32 *randnum);
+
+td_s32 ot_mpi_cipher_trng_get_multi_random(td_u32 size, td_u8 *randnum);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_km.h b/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_km.h
new file mode 100644
index 0000000..2399501
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_km.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef OT_MPI_KM_H
+#define OT_MPI_KM_H
+
+#include "crypto_km_struct.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 ot_mpi_km_init(td_void);
+td_s32 ot_mpi_km_deinit(td_void);
+
+/* Keyslot. */
+td_s32 ot_mpi_keyslot_create(crypto_handle *mpi_keyslot_handle, km_keyslot_type keyslot_type);
+td_s32 ot_mpi_keyslot_destroy(crypto_handle mpi_keyslot_handle);
+
+/* Klad. */
+td_s32 ot_mpi_klad_create(crypto_handle *mpi_klad_handle);
+td_s32 ot_mpi_klad_destroy(crypto_handle mpi_klad_handle);
+
+td_s32 ot_mpi_klad_attach(crypto_handle mpi_klad_handle, km_klad_dest_type klad_type,
+    crypto_handle mpi_keyslot_handle);
+td_s32 ot_mpi_klad_detach(crypto_handle mpi_klad_handle, km_klad_dest_type klad_type,
+    crypto_handle mpi_keyslot_handle);
+
+td_s32 ot_mpi_klad_set_attr(crypto_handle mpi_klad_handle, const km_klad_attr *attr);
+td_s32 ot_mpi_klad_get_attr(crypto_handle mpi_klad_handle, km_klad_attr *attr);
+
+td_s32 ot_mpi_klad_set_session_key(crypto_handle mpi_klad_handle, const km_klad_session_key *key);
+td_s32 ot_mpi_klad_set_content_key(crypto_handle mpi_klad_handle, const km_klad_content_key *key);
+
+td_s32 ot_mpi_klad_set_clear_key(crypto_handle mpi_klad_handle, const km_klad_clear_key *key);
+td_s32 ot_mpi_klad_set_effective_key(crypto_handle mpi_klad_handle, const km_klad_effective_key *key);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_otp.h b/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_otp.h
new file mode 100644
index 0000000..95e8007
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/ot_mpi_api/ot_mpi_otp.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef OT_MPI_OTP_H
+#define OT_MPI_OTP_H
+
+#include "ot_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_s32 ot_mpi_otp_init(td_void);
+
+td_s32 ot_mpi_otp_deinit(td_void);
+
+td_s32 ot_mpi_otp_read_word(td_u32 offset, td_u32 *data);
+
+td_s32 ot_mpi_otp_read_byte(td_u32 offset, td_u8 *data);
+
+td_s32 ot_mpi_otp_write_byte(td_u32 offset, td_u8 data);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_common.c b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_common.c
new file mode 100644
index 0000000..f878154
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_common.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "uapi_common.h"
+
+#include "crypto_ioctl_cmd.h"
+#include "crypto_osal_user_lib.h"
+
+static crypto_mutex_t g_crypto_mutex = CRYPTO_PTHREAD_MUTEX_INITIALIZER;
+
+#define crypto_common_lock()   (void)crypto_pthread_mutex_lock(&g_crypto_mutex)
+#define crypto_common_unlock() (void)crypto_pthread_mutex_unlock(&g_crypto_mutex)
+
+static td_u32 g_init_counter = 0;
+#define CRYPTO_INIT_MAX_NUM 0xffffffff
+
+static td_s32 g_dev_fd = -1;
+
+int crypto_cipher_open(void)
+{
+    int ret = TD_FAILURE;
+    crypto_common_lock();
+    if (g_init_counter >= CRYPTO_INIT_MAX_NUM) {
+        ret = ERROR_COUNT_OVERFLOW;
+        goto exit_unlock;
+    }
+
+    if (g_init_counter > 0) {
+        g_init_counter++;
+        ret = TD_SUCCESS;
+        goto exit_unlock;
+    }
+
+    g_dev_fd = crypto_open("/dev/" CRYPTO_CIPHER_DEV_NAME, O_RDWR, 0);
+    if (g_dev_fd < 0) {
+        ret = ERROR_DEV_OPEN_FAILED;
+        goto exit_unlock;
+    }
+    g_init_counter++;
+
+    ret = TD_SUCCESS;
+exit_unlock:
+    crypto_common_unlock();
+    return ret;
+}
+
+void crypto_cipher_close(void)
+{
+    crypto_common_lock();
+
+    if (g_init_counter > 0) {
+        g_init_counter--;
+    }
+    if (g_init_counter == 0) {
+        crypto_close(g_dev_fd);
+        g_dev_fd = -1;
+    }
+    crypto_common_unlock();
+}
+
+int crypto_cipher_ioctl(int cmd, void *args)
+{
+    return crypto_ioctl(g_dev_fd, cmd, args);
+}
+
+int crypto_cipher_is_init(void)
+{
+    if (g_init_counter == 0) {
+        return 0;
+    }
+    return 1;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_common.h b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_common.h
new file mode 100644
index 0000000..c9d3a27
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_common.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef UAPI_COMMON_H
+#define UAPI_COMMON_H
+
+int crypto_cipher_open(void);
+
+void crypto_cipher_close(void);
+
+int crypto_cipher_ioctl(int cmd, void *args);
+
+int crypto_cipher_is_init(void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_hash.c b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_hash.c
new file mode 100644
index 0000000..864b5c2
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_hash.c
@@ -0,0 +1,324 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "uapi_hash.h"
+
+#include <securec.h>
+
+#include "uapi_common.h"
+#include "crypto_ioctl_cmd.h"
+#include "crypto_osal_user_lib.h"
+
+#define HASH_COMPAT_ERRNO(err_code)     UAPI_COMPAT_ERRNO(ERROR_MODULE_HASH, err_code)
+
+#define CRYPTO_HASH_MAX_PROCESS_LEN         (4 * 1024)
+
+#define crypto_hash_init_chk() do {                 \
+    if (crypto_cipher_is_init() == 0) {                 \
+        return HASH_COMPAT_ERRNO(ERROR_NOT_INIT);   \
+    }                                               \
+} while (0)
+
+td_s32 unify_uapi_cipher_hash_init(td_void)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+
+    crypto_uapi_func_enter();
+
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_INIT, TD_NULL);
+    if (ret != CRYPTO_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        crypto_cipher_close();
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_deinit(td_void)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+
+    crypto_uapi_func_enter();
+
+    if (crypto_cipher_is_init() == 0) {
+        return CRYPTO_SUCCESS;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_DEINIT, TD_NULL);
+    if (ret != CRYPTO_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+    }
+
+    crypto_cipher_close();
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_start(td_handle *uapi_hash_handle, const crypto_hash_attr *hash_attr)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_start_ctl_t start_ctl;
+
+    crypto_uapi_func_enter();
+    crypto_hash_init_chk();
+
+    crypto_chk_return(uapi_hash_handle == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL),
+        "uapi_hash_handle is NULL\n");
+    crypto_chk_return(hash_attr == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "hash_attr is NULL\n");
+
+    (td_void)memset_s(&start_ctl, sizeof(start_ctl), 0, sizeof(start_ctl));
+    start_ctl.hash_type = hash_attr->hash_type;
+    start_ctl.is_long_term = hash_attr->is_long_term;
+    start_ctl.is_keyslot = hash_attr->is_keyslot;
+    start_ctl.key.p = hash_attr->key;
+    start_ctl.key_len = hash_attr->key_len;
+    start_ctl.drv_keyslot_handle = hash_attr->drv_keyslot_handle;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_START, &start_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    *uapi_hash_handle = start_ctl.kapi_hash_handle;
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_update(td_handle uapi_hash_handle, const crypto_buf_attr *src_buf, const td_u32 len)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_update_ctl_t update_ctl;
+
+    crypto_uapi_func_enter();
+    crypto_hash_init_chk();
+
+    crypto_chk_return(src_buf == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "src_buf is NULL\n");
+
+    (td_void)memset_s(&update_ctl, sizeof(update_ctl), 0, sizeof(update_ctl));
+    update_ctl.kapi_hash_handle = uapi_hash_handle;
+    update_ctl.src_buf.p = src_buf->virt_addr;
+    update_ctl.len = len;
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_UPDATE, &update_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_finish(td_handle uapi_hash_handle, td_u8 *out, td_u32 *out_len)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_finish_ctl_t finish_ctl;
+
+    crypto_uapi_func_enter();
+    crypto_hash_init_chk();
+
+    crypto_chk_return(out_len == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "out_len is NULL\n");
+
+    (td_void)memset_s(&finish_ctl, sizeof(finish_ctl), 0, sizeof(finish_ctl));
+
+    finish_ctl.kapi_hash_handle = uapi_hash_handle;
+    finish_ctl.out.p = out;
+    finish_ctl.out_len = *out_len;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_FINISH, &finish_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+    crypto_chk_return(*out_len < finish_ctl.out_len, HASH_COMPAT_ERRNO(ERROR_INVALID_PARAM), "out_len is not enough\n");
+    *out_len = finish_ctl.out_len;
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_get(td_handle uapi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_clone_ctl_t clone_ctl;
+
+    crypto_uapi_func_enter();
+    crypto_hash_init_chk();
+
+    (td_void)memset_s(&clone_ctl, sizeof(clone_ctl), 0, sizeof(clone_ctl));
+    clone_ctl.kapi_hash_handle = uapi_hash_handle;
+    clone_ctl.hash_clone_ctx.p = (td_void *)hash_clone_ctx;
+    clone_ctl.ctx_size = sizeof(crypto_hash_clone_ctx);
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_GET, &clone_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_set(td_handle uapi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_clone_ctl_t clone_ctl;
+
+    crypto_uapi_func_enter();
+    crypto_hash_init_chk();
+
+    (td_void)memset_s(&clone_ctl, sizeof(clone_ctl), 0, sizeof(clone_ctl));
+    clone_ctl.kapi_hash_handle = uapi_hash_handle;
+    clone_ctl.hash_clone_ctx.p = (td_void *)hash_clone_ctx;
+    clone_ctl.ctx_size = sizeof(crypto_hash_clone_ctx);
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_SET, &clone_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_destroy(td_handle uapi_hash_handle)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_handle_ctl_t handle_ctl;
+
+    crypto_uapi_func_enter();
+    crypto_hash_init_chk();
+
+    (td_void)memset_s(&handle_ctl, sizeof(handle_ctl), 0, sizeof(handle_ctl));
+    handle_ctl.kapi_hash_handle = uapi_hash_handle;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_DESTROY, &handle_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_HASH_HARDEN_INTERFACE_SUPPORT)
+td_s32 unify_uapi_cipher_hash_start_impl(crypto_hash_clone_ctx *clone_ctx, crypto_hash_type hash_type)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_start_impl_ctl_t start_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(clone_ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "clone_ctx is NULL\n");
+
+    ret = memcpy_s(&start_ctl.ctx, sizeof(start_ctl.ctx), clone_ctx, sizeof(crypto_hash_clone_ctx));
+    crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    start_ctl.hash_type = hash_type;
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_START_IMPL, &start_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        goto dev_close;
+    }
+
+    ret = memcpy_s(clone_ctx, sizeof(crypto_hash_clone_ctx), &start_ctl.ctx, sizeof(start_ctl.ctx));
+    if (ret != EOK) {
+        printf("memcpy_s failed, ret is 0x%x\n", ret);
+        goto dev_close;
+    }
+    ret = CRYPTO_SUCCESS;
+dev_close:
+    crypto_cipher_close();
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_update_impl(crypto_hash_clone_ctx *clone_ctx, const td_u8 *data, td_u32 data_len)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_update_impl_ctl_t update_ctl = {0};
+
+    crypto_uapi_func_enter();
+
+    crypto_chk_return(clone_ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "clone_ctx is NULL\n");
+    crypto_chk_return(data == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "data is NULL\n");
+
+    ret = memcpy_s(&update_ctl.ctx, sizeof(update_ctl.ctx), clone_ctx, sizeof(crypto_hash_clone_ctx));
+    crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    update_ctl.data.p = (td_void *)data;
+    update_ctl.data_len = data_len;
+
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_UPDATE_IMPL, &update_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        goto dev_close;
+    }
+
+    ret = memcpy_s(clone_ctx, sizeof(crypto_hash_clone_ctx), &update_ctl.ctx, sizeof(update_ctl.ctx));
+    if (ret != EOK) {
+        printf("memcpy_s failed, ret is 0x%x\n", ret);
+        goto dev_close;
+    }
+    ret = CRYPTO_SUCCESS;
+dev_close:
+    crypto_cipher_close();
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_hash_finish_impl(crypto_hash_clone_ctx *clone_ctx, td_u8 *out, td_u32 *out_len)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    hash_finish_impl_ctl_t finish_ctl = {0};
+
+    crypto_uapi_func_enter();
+
+    crypto_chk_return(clone_ctx == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "clone_ctx is NULL\n");
+    crypto_chk_return(out_len == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "out_len is NULL\n");
+    crypto_chk_return(out_len == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "out_len is NULL\n");
+
+    ret = memcpy_s(&finish_ctl.ctx, sizeof(finish_ctl.ctx), clone_ctx, sizeof(crypto_hash_clone_ctx));
+    crypto_chk_return(ret != EOK, HASH_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    finish_ctl.out.p = out;
+    finish_ctl.out_len = *out_len;
+
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_HASH_FINISH_IMPL, &finish_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        goto dev_close;
+    }
+
+    *out_len = finish_ctl.out_len;
+    ret = CRYPTO_SUCCESS;
+dev_close:
+    crypto_cipher_close();
+    crypto_uapi_func_exit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_kdf.c b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_kdf.c
new file mode 100644
index 0000000..56a9084
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_kdf.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "uapi_kdf.h"
+
+#include <securec.h>
+
+#include "uapi_common.h"
+#include "crypto_ioctl_cmd.h"
+#include "crypto_osal_user_lib.h"
+
+#define HASH_COMPAT_ERRNO(err_code)     UAPI_COMPAT_ERRNO(ERROR_MODULE_HASH, err_code)
+
+td_s32 unify_uapi_cipher_pbkdf2(const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len)
+{
+    td_s32 ret = TD_SUCCESS;
+    pbkdf2_ctl_t pbkdf2_ctl;
+    crypto_uapi_func_enter();
+
+    crypto_chk_return(param == TD_NULL, HASH_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "param is NULL\n");
+
+    (td_void)memset_s(&pbkdf2_ctl, sizeof(pbkdf2_ctl), 0, sizeof(pbkdf2_ctl));
+    pbkdf2_ctl.hash_type = param->hash_type;
+    pbkdf2_ctl.password.p = param->password;
+    pbkdf2_ctl.salt.p = param->salt;
+    pbkdf2_ctl.plen = param->plen;
+    pbkdf2_ctl.slen = param->slen;
+    pbkdf2_ctl.count = param->count;
+    pbkdf2_ctl.out.p = out;
+    pbkdf2_ctl.out_len = out_len;
+
+    ret = crypto_cipher_open();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_cipher_open failed\n");
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PBKDF2, &pbkdf2_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit_close, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+exit_close:
+    crypto_cipher_close();
+    crypto_uapi_func_exit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_km.c b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_km.c
new file mode 100644
index 0000000..c185ba1
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_km.c
@@ -0,0 +1,400 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "uapi_km.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <securec.h>
+
+#include "ot_type.h"
+#include "crypto_osal_user_lib.h"
+#include "crypto_km_struct.h"
+#include "crypto_errno.h"
+#include "ioctl_km.h"
+#include "crypto_common_macro.h"
+
+#define REF_COUNT_MAX_NUM     0x7FFFFFFF
+#define KM_COMPAT_ERRNO(err_code)     UAPI_COMPAT_ERRNO(ERROR_MODULE_KM, err_code)
+
+typedef struct mpi_mgnt {
+    crypto_mutex_t      lock;
+    td_s32              ref_count;
+    td_s32              dev_fd;
+} mpi_mgnt_t;
+
+static mpi_mgnt_t km_mgnt = {
+    .lock = CRYPTO_PTHREAD_MUTEX_INITIALIZER,
+    .ref_count = -1,
+    .dev_fd = -1
+};
+
+static td_bool inner_km_is_init(td_void)
+{
+    if (km_mgnt.ref_count >= 0) {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_s32 uapi_km_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_uapi_func_enter();
+    crypto_pthread_mutex_lock(&km_mgnt.lock);
+
+    if (km_mgnt.ref_count >= REF_COUNT_MAX_NUM) {
+        ret = ERROR_COUNT_OVERFLOW;
+        goto exit;
+    }
+
+    if (km_mgnt.ref_count >= 0) {
+        km_mgnt.ref_count++;
+        goto exit;
+    }
+    km_mgnt.dev_fd = crypto_open("/dev/km", O_RDWR, 0);
+    if (km_mgnt.dev_fd < 0) {
+        printf("open /dev/km failed\n");
+        ret = KM_COMPAT_ERRNO(ERROR_DEV_OPEN_FAILED);
+        goto exit;
+    }
+
+    km_mgnt.ref_count = 0;
+
+exit:
+    crypto_pthread_mutex_unlock(&km_mgnt.lock);
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_km_deinit(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_uapi_func_enter();
+    crypto_pthread_mutex_lock(&km_mgnt.lock);
+
+    if (km_mgnt.ref_count > 0) {
+        km_mgnt.ref_count--;
+        goto exit;
+    }
+
+    if (km_mgnt.ref_count == 0) {
+        km_mgnt.ref_count--;
+        crypto_close(km_mgnt.dev_fd);
+        km_mgnt.dev_fd = -1;
+    }
+
+exit:
+    crypto_pthread_mutex_unlock(&km_mgnt.lock);
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+/* Keyslot. */
+td_s32 uapi_keyslot_create(td_handle *mpi_keyslot_handle, crypto_keyslot_type keyslot_type)
+{
+    td_s32 ret = TD_SUCCESS;
+    keyslot_create_ctl_t keyslot_create_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+    km_null_ptr_chk(mpi_keyslot_handle);
+
+    keyslot_create_ctl.keyslot_type = keyslot_type;
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KEYSLOT_CREATE_HANDLE, &keyslot_create_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    *mpi_keyslot_handle = keyslot_create_ctl.kapi_keyslot_handle;
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_keyslot_destroy(td_handle mpi_keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    keyslot_destroy_ctl_t keyslot_destroy_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+
+    keyslot_destroy_ctl.kapi_keyslot_handle = mpi_keyslot_handle;
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KEYSLOT_DESTROY_HANDLE, &keyslot_destroy_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+/* Klad. */
+td_s32 uapi_klad_create(td_handle *mpi_klad_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_handle_ctl_t klad_handle_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+    km_null_ptr_chk(mpi_klad_handle);
+
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_CREATE_HANDLE, &klad_handle_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    *mpi_klad_handle = klad_handle_ctl.kapi_klad_handle;
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_destroy(td_handle mpi_klad_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_handle_ctl_t klad_handle_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+
+    klad_handle_ctl.kapi_klad_handle = mpi_klad_handle;
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_DESTROY_HANDLE, &klad_handle_ctl);
+    crypto_chk_print(ret != TD_SUCCESS, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_attach(td_handle mpi_klad_handle, crypto_klad_dest klad_type,
+    td_handle mpi_keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_attach_ctl_t klad_attach_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+
+    klad_attach_ctl.kapi_klad_handle = mpi_klad_handle;
+    klad_attach_ctl.kapi_keyslot_handle =mpi_keyslot_handle;
+    klad_attach_ctl.klad_type = klad_type;
+
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_ATTACH, &klad_attach_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_detach(td_handle mpi_klad_handle, crypto_klad_dest klad_type,
+    td_handle mpi_keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+
+    klad_attach_ctl_t klad_attach_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+
+    klad_attach_ctl.kapi_klad_handle = mpi_klad_handle;
+    klad_attach_ctl.kapi_keyslot_handle = mpi_keyslot_handle;
+    klad_attach_ctl.klad_type = klad_type;
+
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_DETACH, &klad_attach_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_set_attr(td_handle mpi_klad_handle, const crypto_klad_attr *attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_attr_ctl_t klad_attr_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+    km_null_ptr_chk(attr);
+
+    klad_attr_ctl.kapi_klad_handle = mpi_klad_handle;
+    (td_void)memcpy_s(&klad_attr_ctl.attr, sizeof(crypto_klad_attr), attr, sizeof(crypto_klad_attr));
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_SET_ATTR, &klad_attr_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_get_attr(td_handle mpi_klad_handle, crypto_klad_attr *attr)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_attr_ctl_t klad_attr_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+    km_null_ptr_chk(attr);
+
+    klad_attr_ctl.kapi_klad_handle = mpi_klad_handle;
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_GET_ATTR, &klad_attr_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+    (td_void)memcpy_s(attr, sizeof(crypto_klad_attr), &klad_attr_ctl.attr, sizeof(crypto_klad_attr));
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_set_session_key(td_handle mpi_klad_handle, const crypto_klad_session_key *key)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_set_session_key_ctl_t klad_set_session_key_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+    km_null_ptr_chk(key);
+    km_null_ptr_chk(key->key);
+
+    klad_set_session_key_ctl.kapi_klad_handle = mpi_klad_handle;
+    klad_set_session_key_ctl.alg = key->alg;
+    klad_set_session_key_ctl.level = key->level;
+    klad_set_session_key_ctl.key_size = key->key_length;
+    klad_set_session_key_ctl.key.p = (unsigned char *)key->key;
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_SET_SESSION_KEY, &klad_set_session_key_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_set_content_key(td_handle mpi_klad_handle, const crypto_klad_content_key *key)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_set_content_key_ctl_t klad_set_content_key_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+    km_null_ptr_chk(key);
+    km_null_ptr_chk(key->key);
+
+    klad_set_content_key_ctl.kapi_klad_handle = mpi_klad_handle;
+    klad_set_content_key_ctl.alg = key->alg;
+    klad_set_content_key_ctl.key_parity = key->key_parity;
+    klad_set_content_key_ctl.key_size = key->key_length;
+    klad_set_content_key_ctl.key.p = (unsigned char *)key->key;
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_SET_CONTENT_KEY, &klad_set_content_key_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_set_clear_key(td_handle mpi_klad_handle, const crypto_klad_clear_key *key)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_set_clear_key_ctl_t klad_set_clear_key_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+    km_null_ptr_chk(key);
+    km_null_ptr_chk(key->key);
+
+    klad_set_clear_key_ctl.kapi_klad_handle = mpi_klad_handle;
+    klad_set_clear_key_ctl.hmac_type = key->hmac_type;
+    klad_set_clear_key_ctl.key_parity = key->key_parity;
+    klad_set_clear_key_ctl.key_size = key->key_length;
+    klad_set_clear_key_ctl.key.p = (unsigned char *)key->key;
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_SET_CLEAR_KEY, &klad_set_clear_key_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_klad_set_effective_key(td_handle mpi_klad_handle, const crypto_klad_effective_key *key)
+{
+    td_s32 ret = TD_SUCCESS;
+    klad_set_effective_key_ctl_t klad_set_effective_key_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_chk_return(inner_km_is_init() != TD_TRUE, KM_COMPAT_ERRNO(ERROR_NOT_INIT), "KM not init\n");
+    km_null_ptr_chk(key);
+    km_null_ptr_chk(key->salt);
+
+    klad_set_effective_key_ctl.kapi_klad_handle = mpi_klad_handle;
+    klad_set_effective_key_ctl.kdf_hard_alg = key->kdf_hard_alg;
+    klad_set_effective_key_ctl.key_parity = key->key_parity;
+    klad_set_effective_key_ctl.key_size = key->key_size;
+    klad_set_effective_key_ctl.oneway = key->oneway;
+    klad_set_effective_key_ctl.salt_length = key->salt_length;
+    klad_set_effective_key_ctl.salt = key->salt;
+
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KLAD_SET_EFFECTVE_KEY, &klad_set_effective_key_ctl);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+td_s32 uapi_km_create_key_impl(td_handle *keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    km_create_key_impl_ctl_t km_key = {0};
+
+    crypto_uapi_func_enter();
+    km_null_ptr_chk(keyslot_handle);
+
+    ret = uapi_km_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "uapi_km_init uapi_km_init, ret is 0x%x\n", ret);
+
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KM_CREATE_KEY_IMPL, &km_key);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, km_deinit, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+
+    *keyslot_handle = km_key.kapi_kslot_handle;
+km_deinit:
+    uapi_km_deinit();
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_km_set_key_impl(td_handle keyslot_handle, const td_u8 *key, td_u32 key_len, td_bool tee_open)
+{
+    td_s32 ret = TD_SUCCESS;
+    km_set_impl_ctl_t km_key = {0};
+
+    crypto_uapi_func_enter();
+    km_null_ptr_chk(key);
+
+    km_key.key.p = (void *)key;
+    km_key.key_size = key_len;
+    km_key.tee_open = tee_open;
+    km_key.kapi_kslot_handle = keyslot_handle;
+
+    ret = uapi_km_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "uapi_km_init uapi_km_init, ret is 0x%x\n", ret);
+
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KM_SET_KEY_IMPL, &km_key);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, km_deinit, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+km_deinit:
+    uapi_km_deinit();
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_km_destroy_key_impl(td_handle keyslot_handle)
+{
+    td_s32 ret = TD_SUCCESS;
+    km_destroy_key_impl_ctl_t km_handle = {0};
+
+    crypto_uapi_func_enter();
+
+    km_handle.kapi_keyslot_handle = keyslot_handle;
+
+    ret = uapi_km_init();
+    crypto_chk_return(ret != TD_SUCCESS, ret, "uapi_km_init uapi_km_init, ret is 0x%x\n", ret);
+
+    ret = crypto_km_ioctl(km_mgnt.dev_fd, CMD_KM_DESTROY_KEY_IMPL, &km_handle);
+    crypto_chk_goto_with_ret(ret, ret != TD_SUCCESS, km_deinit, ret, "crypto_km_ioctl failed, ret is 0x%x\n", ret);
+km_deinit:
+    uapi_km_deinit();
+    crypto_uapi_func_exit();
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_otp.c b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_otp.c
new file mode 100644
index 0000000..4545a84
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_otp.c
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "uapi_otp.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <securec.h>
+
+#include "ot_type.h"
+#include "crypto_errno.h"
+#include "crypto_osal_user_lib.h"
+#include "crypto_common_macro.h"
+#include "ioctl_otp.h"
+
+#define REF_COUNT_MAX_NUM     0x7FFFFFFF
+
+typedef struct mpi_mgnt {
+    crypto_mutex_t      lock;
+    td_s32              ref_count;
+    td_s32              dev_fd;
+} mpi_mgnt_t;
+
+static mpi_mgnt_t otp_mgnt = {
+    .lock = CRYPTO_PTHREAD_MUTEX_INITIALIZER,
+    .ref_count = -1,
+    .dev_fd = -1
+};
+
+td_s32 uapi_otp_init(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_uapi_func_enter();
+    crypto_pthread_mutex_lock(&otp_mgnt.lock);
+
+    if (otp_mgnt.ref_count >= REF_COUNT_MAX_NUM) {
+        ret = ERROR_COUNT_OVERFLOW;
+        goto exit;
+    }
+
+    if (otp_mgnt.ref_count >= 0) {
+        otp_mgnt.ref_count++;
+        goto exit;
+    }
+    otp_mgnt.dev_fd = crypto_open("/dev/otp", O_RDWR, 0);
+    if (otp_mgnt.dev_fd < 0) {
+        printf("open /dev/otp failed\n");
+        ret = TD_FAILURE;
+        goto exit;
+    }
+
+    otp_mgnt.ref_count = 0;
+
+exit:
+    crypto_pthread_mutex_unlock(&otp_mgnt.lock);
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 uapi_otp_deinit(td_void)
+{
+    td_s32 ret = TD_SUCCESS;
+    crypto_pthread_mutex_lock(&otp_mgnt.lock);
+
+    if (otp_mgnt.ref_count > 0) {
+        otp_mgnt.ref_count--;
+        goto exit;
+    }
+
+    if (otp_mgnt.ref_count == 0) {
+        otp_mgnt.ref_count--;
+        crypto_close(otp_mgnt.dev_fd);
+        otp_mgnt.dev_fd = -1;
+    }
+
+exit:
+    crypto_pthread_mutex_unlock(&otp_mgnt.lock);
+    return ret;
+}
+
+td_s32 uapi_otp_read_word(td_u32 offset, td_u32 *data)
+{
+    td_s32 ret = TD_SUCCESS;
+    otp_word_ctl_t word_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_param_require(data != TD_NULL);
+
+    word_ctl.addr = offset;
+    ret = crypto_otp_ioctl(otp_mgnt.dev_fd, CMD_OTP_READ_WORD, &word_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_otp_ioctl failed, ret is 0x%x\n", ret);
+
+    *data = word_ctl.word;
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&word_ctl, sizeof(word_ctl), 0, sizeof(word_ctl));
+    return ret;
+}
+
+td_s32 uapi_otp_read_byte(td_u32 offset, td_u8 *data)
+{
+    td_s32 ret = TD_SUCCESS;
+    otp_byte_ctl_t byte_ctl = {0};
+
+    crypto_uapi_func_enter();
+    crypto_param_require(data != TD_NULL);
+
+    byte_ctl.addr = offset;
+    ret = crypto_otp_ioctl(otp_mgnt.dev_fd, CMD_OTP_READ_BYTE, &byte_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_otp_ioctl failed, ret is 0x%x\n", ret);
+
+    *data = byte_ctl.byte;
+
+    crypto_uapi_func_exit();
+exit:
+    (td_void)memset_s(&byte_ctl, sizeof(otp_byte_ctl_t), 0, sizeof(otp_byte_ctl_t));
+    return ret;
+}
+
+td_s32 uapi_otp_write_byte(td_u32 offset, td_u8 data)
+{
+    td_s32 ret = TD_SUCCESS;
+    otp_byte_ctl_t byte_ctl = {0};
+
+    crypto_uapi_func_enter();
+
+    byte_ctl.addr = offset;
+    byte_ctl.byte = data;
+    ret = crypto_otp_ioctl(otp_mgnt.dev_fd, CMD_OTP_WRITE_BYTE, &byte_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_otp_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+exit:
+    (td_void)memset_s(&byte_ctl, sizeof(byte_ctl), 0, sizeof(byte_ctl));
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_pke.c b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_pke.c
new file mode 100644
index 0000000..3a82548
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_pke.c
@@ -0,0 +1,660 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "uapi_pke.h"
+#include <securec.h>
+
+#include "uapi_common.h"
+#include "crypto_ioctl_cmd.h"
+#include "crypto_osal_user_lib.h"
+
+#define PKE_COMPAT_ERRNO(err_code)      UAPI_COMPAT_ERRNO(ERROR_MODULE_PKE, err_code)
+
+#define pke_init_chk() do {                         \
+    if (crypto_cipher_is_init() == 0) {                 \
+        return PKE_COMPAT_ERRNO(ERROR_NOT_INIT);    \
+    }                                               \
+} while (0)
+
+td_s32 unify_uapi_cipher_pke_init(td_void)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+
+    crypto_uapi_func_enter();
+
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_deinit(td_void)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+
+    crypto_uapi_func_enter();
+
+    if (crypto_cipher_is_init() == 0) {
+        return CRYPTO_SUCCESS;
+    }
+
+    crypto_cipher_close();
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_ecc_gen_key(drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_ecc_gen_key_ctl_t ecc_gen_key_ctl;
+
+    crypto_uapi_func_enter();
+
+    pke_init_chk();
+
+    pke_null_ptr_chk(output_priv_key);
+    pke_null_ptr_chk(output_pub_key);
+
+    (td_void)memset_s(&ecc_gen_key_ctl, sizeof(ecc_gen_key_ctl), 0, sizeof(ecc_gen_key_ctl));
+    ecc_gen_key_ctl.curve_type = curve_type;
+    ecc_gen_key_ctl.output_priv_key.data.p = output_priv_key->data;
+    ecc_gen_key_ctl.output_priv_key.length = output_priv_key->length;
+    ecc_gen_key_ctl.output_pub_key.x.p = output_pub_key->x;
+    ecc_gen_key_ctl.output_pub_key.y.p = output_pub_key->y;
+    ecc_gen_key_ctl.output_pub_key.length = output_pub_key->length;
+
+    if (input_priv_key != TD_NULL) {
+        ecc_gen_key_ctl.input_priv_key.data.p = input_priv_key->data;
+        ecc_gen_key_ctl.input_priv_key.length = input_priv_key->length;
+    }
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_ECC_GEN_KEY, &ecc_gen_key_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+exit:
+    (td_void)memset_s(&ecc_gen_key_ctl, sizeof(ecc_gen_key_ctl), 0, sizeof(ecc_gen_key_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_ecc_gen_ecdh_key(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_ecc_gen_ecdh_key_ctl_t gen_ecdh_key_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(input_pub_key);
+    pke_null_ptr_chk(input_priv_key);
+    pke_null_ptr_chk(output_shared_key);
+
+    (td_void)memset_s(&gen_ecdh_key_ctl, sizeof(gen_ecdh_key_ctl), 0, sizeof(gen_ecdh_key_ctl));
+    gen_ecdh_key_ctl.curve_type = curve_type;
+    gen_ecdh_key_ctl.input_pub_key.x.p = input_pub_key->x;
+    gen_ecdh_key_ctl.input_pub_key.y.p = input_pub_key->y;
+    gen_ecdh_key_ctl.input_pub_key.length = input_pub_key->length;
+    gen_ecdh_key_ctl.input_priv_key.data.p = input_priv_key->data;
+    gen_ecdh_key_ctl.input_priv_key.length = input_priv_key->length;
+    gen_ecdh_key_ctl.output_shared_key.data.p = output_shared_key->data;
+    gen_ecdh_key_ctl.output_shared_key.length = output_shared_key->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_ECC_GEN_ECDH_KEY, &gen_ecdh_key_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&gen_ecdh_key_ctl, sizeof(gen_ecdh_key_ctl), 0, sizeof(gen_ecdh_key_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_ecdsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_ecdsa_sign_ctl_t ecdsa_sign_ctl;
+
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(sig);
+
+    (td_void)memset_s(&ecdsa_sign_ctl, sizeof(ecdsa_sign_ctl), 0, sizeof(ecdsa_sign_ctl));
+    ecdsa_sign_ctl.curve_type = curve_type;
+    ecdsa_sign_ctl.priv_key.data.p = priv_key->data;
+    ecdsa_sign_ctl.priv_key.length = priv_key->length;
+    ecdsa_sign_ctl.hash.data.p = hash->data;
+    ecdsa_sign_ctl.hash.length = hash->length;
+    ecdsa_sign_ctl.sig.r.p = sig->r;
+    ecdsa_sign_ctl.sig.s.p = sig->s;
+    ecdsa_sign_ctl.sig.length = sig->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_ECDSA_SIGN, &ecdsa_sign_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&ecdsa_sign_ctl, sizeof(ecdsa_sign_ctl), 0, sizeof(ecdsa_sign_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_ecdsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_ecdsa_verify_ctl_t ecdsa_verify_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(hash);
+    pke_null_ptr_chk(sig);
+
+    (td_void)memset_s(&ecdsa_verify_ctl, sizeof(ecdsa_verify_ctl), 0, sizeof(ecdsa_verify_ctl));
+    ecdsa_verify_ctl.curve_type = curve_type;
+    ecdsa_verify_ctl.pub_key.x.p = pub_key->x;
+    ecdsa_verify_ctl.pub_key.y.p = pub_key->y;
+    ecdsa_verify_ctl.pub_key.length = pub_key->length;
+    ecdsa_verify_ctl.hash.data.p = hash->data;
+    ecdsa_verify_ctl.hash.length = hash->length;
+    ecdsa_verify_ctl.sig.r.p = sig->r;
+    ecdsa_verify_ctl.sig.s.p = sig->s;
+    ecdsa_verify_ctl.sig.length = sig->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_ECDSA_VERIFY, &ecdsa_verify_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&ecdsa_verify_ctl, sizeof(ecdsa_verify_ctl), 0, sizeof(ecdsa_verify_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_eddsa_sign(drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_eddsa_sign_ctl_t eddsa_sign_ctl = {0};
+
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(msg);
+    pke_null_ptr_chk(sig);
+
+    eddsa_sign_ctl.curve_type = curve_type;
+    eddsa_sign_ctl.priv_key.data.p = priv_key->data;
+    eddsa_sign_ctl.priv_key.length = priv_key->length;
+    eddsa_sign_ctl.msg.data.p = msg->data;
+    eddsa_sign_ctl.msg.length = msg->length;
+    eddsa_sign_ctl.msg.buf_sec = msg->buf_sec;
+    eddsa_sign_ctl.sig.r.p = sig->r;
+    eddsa_sign_ctl.sig.s.p = sig->s;
+    eddsa_sign_ctl.sig.length = sig->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_EDDSA_SIGN, &eddsa_sign_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&eddsa_sign_ctl, sizeof(eddsa_sign_ctl), 0, sizeof(eddsa_sign_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_eddsa_verify(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_eddsa_verify_ctl_t eddsa_verify_ctl = {0};
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(msg);
+    pke_null_ptr_chk(sig);
+
+    eddsa_verify_ctl.curve_type = curve_type;
+    eddsa_verify_ctl.pub_key.y.p = pub_key->y;
+    eddsa_verify_ctl.pub_key.length = pub_key->length;
+    eddsa_verify_ctl.msg.data.p = msg->data;
+    eddsa_verify_ctl.msg.length = msg->length;
+    eddsa_verify_ctl.msg.buf_sec = msg->buf_sec;
+    eddsa_verify_ctl.sig.r.p = sig->r;
+    eddsa_verify_ctl.sig.s.p = sig->s;
+    eddsa_verify_ctl.sig.length = sig->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_EDDSA_VERIFY, &eddsa_verify_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&eddsa_verify_ctl, sizeof(eddsa_verify_ctl), 0, sizeof(eddsa_verify_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_check_dot_on_curve(drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_check_dot_on_curve_ctl_t dot_on_curve_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(is_on_curve);
+
+    (td_void)memset_s(&dot_on_curve_ctl, sizeof(dot_on_curve_ctl), 0, sizeof(dot_on_curve_ctl));
+    dot_on_curve_ctl.curve_type = curve_type;
+    dot_on_curve_ctl.pub_key.x.p = pub_key->x;
+    dot_on_curve_ctl.pub_key.y.p = pub_key->y;
+    dot_on_curve_ctl.pub_key.length = pub_key->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_CHECK_DOT_ON_CURVE, &dot_on_curve_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+    *is_on_curve = dot_on_curve_ctl.is_on_curve;
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&dot_on_curve_ctl, sizeof(dot_on_curve_ctl), 0, sizeof(dot_on_curve_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_sm2_dsa_hash(const drv_pke_data *sm2_id, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, drv_pke_data *hash)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_sm2_dsa_hash_ctl_t sm2_dsa_hash_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(sm2_id);
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(msg);
+    pke_null_ptr_chk(hash);
+
+    (td_void)memset_s(&sm2_dsa_hash_ctl, sizeof(sm2_dsa_hash_ctl), 0, sizeof(sm2_dsa_hash_ctl));
+    sm2_dsa_hash_ctl.sm2_id.data.p = sm2_id->data;
+    sm2_dsa_hash_ctl.sm2_id.length = sm2_id->length;
+    sm2_dsa_hash_ctl.pub_key.x.p = pub_key->x;
+    sm2_dsa_hash_ctl.pub_key.y.p = pub_key->y;
+    sm2_dsa_hash_ctl.pub_key.length = pub_key->length;
+    sm2_dsa_hash_ctl.msg.buf_sec = msg->buf_sec;
+    sm2_dsa_hash_ctl.msg.data.p = msg->data;
+    sm2_dsa_hash_ctl.msg.length = msg->length;
+    sm2_dsa_hash_ctl.hash.data.p = hash->data;
+    sm2_dsa_hash_ctl.hash.length = hash->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_SM2_DSA_HASH, &sm2_dsa_hash_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&sm2_dsa_hash_ctl, sizeof(sm2_dsa_hash_ctl), 0, sizeof(sm2_dsa_hash_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_sm2_public_encrypt(const drv_pke_ecc_point *pub_key, const drv_pke_data *plain_text,
+    drv_pke_data *cipher_text)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_sm2_public_encrypt_ctl_t sm2_public_encrypt_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(plain_text);
+    pke_null_ptr_chk(cipher_text);
+
+    (td_void)memset_s(&sm2_public_encrypt_ctl, sizeof(sm2_public_encrypt_ctl), 0, sizeof(sm2_public_encrypt_ctl));
+    sm2_public_encrypt_ctl.pub_key.x.p = pub_key->x;
+    sm2_public_encrypt_ctl.pub_key.y.p = pub_key->y;
+    sm2_public_encrypt_ctl.pub_key.length = pub_key->length;
+    sm2_public_encrypt_ctl.plain_text.data.p = plain_text->data;
+    sm2_public_encrypt_ctl.plain_text.length = plain_text->length;
+    sm2_public_encrypt_ctl.cipher_text.data.p = cipher_text->data;
+    sm2_public_encrypt_ctl.cipher_text.length = cipher_text->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_SM2_PUBLIC_ENCRYPT, &sm2_public_encrypt_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+    cipher_text->length = sm2_public_encrypt_ctl.cipher_text.length;
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&sm2_public_encrypt_ctl, sizeof(sm2_public_encrypt_ctl), 0, sizeof(sm2_public_encrypt_ctl));
+    return ret;
+}
+
+
+td_s32 unify_uapi_cipher_pke_sm2_private_decrypt(const drv_pke_data *priv_key, const drv_pke_data *cipher_text,
+    drv_pke_data *plain_text)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_sm2_private_decrypt_ctl_t sm2_private_decrypt_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(cipher_text);
+    pke_null_ptr_chk(plain_text);
+
+    (td_void)memset_s(&sm2_private_decrypt_ctl, sizeof(sm2_private_decrypt_ctl), 0, sizeof(sm2_private_decrypt_ctl));
+    sm2_private_decrypt_ctl.priv_key.data.p = priv_key->data;
+    sm2_private_decrypt_ctl.priv_key.length = priv_key->length;
+    sm2_private_decrypt_ctl.cipher_text.data.p = cipher_text->data;
+    sm2_private_decrypt_ctl.cipher_text.length = cipher_text->length;
+    sm2_private_decrypt_ctl.plain_text.data.p = plain_text->data;
+    sm2_private_decrypt_ctl.plain_text.length = plain_text->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_SM2_PRIVATE_DECRYPT, &sm2_private_decrypt_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+    plain_text->length = sm2_private_decrypt_ctl.plain_text.length;
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&sm2_private_decrypt_ctl, sizeof(sm2_private_decrypt_ctl), 0, sizeof(sm2_private_decrypt_ctl));
+    return ret;
+}
+
+#if defined(CONFIG_PKE_MOD_SUPPORT)
+td_s32 unify_uapi_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_mod_ctl_t mod_ctr_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(a);
+    pke_null_ptr_chk(p);
+    pke_null_ptr_chk(c);
+
+    (td_void)memset_s(&mod_ctr_ctl, sizeof(mod_ctr_ctl), 0, sizeof(mod_ctr_ctl));
+    mod_ctr_ctl.a.data.p = a->data;
+    mod_ctr_ctl.a.length = a->length;
+    mod_ctr_ctl.p.data.p = p->data;
+    mod_ctr_ctl.p.length = p->length;
+    mod_ctr_ctl.c.data.p = c->data;
+    mod_ctr_ctl.c.length = c->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_MOD, &mod_ctr_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    return ret;
+}
+#else
+td_s32 unify_uapi_cipher_pke_mod(const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c)
+{
+    crypto_unused(a);
+    crypto_unused(p);
+    crypto_unused(c);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_PKE_EXP_MOD_SUPPORT)
+td_s32 unify_uapi_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k,
+    const drv_pke_data *in, const drv_pke_data *out)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_exp_mod_ctl_t exp_mod_ctr_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(n);
+    pke_null_ptr_chk(k);
+    pke_null_ptr_chk(in);
+    pke_null_ptr_chk(out);
+
+    (td_void)memset_s(&exp_mod_ctr_ctl, sizeof(exp_mod_ctr_ctl), 0, sizeof(exp_mod_ctr_ctl));
+    exp_mod_ctr_ctl.n.data.p = n->data;
+    exp_mod_ctr_ctl.n.length = n->length;
+    exp_mod_ctr_ctl.k.data.p = k->data;
+    exp_mod_ctr_ctl.k.length = k->length;
+    exp_mod_ctr_ctl.in.data.p = in->data;
+    exp_mod_ctr_ctl.in.length = in->length;
+    exp_mod_ctr_ctl.out.data.p = out->data;
+    exp_mod_ctr_ctl.out.length = out->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_EXP_MOD, &exp_mod_ctr_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    return ret;
+}
+#else
+td_s32 unify_uapi_cipher_pke_exp_mod(const drv_pke_data *n, const drv_pke_data *k,
+    const drv_pke_data *in, const drv_pke_data *out)
+{
+    crypto_unused(n);
+    crypto_unused(k);
+    crypto_unused(in);
+    crypto_unused(out);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_PKE_RSA_GEN_KEY_SUPPORT)
+/* RSA. */
+td_s32 unify_uapi_cipher_pke_rsa_gen_key(const drv_pke_data *input_e, drv_pke_rsa_priv_key *priv_key)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_rsa_gen_key_ctl_t rsa_gen_key_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(input_e);
+    pke_null_ptr_chk(priv_key);
+
+    (td_void)memset_s(&rsa_gen_key_ctl, sizeof(rsa_gen_key_ctl), 0, sizeof(rsa_gen_key_ctl));
+    rsa_gen_key_ctl.input_e.data.p = input_e->data;
+    rsa_gen_key_ctl.input_e.length = input_e->length;
+    rsa_gen_key_ctl.priv_key.n.p = priv_key->n;
+    rsa_gen_key_ctl.priv_key.d.p = priv_key->d;
+    rsa_gen_key_ctl.priv_key.n_len = priv_key->n_len;
+    rsa_gen_key_ctl.priv_key.d_len = priv_key->d_len;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_RSA_GEN_KEY, &rsa_gen_key_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&rsa_gen_key_ctl, sizeof(rsa_gen_key_ctl), 0, sizeof(rsa_gen_key_ctl));
+    return ret;
+}
+#endif
+
+td_s32 unify_uapi_cipher_pke_rsa_sign(const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_rsa_sign_ctl_t rsa_sign_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(input_hash);
+    pke_null_ptr_chk(sign);
+
+    (td_void)memset_s(&rsa_sign_ctl, sizeof(rsa_sign_ctl), 0, sizeof(rsa_sign_ctl));
+    rsa_sign_ctl.scheme = scheme;
+    rsa_sign_ctl.priv_key.n.p = priv_key->n;
+    rsa_sign_ctl.priv_key.e.p = priv_key->e;
+    rsa_sign_ctl.priv_key.d.p = priv_key->d;
+    rsa_sign_ctl.priv_key.p.p = priv_key->p;
+    rsa_sign_ctl.priv_key.q.p = priv_key->q;
+    rsa_sign_ctl.priv_key.dp.p = priv_key->dp;
+    rsa_sign_ctl.priv_key.dq.p = priv_key->dq;
+    rsa_sign_ctl.priv_key.qp.p = priv_key->qp;
+    rsa_sign_ctl.priv_key.n_len = priv_key->n_len;
+    rsa_sign_ctl.priv_key.e_len = priv_key->e_len;
+    rsa_sign_ctl.priv_key.d_len = priv_key->d_len;
+    rsa_sign_ctl.priv_key.p_len = priv_key->p_len;
+    rsa_sign_ctl.priv_key.q_len = priv_key->q_len;
+    rsa_sign_ctl.priv_key.dp_len = priv_key->dp_len;
+    rsa_sign_ctl.priv_key.dq_len = priv_key->dq_len;
+    rsa_sign_ctl.priv_key.qp_len = priv_key->qp_len;
+    rsa_sign_ctl.scheme = scheme;
+    rsa_sign_ctl.hash_type = hash_type;
+    rsa_sign_ctl.input_hash.data.p = input_hash->data;
+    rsa_sign_ctl.input_hash.length = input_hash->length;
+    rsa_sign_ctl.sig.data.p = sign->data;
+    rsa_sign_ctl.sig.length = sign->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_RSA_SIGN, &rsa_sign_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+    sign->length = rsa_sign_ctl.sig.length;
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&rsa_sign_ctl, sizeof(rsa_sign_ctl), 0, sizeof(rsa_sign_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_rsa_verify(const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash, const drv_pke_data *sig)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_rsa_verify_ctl_t rsa_verify_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(input_hash);
+    pke_null_ptr_chk(sig);
+
+    (td_void)memset_s(&rsa_verify_ctl, sizeof(rsa_verify_ctl), 0, sizeof(rsa_verify_ctl));
+    rsa_verify_ctl.scheme = scheme;
+    rsa_verify_ctl.hash_type = hash_type;
+    rsa_verify_ctl.pub_key.e.p = pub_key->e;
+    rsa_verify_ctl.pub_key.n.p = pub_key->n;
+    rsa_verify_ctl.pub_key.len = pub_key->len;
+    rsa_verify_ctl.input_hash.data.p = input_hash->data;
+    rsa_verify_ctl.input_hash.length = input_hash->length;
+    rsa_verify_ctl.sig.data.p = sig->data;
+    rsa_verify_ctl.sig.length = sig->length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_RSA_VERIFY, &rsa_verify_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&rsa_verify_ctl, sizeof(rsa_verify_ctl), 0, sizeof(rsa_verify_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_rsa_public_encrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_rsa_pub_crypto_ctl_t rsa_pub_crypto_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(pub_key);
+    pke_null_ptr_chk(input);
+    pke_null_ptr_chk(output);
+
+    (td_void)memset_s(&rsa_pub_crypto_ctl, sizeof(rsa_pub_crypto_ctl), 0, sizeof(rsa_pub_crypto_ctl));
+    rsa_pub_crypto_ctl.scheme = scheme;
+    rsa_pub_crypto_ctl.hash_type = hash_type;
+    rsa_pub_crypto_ctl.pub_key.e.p = pub_key->e;
+    rsa_pub_crypto_ctl.pub_key.n.p = pub_key->n;
+    rsa_pub_crypto_ctl.pub_key.len = pub_key->len;
+    rsa_pub_crypto_ctl.input.data.p = input->data;
+    rsa_pub_crypto_ctl.input.length = input->length;
+    rsa_pub_crypto_ctl.output.data.p = output->data;
+    rsa_pub_crypto_ctl.output.length = output->length;
+    if (label != TD_NULL) {
+        rsa_pub_crypto_ctl.label.data.p = label->data;
+        rsa_pub_crypto_ctl.label.length = label->length;
+    } else {
+        rsa_pub_crypto_ctl.label.data.p = TD_NULL;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_RSA_PUBLIC_ENCRYPT, &rsa_pub_crypto_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+    output->length = rsa_pub_crypto_ctl.output.length;
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&rsa_pub_crypto_ctl, sizeof(rsa_pub_crypto_ctl), 0, sizeof(rsa_pub_crypto_ctl));
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_pke_rsa_private_decrypt(drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output)
+{
+    td_s32 ret = TD_SUCCESS;
+    pke_rsa_priv_crypto_ctl_t rsa_priv_crypto_ctl;
+    crypto_uapi_func_enter();
+    pke_init_chk();
+
+    pke_null_ptr_chk(priv_key);
+    pke_null_ptr_chk(input);
+    pke_null_ptr_chk(output);
+
+    (td_void)memset_s(&rsa_priv_crypto_ctl, sizeof(rsa_priv_crypto_ctl), 0, sizeof(rsa_priv_crypto_ctl));
+    rsa_priv_crypto_ctl.scheme = scheme;
+    rsa_priv_crypto_ctl.hash_type = hash_type;
+    rsa_priv_crypto_ctl.priv_key.n.p = priv_key->n;
+    rsa_priv_crypto_ctl.priv_key.e.p = priv_key->e;
+    rsa_priv_crypto_ctl.priv_key.d.p = priv_key->d;
+    rsa_priv_crypto_ctl.priv_key.p.p = priv_key->p;
+    rsa_priv_crypto_ctl.priv_key.q.p = priv_key->q;
+    rsa_priv_crypto_ctl.priv_key.dp.p = priv_key->dp;
+    rsa_priv_crypto_ctl.priv_key.dq.p = priv_key->dq;
+    rsa_priv_crypto_ctl.priv_key.qp.p = priv_key->qp;
+    rsa_priv_crypto_ctl.priv_key.n_len = priv_key->n_len;
+    rsa_priv_crypto_ctl.priv_key.e_len = priv_key->e_len;
+    rsa_priv_crypto_ctl.priv_key.d_len = priv_key->d_len;
+    rsa_priv_crypto_ctl.priv_key.p_len = priv_key->p_len;
+    rsa_priv_crypto_ctl.priv_key.q_len = priv_key->q_len;
+    rsa_priv_crypto_ctl.priv_key.dp_len = priv_key->dp_len;
+    rsa_priv_crypto_ctl.priv_key.dq_len = priv_key->dq_len;
+    rsa_priv_crypto_ctl.priv_key.qp_len = priv_key->qp_len;
+    rsa_priv_crypto_ctl.input.data.p = input->data;
+    rsa_priv_crypto_ctl.input.length = input->length;
+    rsa_priv_crypto_ctl.output.data.p = output->data;
+    rsa_priv_crypto_ctl.output.length = output->length;
+    if (label != TD_NULL) {
+        rsa_priv_crypto_ctl.label.data.p = label->data;
+        rsa_priv_crypto_ctl.label.length = label->length;
+    } else {
+        rsa_priv_crypto_ctl.label.data.p = TD_NULL;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_PKE_RSA_PRIVATE_DECRYPT, &rsa_priv_crypto_ctl);
+    crypto_chk_goto(ret != TD_SUCCESS, exit, "crypto_ioctl failed, ret is 0x%x\n", ret);
+    output->length = rsa_priv_crypto_ctl.output.length;
+    crypto_uapi_func_exit();
+
+exit:
+    (td_void)memset_s(&rsa_priv_crypto_ctl, sizeof(rsa_priv_crypto_ctl), 0, sizeof(rsa_priv_crypto_ctl));
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_symc.c b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_symc.c
new file mode 100644
index 0000000..00c21df
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_symc.c
@@ -0,0 +1,616 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "uapi_symc.h"
+
+#include <securec.h>
+
+#include "uapi_common.h"
+#include "crypto_ioctl_cmd.h"
+#include "crypto_osal_user_lib.h"
+
+#define SYMC_COMPAT_ERRNO(err_code)     UAPI_COMPAT_ERRNO(ERROR_MODULE_SYMC, err_code)
+
+#define CRYPTO_HASH_MAX_PROCESS_LEN         (4 * 1024)
+
+#define crypto_symc_init_chk() do {                 \
+    if (crypto_cipher_is_init() == 0) {                 \
+        return SYMC_COMPAT_ERRNO(ERROR_NOT_INIT);   \
+    }                                               \
+} while (0)
+
+td_s32 unify_uapi_cipher_symc_init(td_void)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+
+    crypto_uapi_func_enter();
+
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_INIT, TD_NULL);
+    if (ret != CRYPTO_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        crypto_cipher_close();
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_deinit(td_void)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+
+    crypto_uapi_func_enter();
+
+    if (crypto_cipher_is_init() == 0) {
+        return CRYPTO_SUCCESS;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_DEINIT, TD_NULL);
+    if (ret != CRYPTO_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+    }
+
+    crypto_cipher_close();
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_create(td_handle *symc_handle, const crypto_symc_attr *symc_attr)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_create_t symc_create;
+
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(symc_handle == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "symc_handle is NULL\n");
+    crypto_chk_return(symc_attr == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "symc_attr is NULL\n");
+
+    (td_void)memset_s(&symc_create, sizeof(symc_create), 0, sizeof(symc_create));
+    (td_void)memcpy_s(&symc_create.symc_attr, sizeof(crypto_symc_attr), symc_attr, sizeof(crypto_symc_attr));
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_CREATE, &symc_create);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    *symc_handle = symc_create.symc_handle;
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_destroy(td_handle symc_handle)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_destroy_t symc_destroy;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    (td_void)memset_s(&symc_destroy, sizeof(symc_destroy), 0, sizeof(symc_destroy));
+
+    symc_destroy.symc_handle = symc_handle;
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_DESTROY, &symc_destroy);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_set_config(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_config_t symc_config;
+    crypto_symc_config_aes_ccm_gcm *ccm_gcm_config = TD_NULL;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(symc_ctrl == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "symc_ctrl is NULL\n");
+
+    (td_void)memset_s(&symc_config, sizeof(symc_config), 0, sizeof(symc_config));
+
+    symc_config.symc_handle = symc_handle;
+    symc_config.symc_alg = symc_ctrl->symc_alg;
+    symc_config.work_mode = symc_ctrl->work_mode;
+    symc_config.symc_key_length = symc_ctrl->symc_key_length;
+    symc_config.symc_bit_width = symc_ctrl->symc_bit_width;
+    symc_config.iv_change_flag = symc_ctrl->iv_change_flag;
+    ret = memcpy_s(symc_config.iv, sizeof(symc_config.iv), symc_ctrl->iv, symc_ctrl->iv_length);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    symc_config.iv_length = symc_ctrl->iv_length;
+
+    if (symc_ctrl->work_mode == CRYPTO_SYMC_WORK_MODE_CCM || symc_ctrl->work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        crypto_chk_return(symc_ctrl->param == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "param is NULL\n");
+        ccm_gcm_config = (crypto_symc_config_aes_ccm_gcm *)symc_ctrl->param;
+        symc_config.total_aad_len = ccm_gcm_config->total_aad_len;
+        symc_config.aad_len = ccm_gcm_config->aad_len;
+        symc_config.data_len = ccm_gcm_config->data_len;
+        symc_config.tag_len = ccm_gcm_config->tag_len;
+        symc_config.aad_mem_handle = ccm_gcm_config->aad_buf.uapi_mem_handle;
+        symc_config.aad_phys_addr = ccm_gcm_config->aad_buf.phys_addr;
+        symc_config.aad.p = ccm_gcm_config->aad_buf.virt_addr;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_SET_CONFIG, &symc_config);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_SYMC_GET_CONFIG_SUPPORT)
+td_s32 unify_uapi_cipher_symc_get_config(td_handle symc_handle, crypto_symc_ctrl_t *symc_ctrl)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_config_t symc_config;
+    crypto_symc_config_aes_ccm_gcm *ccm_gcm_config = TD_NULL;
+    crypto_uapi_func_enter();
+
+    crypto_symc_init_chk();
+    crypto_chk_return(symc_ctrl == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "symc_ctrl is NULL\n");
+    (td_void)memset_s(&symc_config, sizeof(symc_config), 0, sizeof(symc_config));
+    ccm_gcm_config = (crypto_symc_config_aes_ccm_gcm *)symc_ctrl->param;
+    if (ccm_gcm_config != TD_NULL) {
+        symc_config.aad.p = ccm_gcm_config->aad_buf.virt_addr;
+    }
+    symc_config.symc_handle = symc_handle;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_GET_CONFIG, &symc_config);
+    if (ret != TD_SUCCESS) {
+        printf("%s\n", __func__);
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    symc_ctrl->symc_alg = symc_config.symc_alg;
+    symc_ctrl->work_mode = symc_config.work_mode;
+    symc_ctrl->symc_key_length = symc_config.symc_key_length;
+    symc_ctrl->symc_bit_width = symc_config.symc_bit_width;
+    symc_ctrl->iv_change_flag = symc_config.iv_change_flag;
+
+    symc_ctrl->iv_length = symc_config.iv_length;
+    ret = memcpy_s(symc_ctrl->iv, sizeof(symc_ctrl->iv), symc_config.iv, sizeof(symc_config.iv));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    if (symc_ctrl->work_mode == CRYPTO_SYMC_WORK_MODE_CCM || symc_ctrl->work_mode == CRYPTO_SYMC_WORK_MODE_GCM) {
+        crypto_chk_return(ccm_gcm_config == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "param is NULL\n");
+        ccm_gcm_config->aad_len = symc_config.aad_len;
+        ccm_gcm_config->data_len = symc_config.data_len;
+        ccm_gcm_config->tag_len = symc_config.tag_len;
+        ccm_gcm_config->aad_buf.uapi_mem_handle = symc_config.aad_mem_handle;
+        ccm_gcm_config->aad_buf.phys_addr = symc_config.aad_phys_addr;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+#else
+td_s32 unify_uapi_cipher_symc_get_config(td_handle symc_handle, crypto_symc_ctrl_t *symc_ctrl)
+{
+    crypto_unused(symc_handle);
+    crypto_unused(symc_ctrl);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+td_s32 unify_uapi_cipher_symc_attach(td_handle symc_handle, td_handle keyslot_handle)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_attach_t symc_attach;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    (td_void)memset_s(&symc_attach, sizeof(symc_attach), 0, sizeof(symc_attach));
+    symc_attach.symc_handle = symc_handle;
+    symc_attach.keyslot_handle = keyslot_handle;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_ATTACH, &symc_attach);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_encrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_crypto_t symc_crypto;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(src_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "src_buf is NULL\n");
+    crypto_chk_return(dst_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "dst_buf is NULL\n");
+
+    (td_void)memset_s(&symc_crypto, sizeof(symc_crypto), 0, sizeof(symc_crypto));
+    symc_crypto.symc_handle = symc_handle;
+    symc_crypto.src_mem_handle = src_buf->uapi_mem_handle;
+    symc_crypto.src_phys_addr = src_buf->phys_addr;
+    symc_crypto.src_buf_sec = src_buf->buf_sec;
+    symc_crypto.src_addr_offset = src_buf->addr_offset;
+    symc_crypto.dst_mem_handle = dst_buf->uapi_mem_handle;
+    symc_crypto.dst_phys_addr = dst_buf->phys_addr;
+    symc_crypto.dst_buf_sec = dst_buf->buf_sec;
+    symc_crypto.dst_addr_offset = dst_buf->addr_offset;
+    symc_crypto.length = length;
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_ENCRYPT, &symc_crypto);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_decrypt(td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_crypto_t symc_crypto;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(src_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "src_buf is NULL\n");
+    crypto_chk_return(dst_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "dst_buf is NULL\n");
+
+    (td_void)memset_s(&symc_crypto, sizeof(symc_crypto), 0, sizeof(symc_crypto));
+    symc_crypto.symc_handle = symc_handle;
+    symc_crypto.src_mem_handle = src_buf->uapi_mem_handle;
+    symc_crypto.src_phys_addr = src_buf->phys_addr;
+    symc_crypto.src_buf_sec = src_buf->buf_sec;
+    symc_crypto.src_addr_offset = src_buf->addr_offset;
+    symc_crypto.dst_mem_handle = dst_buf->uapi_mem_handle;
+    symc_crypto.dst_phys_addr = dst_buf->phys_addr;
+    symc_crypto.dst_buf_sec = dst_buf->buf_sec;
+    symc_crypto.dst_addr_offset = dst_buf->addr_offset;
+    symc_crypto.length = length;
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_DECRYPT, &symc_crypto);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_get_tag(td_handle symc_handle, td_u8 *tag, td_u32 tag_length)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_get_tag_t symc_get_tag;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(tag == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "tag is NULL\n");
+
+    (td_void)memset_s(&symc_get_tag, sizeof(symc_get_tag), 0, sizeof(symc_get_tag));
+    symc_get_tag.symc_handle = symc_handle;
+    symc_get_tag.tag_length = tag_length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_GET_TAG, &symc_get_tag);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    ret = memcpy_s(tag, tag_length, symc_get_tag.tag, symc_get_tag.tag_length);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_mac_start(td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_mac_start_t mac_start;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(symc_handle == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "symc_handle is NULL\n");
+    crypto_chk_return(mac_attr == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "mac_attr is NULL\n");
+
+    (td_void)memset_s(&mac_start, sizeof(mac_start), 0, sizeof(mac_start));
+    (td_void)memcpy_s(&mac_start.mac_attr, sizeof(crypto_symc_mac_attr), mac_attr, sizeof(crypto_symc_mac_attr));
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_MAC_START, &mac_start);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    *symc_handle = mac_start.symc_handle;
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_mac_update(td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_mac_update_t mac_update;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(src_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "src_buf is NULL\n");
+
+    (td_void)memset_s(&mac_update, sizeof(mac_update), 0, sizeof(mac_update));
+    mac_update.symc_handle = symc_handle;
+    mac_update.src_buf.p = src_buf->virt_addr;
+    mac_update.length = length;
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_MAC_UPDATE, &mac_update);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_mac_finish(td_handle symc_handle, td_u8 *mac, td_u32 *mac_length)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_mac_finish_t mac_finish;
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(mac == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "mac is NULL\n");
+    crypto_chk_return(mac_length == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "mac_length is NULL\n");
+
+    (td_void)memset_s(&mac_finish, sizeof(mac_finish), 0, sizeof(mac_finish));
+    mac_finish.symc_handle = symc_handle;
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_MAC_FINISH, &mac_finish);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+    crypto_chk_return(*mac_length < mac_finish.mac_length, SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM),
+        "mac_length is not enough\n");
+    ret = memcpy_s(mac, *mac_length, mac_finish.mac, mac_finish.mac_length);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    *mac_length = mac_finish.mac_length;
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+#if defined(CONFIG_SYMC_MULTI_PACK_SUPPORT)
+static td_s32 priv_uapi_symc_config_ctrl(const crypto_symc_ctrl_t *symc_ctrl, crypto_symc_multi_t *symc_multi)
+{
+    td_s32 ret;
+
+    symc_multi->symc_alg = symc_ctrl->symc_alg;
+    symc_multi->work_mode = symc_ctrl->work_mode;
+    symc_multi->symc_key_length = symc_ctrl->symc_key_length;
+    symc_multi->key_parity = symc_ctrl->key_parity;
+    symc_multi->symc_bit_width = symc_ctrl->symc_bit_width;
+    symc_multi->iv_change_flag = symc_ctrl->iv_change_flag;
+    symc_multi->iv_length = symc_ctrl->iv_length;
+    ret = memcpy_s(symc_multi->iv, sizeof(symc_multi->iv), symc_ctrl->iv, symc_ctrl->iv_length);
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    return ret;
+}
+
+typedef struct {
+    td_handle symc_handle;
+    td_u32 pack_num;
+    td_u32 crypto_type;
+} priv_multi_param;
+
+static td_s32 priv_uapi_symc_crypto_multi(const priv_multi_param *multi_param, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack)
+{
+    td_u32 i;
+    td_s32 ret = CRYPTO_SUCCESS;
+    crypto_symc_multi_t symc_multi;
+    crypto_mem_pack *buffer = TD_NULL;
+    crypto_mem_pack *src_mem_handle = TD_NULL;
+    crypto_mem_pack *dst_mem_handle = TD_NULL;
+    td_u32 pack_size = sizeof(crypto_mem_pack) * multi_param->pack_num;
+    crypto_symc_init_chk();
+
+    crypto_chk_return(symc_ctrl == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "symc_ctrl is NULL\n");
+    crypto_chk_return(src_buf_pack == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "src_buf_pack is NULL\n");
+    crypto_chk_return(dst_buf_pack == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "dst_buf_pack is NULL\n");
+    crypto_chk_return(multi_param->pack_num > CRYPTO_SYMC_MULTI_PACK_MAX_SIZE,
+        SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM), "pack_num is too large\n");
+
+    (td_void)memset_s(&symc_multi, sizeof(crypto_symc_multi_t), 0, sizeof(crypto_symc_multi_t));
+    symc_multi.symc_handle = multi_param->symc_handle;
+
+    ret = priv_uapi_symc_config_ctrl(symc_ctrl, &symc_multi);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_uapi_symc_config_ctrl failed\n");
+
+    buffer = crypto_malloc(pack_size * 2);  /* 2: for Both src and dst. */
+    crypto_chk_return(buffer == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_MALLOC), "crypto_malloc failed\n");
+
+    src_mem_handle = buffer;
+    dst_mem_handle = buffer + multi_param->pack_num;
+    for (i = 0; i < multi_param->pack_num; i++) {
+        src_mem_handle[i].uapi_mem_handle = src_buf_pack[i].buf_attr.uapi_mem_handle;
+        src_mem_handle[i].length = src_buf_pack[i].length;
+        src_mem_handle[i].phys_addr = src_buf_pack[i].buf_attr.phys_addr;
+        src_mem_handle[i].buf_sec = src_buf_pack[i].buf_attr.buf_sec;
+        dst_mem_handle[i].uapi_mem_handle = dst_buf_pack[i].buf_attr.uapi_mem_handle;
+        dst_mem_handle[i].length = dst_buf_pack[i].length;
+        dst_mem_handle[i].phys_addr = dst_buf_pack[i].buf_attr.phys_addr;
+        dst_mem_handle[i].buf_sec = dst_buf_pack[i].buf_attr.buf_sec;
+    }
+    symc_multi.src_pack_addr.p = (td_void *)src_mem_handle;
+    symc_multi.dst_pack_addr.p = (td_void *)dst_mem_handle;
+    symc_multi.pack_num = multi_param->pack_num;
+    switch (multi_param->crypto_type) {
+        case CRYPTO_TYPE_ENCRYPT:
+            ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_ENCRYPT_MULTI, &symc_multi);
+            break;
+        case CRYPTO_TYPE_DECRYPT:
+            ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_DECRYPT_MULTI, &symc_multi);
+            break;
+        default:
+            printf("Invalid Crypto Type!\n");
+            ret = SYMC_COMPAT_ERRNO(ERROR_INVALID_PARAM);
+    }
+
+    (td_void)memset_s(buffer, pack_size * 2, 0, pack_size * 2); /* 2: for Both src and dst. */
+    crypto_free(buffer);
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_encrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    priv_multi_param multi_param = {
+        .symc_handle = symc_handle,
+        .pack_num = pack_num,
+        .crypto_type = CRYPTO_TYPE_ENCRYPT,
+    };
+    crypto_uapi_func_enter();
+
+    ret = priv_uapi_symc_crypto_multi(&multi_param, symc_ctrl, src_buf_pack, dst_buf_pack);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_uapi_symc_crypto_multi for Encrypt failed\n");
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_symc_decrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    priv_multi_param multi_param = {
+        .symc_handle = symc_handle,
+        .pack_num = pack_num,
+        .crypto_type = CRYPTO_TYPE_DECRYPT,
+    };
+    crypto_uapi_func_enter();
+
+    ret = priv_uapi_symc_crypto_multi(&multi_param, symc_ctrl, src_buf_pack, dst_buf_pack);
+    crypto_chk_return(ret != TD_SUCCESS, ret, "priv_uapi_symc_crypto_multi for Decrypt failed\n");
+    crypto_uapi_func_exit();
+    return ret;
+}
+#else
+td_s32 unify_uapi_cipher_symc_encrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num)
+{
+    crypto_unused(symc_handle);
+    crypto_unused(symc_ctrl);
+    crypto_unused(src_buf_pack);
+    crypto_unused(dst_buf_pack);
+    crypto_unused(pack_num);
+
+    return ERROR_UNSUPPORT;
+}
+
+td_s32 unify_uapi_cipher_symc_decrypt_multi(td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl,
+    const crypto_symc_pack *src_buf_pack, const crypto_symc_pack *dst_buf_pack, td_u32 pack_num)
+{
+    crypto_unused(symc_handle);
+    crypto_unused(symc_ctrl);
+    crypto_unused(src_buf_pack);
+    crypto_unused(dst_buf_pack);
+    crypto_unused(pack_num);
+
+    return ERROR_UNSUPPORT;
+}
+#endif
+
+#if defined(CONFIG_SYMC_CENC_SUPPORT)
+td_s32 unify_uapi_cipher_symc_cenc_decrypt(td_handle symc_handle, const crypto_symc_cenc_param *cenc_param,
+    const crypto_buf_attr *src_buf, const crypto_buf_attr *dst_buf, td_u32 length)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    crypto_symc_cenc_t symc_cenc;
+
+    crypto_uapi_func_enter();
+    crypto_symc_init_chk();
+
+    crypto_chk_return(cenc_param == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "cenc_param is NULL\n");
+    crypto_chk_return(src_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "src_buf is NULL\n");
+    crypto_chk_return(dst_buf == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "dst_buf is NULL\n");
+
+    (td_void)memset_s(&symc_cenc, sizeof(symc_cenc), 0, sizeof(symc_cenc));
+    symc_cenc.symc_handle = symc_handle;
+    symc_cenc.alg = cenc_param->alg;
+    symc_cenc.work_mode = cenc_param->work_mode;
+    ret = memcpy_s(symc_cenc.iv, sizeof(symc_cenc.iv), cenc_param->iv, sizeof(cenc_param->iv));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+
+    symc_cenc.use_odd_key = cenc_param->use_odd_key;
+    symc_cenc.first_encrypt_offset = cenc_param->first_encrypt_offset;
+    symc_cenc.subsample_num = cenc_param->subsample_num;
+    symc_cenc.subsample_addr.p = cenc_param->subsample;
+    symc_cenc.src_mem_handle = src_buf->uapi_mem_handle;
+    symc_cenc.src_buf_sec = src_buf->buf_sec;
+    symc_cenc.dst_mem_handle = dst_buf->uapi_mem_handle;
+    symc_cenc.dst_buf_sec = dst_buf->buf_sec;
+    symc_cenc.length = length;
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_CENC_DECRYPT, &symc_cenc);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        return ret;
+    }
+
+    crypto_uapi_func_exit();
+    return ret;
+}
+#endif
+
+#if defined(CONFIG_SYMC_HARDEN_INTERFACE_SUPPORT)
+td_s32 unify_uapi_cipher_symc_crypt_impl(crypto_symc_ctrl_t *symc_ctrl, td_handle keyslot_handle,
+    const crypto_buf_attr *src, const crypto_buf_attr *dst, td_u32 data_len, td_bool is_decrypt)
+{
+    td_s32 ret = CRYPTO_SUCCESS;
+    symc_crypto_impl_t symc_crypto = {0};
+
+    crypto_chk_return(symc_ctrl == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "symc_ctrl is NULL\n");
+    crypto_chk_return(src == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "src_buf is NULL\n");
+    crypto_chk_return(dst == TD_NULL, SYMC_COMPAT_ERRNO(ERROR_PARAM_IS_NULL), "dst_buf is NULL\n");
+
+    ret = memcpy_s(&symc_crypto.symc_ctrl, sizeof(crypto_symc_ctrl_t), symc_ctrl, sizeof(crypto_symc_ctrl_t));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    symc_crypto.crypto_info.src_phys_addr = src->phys_addr;
+    symc_crypto.crypto_info.src_buf_sec = src->buf_sec;
+    symc_crypto.crypto_info.dst_phys_addr = dst->phys_addr;
+    symc_crypto.crypto_info.dst_buf_sec = dst->buf_sec;
+    symc_crypto.crypto_info.length = data_len;
+    symc_crypto.keyslot_handle = keyslot_handle;
+    symc_crypto.is_decrypt = is_decrypt;
+
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_SYMC_CRYPT_IMPL, &symc_crypto);
+    if (ret != CRYPTO_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+    }
+
+    crypto_cipher_close();
+
+    ret = memcpy_s(symc_ctrl, sizeof(crypto_symc_ctrl_t), &symc_crypto.symc_ctrl, sizeof(crypto_symc_ctrl_t));
+    crypto_chk_return(ret != EOK, SYMC_COMPAT_ERRNO(ERROR_MEMCPY_S), "memcpy_s failed\n");
+    return ret;
+}
+#endif
\ No newline at end of file
diff --git a/bsp/security_subsys/security_subsys_common/uapi_code/uapi_trng.c b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_trng.c
new file mode 100644
index 0000000..09abda7
--- /dev/null
+++ b/bsp/security_subsys/security_subsys_common/uapi_code/uapi_trng.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#include "uapi_trng.h"
+#include <securec.h>
+
+#include "uapi_common.h"
+#include "crypto_ioctl_cmd.h"
+#include "crypto_osal_user_lib.h"
+
+#define TRNG_COMPAT_ERRNO(err_code)     UAPI_COMPAT_ERRNO(ERROR_MODULE_TRNG, err_code)
+
+td_s32 unify_uapi_cipher_trng_get_random(td_u32 *randnum)
+{
+    td_s32 ret = TD_SUCCESS;
+    trng_ctl_t trng_ctl;
+    crypto_uapi_func_enter();
+
+    if (randnum == TD_NULL) {
+        return TRNG_COMPAT_ERRNO(ERROR_PARAM_IS_NULL);
+    }
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+
+    (td_void)memset_s(&trng_ctl, sizeof(trng_ctl), 0, sizeof(trng_ctl));
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_TRNG_GET_RANDOM, &trng_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_cipher_ioctl failed, ret is 0x%x\n", ret);
+        goto exit_close;
+    }
+    *randnum = trng_ctl.randnum;
+
+exit_close:
+    crypto_cipher_close();
+    crypto_uapi_func_exit();
+    return ret;
+}
+
+td_s32 unify_uapi_cipher_trng_get_multi_random(td_u32 size, td_u8 *randnum)
+{
+    td_s32 ret = TD_SUCCESS;
+    trng_multi_ctl_t trng_multi_ctl;
+    crypto_uapi_func_enter();
+
+    if (randnum == TD_NULL) {
+        return TRNG_COMPAT_ERRNO(ERROR_PARAM_IS_NULL);
+    }
+    ret = crypto_cipher_open();
+    if (ret != TD_SUCCESS) {
+        return ret;
+    }
+    (td_void)memset_s(&trng_multi_ctl, sizeof(trng_multi_ctl), 0, sizeof(trng_multi_ctl));
+    trng_multi_ctl.randnum.p = randnum;
+    trng_multi_ctl.size = size;
+    ret = crypto_cipher_ioctl(CRYPTO_CMD_TRNG_GET_MULTI_RANDOM, &trng_multi_ctl);
+    if (ret != TD_SUCCESS) {
+        printf("crypto_ioctl failed, ret is 0x%x\n", ret);
+        goto exit_close;
+    }
+
+exit_close:
+    crypto_cipher_close();
+    crypto_uapi_func_exit();
+    return ret;
+}
\ No newline at end of file
diff --git a/bsp/tzasc/README.md b/bsp/tzasc/README.md
new file mode 100644
index 0000000..c43c8e5
--- /dev/null
+++ b/bsp/tzasc/README.md
@@ -0,0 +1,2 @@
+# optee_tzasc
+
diff --git a/bsp/tzasc/include/memory_zone.h b/bsp/tzasc/include/memory_zone.h
new file mode 100644
index 0000000..aec3fe8
--- /dev/null
+++ b/bsp/tzasc/include/memory_zone.h
@@ -0,0 +1,71 @@
+#ifndef __MEMORY_ZONE_H__
+#define __MEMORY_ZONE_H__
+#include <stddef.h>
+#include <util.h>
+#include <io.h>
+#include <stddef.h>
+#include <util.h>
+#include <tee_api_types.h>
+#include <sys/queue.h>
+
+#define NPU_CLASS_NAME 64
+
+typedef struct smmz_info {
+    struct smmz_info *next;
+    char *name;
+    paddr_t addr;
+    paddr_size_t size;
+    int block_num;
+    int die_id;
+} smmz_info;
+
+#define LIST_FOR_SMMZ(tmp, smmz) for ((tmp) = (smmz); (tmp); (tmp) = (tmp)->next)
+
+#define CHECK_WRONG_ADDR(phys_addr, size, smmz)                                             \
+({                                                                                          \
+	smmz_info *tmp = NULL;                                                                  \
+	td_bool res = true;                                                                     \
+	LIST_FOR_SMMZ(tmp, smmz) {                                                              \
+		if ((phys_addr) >= tmp->addr && (phys_addr) + (size) <= tmp->addr + tmp->size) {    \
+			res = false;                                                                    \
+			break;                                                                          \
+		}                                                                                   \
+	}                                                                                       \
+	res;                                                                                    \
+})
+
+#define CHECK_WRONG_SIZE(size, smmz)                                                        \
+({                                                                                          \
+	smmz_info *tmp = NULL;                                                                  \
+	td_bool res = true;                                                                     \
+	LIST_FOR_SMMZ(tmp, smmz) {                                                              \
+		if ((size) <= tmp->size) {                                                          \
+			res = false;                                                                    \
+			break;                                                                          \
+		}                                                                                   \
+	}                                                                                       \
+	res;                                                                                    \
+})
+
+extern smmz_info *g_smmz1_info;
+extern smmz_info *g_smmz2_info;
+
+struct class_table_entry {
+    LIST_ENTRY(class_table_entry) link;
+    paddr_t addr;
+    paddr_size_t size;
+    int num;
+    char name[NPU_CLASS_NAME];
+};
+LIST_HEAD(class_table_list_head, class_table_entry);
+const struct class_table_list_head *get_npu_class_list(void);
+
+struct smmz1_created_mobj {
+    LIST_ENTRY(smmz1_created_mobj) link;
+    struct mobj *mobj;
+    paddr_t addr;
+    paddr_size_t size;
+};
+LIST_HEAD(smmz1_created_mobj_list_head, smmz1_created_mobj);
+struct mobj *smmz1_zone_get_mobj(paddr_t addr, ssize_t size);
+#endif
diff --git a/bsp/tzasc/include/tee_uuid_from_str.h b/bsp/tzasc/include/tee_uuid_from_str.h
new file mode 100644
index 0000000..f44d435
--- /dev/null
+++ b/bsp/tzasc/include/tee_uuid_from_str.h
@@ -0,0 +1,4 @@
+#ifndef __TEE_UUID_FROM_STR_H__
+#define __TEE_UUID_FROM_STR_H__
+TEE_Result tee_uuid_from_str(TEE_UUID *uuid, const char *s);
+#endif
diff --git a/bsp/tzasc/include/tzasc.h b/bsp/tzasc/include/tzasc.h
new file mode 100644
index 0000000..b57cebe
--- /dev/null
+++ b/bsp/tzasc/include/tzasc.h
@@ -0,0 +1,61 @@
+#ifndef __TZASC_H__
+#define __TZASC_H__
+#include <stddef.h>
+#include <util.h>
+#include <io.h>
+#include <stddef.h>
+#include <util.h>
+#include <tee_api_types.h>
+#include <sys/queue.h>
+
+#define SECURE_READ (1 << 0)
+#define SECURE_WRITE (1 << 1)
+#define NON_SECURE_READ	(1 << 2)
+#define NON_SECURE_WRITE (1 << 3)
+
+struct tzasc_attr {
+    enum {
+        SRW_NSRW = SECURE_READ | SECURE_WRITE | NON_SECURE_READ |
+            NON_SECURE_WRITE,
+        SRW_NSRO = SECURE_READ | SECURE_WRITE | NON_SECURE_READ,
+        SRW_NSWO = SECURE_READ | SECURE_WRITE | NON_SECURE_WRITE,
+        SRW_NSUA = SECURE_READ | SECURE_WRITE,
+        SRO_NSUA = SECURE_READ,
+        SWO_NSUA = SECURE_WRITE,
+    } sp;
+    bool mid_en;
+    bool mid_inv;
+    int mid;
+};
+
+struct tzasc_range {
+    paddr_t addr;
+    paddr_size_t size;
+};
+
+struct tzasc_region {
+    LIST_ENTRY(tzasc_region) link;
+    uint8_t tzasc_region_num;
+    struct tzasc_range range;
+    struct tzasc_attr attr;
+};
+
+typedef struct tzasc_instance {
+    paddr_t base;
+    uint8_t num_regions;
+    uint8_t align_bits;
+    uint8_t num_masters;
+    uint8_t regions_allocated;
+} tzasc_regs;
+
+// Notice: addr and size of function "tzasc_set_rgn_map" must align to 4K
+TEE_Result tzasc_setup(const struct tzasc_region region, int die_id);
+
+// return: if zone type not found, tzasc_rgn_range.size = 0
+struct tzasc_range tzasc_get_range(int zone);
+
+// return: if no matching zone are found, return -1
+int tzasc_get_zone_num_by_phys(unsigned long long phys, unsigned long long size);
+
+bool tzasc_is_secure_buffer_range(unsigned long long phys, unsigned long long size);
+#endif /* __TZASC_H__ */
diff --git a/bsp/tzasc/memory_zone.c b/bsp/tzasc/memory_zone.c
new file mode 100644
index 0000000..0ab68b5
--- /dev/null
+++ b/bsp/tzasc/memory_zone.c
@@ -0,0 +1,474 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: memery_layout
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <kernel/boot.h>
+#include <kernel/dt.h>
+#include <libfdt.h>
+#include <memory_zone.h>
+#include <tee/uuid.h>
+#include <tee_uuid_from_str.h>
+#include <trace.h>
+#include <tzasc.h>
+#include "securec.h"
+#include "string.h"
+#include "tee_api_types.h"
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+#include "mmz_smmz_shared.h"
+#endif
+
+#define RANGE_NAME_LEN 64
+#define MAX_UUID_NUM 8
+#define NPU_CLASS_ALIGN 12  // 4K align
+#define MAX_MEMORY_ZONE 256
+
+struct zone_range {
+    paddr_t start_addr;
+    ssize_t size;
+    bool sec;
+    int master_id;
+    int die_id;
+};
+
+// property read from device tree
+struct memory_zone_dt_property {
+    char range_name[RANGE_NAME_LEN];
+    bool is_npu_zone;
+    bool is_smmz1_zone;
+    bool is_sec_zone;
+    int npu_class;
+    paddr_t phys_addr;
+    ssize_t size;
+    int master_id;
+    int die_id;
+    int uuid_num;
+    const char *uuid[MAX_UUID_NUM];
+};
+
+smmz_info *g_smmz1_info = NULL;
+smmz_info *g_smmz2_info = NULL;
+
+static const char *dt_memory_zone_match_table = {"vendor,memory_zone"};
+static struct class_table_list_head npu_class_list __nex_data =
+    LIST_HEAD_INITIALIZER(class_table_list_head);
+static struct smmz1_created_mobj_list_head smmz1_created_mobj_list __nex_data =
+    LIST_HEAD_INITIALIZER(smmz1_created_mobj_list_head);
+
+static bool fdt_prop_is_okay(const void *fdt, int node, const char *name)
+{
+    const char *prop;
+    int len;
+    prop = fdt_getprop(fdt, node, name, &len);
+    if (prop) {
+        return !strncmp(prop, "okay", len);
+    }
+    return false;
+}
+
+static TEE_Result fdt_read_num(const void *fdt, int node, const char *name,
+                               int *num)
+{
+    const fdt32_t *cuint = NULL;
+
+    cuint = fdt_getprop(fdt, node, name, NULL);
+    if (!cuint) {
+        return TEE_ERROR_BAD_FORMAT;
+    }
+    *num = (int)fdt32_to_cpu(*cuint);
+    return TEE_SUCCESS;
+}
+
+static TEE_Result zone_prop_uuid_push(struct memory_zone_dt_property *prop,
+                                      const char *str)
+{
+    if (prop->uuid_num >= MAX_UUID_NUM) {
+        return TEE_ERROR_OVERFLOW;
+    }
+    prop->uuid[prop->uuid_num] = str;
+    prop->uuid_num++;
+    return TEE_SUCCESS;
+}
+
+// if read error return property, phys_addr = DT_INFO_INVALID_REG
+static struct memory_zone_dt_property dt_read_node(const void *fdt, int node)
+{
+    const char *range_name, *uuid_buff;
+    bool is_npu_zone, is_sec_zone, is_smmz1_zone;
+    int npu_class;
+    paddr_t phys_addr;
+    ssize_t size;
+    struct memory_zone_dt_property prop = {
+        .phys_addr = DT_INFO_INVALID_REG, .uuid_num = 0, .uuid = {NULL}};
+
+    phys_addr = _fdt_reg_base_address(fdt, node);
+    if (phys_addr == DT_INFO_INVALID_REG || phys_addr == 0) {
+        DMSG("fdt node: %d, parase error", node);
+        goto error_out;
+    }
+
+    size = _fdt_reg_size(fdt, node);
+    if (size <= 0) {
+        DMSG("fdt node: %d, parase error", node);
+        goto error_out;
+    }
+
+    if (!fdt_prop_is_okay(fdt, node, "status")) {
+        DMSG("fdt node: %d, status disabled skip this node.", node);
+        goto error_out;
+    }
+
+    is_sec_zone = fdt_prop_is_okay(fdt, node, "secure-node");
+    is_npu_zone = fdt_prop_is_okay(fdt, node, "npuclass-zone");
+    is_smmz1_zone = fdt_prop_is_okay(fdt, node, "smmz1-zone");
+
+    if ((is_npu_zone || is_smmz1_zone) && !is_sec_zone) {
+        DMSG("fdt node: %d, parase error: npu zone or smmz1 zone but not "
+             "secure zone.",
+             node);
+        goto error_out;
+    }
+
+    range_name = fdt_getprop(fdt, node, "zone-name", NULL);
+    if (is_npu_zone || is_smmz1_zone) {
+        if (range_name == NULL) {
+            DMSG("fdt node: %d, parase error", node);
+            goto error_out;
+        } else {
+            if (strcpy_s(prop.range_name, RANGE_NAME_LEN, range_name)) {
+                DMSG("fdt node: %d, parase error", node);
+                goto error_out;
+            }
+        }
+    }
+
+    if (is_npu_zone) {
+        fdt32_t *cuint = NULL;
+
+        if (!(cuint = fdt_getprop(fdt, node, "npuclass-num", NULL))) {
+            DMSG("fdt node: %d, parase error", node);
+            goto error_out;
+        }
+        npu_class = (int)fdt32_to_cpu(*cuint);
+    }
+
+    if (is_smmz1_zone) {
+        if ((uuid_buff = fdt_getprop(fdt, node, "uuids", NULL)) != NULL) {
+            const char *current, *pre;
+            for (current = uuid_buff, pre = "";
+                 *current != '\0' || *pre != '\0';
+                 current = current + 1) {
+                if (*pre == '\0') {
+                    zone_prop_uuid_push(&prop, current);
+                }
+                pre = current;
+            }
+        }
+    }
+
+    for (int i = 0; i < prop.uuid_num; i++) {
+        DMSG("UUID: %s\n", prop.uuid[i]);
+    }
+    prop.phys_addr = phys_addr;
+    prop.size = size;
+    prop.is_npu_zone = is_npu_zone;
+    prop.is_smmz1_zone = is_smmz1_zone;
+    prop.is_sec_zone = is_sec_zone;
+    prop.npu_class = npu_class;
+
+    if (fdt_read_num(fdt, node, "master-id", &prop.master_id) != TEE_SUCCESS) {
+        prop.master_id = -1;
+    }
+    if (fdt_read_num(fdt, node, "die-id", &prop.die_id) != TEE_SUCCESS) {
+        prop.die_id = 0; // 0 is the first die
+    }
+    return prop;
+error_out:
+    prop.phys_addr = DT_INFO_INVALID_REG;
+    return prop;
+}
+
+static bool is_4k_align(paddr_t addr)
+{
+    paddr_t align_mask = (1 << NPU_CLASS_ALIGN) - 1;
+    return !(addr & align_mask);
+}
+
+const struct class_table_list_head *get_npu_class_list(void)
+{
+    return &npu_class_list;
+}
+
+static TEE_Result regist_to_npu_class_list(const struct class_table_entry *node)
+{
+    struct class_table_entry *node_on_list;
+    if (node == NULL) {
+        DMSG("regist smmz error!!!");
+        return TEE_ERROR_NO_DATA;
+    }
+
+    if (!is_4k_align(node->size) || !is_4k_align(node->addr)) {
+        DMSG("regist smmz error!!!");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    node_on_list = nex_calloc(1, sizeof(*node_on_list));
+    if (node_on_list == NULL) {
+        DMSG("regist smmz error!!!");
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    *node_on_list = *node;
+    LIST_INSERT_HEAD(&npu_class_list, node_on_list, link);
+    return TEE_SUCCESS;
+}
+
+static void regist_dt_prop_to_npu_class_list(
+    struct memory_zone_dt_property prop)
+{
+    struct class_table_entry ct_node = {
+        .addr = prop.phys_addr,
+        .size = prop.size,
+        .num = prop.npu_class,
+    };
+
+    if (strcpy_s(ct_node.name, NPU_CLASS_NAME, prop.range_name)) {
+        panic("npu class table regist error!!!");
+    }
+
+    if (regist_to_npu_class_list(&ct_node)) {
+        panic("npu class table regist error!!!");
+    }
+}
+
+#ifdef CFG_MMZ_SUPPORT
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+static void regist_dt_prop_to_smmz1(struct memory_zone_dt_property prop)
+{
+    struct smmz1_info *mmz;
+    const ssize_t mmz_size = sizeof(*mmz) + sizeof(TEE_UUID) * prop.uuid_num;
+
+    mmz = nex_calloc(1, mmz_size);
+    if (mmz == NULL) {
+        panic("npu class table regist error!!!");
+    }
+
+    mmz->size = prop.size;
+    mmz->uuid_num = prop.uuid_num;
+    mmz->phys_addr = prop.phys_addr;
+    for (int i = 0; i < prop.uuid_num; i++) {
+        if (tee_uuid_from_str(&mmz->uuids[i], prop.uuid[i])) {
+            panic("npu class table regist error!!!");
+        }
+    }
+
+    if (register_smmz1_block(mmz) != TEE_SUCCESS) {
+        panic("npu class table regist error!!!");
+    }
+
+    nex_free(mmz);
+}
+
+static void create_smmz1_mobj(struct memory_zone_dt_property prop)
+{
+    struct smmz1_created_mobj *node;
+    node = calloc(1, sizeof(*node));
+    if (node == NULL) {
+        panic("regist smmz mobj error!!!");
+    }
+
+    node->mobj = mobj_phys_alloc(
+        prop.phys_addr, prop.size, TEE_MATTR_MEM_TYPE_CACHED, CORE_MEM_SDP_MEM);
+    if (node->mobj == NULL) {
+        panic("regist smmz mobj error!!!");
+    }
+
+    node->size = prop.size;
+    node->addr = prop.phys_addr;
+    LIST_INSERT_HEAD(&smmz1_created_mobj_list, node, link);
+}
+
+struct mobj *smmz1_zone_get_mobj(paddr_t addr, ssize_t size)
+{
+    struct smmz1_created_mobj *node;
+    LIST_FOREACH(node, &smmz1_created_mobj_list, link)
+    {
+        if (node->addr <= addr && node->addr + node->size >= addr + size) {
+            return node->mobj;
+        }
+    }
+    return NULL;
+}
+#endif
+#endif
+
+static int cmd_start_addr(const void *r0, const void *r1)
+{
+    return ((struct zone_range *)r0)->start_addr -
+           ((struct zone_range *)r1)->start_addr;
+}
+
+static inline bool is_contiguous_regions(struct zone_range *r0,
+                                         struct zone_range *r1)
+{
+    if (r0->start_addr + r0->size == r1->start_addr) {
+        return true;
+    }
+    return false;
+}
+
+static inline bool tzasc_prop_same(struct zone_range *r0, struct zone_range *r1)
+{
+    return (r0->master_id == r1->master_id) && (r0->sec == r1->sec) && (r0->die_id == r1->die_id);
+}
+
+// return array length after merged
+static ssize_t merge_regions(struct zone_range *ranges, ssize_t len)
+{
+    ssize_t array_tail_after_merged = 0;
+    int current;
+
+    if (len == 0) {
+        return 0;
+    }
+
+    qsort(ranges, len, sizeof(*ranges), cmd_start_addr);
+    for (current = 1; current < len; current++) {
+        struct zone_range *tail = &ranges[array_tail_after_merged];
+        struct zone_range *curr = &ranges[current];
+        if (is_contiguous_regions(tail, curr) && tzasc_prop_same(tail, curr)) {
+            ranges[array_tail_after_merged].size =
+                curr->start_addr + curr->size - tail->start_addr;
+        } else {
+            array_tail_after_merged++;
+            ranges[array_tail_after_merged] = ranges[current];
+        }
+    }
+
+    // array length after merged
+    return array_tail_after_merged + 1;
+}
+
+static void insert_smmz(smmz_info **smmz, struct memory_zone_dt_property prop)
+{
+    smmz_info *cur = NULL;
+    smmz_info *tmp = (smmz_info *)malloc(sizeof(smmz_info));
+    if (tmp == NULL) {
+        panic("malloc failed!\n");
+    }
+
+    tmp->addr = prop.phys_addr;
+    tmp->size = prop.size;
+    tmp->name = prop.range_name;
+    tmp->die_id = prop.die_id;
+    tmp->next = NULL;
+
+    if (*smmz == NULL) {
+        tmp->block_num = 1;
+        *smmz = tmp;
+    } else {
+        (*smmz)->block_num += 1;
+        cur = (*smmz)->next;
+        (*smmz)->next = tmp;
+        tmp->next = cur;
+    }
+}
+
+static void memory_zone_dt_probe(void *fdt)
+{
+    int node =
+        fdt_node_offset_by_compatible(fdt, 0, dt_memory_zone_match_table);
+    struct zone_range range_list[MAX_MEMORY_ZONE];
+    ssize_t list_len = 0;
+    for (; node != -FDT_ERR_NOTFOUND;
+         node = fdt_node_offset_by_compatible(
+             fdt, node, dt_memory_zone_match_table)) {
+        struct memory_zone_dt_property prop = dt_read_node(fdt, node);
+
+        if (prop.phys_addr == DT_INFO_INVALID_REG) {
+            DMSG("warr: skip a memory zone");
+            continue;
+        }
+
+        if (list_len >= MAX_MEMORY_ZONE) {
+            panic("too many memory zone!!!!!");
+        }
+
+        if (prop.is_npu_zone) {
+            regist_dt_prop_to_npu_class_list(prop);
+        }
+
+#ifdef CFG_MMZ_SUPPORT
+#ifdef CFG_SMMZ_SHARED_SUPPORT
+        if (prop.is_sec_zone && prop.is_smmz1_zone) {
+            regist_dt_prop_to_smmz1(prop);
+            insert_smmz(
+                &g_smmz1_info, prop);
+        } else if (prop.is_sec_zone) {
+            insert_smmz(
+                &g_smmz2_info, prop);
+        }
+
+        if (prop.is_npu_zone && prop.is_smmz1_zone) {
+            create_smmz1_mobj(prop);
+        }
+#else
+        if (prop.is_sec_zone) {
+            insert_smmz(&g_smmz2_info, prop);
+        }
+#endif
+#endif
+
+        range_list[list_len].start_addr = prop.phys_addr;
+        range_list[list_len].size = prop.size;
+        range_list[list_len].master_id = prop.master_id;
+        range_list[list_len].die_id = prop.die_id;
+        range_list[list_len].sec = prop.is_sec_zone;
+        list_len++;
+    }
+
+    list_len = merge_regions(range_list, list_len);
+    for (int i = 0; i < list_len; i++) {
+        struct tzasc_region region = {
+            .range = {.size = range_list[i].size,
+                      .addr = range_list[i].start_addr}};
+
+        if (range_list[i].master_id != -1) {
+            region.attr.mid_en = 1;
+            region.attr.mid_inv = 0;
+            region.attr.mid = range_list[i].master_id;
+        }
+
+        if (range_list[i].sec) {
+            region.attr.sp = SRW_NSUA;
+        } else {
+            region.attr.sp = SRW_NSRW;
+        }
+
+        tzasc_setup(region, range_list[i].die_id);
+    }
+}
+
+static TEE_Result memory_zone_init(void)
+{
+    const struct class_table_list_head *class_list;
+    struct class_table_entry *node;
+    void *fdt = get_embedded_dt();
+    memory_zone_dt_probe(fdt);
+    class_list = get_npu_class_list();
+
+    LIST_FOREACH(node, class_list, link)
+    {
+        DMSG("class_name:%s\t"
+             "class_num:%d\t"
+             "class_range:%lx-%lx\t",
+             node->name,
+             node->num,
+             node->addr,
+             node->addr + node->size);
+    }
+    return TEE_SUCCESS;
+}
+early_init(memory_zone_init);
diff --git a/bsp/tzasc/sub.mk b/bsp/tzasc/sub.mk
new file mode 100644
index 0000000..38012e1
--- /dev/null
+++ b/bsp/tzasc/sub.mk
@@ -0,0 +1,8 @@
+ifeq ($(CFG_MMZ_SUPPORT), y)
+global-incdirs-y += ../mmz/lib/include
+global-incdirs-y += ../mmz/drivers/src/include
+endif
+global-incdirs-y += ./include
+srcs-y += memory_zone.c
+srcs-$(CFG_TZASC) += tzasc.c
+srcs-y += ../../lib/libutee/tee_uuid_from_str.c
diff --git a/bsp/tzasc/tee_uuid_from_str.c b/bsp/tzasc/tee_uuid_from_str.c
new file mode 100644
index 0000000..490646a
--- /dev/null
+++ b/bsp/tzasc/tee_uuid_from_str.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2019, Linaro Limited
+ */
+
+#include <ctype.h>
+#include <stdint.h>
+#include <string.h>
+#include <tee_api_types.h>
+#include <tee_uuid_from_str.h>
+
+static int hex(char c)
+{
+	char hexc = tolower(c);
+
+	if (isdigit(hexc)) {
+		return hexc - '0';
+    }
+	if (isxdigit(hexc)){
+		return hexc - 'a' + 10;
+    }
+	return -1;
+}
+
+static uint32_t parse_hex(const char *s, size_t nchars, uint32_t *ret)
+{
+    int c = 0;
+    size_t n = 0;
+	uint32_t val = 0;
+
+	for (n = 0; n < nchars; n++) {
+		c = hex(s[n]);
+		if (c == -1) {
+			*ret = TEE_ERROR_BAD_FORMAT;
+			goto out;
+		}
+		val = (val << 4) + c;
+	}
+	*ret = TEE_SUCCESS;
+out:
+	return val;
+}
+
+// uuid format: u.timeLow - u.timeMid - u.timeHiAndVersion - u.clockSeqAndNode
+// length:     |<---8---->|<----4---->|<---------4-------->|<-4->|<----12---->|
+TEE_Result tee_uuid_from_str(TEE_UUID *uuid, const char *s)
+{
+	TEE_Result ret = TEE_SUCCESS;
+	TEE_UUID u = { };
+    size_t i = 0;
+	const char *q = s;
+
+// maximum length of uuid
+	if (!q || strnlen(q, 37) != 36) {
+		return TEE_ERROR_BAD_FORMAT;
+    }
+
+// separator of uuid
+	if (q[8] != '-' || q[13] != '-' || q[18] != '-' || q[23] != '-') {
+		return TEE_ERROR_BAD_FORMAT;
+    }
+
+// obtain u.timeLow
+	u.timeLow = parse_hex(q, 8, &ret);
+	if (ret) {
+		goto out;
+    }
+	q += 9;
+
+// obtain u.timeMid
+	u.timeMid = parse_hex(q, 4, &ret);
+	if (ret) {
+		goto out;
+    }
+	q += 5;
+
+// obtain u.timeHiAndVersion
+	u.timeHiAndVersion = parse_hex(q, 4, &ret);
+	if (ret) {
+		goto out;
+    }
+	q += 5;
+
+// obtain u.clockSeqAndNode
+	for (i = 0; i < 8; i++) {
+		u.clockSeqAndNode[i] = parse_hex(q, 2, &ret);
+		if (ret) {
+			goto out;
+        }
+		if (i == 1) {
+			q += 3;
+        } else {
+			q += 2;
+        }
+	}
+	*uuid = u;
+out:
+	return ret;
+}
diff --git a/bsp/tzasc/tzasc.c b/bsp/tzasc/tzasc.c
new file mode 100644
index 0000000..98c6090
--- /dev/null
+++ b/bsp/tzasc/tzasc.c
@@ -0,0 +1,325 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: TZASC
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <assert.h>
+#include <kernel/panic.h>
+#include <mm/core_memprot.h>
+#include <stddef.h>
+#include <trace.h>
+#include <util.h>
+#include "tee_api_types.h"
+#include "tzasc_plat_conf.h"
+
+#define TZASC_ATTR_SEC_R (0x5 << 28)
+#define TZASC_ATTR_SEC_W (0x5 << 24)
+#define TZASC_ATTR_NOSEC_R (0x5 << 20)
+#define TZASC_ATTR_NOSEC_W (0x5 << 16)
+#define TZASC_ATTR_MID_INV (1 << 9)
+#define TZASC_ATTR_MID_EN (1 << 8)
+#define TZASC_ATTR_SEC_INV (1 << 4)
+
+#define TZASC_RGN_MAP_EXT_REG_OFFSET 0x200
+#define TZASC_RGN_MAP_REG_OFFSET 0x100
+#define TZASC_RGN_ATTR_REG 0x104
+#define TZASC_BYPASS_REG_OFFSET 0x004
+
+#define TZASC_BYPASS_DIS 0x00
+#define TZASC_REGION_EN 1
+
+#define ZONE_NOT_FIND (-1)
+#define STORAGE_PERMISSION_EN 0b0101
+
+typedef union {
+    struct {
+        unsigned rgn_base_addr : 22;  // [21:0]
+        unsigned reserved : 9;        // [30:22]
+        unsigned rgn_en : 1;          // [31]
+    } bits;
+    uint32_t u32;
+} sec_rgn_map;
+
+typedef union {
+    struct {
+        unsigned rgn_size : 24;  // [23:0]
+        unsigned reserved : 8;   // [31:24]
+    } bits;
+    uint32_t u32;
+} sec_rgn_map_ext;
+
+typedef union {
+    struct {
+        unsigned sp : 4;              // [3:0]
+        unsigned security_inv : 1;    // [4]
+        unsigned reserved_1 : 3;      // [7:5]
+        unsigned mid_en : 1;          // [8]
+        unsigned mid_inv : 1;         // [9]
+        unsigned reserved_0 : 6;      // [15:10]
+        unsigned tee_sp_nosec_w : 4;  // [19:16]
+        unsigned tee_sp_nosec_r : 4;  // [23:20]
+        unsigned tee_sp_sec_w : 4;    // [27:24]
+        unsigned tee_sp_sec_r : 4;    // [31:28]
+    } bits;
+    uint32_t u32;
+} sec_rgn_attr;
+
+static int die_id = 0;
+static LIST_HEAD(tzasc_layout_list_head, tzasc_region) tzasc_layout_list
+    __nex_data = LIST_HEAD_INITIALIZER(tzasc_layout_list_head);
+
+static inline void set_die_id(int newValue) {
+    die_id = newValue;
+}
+
+static inline uint32_t tzasc_read32(vaddr_t addr)
+{
+    DMSG("tzasc read addr:%p", (void *)addr);
+    return io_read32(addr);
+}
+
+static inline void tzasc_write32(vaddr_t addr, uint32_t val)
+{
+    DMSG("tzasc write addr:%p, val: 0x%x", (void *)addr, val);
+    io_write32(addr, val);
+}
+
+static paddr_t tzasc_rgn_offset(uint8_t rgn)
+{
+    return (0x10 * (rgn));
+}
+
+static inline vaddr_t tzasc_regremap(paddr_t paddr)
+{
+    return (vaddr_t)phys_to_virt(paddr, MEM_AREA_IO_SEC, 1);
+}
+
+static paddr_t get_sec_rgn_map_reg(uint8_t rgn)
+{
+    return tzasc[die_id].base + tzasc_rgn_offset(rgn) + TZASC_RGN_MAP_REG_OFFSET;
+}
+
+static paddr_t get_sec_rgn_map_ext_reg(uint8_t rgn)
+{
+    return tzasc[die_id].base + tzasc_rgn_offset(rgn) + TZASC_RGN_MAP_EXT_REG_OFFSET;
+}
+
+static paddr_t get_sec_rgn_attr_reg(uint8_t rgn)
+{
+    return tzasc[die_id].base + tzasc_rgn_offset(rgn) + TZASC_RGN_ATTR_REG;
+}
+
+static sec_rgn_attr tzasc_get_attr_val(struct tzasc_attr attr)
+{
+    sec_rgn_attr attr_val;
+    attr_val.u32 = 0;
+
+    if (attr.sp & SECURE_READ) {
+        attr_val.bits.tee_sp_sec_r = STORAGE_PERMISSION_EN;
+    }
+
+    if (attr.sp & SECURE_WRITE) {
+        attr_val.bits.tee_sp_sec_w = STORAGE_PERMISSION_EN;
+    }
+
+    if (attr.sp & NON_SECURE_READ) {
+        attr_val.bits.tee_sp_nosec_r = STORAGE_PERMISSION_EN;
+    }
+
+    if (attr.sp & NON_SECURE_WRITE) {
+        attr_val.bits.tee_sp_nosec_w = STORAGE_PERMISSION_EN;
+    }
+
+    return attr_val;
+}
+
+static void tzasc_set_rgn_attr(uint8_t rgn, struct tzasc_attr attr)
+{
+    vaddr_t attr_reg_addr = tzasc_regremap(get_sec_rgn_attr_reg(rgn));
+    sec_rgn_attr attr_val = tzasc_get_attr_val(attr);
+    if (attr_reg_addr == 0) {
+        return;
+    }
+
+    tzasc_write32(attr_reg_addr, attr_val.u32);
+}
+
+static void tzasc_rgn_enable(uint8_t rgn)
+{
+    vaddr_t reg_addr = tzasc_regremap(get_sec_rgn_map_reg(rgn));
+    sec_rgn_map map_reg;
+
+    if (reg_addr == 0) {
+        return;
+    }
+
+    map_reg.u32 = tzasc_read32(reg_addr);
+    map_reg.bits.rgn_en = TZASC_REGION_EN;
+
+    tzasc_write32(reg_addr, map_reg.u32);
+}
+
+static void tzasc_set_rgn_map(uint8_t rgn, struct tzasc_range range)
+{
+    vaddr_t map_reg_addr = tzasc_regremap(get_sec_rgn_map_reg(rgn));
+    vaddr_t map_ext_reg_addr = tzasc_regremap(get_sec_rgn_map_ext_reg(rgn));
+
+    sec_rgn_map map_reg;
+    sec_rgn_map_ext map_ext_reg;
+
+    if ((map_reg_addr == 0) || (map_ext_reg_addr == 0)) {
+        return;
+    }
+
+    map_reg.u32 = tzasc_read32(map_reg_addr);
+    map_ext_reg.u32 = tzasc_read32(map_ext_reg_addr);
+
+    map_reg.bits.rgn_base_addr = range.addr >> tzasc[die_id].align_bits;
+    map_ext_reg.bits.rgn_size = range.size >> tzasc[die_id].align_bits;
+
+    tzasc_write32(map_reg_addr, map_reg.u32);
+    tzasc_write32(map_ext_reg_addr, map_ext_reg.u32);
+}
+
+// r1.addr < r2.addr
+static inline bool __range_intersected(struct tzasc_range r1,
+                                       struct tzasc_range r2)
+{
+    return r1.size > (r2.addr - r1.addr);
+}
+
+static bool range_intersected(struct tzasc_range r1, struct tzasc_range r2)
+{
+    if (r1.addr < r2.addr) {
+        return __range_intersected(r1, r2);
+    }
+
+    return __range_intersected(r2, r1);
+}
+
+static bool tzasc_check_zone_overlap(struct tzasc_range range)
+{
+    struct tzasc_region *node;
+    LIST_FOREACH(node, &tzasc_layout_list, link)
+    {
+        if (range_intersected(range, node->range)) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+static bool is_align(paddr_t addr)
+{
+    paddr_t align_mask = (1 << tzasc[die_id].align_bits) - 1;
+    return !(addr & align_mask);
+}
+
+static bool range_align(const struct tzasc_range *range)
+{
+    return is_align(range->addr) && is_align(range->size);
+}
+
+// If tzasc has no remaining regions, return 0
+static uint8_t alloc_tzasc_region_num(void)
+{
+    if (tzasc[die_id].regions_allocated >= tzasc[die_id].num_regions) {
+        DMSG("Tzasc has no remaining regions.");
+        return 0;
+    }
+
+    return tzasc[die_id].regions_allocated++;
+}
+
+TEE_Result tzasc_setup(const struct tzasc_region region, int die_id)
+{
+    struct tzasc_region *node = NULL;
+
+    set_die_id(die_id);
+
+    if (!range_align(&region.range)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (tzasc_check_zone_overlap(region.range)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    node = nex_calloc(1, sizeof(*node));
+    if (node == NULL) {
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    *node = region;
+    if ((node->tzasc_region_num = alloc_tzasc_region_num()) == 0) {
+        nex_free(node);
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+    DMSG("node->zone:%lx-%lx",
+         node->range.addr,
+         node->range.addr + node->range.size);
+    tzasc_set_rgn_map(node->tzasc_region_num, node->range);
+    tzasc_set_rgn_attr(node->tzasc_region_num, node->attr);
+    tzasc_rgn_enable(node->tzasc_region_num);
+
+    LIST_INSERT_HEAD(&tzasc_layout_list, node, link);
+    return TEE_SUCCESS;
+}
+
+struct tzasc_range tzasc_get_range(int zone)
+{
+    struct tzasc_region *node;
+    struct tzasc_range not_find = {.size = 0};
+    LIST_FOREACH(node, &tzasc_layout_list, link)
+    {
+        if (node->tzasc_region_num == zone)
+            return node->range;
+    }
+    return not_find;
+}
+
+static bool range_contains(struct tzasc_range r1, struct tzasc_range r2)
+{
+    return r1.addr <= r2.addr && r1.size >= r2.size;
+}
+
+int tzasc_get_zone_num_by_phys(unsigned long long phys, unsigned long long size)
+{
+    struct tzasc_region *node;
+    struct tzasc_range range = {
+        .addr = phys,
+        .size = size,
+    };
+
+    LIST_FOREACH(node, &tzasc_layout_list, link)
+    {
+        if (range_contains(node->range, range)) {
+            return node->tzasc_region_num;
+        }
+    }
+
+    return ZONE_NOT_FIND;
+}
+
+bool tzasc_is_secure_buffer_range(unsigned long long phys,
+                                  unsigned long long size)
+{
+    struct tzasc_region *node;
+    struct tzasc_range range = {
+        .addr = phys,
+        .size = size,
+    };
+
+    LIST_FOREACH(node, &tzasc_layout_list, link)
+    {
+        if (range_contains(node->range, range)) {
+            return node->attr.sp == SRW_NSUA;
+        }
+    }
+
+    return false;
+}
+register_phys_mem(MEM_AREA_IO_SEC, TZASC_REG_BASE, TZASC_REG_LEN);
diff --git a/bsp/tzasc/tzasc_plat_conf.h b/bsp/tzasc/tzasc_plat_conf.h
new file mode 100644
index 0000000..6f72fa3
--- /dev/null
+++ b/bsp/tzasc/tzasc_plat_conf.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: TZASC
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+#ifndef __TZASC_PLAT_CONF_H__
+#define __TZASC_PLAT_CONF_H__
+
+/*
+ * first step -  config dts: core/arch/arm/dts/xxx.dts
+ * second step - config tzasc_regs: tzasc[x]
+ */
+#include <tzasc.h>
+
+#define TZASC_REG_BASE 0x11141000
+#define TZASC_REG_LEN 0x1000
+
+#if defined(CFG_HI3516DV500) || defined(CFG_HI3519DV500) || defined(CFG_HI3559V300) || defined(CFG_HI3516CV610)
+tzasc_regs tzasc[1] = {
+    {.base = TZASC_REG_BASE,
+     .align_bits = 12,   // 4k alignment
+     .num_regions = 15,  // maximum number of areas
+     .num_masters = 0,   // not support
+     // reserved regions 3,
+     // region 0: not configurable
+     // region 1: reserved for all ddr
+     // region 2: reserved for all secure boot
+     .regions_allocated = 3}
+};
+#elif defined(CFG_HIXMATRIX)
+tzasc_regs tzasc[2] = {
+    {.base = TZASC_REG_BASE,
+     .align_bits = 12,   // 4k alignment
+     .num_regions = 15,  // maximum number of areas
+     .num_masters = 0,   // not support
+     // reserved regions 3,
+     // region 0: not configurable
+     // region 1: reserved for all ddr
+     // region 2: reserved for all secure boot
+     .regions_allocated = 3},
+    {.base = TZASC_REG_BASE + 0x200000,
+     .align_bits = 12,   // 4k alignment
+     .num_regions = 15,  // maximum number of areas
+     .num_masters = 0,   // not support
+     // reserved regions 3,
+     // region 0: not configurable
+     // region 1: reserved for all ddr
+     // region 2: reserved for all secure boot
+     .regions_allocated = 3}
+};
+#else
+#error "Unknown platform"
+#endif
+
+#endif /* __TZASC_PLAT_CONF_H__ */
diff --git a/core/arch/arm/arm.mk b/core/arch/arm/arm.mk
index a521435..cc119ac 100644
--- a/core/arch/arm/arm.mk
+++ b/core/arch/arm/arm.mk
@@ -254,7 +254,9 @@ endif
 
 # Provide default supported-ta-targets if not set by the platform config
 ifeq (,$(supported-ta-targets))
+ifeq ($(CFG_ARM32_core),y)
 supported-ta-targets = ta_arm32
+endif
 ifeq ($(CFG_ARM64_core),y)
 supported-ta-targets += ta_arm64
 endif
diff --git a/core/arch/arm/dts/hi3516cv610.dts b/core/arch/arm/dts/hi3516cv610.dts
new file mode 100755
index 0000000..ff239da
--- /dev/null
+++ b/core/arch/arm/dts/hi3516cv610.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+
+/ {
+   #address-cells = <2>;
+   #size-cells = <2>;
+
+	smmz2: smmz@2 {
+		compatible = "vendor,memory_zone";
+		reg = <0x0 0x43002000 0x0 0x400000>;
+		secure-node = "okay";
+		status = "okay";
+	};
+};
diff --git a/core/arch/arm/dts/hi3516dv500.dts b/core/arch/arm/dts/hi3516dv500.dts
new file mode 100644
index 0000000..7e9bba1
--- /dev/null
+++ b/core/arch/arm/dts/hi3516dv500.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+#include "memory_layout.dtsi"
+
+/ {
+	smmz2: smmz@2 {
+		compatible = "vendor,memory_zone";
+		reg = <0x0 0x41030000 0x0 0x800000>;
+		secure-node = "okay";
+		status = "okay";
+	};
+};
diff --git a/core/arch/arm/dts/hi3519dv500.dts b/core/arch/arm/dts/hi3519dv500.dts
new file mode 100644
index 0000000..7e9bba1
--- /dev/null
+++ b/core/arch/arm/dts/hi3519dv500.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+#include "memory_layout.dtsi"
+
+/ {
+	smmz2: smmz@2 {
+		compatible = "vendor,memory_zone";
+		reg = <0x0 0x41030000 0x0 0x800000>;
+		secure-node = "okay";
+		status = "okay";
+	};
+};
diff --git a/core/arch/arm/dts/hi3559v300.dts b/core/arch/arm/dts/hi3559v300.dts
new file mode 100644
index 0000000..7e9bba1
--- /dev/null
+++ b/core/arch/arm/dts/hi3559v300.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+#include "memory_layout.dtsi"
+
+/ {
+	smmz2: smmz@2 {
+		compatible = "vendor,memory_zone";
+		reg = <0x0 0x41030000 0x0 0x800000>;
+		secure-node = "okay";
+		status = "okay";
+	};
+};
diff --git a/core/arch/arm/dts/memory_layout.dtsi b/core/arch/arm/dts/memory_layout.dtsi
new file mode 100644
index 0000000..fe7c696
--- /dev/null
+++ b/core/arch/arm/dts/memory_layout.dtsi
@@ -0,0 +1,217 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/ {
+   #address-cells = <2>;
+   #size-cells = <2>;
+
+   npu_tee1: mmz_tee@1 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x41830000 0x0 0x2000000>;
+
+       zone-name = "tee_zone1";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <1>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee2: mmz_tee@2 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x43830000 0x0 0x800000>;
+
+       zone-name = "tee_zone2";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <2>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee3: mmz_tee@3 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44030000 0x0 0x400000>;
+
+       zone-name = "tee_zone3";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <3>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee4: mmz_tee@4 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44430000 0x0 0x100000>;
+
+       zone-name = "tee_zone4";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <4>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee5: mmz_tee@5 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44530000 0x0 0x100000>;
+
+       zone-name = "tee_zone5";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <5>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee6: mmz_tee@6 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44630000 0x0 0x100000>;
+
+       zone-name = "tee_zone6";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <6>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee7: mmz_tee@7 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44730000 0x0 0x100000>;
+
+       zone-name = "tee_zone7";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <7>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee8: mmz_tee@8 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44830000 0x0 0x100000>;
+
+       zone-name = "tee_zone8";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <8>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee9: mmz_tee@9 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44930000 0x0 0x100000>;
+
+       zone-name = "tee_zone9";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <9>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee10: mmz_tee@10 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44A30000 0x0 0x100000>;
+
+       zone-name = "tee_zone10";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <10>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee11: mmz_tee@11 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44B30000 0x0 0x100000>;
+
+       zone-name = "tee_zone11";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <11>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee12: mmz_tee@12 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44C30000 0x0 0x100000>;
+
+       zone-name = "tee_zone12";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <12>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee13: mmz_tee@13 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44D30000 0x0 0x100000>;
+
+       zone-name = "tee_zone13";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <13>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee14: mmz_tee@14 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44E30000 0x0 0x100000>;
+
+       zone-name = "tee_zone14";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <14>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+   npu_tee15: mmz_tee@15 {
+       compatible = "vendor,memory_zone";
+       reg = <0x0 0x44F30000 0x0 0x100000>;
+
+       zone-name = "tee_zone15";
+       npuclass-zone = "okay";
+       smmz1-zone = "okay";
+
+       npuclass-num = <15>;
+       secure-node = "okay";
+       status = "okay";
+       uuids = "426e8f6f-ec74-427b-9424-0dd8f3f33706", "6d2a963c-bb9e-43e9-82c7-49f6517cccff";
+   };
+
+};
+
diff --git a/core/arch/arm/include/sm/optee_smc.h b/core/arch/arm/include/sm/optee_smc.h
index cd45917..7ffecaa 100644
--- a/core/arch/arm/include/sm/optee_smc.h
+++ b/core/arch/arm/include/sm/optee_smc.h
@@ -559,6 +559,24 @@
 /* See OPTEE_SMC_CALL_WITH_REGD_ARG above */
 #define OPTEE_SMC_FUNCID_CALL_WITH_REGD_ARG	U(19)
 
+/*
+ * dump secure world info
+ *
+ * dump secure world info, such as smmz used.
+ *
+ * Call register usage:
+ * a0   SMC Function ID, OPTEE_SMC_DUMP_DEBUG_INFO
+ * a1   debug info number
+ * a2-6 not use
+ * a7   Hypervisor Client ID register
+ *
+ * return register usage:
+ * a0-7 Preserved
+ */
+#define OPTEE_SMC_FUNCID_DUMP_DEBUG_INFO   20
+#define OPTEE_SMC_DUMP_DEBUG_INFO \
+    OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_DUMP_DEBUG_INFO)
+ 
 /*
  * Resume from RPC (for example after processing a foreign interrupt)
  *
diff --git a/core/arch/arm/include/tee/entry_fast.h b/core/arch/arm/include/tee/entry_fast.h
index 0f6fef8..cd2de97 100644
--- a/core/arch/arm/include/tee/entry_fast.h
+++ b/core/arch/arm/include/tee/entry_fast.h
@@ -30,4 +30,16 @@ size_t tee_entry_generic_get_api_call_count(void);
 void tee_entry_fast(struct thread_smc_args *args);
 void __tee_entry_fast(struct thread_smc_args *args);
 
+enum OPTEE_DEBUG_CMD {
+    DUMP_SMMZ1,
+    DUMP_SMMZ2,
+    INVALID_CMD
+};
+ 
+#ifdef CFG_OPTEE_DEBUG
+void register_debug_func(enum OPTEE_DEBUG_CMD cmd, void (*f)(void));
+#else
+static inline void register_debug_func(enum OPTEE_DEBUG_CMD cmd, void (*f)(void)) {(void)cmd;(void)f;};
+#endif
+ 
 #endif /* TEE_ENTRY_FAST_H */
diff --git a/core/arch/arm/kernel/link.mk b/core/arch/arm/kernel/link.mk
index 0e96e60..79c8766 100644
--- a/core/arch/arm/kernel/link.mk
+++ b/core/arch/arm/kernel/link.mk
@@ -60,9 +60,10 @@ link-script-cppflags := \
 		$(addprefix -I,$(incdirscore) $(link-out-dir)) \
 		$(cppflagscore))
 
+# add -s to avoid ICSL alarm
 ldargs-all_objs := -T $(link-script-dummy) --no-check-sections \
 		   $(link-ldflags-common) \
-		   $(link-objs) $(link-ldadd) $(libgcccore)
+		   $(link-objs) $(link-ldadd) $(libgcccore) -s
 cleanfiles += $(link-out-dir)/all_objs.o
 $(link-out-dir)/all_objs.o: $(objs) $(libdeps) $(MAKEFILE_LIST)
 	@$(cmd-echo-silent) '  LD      $@'
@@ -75,7 +76,7 @@ $(link-out-dir)/unpaged_entries.txt: $(link-out-dir)/all_objs.o
 		$(AWK) '/ ____keep_pager/ { printf "-u%s ", $$3 }' > $@
 
 unpaged-ldargs := -T $(link-script-dummy) --no-check-sections --gc-sections \
-		 $(link-ldflags-common)
+		 $(link-ldflags-common) -s
 unpaged-ldadd := $(objs) $(link-ldadd) $(libgcccore)
 cleanfiles += $(link-out-dir)/unpaged.o
 $(link-out-dir)/unpaged.o: $(link-out-dir)/unpaged_entries.txt
@@ -104,7 +105,7 @@ $(link-out-dir)/init_entries.txt: $(link-out-dir)/all_objs.o
 		$(AWK) '/ ____keep_init/ { printf "-u%s ", $$3 }' > $@
 
 init-ldargs := -T $(link-script-dummy) --no-check-sections --gc-sections \
-	       $(link-ldflags-common)
+	       $(link-ldflags-common) -s
 init-ldadd := $(link-objs-init) $(link-out-dir)/version.o  $(link-ldadd) \
 	      $(libgcccore)
 cleanfiles += $(link-out-dir)/init.o
diff --git a/core/arch/arm/plat-stm/.gitignore b/core/arch/arm/plat-stm/.gitignore
new file mode 100644
index 0000000..49b7bb9
--- /dev/null
+++ b/core/arch/arm/plat-stm/.gitignore
@@ -0,0 +1 @@
+System.map
diff --git a/core/arch/arm/plat-vendor/conf.mk b/core/arch/arm/plat-vendor/conf.mk
new file mode 100755
index 0000000..5f2fe6b
--- /dev/null
+++ b/core/arch/arm/plat-vendor/conf.mk
@@ -0,0 +1,28 @@
+PLATFORM_FLAVOR ?= hi3516dv500_demo
+
+hi3516dv500-flavorlist = hi3516dv500_demo
+hi3519dv500-flavorlist = hi3519dv500_demo
+hi3559v300-flavorlist = hi3559v300_demo
+hi3516cv610-flavorlist = hi3516cv610_demo
+
+PLATFORM = $(patsubst %_demo, %, $(PLATFORM_FLAVOR))
+
+CFG_SECUREC_LIB := y
+CFG_CORE_DYN_SHM=y
+CFG_CACHE_API=y
+CFG_TEE_CORE_LOG_LEVEL=0
+CFG_TEE_TA_LOG_LEVEL=0
+
+CONF_DIR = core/arch/arm/plat-vendor
+
+ifneq (,$(filter $(PLATFORM_FLAVOR),$(hi3516dv500-flavorlist)))
+include $(CONF_DIR)/hi3516dv500.mk
+else ifneq (,$(filter $(PLATFORM_FLAVOR),$(hi3519dv500-flavorlist)))
+include $(CONF_DIR)/hi3519dv500.mk
+else ifneq (,$(filter $(PLATFORM_FLAVOR),$(hi3559v300-flavorlist)))
+include $(CONF_DIR)/hi3559v300.mk
+else ifneq (,$(filter $(PLATFORM_FLAVOR),$(hi3516cv610-flavorlist)))
+include $(CONF_DIR)/hi3516cv610.mk
+else
+$(error Error: Not supported PLATFORM_FLAVOR or NULL PLATFORM_FLAVOR)
+endif
diff --git a/core/arch/arm/plat-vendor/get_ta_enc_key/get_ta_enc_key.py b/core/arch/arm/plat-vendor/get_ta_enc_key/get_ta_enc_key.py
new file mode 100755
index 0000000..af1d5b5
--- /dev/null
+++ b/core/arch/arm/plat-vendor/get_ta_enc_key/get_ta_enc_key.py
@@ -0,0 +1,28 @@
+# coding = utf-8
+from Crypto.Hash import HMAC, SHA256
+import sys
+import binascii
+import re
+
+
+if __name__ == "__main__":
+    keyname = sys.argv[1]
+    filename = sys.argv[2]
+    with open(filename, "r") as f:
+        data = f.read()
+        pattern = r"{(.*?)}"
+        string = re.findall(pattern, data, re.S)[0]
+        string = string.replace("\n", "")
+        string = string.replace(",", "")
+        string = string.replace("0x", "")
+        string = string.replace(" ", "")
+
+    with open(keyname, "r") as f:
+        key = f.readline()
+        key = key.strip()
+        key = key[:32]
+
+    msg = '04000000'
+    result = HMAC.HMAC(key=binascii.unhexlify(key), msg=binascii.unhexlify(msg), digestmod=SHA256)
+    result.update(binascii.unhexlify(string))
+    print(binascii.hexlify(result.digest()))
diff --git a/core/arch/arm/plat-vendor/get_ta_enc_key/get_ta_enc_key.sh b/core/arch/arm/plat-vendor/get_ta_enc_key/get_ta_enc_key.sh
new file mode 100755
index 0000000..e7daf3f
--- /dev/null
+++ b/core/arch/arm/plat-vendor/get_ta_enc_key/get_ta_enc_key.sh
@@ -0,0 +1,26 @@
+#===============================================================
+# Copyright (c) @CompanyNameMagicTag 2024-2024. All rights reserved.
+# 
+# filename:get_enc_ta_key.sh
+# Author: @CompanyNameTag
+# Create:2024-02-06
+# Description: Script for generating ta encryption keys
+#================================================================*/
+
+KDF_DIR=KDFTools
+CUR_DIR=$(pwd)
+
+if [ -d ${CUR_DIR}/${KDF_DIR} ];then
+    echo "KDFTools exists, generate workkey"
+    pushd ${CUR_DIR}/${KDF_DIR}
+        ./KDF_Linux_Cv610 ./key.ini
+        hexdump -e '/1 "%02x"' ./workkey.bin > ../workkey.txt || exit 1 
+    popd
+else
+    echo "KDFTools doesn't exist, exit"
+fi
+
+ta_pub=$1
+
+python get_ta_enc_key.py workkey.txt ${ta_pub}
+rm workkey.txt
diff --git a/core/arch/arm/plat-vendor/get_ta_enc_key/readme.md b/core/arch/arm/plat-vendor/get_ta_enc_key/readme.md
new file mode 100755
index 0000000..8246cf5
--- /dev/null
+++ b/core/arch/arm/plat-vendor/get_ta_enc_key/readme.md
@@ -0,0 +1,17 @@
+# 
+KDFget_ta_enc_key.sh
+.
+ get_ta_enc_key.py # tapython
+ get_ta_enc_key.sh # ta
+ KDFTools
+  KDF_Linux_Cv610 # KDF
+  key.ini # KDFrootkey
+  readme.txt # KDF
+  StaticValueEnc.bin # 
+ readme.md
+
+```shell
+sh ./get_ta_enc_key.sh path/to/ta_pub_key.c
+```
+
+> path/to/ta_pub_key.coptee_osta_pub_key.c
diff --git a/core/arch/arm/plat-vendor/get_ta_enc_key/sub.mk b/core/arch/arm/plat-vendor/get_ta_enc_key/sub.mk
new file mode 100755
index 0000000..51a00cd
--- /dev/null
+++ b/core/arch/arm/plat-vendor/get_ta_enc_key/sub.mk
@@ -0,0 +1,20 @@
+define copy-file
+$2/$$(notdir $1): $1
+	@set -e; \
+	$(shell mkdir -p $2) ; \
+	$(shell cp -rP $1 $2);
+endef
+
+ta-encfiles = $(PWD)/core/arch/arm/plat-vendor/get_ta_enc_key/get_ta_enc_key.py
+ta-encfiles += $(PWD)/core/arch/arm/plat-vendor/get_ta_enc_key/get_ta_enc_key.sh
+ta-encfiles += $(PWD)/core/arch/arm/plat-vendor/get_ta_enc_key/readme.md
+
+
+ifeq ($(CFG_ARM64_core),y)
+ta-target = ta_arm64
+else
+ta-target = ta_arm32
+endif
+
+$(foreach f, $(ta-encfiles), \
+	$(eval $(call copy-file, $(f), $(out-dir)/export-$(ta-target)/scripts/get_ta_enc_key)))
diff --git a/core/arch/arm/plat-vendor/hi3516cv610.h b/core/arch/arm/plat-vendor/hi3516cv610.h
new file mode 100755
index 0000000..be4faeb
--- /dev/null
+++ b/core/arch/arm/plat-vendor/hi3516cv610.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2019, HiSilicon Technologies Co., Ltd.
+ */
+
+#ifndef __HI3516CV610_H__
+#define __HI3516CV610_H__
+
+#include <mm/generic_ram_layout.h>
+
+/* PL011 */
+#define PL011_UART0_BASE		0x11040000
+#define PL011_BAUDRATE			115200
+#define PL011_UART0_CLK_IN_HZ   24000000
+
+/* Gic */
+#define GIC_BASE                0x12400000
+#define GICD_OFFSET	            0x1000
+#define GICC_OFFSET	            0x2000
+
+/* BootSRAM */
+#define BOOTSRAM_BASE			0x04010000
+#define BOOTSRAM_SIZE			0x1000
+
+/* CPU Reset Control */
+#define CPU_CRG_BASE			0x11010000
+#define CPU_CRG_SIZE			0x10000
+
+/* Sysctrl Register */
+#define SYS_CTRL_BASE			0x11020000
+#define SYS_CTRL_SIZE			0x3000
+
+/* AHB_MISC Register*/
+#define AHB_MISC_BASE			0x10270000
+#define SEC_BOOTRAM_CTRL        0x620
+#define SEC_BOOTRAM_CTRL_ENABLE 0x1
+
+/* SECURITY SUBSYS Register
+ * SPACC: 0x101F0000 -> 0x10000
+ * HKL:   0x10110000 -> 0x1000
+ * RKP:   0x10111000 -> 0x1000
+ * KC:    0x10112000 -> 0x1000
+ * CA:    0x101EC000 -> 0x1000
+ * TRNG:  0x101EE000 -> 0x1000
+ * PKE:   0x101EC000 -> 0x1000
+ * OTP:   0x10120000 -> 0x4000
+ */
+#define SECIP_CTRL_BASE         0x10100000
+#define SECIP_CTRL_SIZE         0x24000
+
+#define RNG_BASE 0x101EE100
+#define MAX_XLAT_TABLES		8
+
+#endif /* __HI3516CV610_H__ */
diff --git a/core/arch/arm/plat-vendor/hi3516cv610.mk b/core/arch/arm/plat-vendor/hi3516cv610.mk
new file mode 100755
index 0000000..506fc3f
--- /dev/null
+++ b/core/arch/arm/plat-vendor/hi3516cv610.mk
@@ -0,0 +1,91 @@
+include core/arch/arm/cpu/cortex-a7.mk
+$(call force,CFG_HI3516CV610,y)
+$(call force,CFG_TEE_CORE_NB_CORE,2)
+$(call force,CFG_GENERIC_BOOT,y)
+$(call force,CFG_PL011,y)
+# $(call force,CFG_PM_STUBS,y)
+$(call force,CFG_SECURE_TIME_SOURCE_CNTPCT,y)
+$(call force,CFG_PSCI_ARM32,y)
+$(call force,CFG_GIC,y)
+$(call force,CFG_WITH_LPAE,n)
+$(call force,CFG_WITH_ARM_TRUSTED_FW,n)
+$(call force,CFG_ARM_GICV2,y)
+$(call force,CFG_BOOT_SECONDARY_REQUEST,y)
+
+### CFG UNIFIED SYSCALL ####
+$(call force,CFG_UNIFIED_SYSCALL,y)
+### END of CFG UNIFIED SYSCALL ####
+### CFG TZASC and MMZ ####
+# SEC_ MMZ componentized compilation switch, CFG_MMZ_SUPPORT must be opened first.
+$(call force,CFG_TZASC,y)
+$(call force,CFG_MMZ_SUPPORT,y)
+$(call force,CFG_MMZ_COMPONENT,n)
+$(call force,CFG_SMMZ_SHARED_SUPPORT,n)
+$(call cfg-depends-all,CFG_MMZ_SUPPORT,CFG_TZASC CFG_UNIFIED_SYSCALL)
+$(call cfg-depends-all,CFG_MMZ_COMPONENT,CFG_TZASC CFG_MMZ_SUPPORT)
+$(call cfg-depends-all,CFG_SMMZ_SHARED_SUPPORT,CFG_TZASC CFG_MMZ_SUPPORT)
+### END of CFG TZASC and MMZ ####
+### CFG SECURITY_SUBSYS ####
+# Security_SUBSYS depends on MMZ. If you want to use Security_SUBSYS, open CFG_MMZ_SUPPORT.
+$(call force,CFG_SECURITY_SUBSYS_SUPPORT,y)
+$(call cfg-depends-all,CFG_SECURITY_SUBSYS_SUPPORT,CFG_MMZ_SUPPORT CFG_UNIFIED_SYSCALL)
+### END of CFG SECURITY_SUBSYS ####
+### CFG GP CIPHER ####
+# CFG_HUK_CIPHER modifies the process of generating the optee storage SSK key to improve security.
+# HUK in storage depends on SECURITY_SUBSYS. If you want to use HUK CIPHER, open Security_SUBSYS.
+$(call force,CFG_GP_CIPHER,n)
+$(call cfg-depends-all,CFG_GP_CIPHER,CFG_SECURITY_SUBSYS_SUPPORT)
+ifeq ($(CFG_GP_CIPHER), y)
+# Crypto driver
+$(call force,CFG_CRYPTO_DRIVER,y)
+$(call force,CFG_CRYPTO_DRV_HASH,y)
+$(call force,CFG_CRYPTO_DRV_CIPHER,n)
+$(call force,CFG_CRYPTO_DRV_MAC,n)
+$(call force,CFG_CRYPTO_DRV_AUTHENC,n)
+$(call force,CFG_CRYPTO_DRV_ACIPHER,y)
+$(call force,CFG_CRYPTO_DRV_RSA,y)
+$(call force,CFG_CRYPTO_DRV_ECC,n)
+$(call force,CFG_CRYPTO_DRV_DH,n)
+CFG_CRYPTO_DRIVER_DEBUG ?= 1
+endif
+### END of CFG GP CIPHER ####
+### CFG HUK CIPHER ####
+# CFG_HUK_CIPHER modifies the process of generating the optee storage SSK key to improve security.
+# HUK in storage depends on SECURITY_SUBSYS. If you want to use HUK CIPHER, open Security_SUBSYS.
+$(call force,CFG_HUK_CIPHER,y)
+$(call cfg-depends-all,CFG_HUK_CIPHER,CFG_SECURITY_SUBSYS_SUPPORT)
+ifeq ($(CFG_HUK_CIPHER), y)
+CFG_WITH_SOFTWARE_PRNG := n
+endif
+### END of CFG HUK CIPHER ####
+$(call force,CFG_WITH_MUSL_MATH_LIB,n)
+
+# Enabling customized features.
+$(call force,CFG_VENDOR,y)
+#CFG_BOOT_SECONDARY_REQUEST ?= y
+$(call force,CFG_WITH_STACK_CANARIES,y)
+$(call force,CFG_DT,y)
+$(call force,CFG_EXTERNAL_DT,n)
+$(call force,CFG_EMBED_DTB,y)
+$(call force,CFG_SECUREC_LIB,y)
+CFG_EMBED_DTB_SOURCE_FILE ?= hi3516cv610.dts
+CFG_NUM_THREADS ?= 2
+CFG_CORE_HEAP_SIZE ?= 65535
+CFG_MMAP_REGIONS ?= 30
+CFG_TZDRAM_START ?= 0x42000000
+CFG_TZDRAM_SIZE ?= 0x01000000
+CFG_TEE_RAM_VA_SIZE ?= 0x00400000
+CFG_SHMEM_START ?= 0x47600000
+CFG_SHMEM_SIZE ?= 0x00400000
+CFG_STACK_THREAD_EXTRA ?= 0x2000
+CFG_NPU ?= n
+$(call cfg-depends-all,CFG_NPU,CFG_UNIFIED_SYSCALL)
+
+### Low-flash and Low-RAM ###
+CFG_SECSTOR_TA = n
+CFG_CORE_STACK_PROTECTOR_ALL=n
+CFG_CORE_STACK_PROTECTOR_STRONG=y
+CFG_TA_STACK_PROTECTOR_ALL=n
+CFG_TA_STACK_PROTECTOR_STRONG=y
+CFG_TEE_CORE_DEBUG=n
+CFG_CORE_DYN_SHM=n
diff --git a/core/arch/arm/plat-vendor/hi3516dv500.h b/core/arch/arm/plat-vendor/hi3516dv500.h
new file mode 100644
index 0000000..295a922
--- /dev/null
+++ b/core/arch/arm/plat-vendor/hi3516dv500.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2019, HiSilicon Technologies Co., Ltd.
+ */
+
+#ifndef __HI3516DV500_H__
+#define __HI3516DV500_H__
+
+#include <mm/generic_ram_layout.h>
+
+/* PL011 */
+#define PL011_UART0_BASE		0x11040000
+#define PL011_BAUDRATE			115200
+#define PL011_UART0_CLK_IN_HZ   24000000
+
+/* Gic */
+#define GIC_BASE                0x12400000
+#define GICD_OFFSET	            0x0000
+/* Fixme, for gicv3, this is not nessary */
+#define GICC_OFFSET	            0x2000
+
+/* BootSRAM */
+#define BOOTSRAM_BASE			0x04010000
+#define BOOTSRAM_SIZE			0x1000
+
+/* CPU Reset Control */
+#define CPU_CRG_BASE			0x11010000
+#define CPU_CRG_SIZE			0x10000
+
+/* Sysctrl Register */
+#define SYS_CTRL_BASE			0x11020000
+#define SYS_CTRL_SIZE			0x3000
+
+/* SECURITY SUBSYS Register
+ * SPACC: 0x101F0000 -> 0x10000
+ * HKL:   0x10110000 -> 0x1000
+ * RKP:   0x10111000 -> 0x1000
+ * KC:    0x10112000 -> 0x1000
+ * CA:    0x101EC000 -> 0x1000
+ * TRNG:  0x101EE000 -> 0x1000
+ * PKE:   0x101EC000 -> 0x1000
+ * OTP:   0x10120000 -> 0x4000
+ */
+#define SECIP_CTRL_BASE         0x10100000
+#define SECIP_CTRL_SIZE         0x24000
+
+#define RNG_BASE 0x101EE100
+
+#endif	/* __HI3516DV500_H__ */
diff --git a/core/arch/arm/plat-vendor/hi3516dv500.mk b/core/arch/arm/plat-vendor/hi3516dv500.mk
new file mode 100755
index 0000000..31f18c0
--- /dev/null
+++ b/core/arch/arm/plat-vendor/hi3516dv500.mk
@@ -0,0 +1,83 @@
+include core/arch/arm/cpu/cortex-armv8-0.mk
+$(call force,CFG_HI3516DV500,y)
+$(call force,CFG_TEE_CORE_NB_CORE,2)
+$(call force,CFG_GENERIC_BOOT,y)
+$(call force,CFG_PL011,y)
+$(call force,CFG_PM_STUBS,y)
+$(call force,CFG_SECURE_TIME_SOURCE_CNTPCT,y)
+$(call force,CFG_ARM64_core,y)
+$(call force,CFG_PSCI_ARM64,y)
+$(call force,CFG_GIC,y)
+$(call force,CFG_WITH_LPAE,y)
+$(call force,CFG_WITH_ARM_TRUSTED_FW,y)
+$(call force,CFG_ARM_GICV3,y)
+
+### CFG UNIFIED SYSCALL ####
+$(call force,CFG_UNIFIED_SYSCALL,y)
+### END of CFG UNIFIED SYSCALL ####
+
+### CFG TZASC and MMZ ####
+# SEC_ MMZ componentized compilation switch, CFG_MMZ_SUPPORT must be opened first.
+$(call force,CFG_TZASC,y)
+$(call force,CFG_MMZ_SUPPORT,y)
+$(call force,CFG_MMZ_COMPONENT,n)
+$(call force,CFG_SMMZ_SHARED_SUPPORT,n)
+$(call cfg-depends-all,CFG_MMZ_SUPPORT,CFG_TZASC CFG_UNIFIED_SYSCALL)
+$(call cfg-depends-all,CFG_MMZ_COMPONENT,CFG_TZASC CFG_MMZ_SUPPORT)
+$(call cfg-depends-all,CFG_SMMZ_SHARED_SUPPORT,CFG_TZASC CFG_MMZ_SUPPORT)
+### END of CFG TZASC and MMZ ####
+### CFG SECURITY_SUBSYS ####
+# Security_SUBSYS depends on MMZ. If you want to use Security_SUBSYS, open CFG_MMZ_SUPPORT.
+$(call force,CFG_SECURITY_SUBSYS_SUPPORT,y)
+$(call cfg-depends-all,CFG_SECURITY_SUBSYS_SUPPORT,CFG_MMZ_SUPPORT CFG_UNIFIED_SYSCALL)
+### END of CFG SECURITY_SUBSYS ####
+### CFG GP CIPHER ####
+# CFG_HUK_CIPHER modifies the process of generating the optee storage SSK key to improve security.
+# HUK in storage depends on SECURITY_SUBSYS. If you want to use HUK CIPHER, open Security_SUBSYS.
+$(call force,CFG_GP_CIPHER,n)
+$(call cfg-depends-all,CFG_GP_CIPHER,CFG_SECURITY_SUBSYS_SUPPORT)
+ifeq ($(CFG_GP_CIPHER), y)
+# Crypto driver
+$(call force,CFG_CRYPTO_DRIVER,y)
+$(call force,CFG_CRYPTO_DRV_HASH,y)
+$(call force,CFG_CRYPTO_DRV_CIPHER,n)
+$(call force,CFG_CRYPTO_DRV_MAC,n)
+$(call force,CFG_CRYPTO_DRV_AUTHENC,n)
+$(call force,CFG_CRYPTO_DRV_ACIPHER,y)
+$(call force,CFG_CRYPTO_DRV_RSA,y)
+$(call force,CFG_CRYPTO_DRV_ECC,n)
+$(call force,CFG_CRYPTO_DRV_DH,y)
+CFG_CRYPTO_DRIVER_DEBUG ?= 1
+endif
+### END of CFG GP CIPHER ####
+### CFG HUK CIPHER ####
+# CFG_HUK_CIPHER modifies the process of generating the optee storage SSK key to improve security.
+# HUK in storage depends on SECURITY_SUBSYS. If you want to use HUK CIPHER, open Security_SUBSYS.
+$(call force,CFG_HUK_CIPHER,y)
+$(call cfg-depends-all,CFG_HUK_CIPHER,CFG_SECURITY_SUBSYS_SUPPORT)
+ifeq ($(CFG_HUK_CIPHER), y)
+CFG_WITH_SOFTWARE_PRNG := n
+endif
+### END of CFG HUK CIPHER ####
+$(call force,CFG_WITH_MUSL_MATH_LIB,y)
+
+# Enabling customized features.
+$(call force,CFG_VENDOR,y)
+#CFG_BOOT_SECONDARY_REQUEST ?= y
+$(call force,CFG_WITH_STACK_CANARIES,y)
+$(call force,CFG_DT,y)
+$(call force,CFG_EMBED_DTB,y)
+$(call force,CFG_SECUREC_LIB,y)
+CFG_EMBED_DTB_SOURCE_FILE ?= hi3516dv500.dts
+CFG_NUM_THREADS ?= 24
+CFG_CORE_HEAP_SIZE ?= 262144
+CFG_MMAP_REGIONS ?= 30
+CFG_TZDRAM_START ?= 0x40030000
+CFG_TZDRAM_SIZE ?= 0x01000000
+CFG_TEE_RAM_VA_SIZE ?= 0x00400000
+CFG_SHMEM_START ?= 0x48600000
+CFG_SHMEM_SIZE ?= 0x00400000
+CFG_STACK_THREAD_EXTRA ?= 0x2000
+CFLAGS += -DCONFIG_CRYPTO_CHIP_HI3519DV500
+CFG_NPU ?= y
+$(call cfg-depends-all,CFG_NPU,CFG_UNIFIED_SYSCALL)
diff --git a/core/arch/arm/plat-vendor/hi3519dv500.h b/core/arch/arm/plat-vendor/hi3519dv500.h
new file mode 100644
index 0000000..63e5a8c
--- /dev/null
+++ b/core/arch/arm/plat-vendor/hi3519dv500.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2019, HiSilicon Technologies Co., Ltd.
+ */
+
+#ifndef __HI3519DV500_H__
+#define __HI3519DV500_H__
+
+#include <mm/generic_ram_layout.h>
+
+/* PL011 */
+#define PL011_UART0_BASE		0x11040000
+#define PL011_BAUDRATE			115200
+#define PL011_UART0_CLK_IN_HZ   24000000
+
+/* Gic */
+#define GIC_BASE                0x12400000
+#define GICD_OFFSET	            0x0000
+/* Fixme, for gicv3, this is not nessary */
+#define GICC_OFFSET	            0x2000
+
+/* BootSRAM */
+#define BOOTSRAM_BASE			0x04010000
+#define BOOTSRAM_SIZE			0x1000
+
+/* CPU Reset Control */
+#define CPU_CRG_BASE			0x11010000
+#define CPU_CRG_SIZE			0x10000
+
+/* Sysctrl Register */
+#define SYS_CTRL_BASE			0x11020000
+#define SYS_CTRL_SIZE			0x3000
+
+/* SECURITY SUBSYS Register
+ * SPACC: 0x101F0000 -> 0x10000
+ * HKL:   0x10110000 -> 0x1000
+ * RKP:   0x10111000 -> 0x1000
+ * KC:    0x10112000 -> 0x1000
+ * CA:    0x101EC000 -> 0x1000
+ * TRNG:  0x101EE000 -> 0x1000
+ * PKE:   0x101EC000 -> 0x1000
+ * OTP:   0x10120000 -> 0x4000
+ */
+#define SECIP_CTRL_BASE         0x10100000
+#define SECIP_CTRL_SIZE         0x24000
+
+#define RNG_BASE 0x101EE100
+
+#endif	/* __HI3519DV500_H__ */
diff --git a/core/arch/arm/plat-vendor/hi3519dv500.mk b/core/arch/arm/plat-vendor/hi3519dv500.mk
new file mode 100755
index 0000000..b6507e3
--- /dev/null
+++ b/core/arch/arm/plat-vendor/hi3519dv500.mk
@@ -0,0 +1,82 @@
+include core/arch/arm/cpu/cortex-armv8-0.mk
+$(call force,CFG_HI3519DV500,y)
+$(call force,CFG_TEE_CORE_NB_CORE,2)
+$(call force,CFG_GENERIC_BOOT,y)
+$(call force,CFG_PL011,y)
+$(call force,CFG_PM_STUBS,y)
+$(call force,CFG_SECURE_TIME_SOURCE_CNTPCT,y)
+$(call force,CFG_ARM64_core,y)
+$(call force,CFG_PSCI_ARM64,y)
+$(call force,CFG_GIC,y)
+$(call force,CFG_WITH_LPAE,y)
+$(call force,CFG_WITH_ARM_TRUSTED_FW,y)
+$(call force,CFG_ARM_GICV3,y)
+
+### CFG UNIFIED SYSCALL ####
+$(call force,CFG_UNIFIED_SYSCALL,y)
+### END of CFG UNIFIED SYSCALL ####
+### CFG TZASC and MMZ ####
+# SEC_ MMZ componentized compilation switch, CFG_MMZ_SUPPORT must be opened first.
+$(call force,CFG_TZASC,y)
+$(call force,CFG_MMZ_SUPPORT,y)
+$(call force,CFG_MMZ_COMPONENT,n)
+$(call force,CFG_SMMZ_SHARED_SUPPORT,n)
+$(call cfg-depends-all,CFG_MMZ_SUPPORT,CFG_TZASC CFG_UNIFIED_SYSCALL)
+$(call cfg-depends-all,CFG_MMZ_COMPONENT,CFG_TZASC CFG_MMZ_SUPPORT)
+$(call cfg-depends-all,CFG_SMMZ_SHARED_SUPPORT,CFG_TZASC CFG_MMZ_SUPPORT)
+### END of CFG TZASC and MMZ ####
+### CFG SECURITY_SUBSYS ####
+# Security_SUBSYS depends on MMZ. If you want to use Security_SUBSYS, open CFG_MMZ_SUPPORT.
+$(call force,CFG_SECURITY_SUBSYS_SUPPORT,y)
+$(call cfg-depends-all,CFG_SECURITY_SUBSYS_SUPPORT,CFG_MMZ_SUPPORT CFG_UNIFIED_SYSCALL)
+### END of CFG SECURITY_SUBSYS ####
+### CFG GP CIPHER ####
+# CFG_HUK_CIPHER modifies the process of generating the optee storage SSK key to improve security.
+# HUK in storage depends on SECURITY_SUBSYS. If you want to use HUK CIPHER, open Security_SUBSYS.
+$(call force,CFG_GP_CIPHER,n)
+$(call cfg-depends-all,CFG_GP_CIPHER,CFG_SECURITY_SUBSYS_SUPPORT)
+ifeq ($(CFG_GP_CIPHER), y)
+# Crypto driver
+$(call force,CFG_CRYPTO_DRIVER,y)
+$(call force,CFG_CRYPTO_DRV_HASH,y)
+$(call force,CFG_CRYPTO_DRV_CIPHER,n)
+$(call force,CFG_CRYPTO_DRV_MAC,n)
+$(call force,CFG_CRYPTO_DRV_AUTHENC,n)
+$(call force,CFG_CRYPTO_DRV_ACIPHER,y)
+$(call force,CFG_CRYPTO_DRV_RSA,y)
+$(call force,CFG_CRYPTO_DRV_ECC,n)
+$(call force,CFG_CRYPTO_DRV_DH,y)
+CFG_CRYPTO_DRIVER_DEBUG ?= 1
+endif
+### END of CFG GP CIPHER ####
+### CFG HUK CIPHER ####
+# CFG_HUK_CIPHER modifies the process of generating the optee storage SSK key to improve security.
+# HUK in storage depends on SECURITY_SUBSYS. If you want to use HUK CIPHER, open Security_SUBSYS.
+$(call force,CFG_HUK_CIPHER,y)
+$(call cfg-depends-all,CFG_HUK_CIPHER,CFG_SECURITY_SUBSYS_SUPPORT)
+ifeq ($(CFG_HUK_CIPHER), y)
+CFG_WITH_SOFTWARE_PRNG := n
+endif
+### END of CFG HUK CIPHER ####
+$(call force,CFG_WITH_MUSL_MATH_LIB,y)
+
+# Enabling customized features.
+$(call force,CFG_VENDOR,y)
+#CFG_BOOT_SECONDARY_REQUEST ?= y
+$(call force,CFG_WITH_STACK_CANARIES,y)
+$(call force,CFG_DT,y)
+$(call force,CFG_EMBED_DTB,y)
+$(call force,CFG_SECUREC_LIB,y)
+CFG_EMBED_DTB_SOURCE_FILE ?= hi3519dv500.dts
+CFG_NUM_THREADS ?= 24
+CFG_CORE_HEAP_SIZE ?= 262144
+CFG_MMAP_REGIONS ?= 30
+CFG_TZDRAM_START ?= 0x40030000
+CFG_TZDRAM_SIZE ?= 0x01000000
+CFG_TEE_RAM_VA_SIZE ?= 0x00400000
+CFG_SHMEM_START ?= 0x48600000
+CFG_SHMEM_SIZE ?= 0x00400000
+CFG_STACK_THREAD_EXTRA ?= 0x2000
+CFLAGS += -DCONFIG_CRYPTO_CHIP_HI3519DV500
+CFG_NPU ?= y
+$(call cfg-depends-all,CFG_NPU,CFG_UNIFIED_SYSCALL)
diff --git a/core/arch/arm/plat-vendor/hi3559v300.h b/core/arch/arm/plat-vendor/hi3559v300.h
new file mode 100644
index 0000000..a335a82
--- /dev/null
+++ b/core/arch/arm/plat-vendor/hi3559v300.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: BSD-2-Clause
+ *
+ * Copyright (c) Huawei Technologies Co., Ltd. 2022-2023. All rights reserved.
+ */
+
+#ifndef __HI3559V300_H__
+#define __HI3559V300_H__
+
+#include <mm/generic_ram_layout.h>
+
+/* PL011 */
+#define PL011_UART0_BASE		0x11040000
+#define PL011_BAUDRATE			115200
+#define PL011_UART0_CLK_IN_HZ   24000000
+
+/* Gic */
+#define GIC_BASE                0x12400000
+#define GICD_OFFSET	            0x0000
+/* Fixme, for gicv3, this is not nessary */
+#define GICC_OFFSET	            0x2000
+
+/* BootSRAM */
+#define BOOTSRAM_BASE			0x04010000
+#define BOOTSRAM_SIZE			0x1000
+
+/* CPU Reset Control */
+#define CPU_CRG_BASE			0x11010000
+#define CPU_CRG_SIZE			0x10000
+
+/* Sysctrl Register */
+#define SYS_CTRL_BASE			0x11020000
+#define SYS_CTRL_SIZE			0x3000
+
+/* SECURITY SUBSYS Register
+ * SPACC: 0x101F0000 -> 0x10000
+ * HKL:   0x10110000 -> 0x1000
+ * RKP:   0x10111000 -> 0x1000
+ * KC:    0x10112000 -> 0x1000
+ * CA:    0x101EC000 -> 0x1000
+ * TRNG:  0x101EE000 -> 0x1000
+ * PKE:   0x101EC000 -> 0x1000
+ * OTP:   0x10120000 -> 0x4000
+ */
+#define SECIP_CTRL_BASE         0x10100000
+#define SECIP_CTRL_SIZE         0x24000
+
+#define RNG_BASE 0x101EE100
+
+#endif /* __HI3559V300_H__ */
diff --git a/core/arch/arm/plat-vendor/hi3559v300.mk b/core/arch/arm/plat-vendor/hi3559v300.mk
new file mode 100644
index 0000000..08c8779
--- /dev/null
+++ b/core/arch/arm/plat-vendor/hi3559v300.mk
@@ -0,0 +1,60 @@
+include core/arch/arm/cpu/cortex-armv8-0.mk
+$(call force,CFG_HI3559V300,y)
+$(call force,CFG_TEE_CORE_NB_CORE,2)
+$(call force,CFG_GENERIC_BOOT,y)
+$(call force,CFG_PL011,y)
+$(call force,CFG_PM_STUBS,y)
+$(call force,CFG_SECURE_TIME_SOURCE_CNTPCT,y)
+$(call force,CFG_ARM64_core,y)
+$(call force,CFG_PSCI_ARM64,y)
+$(call force,CFG_GIC,y)
+$(call force,CFG_WITH_LPAE,y)
+$(call force,CFG_WITH_ARM_TRUSTED_FW,y)
+$(call force,CFG_ARM_GICV3,y)
+
+### CFG TZASC and MMZ ####
+# SEC_ MMZ componentized compilation switch, CFG_MMZ_SUPPORT must be opened first.
+$(call force,CFG_TZASC,y)
+$(call force,CFG_MMZ_SUPPORT,y)
+$(call force,CFG_MMZ_COMPONENT,n)
+$(call cfg-depends-all,CFG_MMZ_SUPPORT,CFG_TZASC)
+$(call cfg-depends-all,CFG_MMZ_COMPONENT,CFG_TZASC CFG_MMZ_SUPPORT)
+### END of CFG TZASC and MMZ ####
+### CFG UNIFIED SYSCALL ####
+$(call force,CFG_UNIFIED_SYSCALL,y)
+### END of CFG UNIFIED SYSCALL ####
+### CFG SECURITY_SUBSYS ####
+# Security_SUBSYS depends on MMZ. If you want to use Security_SUBSYS, open CFG_MMZ_SUPPORT.
+$(call force,CFG_SECURITY_SUBSYS_SUPPORT,y)
+$(call cfg-depends-all,CFG_SECURITY_SUBSYS_SUPPORT,CFG_MMZ_SUPPORT)
+### END of CFG SECURITY_SUBSYS ####
+### CFG HUK CIPHER ####
+# CFG_HUK_CIPHER modifies the process of generating the optee storage SSK key to improve security.
+# HUK in storage depends on SECURITY_SUBSYS. If you want to use HUK CIPHER, open Security_SUBSYS.
+$(call force,CFG_HUK_CIPHER,y)
+$(call cfg-depends-all,CFG_HUK_CIPHER,CFG_SECURITY_SUBSYS_SUPPORT)
+ifeq ($(CFG_HUK_CIPHER), y)
+CFG_WITH_SOFTWARE_PRNG := n
+endif
+### END of CFG HUK CIPHER ####
+$(call force,CFG_WITH_MUSL_MATH_LIB,y)
+
+# Enabling customized features.
+$(call force,CFG_VENDOR,y)
+#CFG_BOOT_SECONDARY_REQUEST ?= y
+$(call force,CFG_WITH_STACK_CANARIES,y)
+$(call force,CFG_DT,y)
+$(call force,CFG_EMBED_DTB,y)
+$(call force,CFG_SECUREC_LIB,y)
+CFG_EMBED_DTB_SOURCE_FILE ?= hi3559v300.dts
+CFG_NUM_THREADS ?= 24
+CFG_CORE_HEAP_SIZE ?= 262144
+CFG_MMAP_REGIONS ?= 30
+CFG_TZDRAM_START ?= 0x40030000
+CFG_TZDRAM_SIZE ?= 0x01000000
+CFG_TEE_RAM_VA_SIZE ?= 0x00400000
+CFG_SHMEM_START ?= 0x48600000
+CFG_SHMEM_SIZE ?= 0x00400000
+CFG_STACK_THREAD_EXTRA ?= 0x2000
+CFLAGS += -DCONFIG_CRYPTO_CHIP_HI3519DV500
+CFG_NPU ?= y
diff --git a/core/arch/arm/plat-vendor/main.c b/core/arch/arm/plat-vendor/main.c
new file mode 100755
index 0000000..04a7ed7
--- /dev/null
+++ b/core/arch/arm/plat-vendor/main.c
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2019, HiSilicon Technologies Co., Ltd.
+ */
+#include <console.h>
+#include <io.h>
+#include <drivers/gic.h>
+#include <drivers/pl011.h>
+#ifdef CFG_TZASC
+#include <tzasc.h>
+#endif
+#include <kernel/boot.h>
+#include <kernel/panic.h>
+#include <kernel/spinlock.h>
+#include <mm/tee_pager.h>
+#include <mm/core_memprot.h>
+#include <platform_config.h>
+#include <stdint.h>
+#include <rng_support.h>
+
+static struct pl011_data console_data;
+
+#ifdef CFG_CORE_DYN_SHM
+#ifndef DRAM0_BASE
+#define DRAM0_BASE 0x45030000
+#define DRAM0_SIZE_NSEC 0x20000000
+#endif
+
+register_dynamic_shm(DRAM0_BASE, DRAM0_SIZE_NSEC);
+#endif
+
+register_phys_mem(MEM_AREA_IO_NSEC, CONSOLE_UART_BASE, PL011_REG_SIZE);
+#ifdef BOOTSRAM_BASE
+register_phys_mem(MEM_AREA_IO_SEC, BOOTSRAM_BASE, BOOTSRAM_SIZE);
+#endif
+#ifdef CPU_CRG_BASE
+register_phys_mem(MEM_AREA_IO_SEC, CPU_CRG_BASE, CPU_CRG_SIZE);
+#endif
+#ifdef SYS_CTRL_BASE
+register_phys_mem(MEM_AREA_IO_SEC, SYS_CTRL_BASE, SYS_CTRL_SIZE);
+#endif
+#ifdef SECIP_CTRL_BASE
+register_phys_mem(MEM_AREA_IO_SEC, SECIP_CTRL_BASE, SECIP_CTRL_SIZE);
+#endif
+
+#ifndef SEC_SUBSYS_BASE_ADDR
+#define SEC_SUBSYS_BASE_ADDR        0x10100000
+#define TRNG_BASE_ADDR              (SEC_SUBSYS_BASE_ADDR + 0xEE000)
+#define TRNG_ADDR_SIZE              (0x1000)
+#endif
+
+register_phys_mem(MEM_AREA_IO_SEC, TRNG_BASE_ADDR, TRNG_ADDR_SIZE);
+
+void console_init(void)
+{
+	pl011_init(&console_data, CONSOLE_UART_BASE, CONSOLE_UART_CLK_IN_HZ,
+		   CONSOLE_BAUDRATE);
+	register_serial_console(&console_data.chip);
+}
+
+void plat_primary_init_early(void)
+{
+#ifndef CFG_WITH_ARM_TRUSTED_FW
+    write_cntfrq(PL011_UART0_CLK_IN_HZ);
+#endif
+
+#ifdef AHB_MISC_BASE
+    *(uint32_t *)(AHB_MISC_BASE + SEC_BOOTRAM_CTRL) = SEC_BOOTRAM_CTRL_ENABLE;
+#endif
+}
+
+#if defined(GIC_BASE)
+
+static struct gic_data gic_data __nex_bss;
+#ifdef CFG_HI3516CV610
+#define GIC_SIZE		0x8000
+register_phys_mem_pgdir(MEM_AREA_IO_SEC, GIC_BASE, GIC_SIZE);
+#else
+register_phys_mem_pgdir(MEM_AREA_IO_SEC, GICD_BASE, GIC_DIST_REG_SIZE);
+register_phys_mem_pgdir(MEM_AREA_IO_SEC, GICC_BASE, GIC_DIST_REG_SIZE);
+#endif
+
+void itr_core_handler(void)
+{
+	gic_it_handle(&gic_data);
+}
+
+void main_init_gic(void)
+{
+#if defined(CFG_WITH_ARM_TRUSTED_FW)
+	/* On ARMv8, GIC configuration is initialized in ARM-TF */
+	gic_init_base_addr(&gic_data, GIC_BASE + GICC_OFFSET, GIC_BASE + GICD_OFFSET);
+#else
+	/* Initialize GIC */
+	gic_init(&gic_data, GIC_BASE + GICC_OFFSET, GIC_BASE + GICD_OFFSET);
+#endif
+	itr_init(&gic_data.chip);
+}
+
+void main_secondary_init_gic(void)
+{
+	gic_cpu_init(&gic_data);
+}
+
+#endif  /* GIC_BASE */
+
+#if defined RNG_BASE
+static unsigned int rng_lock = SPINLOCK_UNLOCK;
+
+TEE_Result hw_get_random_bytes(void *buf, size_t blen)
+{
+	static vaddr_t addr;
+	static int pos;
+	static union {
+		uint32_t val;
+		uint8_t byte[4];
+	} random;
+	size_t buffer_pos = 0;
+	uint8_t *buffer = buf;
+	uint32_t exceptions;
+
+	exceptions = cpu_spin_lock_xsave(&rng_lock);
+
+	if (addr == NULL) {
+		addr = (vaddr_t)phys_to_virt(RNG_BASE, MEM_AREA_IO_SEC, 1);
+	}
+
+	cpu_spin_unlock_xrestore(&rng_lock, exceptions);
+
+	while (buffer_pos < blen) {
+		exceptions = cpu_spin_lock_xsave(&rng_lock);
+
+		/* Refill our FIFO */
+		if (pos == 0) {
+			random.val = io_read32(addr);
+		}
+
+		buffer[buffer_pos++] = random.byte[pos++];
+		pos = pos == 4 ? 0 : pos; // 4: the size of uint32_t is 4 times of uint8_t
+
+		cpu_spin_unlock_xrestore(&rng_lock, exceptions);
+	}
+
+	return TEE_SUCCESS;
+}
+#else
+TEE_Result hw_get_random_bytes(void *buf, size_t blen)
+{
+	(void)buf;
+	(void)&blen;
+	EMSG("RNG_BASE is not defined!\n");
+	return TEE_ERROR_CANCEL;
+}
+#endif /* RNG_BASE */
diff --git a/core/arch/arm/plat-vendor/platform_config.h b/core/arch/arm/plat-vendor/platform_config.h
new file mode 100755
index 0000000..f804630
--- /dev/null
+++ b/core/arch/arm/plat-vendor/platform_config.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2019-2022, HiSilicon Technologies Co., Ltd.
+ */
+
+#ifndef PLATFORM_CONFIG_H
+#define PLATFORM_CONFIG_H
+
+#if defined(CFG_HI3516DV500)
+#include <hi3516dv500.h>
+#elif defined(CFG_HI3519DV500)
+#include <hi3519dv500.h>
+#elif defined(CFG_HI3559V300)
+#include <hi3559v300.h>
+#elif defined(CFG_HI3516CV610)
+#include <hi3516cv610.h>
+#else
+#error "Unknown platform"
+#endif
+
+/* Make stacks aligned to data cache line length */
+#define STACK_ALIGNMENT		64
+
+/* PL011 UART */
+#define CONSOLE_UART_BASE	PL011_UART0_BASE
+#define CONSOLE_BAUDRATE	PL011_BAUDRATE
+#define CONSOLE_UART_CLK_IN_HZ	PL011_UART0_CLK_IN_HZ
+
+#ifdef GIC_BASE
+#define GICD_BASE      (GIC_BASE + GICD_OFFSET)
+#define GICC_BASE      (GIC_BASE + GICC_OFFSET)
+#endif
+
+#endif /* PLATFORM_CONFIG_H */
diff --git a/core/arch/arm/plat-vendor/psci.c b/core/arch/arm/plat-vendor/psci.c
new file mode 100755
index 0000000..5b75bf7
--- /dev/null
+++ b/core/arch/arm/plat-vendor/psci.c
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2019, HiSilicon Technologies Co., Ltd.
+ */
+
+#include <console.h>
+#include <io.h>
+#include <kernel/boot.h>
+#include <kernel/misc.h>
+#include <kernel/panic.h>
+#include <mm/core_mmu.h>
+#include <mm/core_memprot.h>
+#include <platform_config.h>
+#include <stdint.h>
+#include <sm/optee_smc.h>
+#include <sm/psci.h>
+#include <sm/std_smc.h>
+#include <tee/entry_std.h>
+#include <tee/entry_fast.h>
+
+#define REG_CPU_SUSSYS_RESET	0xcc
+#define REG_CPU_START_COMMAND	0x0
+#define REG_CPU_START_ADDR	0x4
+#define REG_SYSCTRL_RESET	0x4
+#define RELEASE_CORE_MASK	(BIT32(25) | BIT32(1))
+
+int psci_features(uint32_t psci_fid)
+{
+	switch (psci_fid) {
+		case ARM_SMCCC_VERSION:
+		case PSCI_PSCI_FEATURES:
+		case PSCI_VERSION:
+		case PSCI_SYSTEM_RESET:
+		case PSCI_CPU_ON:
+			return PSCI_RET_SUCCESS;
+		default:
+			return PSCI_RET_NOT_SUPPORTED;
+	}
+}
+
+uint32_t psci_version(void)
+{
+	return PSCI_VERSION_1_0;
+}
+
+void psci_system_reset(void)
+{
+	vaddr_t sysctrl = core_mmu_get_va(SYS_CTRL_BASE, MEM_AREA_IO_SEC, SYS_CTRL_SIZE);
+
+	if (!sysctrl) {
+		EMSG("no sysctrl mapping, hang here");
+		panic();
+	}
+
+	io_write32(sysctrl + REG_SYSCTRL_RESET, 0xdeadbeef);
+}
+
+int psci_cpu_on(uint32_t core_idx, uint32_t entry,
+		uint32_t context_id)
+{
+	uint32_t val = 0;
+	size_t pos = get_core_pos_mpidr(core_idx);
+	vaddr_t bootsram = core_mmu_get_va(BOOTSRAM_BASE, MEM_AREA_IO_SEC, BOOTSRAM_SIZE);
+	vaddr_t crg = core_mmu_get_va(CPU_CRG_BASE, MEM_AREA_IO_SEC, CPU_CRG_SIZE);
+
+	if (!bootsram || !crg) {
+		EMSG("No bootsram or crg mapping");
+		return PSCI_RET_INVALID_PARAMETERS;
+	}
+
+	if ((pos == 0) || (pos >= CFG_TEE_CORE_NB_CORE))
+		return PSCI_RET_INVALID_PARAMETERS;
+
+	/* set secondary core's NS entry addresses */
+	boot_set_core_ns_entry(pos, entry, context_id);
+
+	val = virt_to_phys((void *)TEE_TEXT_VA_START);
+
+	/* release secondary core */
+	io_clrbits32(crg + REG_CPU_SUSSYS_RESET, RELEASE_CORE_MASK);
+
+	return PSCI_RET_SUCCESS;
+}
diff --git a/core/arch/arm/plat-vendor/reset.S b/core/arch/arm/plat-vendor/reset.S
new file mode 100755
index 0000000..eab30cf
--- /dev/null
+++ b/core/arch/arm/plat-vendor/reset.S
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2024-2024. All rights reserved.
+ */
+
+#include <arm32.h>
+#include <arm32_macros.S>
+#include <asm.S>
+
+.section .text.plat_cpu_reset_early
+.balign 4
+.code 32
+
+/* The address of R3 is transferred from the GSL, and R5 is read by the OP-TEE
+ * during the startup process. It is used to provide the address for the OPTEE
+ * to return the REE. Currently, the adaptation is mainly for Hi3516C V610. For
+ * other 32-bit ARMs, the adaptation may be adjusted as required. */
+FUNC plat_cpu_reset_early , :
+	mov	r5, r3
+
+	bx	lr
+END_FUNC plat_cpu_reset_early
diff --git a/core/arch/arm/plat-vendor/sub.mk b/core/arch/arm/plat-vendor/sub.mk
new file mode 100755
index 0000000..d9100ee
--- /dev/null
+++ b/core/arch/arm/plat-vendor/sub.mk
@@ -0,0 +1,8 @@
+global-incdirs-y += .
+srcs-y += main.c
+srcs-$(CFG_PSCI_ARM32) += psci.c
+srcs-$(CFG_PSCI_ARM32) += reset.S
+
+ifeq ($(CFG_HI3516CV610), y)
+include core/arch/arm/plat-vendor/get_ta_enc_key/sub.mk
+endif
diff --git a/core/arch/arm/tee/arch_svc.c b/core/arch/arm/tee/arch_svc.c
index 6aff802..1748ec6 100644
--- a/core/arch/arm/tee/arch_svc.c
+++ b/core/arch/arm/tee/arch_svc.c
@@ -21,11 +21,15 @@
 #include <tee/arch_svc.h>
 #include <tee/svc_cache.h>
 #include <tee_syscall_numbers.h>
+#include <tee/tee_svc_security_subsys.h>
 #include <tee/tee_svc_cryp.h>
 #include <tee/tee_svc.h>
 #include <tee/tee_svc_storage.h>
 #include <trace.h>
 #include <util.h>
+#ifdef CFG_UNIFIED_SYSCALL
+#include <unified_syscall.h>
+#endif
 
 #include "arch_svc_private.h"
 
@@ -121,6 +125,9 @@ static const struct syscall_entry tee_svc_syscall_table[] = {
 	SYSCALL_ENTRY(syscall_not_supported),
 	SYSCALL_ENTRY(syscall_not_supported),
 	SYSCALL_ENTRY(syscall_cache_operation),
+#ifdef CFG_UNIFIED_SYSCALL
+	SYSCALL_ENTRY(syscall_pick_function),
+#endif
 };
 
 /*
diff --git a/core/arch/arm/tee/entry_fast.c b/core/arch/arm/tee/entry_fast.c
index 5198cae..d1db8f7 100644
--- a/core/arch/arm/tee/entry_fast.c
+++ b/core/arch/arm/tee/entry_fast.c
@@ -197,6 +197,23 @@ static void tee_entry_vm_destroyed(struct thread_smc_args *args)
 }
 #endif
 
+#ifdef CFG_OPTEE_DEBUG
+void (*func[INVALID_CMD])(void);
+ 
+void register_debug_func(enum OPTEE_DEBUG_CMD cmd, void (*f)(void))
+{
+	func[cmd] = f;
+}
+static void debug_by_cmd(enum OPTEE_DEBUG_CMD cmd)
+{
+	if(func[cmd] == NULL) {
+		DMSG("please register_debug_func(%#x, func);\n", cmd);
+		return;
+	}
+	func[cmd]();
+}
+#endif
+
 /* Note: this function is weak to let platforms add special handling */
 void __weak tee_entry_fast(struct thread_smc_args *args)
 {
@@ -291,6 +308,12 @@ void __tee_entry_fast(struct thread_smc_args *args)
 			args->a0 = OPTEE_SMC_RETURN_UNKNOWN_FUNCTION;
 		break;
 
+#ifdef CFG_OPTEE_DEBUG
+    case OPTEE_SMC_DUMP_DEBUG_INFO:
+		debug_by_cmd(args->a1);
+        break;
+#endif
+
 	default:
 		args->a0 = OPTEE_SMC_RETURN_UNKNOWN_FUNCTION;
 		break;
diff --git a/core/core.mk b/core/core.mk
index b023e46..6d5812b 100644
--- a/core/core.mk
+++ b/core/core.mk
@@ -162,6 +162,17 @@ libdir = core/lib/scmi-server
 include mk/lib.mk
 endif
 
+ifeq ($(CFG_SECUREC_LIB),y)
+libname = securec
+libdir = lib/libsecurec
+include mk/lib.mk
+endif
+
+ifeq ($(CFG_MMZ_COMPONENT), y)
+libname = mmz
+libdir = core/drivers/mmz
+include mk/lib.mk
+endif
 #
 # Do main source
 #
diff --git a/core/crypto/crypto.c b/core/crypto/crypto.c
index 9f7d350..60cb89a 100644
--- a/core/crypto/crypto.c
+++ b/core/crypto/crypto.c
@@ -498,9 +498,9 @@ void crypto_bignum_copy(struct bignum *to __unused,
 	bignum_cant_happen();
 }
 
-void crypto_bignum_free(struct bignum *a)
+void crypto_bignum_free(struct bignum **a)
 {
-	if (a)
+	if (a && *a)
 		panic();
 }
 
diff --git a/core/crypto/rng_hw.c b/core/crypto/rng_hw.c
index 4d94ea7..b510b44 100644
--- a/core/crypto/rng_hw.c
+++ b/core/crypto/rng_hw.c
@@ -22,7 +22,7 @@ void crypto_rng_add_event(enum crypto_rng_src sid __unused,
 {
 }
 
-TEE_Result crypto_rng_read(void *buf, size_t blen)
+TEE_Result __weak crypto_rng_read(void *buf, size_t blen)
 {
 	if (!buf)
 		return TEE_ERROR_BAD_PARAMETERS;
diff --git a/core/drivers/crypto/caam/acipher/caam_dh.c b/core/drivers/crypto/caam/acipher/caam_dh.c
index 6131ff0..35fc445 100644
--- a/core/drivers/crypto/caam/acipher/caam_dh.c
+++ b/core/drivers/crypto/caam/acipher/caam_dh.c
@@ -195,10 +195,10 @@ static TEE_Result do_allocate_keypair(struct dh_keypair *key, size_t size_bits)
 err:
 	DH_TRACE("Allocation error");
 
-	crypto_bignum_free(key->g);
-	crypto_bignum_free(key->p);
-	crypto_bignum_free(key->x);
-	crypto_bignum_free(key->y);
+	crypto_bignum_free(&key->g);
+	crypto_bignum_free(&key->p);
+	crypto_bignum_free(&key->x);
+	crypto_bignum_free(&key->y);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
diff --git a/core/drivers/crypto/caam/acipher/caam_dsa.c b/core/drivers/crypto/caam/acipher/caam_dsa.c
index 2696f0b..d60bb8e 100644
--- a/core/drivers/crypto/caam/acipher/caam_dsa.c
+++ b/core/drivers/crypto/caam/acipher/caam_dsa.c
@@ -309,10 +309,10 @@ static TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,
 err:
 	DSA_TRACE("Allocation error");
 
-	crypto_bignum_free(key->g);
-	crypto_bignum_free(key->p);
-	crypto_bignum_free(key->q);
-	crypto_bignum_free(key->x);
+	crypto_bignum_free(&key->g);
+	crypto_bignum_free(&key->p);
+	crypto_bignum_free(&key->q);
+	crypto_bignum_free(&key->x);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
@@ -358,9 +358,9 @@ static TEE_Result do_allocate_publickey(struct dsa_public_key *key,
 err:
 	DSA_TRACE("Allocation error");
 
-	crypto_bignum_free(key->g);
-	crypto_bignum_free(key->p);
-	crypto_bignum_free(key->q);
+	crypto_bignum_free(&key->g);
+	crypto_bignum_free(&key->p);
+	crypto_bignum_free(&key->q);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
diff --git a/core/drivers/crypto/caam/acipher/caam_ecc.c b/core/drivers/crypto/caam/acipher/caam_ecc.c
index 90e87c2..6b12b6c 100644
--- a/core/drivers/crypto/caam/acipher/caam_ecc.c
+++ b/core/drivers/crypto/caam/acipher/caam_ecc.c
@@ -169,8 +169,8 @@ static TEE_Result do_allocate_keypair(struct ecc_keypair *key, size_t size_bits)
 err:
 	ECC_TRACE("Allocation error");
 
-	crypto_bignum_free(key->d);
-	crypto_bignum_free(key->x);
+	crypto_bignum_free(&key->d);
+	crypto_bignum_free(&key->x);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
@@ -204,7 +204,7 @@ static TEE_Result do_allocate_publickey(struct ecc_public_key *key,
 err:
 	ECC_TRACE("Allocation error");
 
-	crypto_bignum_free(key->x);
+	crypto_bignum_free(&key->x);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
@@ -216,8 +216,8 @@ err:
  */
 static void do_free_publickey(struct ecc_public_key *key)
 {
-	crypto_bignum_free(key->x);
-	crypto_bignum_free(key->y);
+	crypto_bignum_free(&key->x);
+	crypto_bignum_free(&key->y);
 }
 
 /*
diff --git a/core/drivers/crypto/caam/acipher/caam_rsa.c b/core/drivers/crypto/caam/acipher/caam_rsa.c
index e860c64..b59ab0b 100644
--- a/core/drivers/crypto/caam/acipher/caam_rsa.c
+++ b/core/drivers/crypto/caam/acipher/caam_rsa.c
@@ -86,14 +86,14 @@ static uint8_t caam_era;
  */
 static void do_free_keypair(struct rsa_keypair *key)
 {
-	crypto_bignum_free(key->e);
-	crypto_bignum_free(key->d);
-	crypto_bignum_free(key->n);
-	crypto_bignum_free(key->p);
-	crypto_bignum_free(key->q);
-	crypto_bignum_free(key->qp);
-	crypto_bignum_free(key->dp);
-	crypto_bignum_free(key->dq);
+	crypto_bignum_free(&key->e);
+	crypto_bignum_free(&key->d);
+	crypto_bignum_free(&key->n);
+	crypto_bignum_free(&key->p);
+	crypto_bignum_free(&key->q);
+	crypto_bignum_free(&key->qp);
+	crypto_bignum_free(&key->dp);
+	crypto_bignum_free(&key->dq);
 }
 
 /*
@@ -435,8 +435,8 @@ static TEE_Result do_allocate_publickey(struct rsa_public_key *key,
 err_alloc_publickey:
 	RSA_TRACE("Allocation error");
 
-	crypto_bignum_free(key->e);
-	crypto_bignum_free(key->n);
+	crypto_bignum_free(&key->e);
+	crypto_bignum_free(&key->n);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
@@ -448,8 +448,8 @@ err_alloc_publickey:
  */
 static void do_free_publickey(struct rsa_public_key *key)
 {
-	crypto_bignum_free(key->e);
-	crypto_bignum_free(key->n);
+	crypto_bignum_free(&key->e);
+	crypto_bignum_free(&key->n);
 }
 
 /*
diff --git a/core/drivers/crypto/se050/core/ecc.c b/core/drivers/crypto/se050/core/ecc.c
index d743347..52f82c6 100644
--- a/core/drivers/crypto/se050/core/ecc.c
+++ b/core/drivers/crypto/se050/core/ecc.c
@@ -752,9 +752,9 @@ static TEE_Result do_alloc_keypair(struct ecc_keypair *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->d);
-	crypto_bignum_free(s->x);
-	crypto_bignum_free(s->y);
+	crypto_bignum_free(&s->d);
+	crypto_bignum_free(&s->x);
+	crypto_bignum_free(&s->y);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -768,8 +768,8 @@ static TEE_Result do_alloc_publickey(struct ecc_public_key *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->x);
-	crypto_bignum_free(s->y);
+	crypto_bignum_free(&s->x);
+	crypto_bignum_free(&s->y);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -778,8 +778,8 @@ static void do_free_publickey(struct ecc_public_key *s)
 	if (!s)
 		return;
 
-	crypto_bignum_free(s->x);
-	crypto_bignum_free(s->y);
+	crypto_bignum_free(&s->x);
+	crypto_bignum_free(&s->y);
 }
 
 static struct drvcrypt_ecc driver_ecc = {
diff --git a/core/drivers/crypto/se050/core/rsa.c b/core/drivers/crypto/se050/core/rsa.c
index 815abb3..475d2b9 100644
--- a/core/drivers/crypto/se050/core/rsa.c
+++ b/core/drivers/crypto/se050/core/rsa.c
@@ -537,14 +537,14 @@ static TEE_Result do_alloc_keypair(struct rsa_keypair *s,
 
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->e);
-	crypto_bignum_free(s->d);
-	crypto_bignum_free(s->n);
-	crypto_bignum_free(s->p);
-	crypto_bignum_free(s->q);
-	crypto_bignum_free(s->qp);
-	crypto_bignum_free(s->dp);
-	crypto_bignum_free(s->dq);
+	crypto_bignum_free(&s->e);
+	crypto_bignum_free(&s->d);
+	crypto_bignum_free(&s->n);
+	crypto_bignum_free(&s->p);
+	crypto_bignum_free(&s->q);
+	crypto_bignum_free(&s->qp);
+	crypto_bignum_free(&s->dp);
+	crypto_bignum_free(&s->dq);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
@@ -556,7 +556,7 @@ static TEE_Result do_alloc_publickey(struct rsa_public_key *s,
 	if (!bn_alloc_max(&s->e))
 		return TEE_ERROR_OUT_OF_MEMORY;
 	if (!bn_alloc_max(&s->n)) {
-		crypto_bignum_free(s->e);
+		crypto_bignum_free(&s->e);
 		return TEE_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -566,8 +566,8 @@ static TEE_Result do_alloc_publickey(struct rsa_public_key *s,
 static void do_free_publickey(struct rsa_public_key *s)
 {
 	if (s) {
-		crypto_bignum_free(s->n);
-		crypto_bignum_free(s->e);
+		crypto_bignum_free(&s->n);
+		crypto_bignum_free(&s->e);
 	}
 }
 
@@ -587,14 +587,14 @@ static void do_free_keypair(struct rsa_keypair *s)
 			sss_se05x_key_store_erase_key(se050_kstore, &k_object);
 	}
 
-	crypto_bignum_free(s->e);
-	crypto_bignum_free(s->d);
-	crypto_bignum_free(s->n);
-	crypto_bignum_free(s->p);
-	crypto_bignum_free(s->q);
-	crypto_bignum_free(s->qp);
-	crypto_bignum_free(s->dp);
-	crypto_bignum_free(s->dq);
+	crypto_bignum_free(&s->e);
+	crypto_bignum_free(&s->d);
+	crypto_bignum_free(&s->n);
+	crypto_bignum_free(&s->p);
+	crypto_bignum_free(&s->q);
+	crypto_bignum_free(&s->qp);
+	crypto_bignum_free(&s->dp);
+	crypto_bignum_free(&s->dq);
 }
 
 static TEE_Result do_gen_keypair(struct rsa_keypair *key, size_t kb)
diff --git a/core/drivers/crypto/versal/ecc.c b/core/drivers/crypto/versal/ecc.c
index 3d54545..18ec4f7 100644
--- a/core/drivers/crypto/versal/ecc.c
+++ b/core/drivers/crypto/versal/ecc.c
@@ -284,9 +284,9 @@ static TEE_Result sign(uint32_t algo, struct ecc_keypair *key,
 
 	versal_mbox_alloc(bytes, NULL, &k);
 	crypto_bignum_bn2bin_eswap(key->curve, ephemeral.d, k.buf);
-	crypto_bignum_free(ephemeral.d);
-	crypto_bignum_free(ephemeral.x);
-	crypto_bignum_free(ephemeral.y);
+	crypto_bignum_free(&ephemeral.d);
+	crypto_bignum_free(&ephemeral.x);
+	crypto_bignum_free(&ephemeral.y);
 
 	/* Private key*/
 	versal_mbox_alloc(bytes, NULL, &d);
diff --git a/core/drivers/sub.mk b/core/drivers/sub.mk
index e72bded..f01e77a 100644
--- a/core/drivers/sub.mk
+++ b/core/drivers/sub.mk
@@ -81,3 +81,13 @@ subdirs-y += pm
 subdirs-y += wdt
 subdirs-y += rtc
 subdirs-y += tpm2
+
+subdirs-$(CFG_UNIFIED_SYSCALL) += unified_syscall
+subdirs-y += ../../bsp/osal
+subdirs-$(CFG_TZASC) += ../../bsp/tzasc
+subdirs-$(CFG_NPU) += ../../bsp/npu/drivers
+ifeq ($(CFG_MMZ_COMPONENT), n)
+subdirs-$(CFG_MMZ_SUPPORT) += ../../bsp/mmz/drivers
+endif
+subdirs-$(CFG_SECURITY_SUBSYS_SUPPORT) += ../../bsp/security_subsys/drivers
+subdirs-$(CFG_GP_CIPHER) += ../../bsp/gp_cipher
diff --git a/core/drivers/unified_syscall/include/unified_syscall.h b/core/drivers/unified_syscall/include/unified_syscall.h
new file mode 100644
index 0000000..9c8062e
--- /dev/null
+++ b/core/drivers/unified_syscall/include/unified_syscall.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related unified_syscall
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#ifndef __UNIFIED_SYSCALL_
+#define __UNIFIED_SYSCALL_
+
+#include <kernel/ts_manager.h>
+#include <stdint.h>
+#include <sys/queue.h>
+#include <tee_api_types.h>
+#include <types_ext.h>
+#include <utee_types.h>
+
+typedef TEE_Result (*function_entry)(void *param, size_t param_len);
+
+typedef struct function_entry_node {
+    const char *func_name;
+    function_entry func;
+    SLIST_ENTRY(function_entry_node) link;
+} function_entry_node;
+
+SLIST_HEAD(func_entry_head, function_entry_node);
+
+TEE_Result tee_register_function(function_entry_node function);
+
+#define FUNCTION_ENTRY(_fn)                              \
+    {                                                    \
+        .func = (function_entry)(_fn), .func_name = #_fn \
+    }
+
+#define TEE_REGISTER_FUNCTION(func_name)                    \
+    do {                                                    \
+        function_entry_node fn = FUNCTION_ENTRY(func_name); \
+        if (tee_register_function(fn) != TEE_SUCCESS) {     \
+            EMSG("registered failed!\n");                   \
+        }                                                   \
+    } while (0)
+
+TEE_Result syscall_pick_function(unsigned long cat, char *func, void *param,
+                                 size_t param_len);
+
+#endif /* __UNIFIED_SYSCALL_ */
diff --git a/core/drivers/unified_syscall/src/sub.mk b/core/drivers/unified_syscall/src/sub.mk
new file mode 100644
index 0000000..ec7b194
--- /dev/null
+++ b/core/drivers/unified_syscall/src/sub.mk
@@ -0,0 +1 @@
+srcs-y += unified_syscall.c
diff --git a/core/drivers/unified_syscall/src/unified_syscall.c b/core/drivers/unified_syscall/src/unified_syscall.c
new file mode 100644
index 0000000..0d26160
--- /dev/null
+++ b/core/drivers/unified_syscall/src/unified_syscall.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Define the unified syscall function
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+ */
+
+#include <initcall.h>
+#include <kernel/mutex.h>
+#include <kernel/user_access.h>
+#include <kernel/user_mode_ctx.h>
+#include <mm/vm.h>
+#include <stdlib.h>
+#include <string.h>
+#include <tee/tee_svc_security_subsys.h>
+#include <trace.h>
+#include <unified_syscall.h>
+
+static struct func_entry_head g_func_head;
+
+static struct mutex func_mu = MUTEX_INITIALIZER;
+
+TEE_Result tee_register_function(function_entry_node function)
+{
+    const char *name = function.func_name;
+    function_entry_node *cur = NULL;
+    function_entry_node *tmp =
+        (function_entry_node *)malloc(sizeof(function_entry_node));
+    if (tmp == NULL) {
+        EMSG("malloc failed!\n");
+        return TEE_ERROR_OUT_OF_MEMORY;
+    }
+
+    mutex_lock(&func_mu);
+
+    tmp->func = function.func;
+    tmp->func_name = name;
+
+    if (!SLIST_EMPTY(&g_func_head)) {
+        SLIST_FOREACH(cur, &g_func_head, link)
+        {
+            if (strcmp(name, cur->func_name) == 0) {
+                EMSG("func has been already registered!\n");
+                mutex_unlock(&func_mu);
+                free(tmp);
+                return TEE_ERROR_BAD_STATE;
+            }
+        }
+    }
+
+    SLIST_INSERT_HEAD(&g_func_head, tmp, link);
+    mutex_unlock(&func_mu);
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result osal_register(void)
+{
+    function_entry_node *cur = NULL;
+
+    SLIST_INIT(&g_func_head);
+#ifdef CFG_SECURITY_SUBSYS_SUPPORT
+    TEE_REGISTER_FUNCTION(syscall_otp_ioctl);
+    TEE_REGISTER_FUNCTION(syscall_km_ioctl);
+    TEE_REGISTER_FUNCTION(syscall_cipher_ioctl);
+#endif
+#ifdef CFG_MMZ_SUPPORT
+    TEE_REGISTER_FUNCTION(syscall_mmz_ioctl);
+#endif
+#ifdef CFG_NPU
+    TEE_REGISTER_FUNCTION(syscall_npu_ioctl);
+#endif
+
+    return TEE_SUCCESS;
+}
+
+driver_init_late(osal_register);
+
+static TEE_Result pick_function(char *func, void *param, size_t param_len)
+{
+    TEE_Result res = TEE_SUCCESS;
+    TEE_Result res2 = TEE_SUCCESS;
+    uint8_t *local_param = NULL;
+    function_entry_node *cur = NULL;
+    struct ts_session *s = ts_get_current_session();
+    uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER;
+
+    if (func == NULL || (param == NULL) != (param_len == 0)) {
+        EMSG("parameters invalid !\n");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    res = vm_check_access_rights(to_user_mode_ctx(s->ctx), flags, func,
+                                 strlen(func));
+    if (res != TEE_SUCCESS) {
+        EMSG("%s func invalid !\n", __func__);
+        return res;
+    }
+
+    if (param_len != 0) {
+        local_param = (uint8_t *)malloc(sizeof(uint8_t) * param_len);
+        if (local_param == NULL) {
+            EMSG("malloc failed!\n");
+            return TEE_ERROR_OUT_OF_MEMORY;
+        }
+        res2 = copy_from_user(local_param, param, param_len);
+        if (res2 != TEE_SUCCESS) {
+            EMSG("copy_from_user failed!\n");
+            res = res2;
+            goto exit;
+        }
+    }
+    SLIST_FOREACH(cur, &g_func_head, link)
+    {
+        if (strcmp(func, cur->func_name) == 0) {
+            res = cur->func(local_param, param_len);
+            if (param_len != 0 && res == TEE_SUCCESS) {
+                res2 = copy_to_user(param, local_param, param_len);
+                if (res2 != TEE_SUCCESS) {
+                    res = res2;
+                    EMSG("copy_to_user failed!\n");
+                    goto exit;
+                }
+            }
+            goto exit;
+        }
+    }
+
+    EMSG("undefined function!\n");
+    res = TEE_ERROR_BAD_PARAMETERS;
+exit:
+    if (local_param != NULL) {
+        free(local_param);
+    }
+
+    return res;
+}
+
+/* By using the pick_function interface, you can reduce the number of
+ * steps required for adding system calls.
+ *
+ * @ cat: Specifies the command directory of syscall_pick_function.
+ * When the value is UTEE_PICK_functional, the unified syscall function
+ * is implemented.
+ *
+ * @ func: the name of the function need to call.
+ *
+ * @ param: the paramters of the func, if there are too many parameters
+ * need to be tranferred, that should be to create a structure corresponding
+ * to the parameters in lib/libutee/include/tee_pick_function_types.h.
+ *
+ * usage steps: 1. create the syscall interface need to be called, whatever in
+ * this file or other file, if in the other file, need to include the header
+ * file.
+ * 2. add the syscall interface into the arrays g_function_subentry.
+ * 3. if there are too many paramters, should to create a structure in
+ * lib/libutee/include/tee_pick_function_types.h.
+ */
+TEE_Result syscall_pick_function(unsigned long cat, char *func, void *param,
+                                 size_t param_len)
+{
+    TEE_Result res = TEE_SUCCESS;
+
+    switch (cat) {
+        case UTEE_PICK_FUNCTION:
+            res = pick_function(func, param, param_len);
+            break;
+        default:
+            res = TEE_ERROR_BAD_PARAMETERS;
+            break;
+    }
+
+    return res;
+}
diff --git a/core/drivers/unified_syscall/sub.mk b/core/drivers/unified_syscall/sub.mk
new file mode 100644
index 0000000..25712c4
--- /dev/null
+++ b/core/drivers/unified_syscall/sub.mk
@@ -0,0 +1,2 @@
+global-incdirs-y += include
+subdirs-y += src
diff --git a/core/include/crypto/crypto.h b/core/include/crypto/crypto.h
index 71a287e..0e6c139 100644
--- a/core/include/crypto/crypto.h
+++ b/core/include/crypto/crypto.h
@@ -98,7 +98,7 @@ size_t crypto_bignum_num_bytes(struct bignum *a);
 size_t crypto_bignum_num_bits(struct bignum *a);
 void crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to);
 void crypto_bignum_copy(struct bignum *to, const struct bignum *from);
-void crypto_bignum_free(struct bignum *a);
+void crypto_bignum_free(struct bignum **a);
 void crypto_bignum_clear(struct bignum *a);
 
 /* return -1 if a<b, 0 if a==b, +1 if a>b */
diff --git a/core/include/kernel/notif.h b/core/include/kernel/notif.h
index 71b53d8..220c7b7 100644
--- a/core/include/kernel/notif.h
+++ b/core/include/kernel/notif.h
@@ -106,6 +106,11 @@ void notif_free_async_value(uint32_t value);
  */
 TEE_Result notif_wait(uint32_t value);
 
+/*
+ * Wait with timtout in normal world for a value to be sent by notif_send()
+ */
+TEE_Result notif_wait_timeout(uint32_t value, uint32_t timeout);
+
 /*
  * Send an asynchronous value, note that it must be <= NOTIF_ASYNC_VALUE_MAX
  */
diff --git a/core/include/kernel/wait_queue.h b/core/include/kernel/wait_queue.h
index a13c02b..b43aec5 100644
--- a/core/include/kernel/wait_queue.h
+++ b/core/include/kernel/wait_queue.h
@@ -44,6 +44,10 @@ static inline void wq_wait_init(struct wait_queue *wq,
 	wq_wait_init_condvar(wq, wqe, NULL, wait_read);
 }
 
+/* Waits for the wait queue element or timeout to the awakened. */
+uint32_t wq_wait_final_timeout(struct wait_queue *wq, struct wait_queue_elem *wqe,
+		   const void *sync_obj, uint32_t timeout, const char *fname, int lineno);
+
 /* Waits for the wait queue element to the awakened. */
 void wq_wait_final(struct wait_queue *wq, struct wait_queue_elem *wqe,
 		   const void *sync_obj, const char *fname, int lineno);
diff --git a/core/include/mm/core_mmu.h b/core/include/mm/core_mmu.h
index 52f802f..a083584 100644
--- a/core/include/mm/core_mmu.h
+++ b/core/include/mm/core_mmu.h
@@ -84,6 +84,7 @@
  * MEM_AREA_TS_VASPACE: TS va space, only used with phys_to_virt()
  * MEM_AREA_DDR_OVERALL: Overall DDR address range, candidate to dynamic shm.
  * MEM_AREA_SEC_RAM_OVERALL: Whole secure RAM
+ * MEM_AREA_SEC_MMZ_VASPACE: SEC MMZ memory virt addr space
  * MEM_AREA_MAXTYPE:  lower invalid 'type' value
  */
 enum teecore_memtypes {
@@ -113,6 +114,7 @@ enum teecore_memtypes {
 	MEM_AREA_SDP_MEM,
 	MEM_AREA_DDR_OVERALL,
 	MEM_AREA_SEC_RAM_OVERALL,
+    MEM_AREA_SEC_MMZ_VASPACE,
 	MEM_AREA_MAXTYPE
 };
 
@@ -144,6 +146,7 @@ static inline const char *teecore_memtype_name(enum teecore_memtypes type)
 		[MEM_AREA_PAGER_VASPACE] = "PAGER_VASPACE",
 		[MEM_AREA_SDP_MEM] = "SDP_MEM",
 		[MEM_AREA_DDR_OVERALL] = "DDR_OVERALL",
+        [MEM_AREA_SEC_MMZ_VASPACE] = "SEC_MMZ_VASPACE",
 		[MEM_AREA_SEC_RAM_OVERALL] = "SEC_RAM_OVERALL",
 	};
 
@@ -475,7 +478,7 @@ static inline size_t core_mmu_get_block_offset(
 static inline bool core_mmu_is_dynamic_vaspace(struct tee_mmap_region *mm)
 {
 	return mm->type == MEM_AREA_RES_VASPACE ||
-		mm->type == MEM_AREA_SHM_VASPACE;
+		mm->type == MEM_AREA_SHM_VASPACE || mm->type == MEM_AREA_SEC_MMZ_VASPACE;
 }
 
 /*
diff --git a/core/include/mm/mobj_mmz.h b/core/include/mm/mobj_mmz.h
new file mode 100644
index 0000000..8759d88
--- /dev/null
+++ b/core/include/mm/mobj_mmz.h
@@ -0,0 +1,8 @@
+#include <mm/mobj.h>
+#include <tee_api_types.h>
+
+TEE_Result mobj_mapped_sec_mmz_init(void);
+TEE_Result mobj_reg_sec_mmz_kunmap(struct mobj *mobj);
+TEE_Result mobj_reg_sec_mmz_kmap(struct mobj *mobj);
+struct mobj_reg_sec_mmz *to_mobj_reg_sec_mmz(struct mobj *mobj);
+struct mobj *mobj_reg_sec_mmz_alloc(paddr_t pa, size_t size, uint32_t cattr);
diff --git a/core/include/mm/tee_mm.h b/core/include/mm/tee_mm.h
index 481f583..3ae492b 100644
--- a/core/include/mm/tee_mm.h
+++ b/core/include/mm/tee_mm.h
@@ -46,6 +46,9 @@ extern tee_mm_pool_t tee_mm_vcore;
 /* Shared memory pool */
 extern tee_mm_pool_t tee_mm_shm;
 
+/* SEC MMZ virt addr pool */
+extern tee_mm_pool_t tee_mm_sec_mmz;
+ 
 /*
  * Returns a pointer to the mm covering the supplied address,
  * if no mm is found NULL is returned.
diff --git a/core/include/optee_rpc_cmd.h b/core/include/optee_rpc_cmd.h
index 816f0a2..745d5dc 100644
--- a/core/include/optee_rpc_cmd.h
+++ b/core/include/optee_rpc_cmd.h
@@ -69,10 +69,17 @@
  * Sending a synchronous notification
  * [in]    value[0].a	    OPTEE_RPC_NOTIFICATION_SEND
  * [in]    value[0].b	    notification value
+ *
+ * Waiting on notification
+ * [in]    value[0].a	    OPTEE_RPC_NOTIFICATION_WAIT_TIMEOUT
+ * [in]    value[0].b	    notification value
+ * [in]    value[0].c	    timeout time in ms
+ * [in]    value[1].a	    time left before timeout
  */
 #define OPTEE_RPC_CMD_NOTIFICATION	U(4)
 #define OPTEE_RPC_NOTIFICATION_WAIT	U(0)
 #define OPTEE_RPC_NOTIFICATION_SEND	U(1)
+#define OPTEE_RPC_NOTIFICATION_WAIT_TIMEOUT	U(2)
 
 /*
  * Suspend execution
diff --git a/core/include/rng_support.h b/core/include/rng_support.h
index 1dc4d89..d86707b 100644
--- a/core/include/rng_support.h
+++ b/core/include/rng_support.h
@@ -6,6 +6,8 @@
 #define __RNG_SUPPORT_H__
 
 #include <stdint.h>
+#include <stddef.h>
+#include <tee_api_types.h>
 
 TEE_Result hw_get_random_bytes(void *buf, size_t blen);
 
diff --git a/core/include/tee/cache.h b/core/include/tee/cache.h
index 568b251..13dcfd5 100644
--- a/core/include/tee/cache.h
+++ b/core/include/tee/cache.h
@@ -6,6 +6,7 @@
 #define TEE_CACHE_H
 
 #include <utee_types.h>
+#include <tee_api_types.h>
 
 TEE_Result cache_operation(enum utee_cache_operation op, void *va, size_t len);
 
diff --git a/core/include/tee/tee_svc.h b/core/include/tee/tee_svc.h
index 27a04c0..23a531f 100644
--- a/core/include/tee/tee_svc.h
+++ b/core/include/tee/tee_svc.h
@@ -73,5 +73,4 @@ TEE_Result syscall_wait(unsigned long timeout);
 
 TEE_Result syscall_get_time(unsigned long cat, TEE_Time *time);
 TEE_Result syscall_set_ta_time(const TEE_Time *time);
-
 #endif /* TEE_SVC_H */
diff --git a/core/include/tee/tee_svc_security_subsys.h b/core/include/tee/tee_svc_security_subsys.h
new file mode 100644
index 0000000..2bfd50a
--- /dev/null
+++ b/core/include/tee/tee_svc_security_subsys.h
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2019, HiSilicon Technologies Co., Ltd.
+ */
+
+#ifndef __TEE_SVC_SECURITY_SUBSYS_H__
+#define __TEE_SVC_SECURITY_SUBSYS_H__
+
+#include <tee_pick_function_types.h>
+
+#ifdef CFG_SECURITY_SUBSYS_SUPPORT
+TEE_Result syscall_otp_ioctl(void *param, size_t param_len);
+
+TEE_Result syscall_km_ioctl(void *param, size_t param_len);
+
+TEE_Result syscall_cipher_ioctl(void *param, size_t param_len);
+#endif
+
+#ifdef CFG_MMZ_SUPPORT
+TEE_Result syscall_mmz_ioctl(void *param, size_t param_len);
+#endif
+
+#ifdef CFG_NPU
+TEE_Result syscall_npu_ioctl(void *param, size_t param_len);
+#endif
+
+#endif /* __TEE_SVC_SECURITY_SUBSYS_H__ */
diff --git a/core/kernel/notif.c b/core/kernel/notif.c
index 7ecc246..174849d 100644
--- a/core/kernel/notif.c
+++ b/core/kernel/notif.c
@@ -203,6 +203,26 @@ out:
 }
 #endif /*CFG_CORE_ASYNC_NOTIF*/
 
+/* This function is for WaitQueue_timeout function */
+static uint32_t notif_rpc_timeout(uint32_t func, uint32_t value, uint32_t timeout)
+{
+	struct thread_param params[2] = {0};
+	uint32_t time_left = 0;
+	uint32_t ret = TEE_SUCCESS;
+
+	params[0] = THREAD_PARAM_VALUE(IN, func, value, timeout);
+	params[1] = THREAD_PARAM_VALUE(OUT, 0, 0, 0);
+
+	ret = thread_rpc_cmd(OPTEE_RPC_CMD_NOTIFICATION, 2, params);
+	time_left = (uint32_t)params[1].u.value.a;
+
+	if (ret != TEE_SUCCESS) {
+		DMSG("thread %u res 0x%x time_left %u\n", func, ret, time_left);
+	}
+
+	return time_left;
+}
+
 static TEE_Result notif_rpc(uint32_t func, uint32_t value)
 {
 	struct thread_param params = THREAD_PARAM_VALUE(IN, func, value, 0);
@@ -210,6 +230,12 @@ static TEE_Result notif_rpc(uint32_t func, uint32_t value)
 	return thread_rpc_cmd(OPTEE_RPC_CMD_NOTIFICATION, 1, &params);
 }
 
+/* This function is for WaitQueue_timeout function */
+uint32_t notif_wait_timeout(uint32_t value, uint32_t timeout)
+{
+	return notif_rpc_timeout(OPTEE_RPC_NOTIFICATION_WAIT_TIMEOUT, value, timeout);
+}
+
 TEE_Result notif_wait(uint32_t value)
 {
 	return notif_rpc(OPTEE_RPC_NOTIFICATION_WAIT, value);
diff --git a/core/kernel/sub.mk b/core/kernel/sub.mk
index 7ae0b70..5f82637 100644
--- a/core/kernel/sub.mk
+++ b/core/kernel/sub.mk
@@ -26,7 +26,17 @@ srcs-y += tee_ta_manager.c
 srcs-y += ts_manager.c
 srcs-$(CFG_CORE_SANITIZE_UNDEFINED) += ubsan.c
 srcs-y += scattered_array.c
+ifneq ($(CFG_HUK_CIPHER),y)
 srcs-y += huk_subkey.c
+else
+srcs-y += ../../bsp/security_subsys/drivers/storage/huk_subkey2.c
+cflags-y += -Ibsp/security_subsys/drivers/crypto_osal
+cflags-y += -Ibsp/security_subsys/
+cflags-y += -Ibsp/security_subsys/lib/../security_subsys_common/common
+cflags-y += -Ibsp/security_subsys/lib/../security_subsys_common/include/kapi_include
+cflags-y += -Ibsp/security_subsys/lib/../security_subsys_common/include/common_include
+cflags-y += -Ibsp/security_subsys/lib/../security_subsys_common/include/drv_include
+endif
 srcs-$(CFG_SHOW_CONF_ON_BOOT) += show_conf.c
 srcs-y += user_mode_ctx.c
 srcs-$(CFG_CORE_TPM_EVENT_LOG) += tpm.c
diff --git a/core/kernel/tee_ta_manager.c b/core/kernel/tee_ta_manager.c
old mode 100644
new mode 100755
diff --git a/core/kernel/wait_queue.c b/core/kernel/wait_queue.c
index 1326ef8..715d994 100644
--- a/core/kernel/wait_queue.c
+++ b/core/kernel/wait_queue.c
@@ -22,6 +22,27 @@ void wq_init(struct wait_queue *wq)
 	*wq = (struct wait_queue)WAIT_QUEUE_INITIALIZER;
 }
 
+/* This function is for WaitQueue_timeout function */
+static uint32_t do_notif_timeout(TEE_Result (*fn)(uint32_t, uint32_t),
+		     int id, uint32_t timeout,
+		     const char *cmd_str __maybe_unused,
+		     const void *sync_obj __maybe_unused,
+		     const char *fname, int lineno __maybe_unused)
+{
+	uint32_t time_left = 0;
+
+	if (fname) {
+		DMSG("%s thread %d %p %s:%d %u", cmd_str, id,
+		     sync_obj, fname, lineno, timeout);
+	}
+	else {
+		DMSG("%s thread %d %p %u", cmd_str, id, sync_obj, timeout);
+	}
+
+	time_left = fn(id + NOTIF_SYNC_VALUE_BASE, timeout);
+	return time_left;
+}
+
 static void do_notif(TEE_Result (*fn)(uint32_t), int id,
 		     const char *cmd_str __maybe_unused,
 		     const void *sync_obj __maybe_unused,
@@ -29,15 +50,18 @@ static void do_notif(TEE_Result (*fn)(uint32_t), int id,
 {
 	TEE_Result res = TEE_SUCCESS;
 
-	if (fname)
+	if (fname) {
 		DMSG("%s thread %d %p %s:%d", cmd_str, id,
 		     sync_obj, fname, lineno);
-	else
+	}
+	else {
 		DMSG("%s thread %d %p", cmd_str, id, sync_obj);
+	}
 
 	res = fn(id + NOTIF_SYNC_VALUE_BASE);
-	if (res)
+	if (res) {
 		DMSG("%s thread %d res %#"PRIx32, cmd_str, id, res);
+	}
 }
 
 static void slist_add_tail(struct wait_queue *wq, struct wait_queue_elem *wqe)
@@ -91,6 +115,30 @@ void wq_wait_final(struct wait_queue *wq, struct wait_queue_elem *wqe,
 	} while (!done);
 }
 
+/* This function is for WaitQueue_timeout function */
+uint32_t wq_wait_final_timeout(struct wait_queue *wq, struct wait_queue_elem *wqe,
+			const void *sync_obj, uint32_t timeout, const char *fname, int lineno)
+{
+	uint32_t old_itr_status;
+	unsigned done;
+	uint32_t time_left = 0;
+
+	do {
+		time_left = do_notif_timeout(notif_wait_timeout, wqe->handle,
+			 timeout, "sleep_timeout", sync_obj, fname, lineno);
+
+		old_itr_status = cpu_spin_lock_xsave(&wq_spin_lock);
+
+		done = wqe->done || (time_left == 0);
+		if (done)
+			SLIST_REMOVE(wq, wqe, wait_queue_elem, link);
+
+		cpu_spin_unlock_xrestore(&wq_spin_lock, old_itr_status);
+	} while (!done);
+
+	return time_left;
+}
+
 void wq_wake_next(struct wait_queue *wq, const void *sync_obj,
 			const char *fname, int lineno)
 {
diff --git a/core/lib/libtomcrypt/dh.c b/core/lib/libtomcrypt/dh.c
index 4eb9916..b1d0a4d 100644
--- a/core/lib/libtomcrypt/dh.c
+++ b/core/lib/libtomcrypt/dh.c
@@ -28,10 +28,10 @@ TEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->g);
-	crypto_bignum_free(s->p);
-	crypto_bignum_free(s->y);
-	crypto_bignum_free(s->x);
+	crypto_bignum_free(&s->g);
+	crypto_bignum_free(&s->p);
+	crypto_bignum_free(&s->y);
+	crypto_bignum_free(&s->x);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
diff --git a/core/lib/libtomcrypt/dsa.c b/core/lib/libtomcrypt/dsa.c
index a2dc720..d6243c4 100644
--- a/core/lib/libtomcrypt/dsa.c
+++ b/core/lib/libtomcrypt/dsa.c
@@ -30,10 +30,10 @@ TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->g);
-	crypto_bignum_free(s->p);
-	crypto_bignum_free(s->q);
-	crypto_bignum_free(s->y);
+	crypto_bignum_free(&s->g);
+	crypto_bignum_free(&s->p);
+	crypto_bignum_free(&s->q);
+	crypto_bignum_free(&s->y);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -52,9 +52,9 @@ TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->g);
-	crypto_bignum_free(s->p);
-	crypto_bignum_free(s->q);
+	crypto_bignum_free(&s->g);
+	crypto_bignum_free(&s->p);
+	crypto_bignum_free(&s->q);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
diff --git a/core/lib/libtomcrypt/ecc.c b/core/lib/libtomcrypt/ecc.c
index 9383782..fa645e1 100644
--- a/core/lib/libtomcrypt/ecc.c
+++ b/core/lib/libtomcrypt/ecc.c
@@ -18,8 +18,8 @@ static void _ltc_ecc_free_public_key(struct ecc_public_key *s)
 	if (!s)
 		return;
 
-	crypto_bignum_free(s->x);
-	crypto_bignum_free(s->y);
+	crypto_bignum_free(&s->x);
+	crypto_bignum_free(&s->y);
 }
 
 /*
@@ -465,8 +465,8 @@ TEE_Result crypto_asym_alloc_ecc_keypair(struct ecc_keypair *s,
 err:
 	s->ops = NULL;
 
-	crypto_bignum_free(s->d);
-	crypto_bignum_free(s->x);
+	crypto_bignum_free(&s->d);
+	crypto_bignum_free(&s->x);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
@@ -541,7 +541,7 @@ TEE_Result crypto_asym_alloc_ecc_public_key(struct ecc_public_key *s,
 err:
 	s->ops = NULL;
 
-	crypto_bignum_free(s->x);
+	crypto_bignum_free(&s->x);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
diff --git a/core/lib/libtomcrypt/mpi_desc.c b/core/lib/libtomcrypt/mpi_desc.c
index 235fbe6..ff8dd13 100644
--- a/core/lib/libtomcrypt/mpi_desc.c
+++ b/core/lib/libtomcrypt/mpi_desc.c
@@ -763,10 +763,13 @@ struct bignum *crypto_bignum_allocate(size_t size_bits)
 	return (struct bignum *)bn;
 }
 
-void crypto_bignum_free(struct bignum *s)
+void crypto_bignum_free(struct bignum **s)
 {
-	mbedtls_mpi_free((mbedtls_mpi *)s);
-	free(s);
+	assert(s);
+
+	mbedtls_mpi_free((mbedtls_mpi *)*s);
+	free(*s);
+	*s = NULL;
 }
 
 void crypto_bignum_clear(struct bignum *s)
diff --git a/core/lib/libtomcrypt/rsa.c b/core/lib/libtomcrypt/rsa.c
index 8d0443f..13ed239 100644
--- a/core/lib/libtomcrypt/rsa.c
+++ b/core/lib/libtomcrypt/rsa.c
@@ -131,7 +131,7 @@ TEE_Result sw_crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->e);
+	crypto_bignum_free(&s->e);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -143,8 +143,8 @@ void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)
 {
 	if (!s)
 		return;
-	crypto_bignum_free(s->n);
-	crypto_bignum_free(s->e);
+	crypto_bignum_free(&s->n);
+	crypto_bignum_free(&s->e);
 }
 
 
@@ -155,14 +155,14 @@ void sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)
 {
 	if (!s)
 		return;
-	crypto_bignum_free(s->e);
-	crypto_bignum_free(s->d);
-	crypto_bignum_free(s->n);
-	crypto_bignum_free(s->p);
-	crypto_bignum_free(s->q);
-	crypto_bignum_free(s->qp);
-	crypto_bignum_free(s->dp);
-	crypto_bignum_free(s->dq);
+	crypto_bignum_free(&s->e);
+	crypto_bignum_free(&s->d);
+	crypto_bignum_free(&s->n);
+	crypto_bignum_free(&s->p);
+	crypto_bignum_free(&s->q);
+	crypto_bignum_free(&s->qp);
+	crypto_bignum_free(&s->dp);
+	crypto_bignum_free(&s->dq);
 }
 
 TEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key,
diff --git a/core/mm/core_mmu.c b/core/mm/core_mmu.c
index f2ca9ff..2a8b5a0 100644
--- a/core/mm/core_mmu.c
+++ b/core/mm/core_mmu.c
@@ -34,6 +34,7 @@
 #endif
 
 #define SHM_VASPACE_SIZE	(1024 * 1024 * 32)
+#define MMZ_VASPACE_SIZE	(1024 * 1024 * 32)
 
 /*
  * These variables are initialized before .bss is cleared. To avoid
@@ -745,6 +746,7 @@ uint32_t core_mmu_type_to_attr(enum teecore_memtypes t)
 		return attr | TEE_MATTR_SECURE | TEE_MATTR_PRW | cached;
 	case MEM_AREA_RES_VASPACE:
 	case MEM_AREA_SHM_VASPACE:
+    case MEM_AREA_SEC_MMZ_VASPACE:
 		return 0;
 	case MEM_AREA_PAGER_VASPACE:
 		return TEE_MATTR_SECURE;
@@ -950,6 +952,9 @@ static size_t collect_mem_ranges(struct tee_mmap_region *memory_map,
 	add_va_space(memory_map, num_elems, MEM_AREA_SHM_VASPACE,
 		     SHM_VASPACE_SIZE, &last);
 
+    add_va_space(memory_map, num_elems, MEM_AREA_SEC_MMZ_VASPACE,
+		     MMZ_VASPACE_SIZE, &last);
+ 
 	memory_map[last].type = MEM_AREA_END;
 
 	return last;
@@ -1300,6 +1305,7 @@ static void check_mem_map(struct tee_mmap_region *map)
 		case MEM_AREA_RES_VASPACE:
 		case MEM_AREA_SHM_VASPACE:
 		case MEM_AREA_PAGER_VASPACE:
+        case MEM_AREA_SEC_MMZ_VASPACE:
 			break;
 		default:
 			EMSG("Uhandled memtype %d", m->type);
@@ -2265,6 +2271,7 @@ void *phys_to_virt(paddr_t pa, enum teecore_memtypes m, size_t len)
 		va = phys_to_virt_tee_ram(pa, len);
 		break;
 	case MEM_AREA_SHM_VASPACE:
+    case MEM_AREA_SEC_MMZ_VASPACE:
 		/* Find VA from PA in dynamic SHM is not yet supported */
 		va = NULL;
 		break;
diff --git a/core/mm/mobj_mmz.c b/core/mm/mobj_mmz.c
new file mode 100644
index 0000000..e5b9f1d
--- /dev/null
+++ b/core/mm/mobj_mmz.c
@@ -0,0 +1,255 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2022,
+ */
+
+#include <initcall.h>
+#include <keep.h>
+#include <kernel/linker.h>
+#include <kernel/mutex.h>
+#include <kernel/panic.h>
+#include <kernel/refcount.h>
+#include <kernel/spinlock.h>
+#include <kernel/tee_misc.h>
+#include <mm/core_mmu.h>
+#include <mm/mobj.h>
+#include <mm/mobj_mmz.h>
+#include <mm/tee_pager.h>
+#include <optee_msg.h>
+#include <sm/optee_smc.h>
+#include <stdlib.h>
+#include <tee_api_types.h>
+#include <types_ext.h>
+#include <util.h>
+
+/*
+ * mobj_reg_sec_mmz implementation. Describes SEC MMZ memory
+ */
+
+struct mobj_reg_sec_mmz {
+	struct mobj mobj;
+	tee_mm_entry_t *mm;
+	uint32_t cattr;
+	paddr_t pa;
+};
+
+static unsigned int reg_sec_mmz_map_lock = SPINLOCK_UNLOCK;
+
+static TEE_Result mobj_reg_sec_mmz_get_pa(struct mobj *mobj, size_t offst,
+				      size_t granule, paddr_t *pa)
+{
+	struct mobj_reg_sec_mmz *mobj_reg = to_mobj_reg_sec_mmz(mobj);
+	paddr_t p = 0;
+
+	if (!pa)
+		return TEE_ERROR_GENERIC;
+
+	if (offst >= mobj->size)
+		return TEE_ERROR_GENERIC;
+
+	switch (granule) {
+	case 0:
+		p = mobj_reg->pa + offst;
+		break;
+	case SMALL_PAGE_SIZE:
+		p = mobj_reg->pa + offst;
+		break;
+	default:
+		return TEE_ERROR_GENERIC;
+	}
+	*pa = p;
+
+	return TEE_SUCCESS;
+}
+DECLARE_KEEP_PAGER(mobj_reg_sec_mmz_get_pa);
+
+static void *mobj_reg_sec_mmz_get_va(struct mobj *mobj, size_t offst, size_t len)
+{
+    struct mobj_reg_sec_mmz *mobj_reg = to_mobj_reg_sec_mmz(mobj);
+    (void) len;
+
+	if (!mobj_reg->mm || offst >= mobj->size)
+		return NULL;
+
+	return (void *)(vaddr_t)(tee_mm_get_smem(mobj_reg->mm) + offst);
+}
+
+static void reg_shm_free_helper(struct mobj_reg_sec_mmz *mobj_reg_sec_mmz)
+{
+	if (mobj_reg_sec_mmz->mm) {
+		panic("This mem still maped in kernel");
+	}
+
+	free(mobj_reg_sec_mmz);
+}
+
+static void mobj_reg_sec_mmz_free(struct mobj *mobj)
+{
+	struct mobj_reg_sec_mmz *mobj_reg = to_mobj_reg_sec_mmz(mobj);
+        uint32_t exceptions = 0;
+
+	exceptions = cpu_spin_lock_xsave(&reg_sec_mmz_map_lock);
+	reg_shm_free_helper(mobj_reg);
+	cpu_spin_unlock_xrestore(&reg_sec_mmz_map_lock, exceptions);
+}
+
+static TEE_Result mobj_reg_sec_mmz_get_cattr(struct mobj *mobj __unused,
+					 uint32_t *cattr)
+{
+	struct mobj_reg_sec_mmz *mobj_reg = to_mobj_reg_sec_mmz(mobj);
+
+	if (!cattr)
+		return TEE_ERROR_GENERIC;
+
+	*cattr = mobj_reg->cattr;
+
+	return TEE_SUCCESS;
+}
+
+static bool mobj_shm_matches(struct mobj *mobj __unused, enum buf_is_attr attr);
+
+const struct mobj_ops mobj_reg_sec_mmz_ops __weak __relrodata_unpaged ("mobj_reg_sec_mmz_ops")= {
+	.get_pa = mobj_reg_sec_mmz_get_pa,
+	.get_phys_offs = NULL,
+	.get_va = mobj_reg_sec_mmz_get_va,
+	.get_mem_type = mobj_reg_sec_mmz_get_cattr,
+	.matches = mobj_shm_matches,
+	.free = mobj_reg_sec_mmz_free,
+	.get_cookie = NULL,
+	.get_fobj = NULL,
+};
+
+static bool mobj_shm_matches(struct mobj *mobj __unused, enum buf_is_attr attr)
+{
+    return attr == CORE_MEM_SEC;
+}
+
+struct mobj_reg_sec_mmz *to_mobj_reg_sec_mmz(struct mobj *mobj)
+{
+	return container_of(mobj, struct mobj_reg_sec_mmz, mobj);
+}
+
+static struct mobj_reg_sec_mmz *to_mobj_reg_sec_mmz_may_fail(struct mobj *mobj)
+{
+	if (mobj && mobj->ops != &mobj_reg_sec_mmz_ops)
+		return NULL;
+
+	return container_of(mobj, struct mobj_reg_sec_mmz, mobj);
+}
+
+struct mobj *mobj_reg_sec_mmz_alloc(paddr_t pa, size_t size, uint32_t cattr)
+{
+	struct mobj_reg_sec_mmz *mobj_reg  = NULL;
+
+	mobj_reg = calloc(1, sizeof(struct mobj_reg_sec_mmz));
+	if (!mobj_reg)
+		return NULL;
+
+	mobj_reg->mobj.ops = &mobj_reg_sec_mmz_ops;
+	mobj_reg->mobj.size = size;
+	mobj_reg->mobj.phys_granule = SMALL_PAGE_SIZE;
+	refcount_set(&mobj_reg->mobj.refc, 1);
+	mobj_reg->pa = pa;
+	mobj_reg->cattr = cattr;
+	return &mobj_reg->mobj;
+}
+
+TEE_Result mobj_reg_sec_mmz_kmap(struct mobj *mobj)
+{
+	TEE_Result res = TEE_SUCCESS;
+	struct mobj_reg_sec_mmz *mobj_reg = to_mobj_reg_sec_mmz_may_fail(mobj);
+	size_t sz = 0;
+	size_t pages_num = 0;
+	paddr_t *pages = NULL;
+	size_t i;
+    uint32_t exceptions = cpu_spin_lock_xsave(&reg_sec_mmz_map_lock);
+
+	if (!mobj_reg)
+		return TEE_ERROR_GENERIC;
+
+	if (mobj_reg->mm != NULL)
+		return TEE_SUCCESS;
+
+	sz = ROUNDUP(mobj->size, SMALL_PAGE_SIZE);
+	
+	mobj_reg->mm = tee_mm_alloc(&tee_mm_sec_mmz, sz);
+	if (!mobj_reg->mm) {
+		res = TEE_ERROR_OUT_OF_MEMORY;
+		goto out;
+	}
+
+	pages_num = sz / SMALL_PAGE_SIZE;
+	pages = calloc(pages_num, sizeof(paddr_t));
+	if (pages == NULL) {
+		res = TEE_ERROR_OUT_OF_MEMORY;
+		goto pages_calloc_err;
+	}
+
+	for (i = 0; i < pages_num; i++) {
+		pages[i] = mobj_reg->pa + i * SMALL_PAGE_SIZE;
+	}
+
+	/* 
+	 * Here we simply use MEM_AREA_IO_SEC and MEM_AREA_RAM_SEC to 
+	 * obtain the correct memory attributes.
+	 * This memory is SEC MMZ memory.
+	 * noncache : TEE_MATTR_CACHE_NONCACHE << TEE_MATTR_CACHE_SHIFT
+	 * cached : TEE_MATTR_MEM_TYPE_CACHED << TEE_MATTR_CACHE_SHIFT
+	 * MEM_AREA_IO_SEC : TEE_MATTR_SECURE | TEE_MATTR_PRW | noncache
+	 * MEM_AREA_RAM_SEC : TEE_MATTR_SECURE | TEE_MATTR_PRW | cached
+	 */
+
+	if (mobj_reg->cattr == TEE_MATTR_MEM_TYPE_DEV) {
+		res = core_mmu_map_pages(tee_mm_get_smem(mobj_reg->mm), pages, pages_num, MEM_AREA_IO_SEC);
+	} else {
+		res = core_mmu_map_pages(tee_mm_get_smem(mobj_reg->mm), pages, pages_num, MEM_AREA_RAM_SEC);
+	}
+
+	free(pages);
+
+pages_calloc_err:
+	if (res) {
+		tee_mm_free(mobj_reg->mm);
+		mobj_reg->mm = NULL;
+	}
+
+out:
+	cpu_spin_unlock_xrestore(&reg_sec_mmz_map_lock, exceptions);
+
+	return res;
+}
+
+TEE_Result mobj_reg_sec_mmz_kunmap(struct mobj *mobj)
+{
+	struct mobj_reg_sec_mmz *mobj_reg = to_mobj_reg_sec_mmz_may_fail(mobj);
+	uint32_t exceptions = 0;
+
+	if (!mobj_reg)
+		return TEE_ERROR_GENERIC;
+
+	exceptions = cpu_spin_lock_xsave(&reg_sec_mmz_map_lock);
+	core_mmu_unmap_pages(tee_mm_get_smem(mobj_reg->mm), mobj_reg->mm->size);
+	tee_mm_free(mobj_reg->mm);
+	mobj_reg->mm = NULL;
+	cpu_spin_unlock_xrestore(&reg_sec_mmz_map_lock, exceptions);
+
+	return TEE_SUCCESS;
+}
+
+TEE_Result mobj_mapped_sec_mmz_init(void)
+{
+	vaddr_t pool_start = 0;
+	vaddr_t pool_end = 0;
+
+	core_mmu_get_mem_by_type(MEM_AREA_SEC_MMZ_VASPACE, &pool_start, &pool_end);
+	if (!pool_start || !pool_end)
+		panic("Can't find region for shmem pool");
+
+	if (!tee_mm_init(&tee_mm_sec_mmz, pool_start, pool_end, SMALL_PAGE_SHIFT,
+		    TEE_MM_POOL_NO_FLAGS))
+		panic("Could not create shmem pool");
+
+	DMSG("Shared memory address range: %" PRIxVA ", %" PRIxVA,
+	     pool_start, pool_end);
+	return TEE_SUCCESS;
+}
diff --git a/core/mm/sub.mk b/core/mm/sub.mk
index 4f9647f..b593c17 100644
--- a/core/mm/sub.mk
+++ b/core/mm/sub.mk
@@ -5,4 +5,4 @@ srcs-y += file.c
 srcs-y += vm.c
 srcs-y += core_mmu.c
 srcs-y += tee_mm.c
-
+srcs-$(CFG_MMZ_SUPPORT) += mobj_mmz.c
diff --git a/core/mm/tee_mm.c b/core/mm/tee_mm.c
index c61306d..ff2bcae 100644
--- a/core/mm/tee_mm.c
+++ b/core/mm/tee_mm.c
@@ -362,6 +362,9 @@ tee_mm_pool_t tee_mm_vcore;
 /* Shared memory pool */
 tee_mm_pool_t tee_mm_shm;
 
+/* SEC MMZ virt addr pool */
+tee_mm_pool_t tee_mm_sec_mmz;
+ 
 tee_mm_entry_t *tee_mm_find(const tee_mm_pool_t *pool, paddr_t addr)
 {
 	tee_mm_entry_t *entry = pool->entry;
diff --git a/core/secure_boot.om b/core/secure_boot.om
new file mode 100644
index 0000000..f73af5e
--- /dev/null
+++ b/core/secure_boot.om
@@ -0,0 +1,7 @@
+                                                                                                            1   )0     0      +0            #     '           +     V    >     N    /     Q    "     &         +  (    V    >     N    /     Q    )0     0      +0             
+   b     f                  "    &     +      /     ^    >    N    3      Y       "     &    +      /     ^    >    N    3      Y         "  "  &  $   +      /  h  ^    >    N    3      Y         )0     0      +0        (                         ,   #    F   &   P  $    !       	F    .
+   %   N     &     .
+                       h  !          &    $    !             h      .
+    $    !          6       6    '(     0    h             6     &         &    !    &    '     +      .     V   &   L 1   N    5    N    9    N    p  >   &   <  F   &   8 <     x    $   L  !       !       @     V    $     !       ~    &     %     (   P  V    ,    ^   X    0   `    7     f     &    7     !       n     &       .
+        .
+       *   `    P    A-   !       !       $    6    6     &     $    !          $    !       !           &     ,h    $    !         h b      j  f       l  j       n n      p r       r  v      t  z      v ~       x         z       |       ~                                                                                                                                                                               ,h      !       )             +      )       !      +      )       *!     +      )       "      +      )       *#      +      )       #     +      )       *$     +      )       *"     +      ,     "       
\ No newline at end of file
diff --git a/core/tee/tee_svc_cryp.c b/core/tee/tee_svc_cryp.c
index 534e5ac..ca1f371 100644
--- a/core/tee/tee_svc_cryp.c
+++ b/core/tee/tee_svc_cryp.c
@@ -869,7 +869,7 @@ static void op_attr_bignum_free(void *attr)
 {
 	struct bignum **bn = attr;
 
-	crypto_bignum_free(*bn);
+	crypto_bignum_free(bn);
 	*bn = NULL;
 }
 
@@ -3445,8 +3445,8 @@ TEE_Result syscall_cryp_derive_key(unsigned long state,
 		} else {
 			res = TEE_ERROR_OUT_OF_MEMORY;
 		}
-		crypto_bignum_free(pub);
-		crypto_bignum_free(ss);
+		crypto_bignum_free(&pub);
+		crypto_bignum_free(&ss);
 	} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {
 		struct ecc_public_key key_public;
 		uint8_t *pt_secret;
diff --git a/keys/.gitkeep b/keys/.gitkeep
new file mode 100644
index 0000000..e69de29
diff --git a/keys/default_ta.pem b/keys/default_ta.pem
deleted file mode 100644
index a8e5dcd..0000000
--- a/keys/default_ta.pem
+++ /dev/null
@@ -1,27 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEpAIBAAKCAQEAploYrcCzzuMMkCt9QJusu1pJiEIKseCSwIaR5p7voOHxL5D2
-Zt3qFVrAKLSd31IMbqXGGUOsaajyX/5gAKXSOswSAfNbugxRHCz0sHe51nI1HA9z
-zS8W+bqJhKCbv4tbf+iLi5/IceocbB8AoO7KPr8YjlebSGbri9RAUa6GoYb40Av6
-ti4lLgX/dgFG1z3rH3z83x6Ci16wyqPqFr4tblRQnLhB7xfHf2BUqvlwoPiYLoL5
-jF/7nIiOd7Aycpka4ARevx2q9/AFPLSV3U26OnGh+HKOHZjjE7rKsCe/h1lUJ/jo
-7MaFN9I6leSlCZrQH6OGsJLYAh4zddsmvyf8NQIDAQABAoIBAEoooBfVcFMqpM8g
-lBXZUIe1GFLGHj5t/v4U/7Xv5KO0FfE+jpoNE+2xJzj+S+LikOhCvq1Enff8eRCS
-NfoT8kSD9QMpmhq2ovIMmIiS1yXihAqeWOF/vJ5XqjaV4tjhJ0k+Qfdco98knscU
-ixMzYLXYOvo509/TAe60EHhZdWtMKCmHqvFBRDhYFF+HUxWnJa39G1u828ljv8uN
-iRCXbEjoaWDwBJWRzDZJehrkQc2gQAkFpyePVqA3wm1tx1ZHEVwCqYOXOP49/LAc
-rQfoWUpm4chjEHnZEb+dQxa3N8Qeq2lqgcqrOX8NIfpzWTWQ1JM+ksinQwMJ0BDV
-+Lf1nAECgYEA2KBBtsj41ITez8iA0DpXovH1F9oU9aJ9JKopNos8zIZg012bE5Ib
-kFII0LiBGKLUP2PepTsPDIOxibLQDojg1aBGHISZVp/y81B4Rk7Wwg206ZQ848dM
-AhACIrzOtJLoVEZTPf7C5QrNMhViyf2c8vFBjfTuM7Ze6a0fsvfJ2ikCgYEAxJaO
-XKnOgKoG1Fe9JVM01U+260BEybNUbbXQCnvMjTSZCsOEmST9mhXhC56lhCNqmynt
-FxNuq/JMwtS3TRhrYCPPCLFly+JNTqUS1mLQ9ytVbaw6fp9mSxFUQE9d9obkGwJC
-3uXEx+bc7YSGuwD34wikX0tB1zzGIXRH2JlB6y0CgYEAgFlDVjdxJwmqslXL7JQE
-xKizXPR7oqYpm4WucYDB/zRHPjSh41CYQEQ6sOAArUYcl4pmqmN5oSKOGFX37ASx
-oiEaKV9vMuIGIp+1A4NGvyc734FTKmo04Kv3d/mCR38bZINeYscFVou11EzTgXZg
-fZjwDFnooH8XcUCAHZuu3zECgYEAt6pltSMcgE7Z9JdIas/TI5vHLQEtgzhdH+bm
-SHUjRaWnekvy3VWW7deVGtMMlmi0V+US0iVgl5rXposv+gJfh0HNUrTSg2qZiWlm
-MQ+/Zb2BoeZv/A8Wdfnpue+svP+Hq8gwC6mlcJI7RFk1uw8LiXxwfWuFRv9LqMPH
-wBBnar0CgYAJF3ukzm7rnut19lzS4r1uEIuuPwk/DjEkkil7U9wE5fr+ds5rCtXj
-9591DLHrtE/CBOWym2+tIDr7OnmfU+934524mtLWVZdf39/DFM9Fc1VaSualrj/1
-BOLhBb7MEZqN7hHcQP7+49YW72GgX3pm0Ov5ke33FzN3ubIwAS6T7A==
------END RSA PRIVATE KEY-----
diff --git a/lib/libbsptee/sub.mk b/lib/libbsptee/sub.mk
new file mode 100644
index 0000000..a41275b
--- /dev/null
+++ b/lib/libbsptee/sub.mk
@@ -0,0 +1,6 @@
+ifeq ($(CFG_MMZ_COMPONENT), n)
+subdirs-$(CFG_MMZ_SUPPORT) += ../../bsp/mmz/lib
+endif
+subdirs-$(CFG_SECURITY_SUBSYS_SUPPORT) += ../../bsp/security_subsys/lib
+subdirs-$(CFG_NPU) += ../../bsp/npu/lib
+subdirs_ext-$(CFG_WITH_MUSL_MATH_LIB) += $(PWD)/../../musl
diff --git a/lib/libmbedtls/core/bignum.c b/lib/libmbedtls/core/bignum.c
index 61f6c5c..dea30f6 100644
--- a/lib/libmbedtls/core/bignum.c
+++ b/lib/libmbedtls/core/bignum.c
@@ -87,10 +87,13 @@ struct bignum *crypto_bignum_allocate(size_t size_bits)
 	return (struct bignum *)bn;
 }
 
-void crypto_bignum_free(struct bignum *s)
+void crypto_bignum_free(struct bignum **s)
 {
-	mbedtls_mpi_free((mbedtls_mpi *)s);
-	free(s);
+	assert(s);
+
+	mbedtls_mpi_free((mbedtls_mpi *)*s);
+	free(*s);
+	*s = NULL;
 }
 
 void crypto_bignum_clear(struct bignum *s)
diff --git a/lib/libmbedtls/core/dh.c b/lib/libmbedtls/core/dh.c
index b3415aa..e95aa14 100644
--- a/lib/libmbedtls/core/dh.c
+++ b/lib/libmbedtls/core/dh.c
@@ -35,10 +35,10 @@ TEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->g);
-	crypto_bignum_free(s->p);
-	crypto_bignum_free(s->y);
-	crypto_bignum_free(s->x);
+	crypto_bignum_free(&s->g);
+	crypto_bignum_free(&s->p);
+	crypto_bignum_free(&s->y);
+	crypto_bignum_free(&s->x);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
diff --git a/lib/libmbedtls/core/ecc.c b/lib/libmbedtls/core/ecc.c
index fd4a51b..46cd9fd 100644
--- a/lib/libmbedtls/core/ecc.c
+++ b/lib/libmbedtls/core/ecc.c
@@ -40,8 +40,8 @@ static void ecc_free_public_key(struct ecc_public_key *s)
 	if (!s)
 		return;
 
-	crypto_bignum_free(s->x);
-	crypto_bignum_free(s->y);
+	crypto_bignum_free(&s->x);
+	crypto_bignum_free(&s->y);
 }
 
 /*
@@ -484,8 +484,8 @@ TEE_Result crypto_asym_alloc_ecc_keypair(struct ecc_keypair *s,
 	return TEE_SUCCESS;
 
 err:
-	crypto_bignum_free(s->d);
-	crypto_bignum_free(s->x);
+	crypto_bignum_free(&s->d);
+	crypto_bignum_free(&s->x);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
@@ -581,7 +581,7 @@ TEE_Result crypto_asym_alloc_ecc_public_key(struct ecc_public_key *s,
 	return TEE_SUCCESS;
 
 err:
-	crypto_bignum_free(s->x);
+	crypto_bignum_free(&s->x);
 
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
diff --git a/lib/libmbedtls/core/rsa.c b/lib/libmbedtls/core/rsa.c
index c3b5be5..a8aeb2c 100644
--- a/lib/libmbedtls/core/rsa.c
+++ b/lib/libmbedtls/core/rsa.c
@@ -183,7 +183,7 @@ TEE_Result sw_crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,
 		goto err;
 	return TEE_SUCCESS;
 err:
-	crypto_bignum_free(s->e);
+	crypto_bignum_free(&s->e);
 	return TEE_ERROR_OUT_OF_MEMORY;
 }
 
@@ -194,8 +194,8 @@ void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)
 {
 	if (!s)
 		return;
-	crypto_bignum_free(s->n);
-	crypto_bignum_free(s->e);
+	crypto_bignum_free(&s->n);
+	crypto_bignum_free(&s->e);
 }
 
 void crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)
@@ -205,14 +205,14 @@ void sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)
 {
 	if (!s)
 		return;
-	crypto_bignum_free(s->e);
-	crypto_bignum_free(s->d);
-	crypto_bignum_free(s->n);
-	crypto_bignum_free(s->p);
-	crypto_bignum_free(s->q);
-	crypto_bignum_free(s->qp);
-	crypto_bignum_free(s->dp);
-	crypto_bignum_free(s->dq);
+	crypto_bignum_free(&s->e);
+	crypto_bignum_free(&s->d);
+	crypto_bignum_free(&s->n);
+	crypto_bignum_free(&s->p);
+	crypto_bignum_free(&s->q);
+	crypto_bignum_free(&s->qp);
+	crypto_bignum_free(&s->dp);
+	crypto_bignum_free(&s->dq);
 }
 
 TEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key,
diff --git a/lib/libsecurec/LICENSE b/lib/libsecurec/LICENSE
new file mode 100644
index 0000000..42f2a83
--- /dev/null
+++ b/lib/libsecurec/LICENSE
@@ -0,0 +1,124 @@
+ 2
+
+20201 http://license.coscl.org.cn/MulanPSL2
+
+2
+
+0.   
+
+ 
+
+ 
+
+ 
+
+ 
+
+ 50%
+
+1.   
+
+
+
+2.   
+
+
+
+3.   
+
+4
+
+4.   
+
+
+
+5.   
+
+
+
+6.   
+
+
+
+
+
+2
+
+2
+
+1 
+
+2 LICENSE
+
+3 
+
+Copyright (c) [Year] [name of copyright holder]
+[Software Name] is licensed under Mulan PSL v2.
+You can use this software according to the terms and conditions of the Mulan PSL v2.
+You may obtain a copy of Mulan PSL v2 at:
+         http://license.coscl.org.cn/MulanPSL2
+THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+See the Mulan PSL v2 for more details.
+Mulan Permissive Software License,Version 2
+Mulan Permissive Software License,Version 2 (Mulan PSL v2)
+
+January 2020 http://license.coscl.org.cn/MulanPSL2
+
+Your reproduction, use, modification and distribution of the Software shall be subject to Mulan PSL v2 (this License) with the following terms and conditions:
+
+0. Definition
+
+Software means the program and related documents which are licensed under this License and comprise all Contribution(s).
+
+Contribution means the copyrightable work licensed by a particular Contributor under this License.
+
+Contributor means the Individual or Legal Entity who licenses its copyrightable work under this License.
+
+Legal Entity means the entity making a Contribution and all its Affiliates.
+
+Affiliates means entities that control, are controlled by, or are under common control with the acting entity under this License, 'control' means direct or indirect ownership of at least fifty percent (50%) of the voting power, capital or other securities of controlled or commonly controlled entity.
+
+1. Grant of Copyright License
+
+Subject to the terms and conditions of this License, each Contributor hereby grants to you a perpetual, worldwide, royalty-free, non-exclusive, irrevocable copyright license to reproduce, use, modify, or distribute its Contribution, with modification or not.
+
+2. Grant of Patent License
+
+Subject to the terms and conditions of this License, each Contributor hereby grants to you a perpetual, worldwide, royalty-free, non-exclusive, irrevocable (except for revocation under this Section) patent license to make, have made, use, offer for sale, sell, import or otherwise transfer its Contribution, where such patent license is only limited to the patent claims owned or controlled by such Contributor now or in future which will be necessarily infringed by its Contribution alone, or by combination of the Contribution with the Software to which the Contribution was contributed. The patent license shall not apply to any modification of the Contribution, and any other combination which includes the Contribution. If you or your Affiliates directly or indirectly institute patent litigation (including a cross claim or counterclaim in a litigation) or other patent enforcement activities against any individual or entity by alleging that the Software or any Contribution in it infringes patents, then any patent license granted to you under this License for the Software shall terminate as of the date such litigation or activity is filed or taken.
+
+3. No Trademark License
+
+No trademark license is granted to use the trade names, trademarks, service marks, or product names of Contributor, except as required to fulfill notice requirements in section 4.
+
+4. Distribution Restriction
+
+You may distribute the Software in any medium with or without modification, whether in source or executable forms, provided that you provide recipients with a copy of this License and retain copyright, patent, trademark and disclaimer statements in the Software.
+
+5. Disclaimer of Warranty and Limitation of Liability
+
+THE SOFTWARE AND CONTRIBUTION IN IT ARE PROVIDED WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED. IN NO EVENT SHALL ANY CONTRIBUTOR OR COPYRIGHT HOLDER BE LIABLE TO YOU FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO ANY DIRECT, OR INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING FROM YOUR USE OR INABILITY TO USE THE SOFTWARE OR THE CONTRIBUTION IN IT, NO MATTER HOW IT'S CAUSED OR BASED ON WHICH LEGAL THEORY, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+6. Language
+
+THIS LICENSE IS WRITTEN IN BOTH CHINESE AND ENGLISH, AND THE CHINESE VERSION AND ENGLISH VERSION SHALL HAVE THE SAME LEGAL EFFECT. IN THE CASE OF DIVERGENCE BETWEEN THE CHINESE AND ENGLISH VERSIONS, THE CHINESE VERSION SHALL PREVAIL.
+
+END OF THE TERMS AND CONDITIONS
+
+How to Apply the Mulan Permissive Software License,Version 2 (Mulan PSL v2) to Your Software
+
+To apply the Mulan PSL v2 to your work, for easy identification by recipients, you are suggested to complete following three steps:
+
+Fill in the blanks in following statement, including insert your software name, the year of the first publication of your software, and your name identified as the copyright owner;
+Create a file named "LICENSE" which contains the whole context of this License in the first directory of your software package;
+Attach the statement to the appropriate annotated syntax at the beginning of each source file.
+Copyright (c) [Year] [name of copyright holder]
+[Software Name] is licensed under Mulan PSL v2.
+You can use this software according to the terms and conditions of the Mulan PSL v2.
+You may obtain a copy of Mulan PSL v2 at:
+         http://license.coscl.org.cn/MulanPSL2
+THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+See the Mulan PSL v2 for more details.
\ No newline at end of file
diff --git a/lib/libsecurec/README.en.md b/lib/libsecurec/README.en.md
new file mode 100644
index 0000000..60c477f
--- /dev/null
+++ b/lib/libsecurec/README.en.md
@@ -0,0 +1,59 @@
+# libboundscheck
+
+#### Description
+
+- following the standard of C11 Annex K (bound-checking interfaces), functions of the common memory/string operation classes, such as memcpy_s, strcpy_s, are selected and implemented.
+
+- other standard functions in C11 Annex K will be analyzed in the future and implemented in this organization if necessary.
+
+- handles the release, update, and maintenance of bounds_checking_function.
+
+#### Function List
+
+- memcpy_s
+- wmemcpy_s
+- memmove_s
+- wmemmove_s
+- memset_s
+- strcpy_s
+- wcscpy_s
+- strncpy_s
+- wcsncpy_s
+- strcat_s
+- wcscat_s
+- strncat_s
+- wcsncat_s
+- strtok_s
+- wcstok_s
+- sprintf_s
+- swprintf_s
+- vsprintf_s
+- vswprintf_s
+- snprintf_s
+- vsnprintf_s
+- scanf_s
+- wscanf_s
+- vscanf_s
+- vwscanf_s
+- fscanf_s
+- fwscanf_s
+- vfscanf_s
+- vfwscanf_s
+- sscanf_s
+- swscanf_s
+- vsscanf_s
+- vswscanf_s
+- gets_s
+
+
+#### Build
+
+```
+CC=gcc make
+```
+The generated Dynamic library libboundscheck.so is stored in the newly created directory lib.
+
+#### How to use
+1. Copy the libboundscheck.so to the library file directory, for example: "/usr/local/lib/".
+
+2. To use the libboundscheck, add the -lboundscheck parameters to the compiler, for example: gcc -g -o test test.c -lboundscheck. 
\ No newline at end of file
diff --git a/lib/libsecurec/README.md b/lib/libsecurec/README.md
new file mode 100644
index 0000000..c16cbb1
--- /dev/null
+++ b/lib/libsecurec/README.md
@@ -0,0 +1,56 @@
+# libboundscheck
+
+#### 
+- C11 Annex K (Bounds-checking interfaces)/memcpy_sstrcpy_s
+- C11 Annex K
+- 
+
+#### 
+
+- memcpy_s
+- wmemcpy_s
+- memmove_s
+- wmemmove_s
+- memset_s
+- strcpy_s
+- wcscpy_s
+- strncpy_s
+- wcsncpy_s
+- strcat_s
+- wcscat_s
+- strncat_s
+- wcsncat_s
+- strtok_s
+- wcstok_s
+- sprintf_s
+- swprintf_s
+- vsprintf_s
+- vswprintf_s
+- snprintf_s
+- vsnprintf_s
+- scanf_s
+- wscanf_s
+- vscanf_s
+- vwscanf_s
+- fscanf_s
+- fwscanf_s
+- vfscanf_s
+- vfwscanf_s
+- sscanf_s
+- swscanf_s
+- vsscanf_s
+- vswscanf_s
+- gets_s
+
+#### 
+
+
+```
+make CC=gcc
+```
+libboundscheck.solib
+
+#### 
+1. libboundscheck.so"/usr/local/lib/"
+
+2. libboundscheck"-lboundscheck""gcc -g -o test test.c -lboundscheck"
\ No newline at end of file
diff --git a/lib/libsecurec/include/securec.h b/lib/libsecurec/include/securec.h
new file mode 100644
index 0000000..0dc4c7a
--- /dev/null
+++ b/lib/libsecurec/include/securec.h
@@ -0,0 +1,629 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: The user of this secure c library should include this header file in you source code.
+ *              This header file declare all supported API prototype of the library,
+ *              such as memcpy_s, strcpy_s, wcscpy_s,strcat_s, strncat_s, sprintf_s, scanf_s, and so on.
+ * Create: 2014-02-25
+ * Notes: Do not modify this file by yourself.
+ */
+
+#ifndef SECUREC_H_5D13A042_DC3F_4ED9_A8D1_882811274C27
+#define SECUREC_H_5D13A042_DC3F_4ED9_A8D1_882811274C27
+
+#include "securectype.h"
+#ifndef SECUREC_HAVE_STDARG_H
+#define SECUREC_HAVE_STDARG_H 1
+#endif
+
+#if SECUREC_HAVE_STDARG_H
+#include <stdarg.h>
+#endif
+
+#ifndef SECUREC_HAVE_ERRNO_H
+#define SECUREC_HAVE_ERRNO_H 1
+#endif
+
+/* EINVAL ERANGE may defined in errno.h */
+#if SECUREC_HAVE_ERRNO_H
+#if SECUREC_IN_KERNEL
+#include <linux/errno.h>
+#else
+//#include <errno.h>
+#endif
+#endif
+
+/* Define error code */
+#if defined(SECUREC_NEED_ERRNO_TYPE) || !defined(__STDC_WANT_LIB_EXT1__) || \
+    (defined(__STDC_WANT_LIB_EXT1__) && (!__STDC_WANT_LIB_EXT1__))
+#ifndef SECUREC_DEFINED_ERRNO_TYPE
+#define SECUREC_DEFINED_ERRNO_TYPE
+/* Just check whether macrodefinition exists. */
+#ifndef errno_t
+typedef int errno_t;
+#endif
+#endif
+#endif
+
+/* Success */
+#ifndef EOK
+#define EOK 0
+#endif
+
+#ifndef EINVAL
+/* The src buffer is not correct and destination buffer can not be reset */
+#define EINVAL 22
+#endif
+
+#ifndef EINVAL_AND_RESET
+/* Once the error is detected, the dest buffer must be reset! Value is 22 or 128 */
+#define EINVAL_AND_RESET 150
+#endif
+
+#ifndef ERANGE
+/* The destination buffer is not long enough and destination buffer can not be reset */
+#define ERANGE 34
+#endif
+
+#ifndef ERANGE_AND_RESET
+/* Once the error is detected, the dest buffer must be reset! Value is 34 or 128 */
+#define ERANGE_AND_RESET  162
+#endif
+
+#ifndef EOVERLAP_AND_RESET
+/* Once the buffer overlap is detected, the dest buffer must be reset! Value is 54 or 128 */
+#define EOVERLAP_AND_RESET 182
+#endif
+
+/* If you need export the function of this library in Win32 dll, use __declspec(dllexport) */
+#ifndef SECUREC_API
+#if defined(SECUREC_DLL_EXPORT)
+#define SECUREC_API __declspec(dllexport)
+#elif defined(SECUREC_DLL_IMPORT)
+#define SECUREC_API __declspec(dllimport)
+#else
+/*
+ * Standardized function declaration. If a security function is declared in the your code,
+ * it may cause a compilation alarm,Please delete the security function you declared.
+ * Adding extern under windows will cause the system to have inline functions to expand,
+ * so do not add the extern in default
+ */
+#if defined(_MSC_VER)
+#define SECUREC_API
+#else
+#define SECUREC_API extern
+#endif
+#endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Description: The GetHwSecureCVersion function get SecureC Version string and version number.
+ * Parameter: verNumber - to store version number (for example value is 0x500 | 0xa)
+ * Return:   version string
+ */
+SECUREC_API const char *GetHwSecureCVersion(unsigned short *verNumber);
+
+#if SECUREC_ENABLE_MEMSET
+/*
+ * Description: The memset_s function copies the value of c (converted to an unsigned char) into each of
+ * the first count characters of the object pointed to by dest.
+ * Parameter: dest - destination address
+ * Parameter: destMax - The maximum length of destination buffer
+ * Parameter: c - the value to be copied
+ * Parameter: count - copies count bytes of value to dest
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t memset_s(void *dest, size_t destMax, int c, size_t count);
+#endif
+
+#ifndef SECUREC_ONLY_DECLARE_MEMSET
+#define SECUREC_ONLY_DECLARE_MEMSET     0
+#endif
+
+#if !SECUREC_ONLY_DECLARE_MEMSET
+
+#if SECUREC_ENABLE_MEMMOVE
+/*
+ * Description: The memmove_s function copies n characters from the object pointed to by src
+ * into the object pointed to by dest.
+ * Parameter: dest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer
+ * Parameter: src - source address
+ * Parameter: count - copies count bytes from the src
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t memmove_s(void *dest, size_t destMax, const void *src, size_t count);
+#endif
+
+#if SECUREC_ENABLE_MEMCPY
+/*
+ * Description: The memcpy_s function copies n characters from the object pointed to
+ * by src into the object pointed to by dest.
+ * Parameter: dest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer
+ * Parameter: src - source address
+ * Parameter: count - copies count bytes from the  src
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t memcpy_s(void *dest, size_t destMax, const void *src, size_t count);
+#endif
+
+#if SECUREC_ENABLE_STRCPY
+/*
+ * Description: The strcpy_s function copies the string pointed to by strSrc (including
+ * the terminating null character) into the array pointed to by strDest
+ * Parameter: strDest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null character)
+ * Parameter: strSrc - source address
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t strcpy_s(char *strDest, size_t destMax, const char *strSrc);
+#endif
+
+#if SECUREC_ENABLE_STRNCPY
+/*
+ * Description: The strncpy_s function copies not more than n successive characters (not including
+ * the terminating null character) from the array pointed to by strSrc to the array pointed to by strDest.
+ * Parameter: strDest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null character)
+ * Parameter: strSrc - source  address
+ * Parameter: count - copies count characters from the src
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t strncpy_s(char *strDest, size_t destMax, const char *strSrc, size_t count);
+#endif
+
+#if SECUREC_ENABLE_STRCAT
+/*
+ * Description: The strcat_s function appends a copy of the string pointed to by strSrc (including
+ * the terminating null character) to the end of the string pointed to by strDest.
+ * Parameter: strDest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null wide character)
+ * Parameter: strSrc - source address
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t strcat_s(char *strDest, size_t destMax, const char *strSrc);
+#endif
+
+#if SECUREC_ENABLE_STRNCAT
+/*
+ * Description: The strncat_s function appends not more than n successive characters (not including
+ * the terminating null character)
+ * from the array pointed to by strSrc to the end of the string pointed to by strDest.
+ * Parameter: strDest - destination address
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null character)
+ * Parameter: strSrc - source address
+ * Parameter: count - copies count characters from the src
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t strncat_s(char *strDest, size_t destMax, const char *strSrc, size_t count);
+#endif
+
+#if SECUREC_ENABLE_VSPRINTF
+/*
+ * Description: The vsprintf_s function is equivalent to the vsprintf function except for the parameter destMax
+ * and the explicit runtime-constraints violation
+ * Parameter: strDest -  produce output according to a format,write to the character string strDest.
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null wide character)
+ * Parameter: format - format string
+ * Parameter: argList - instead of a variable number of arguments
+ * Return:    the number of characters printed(not including the terminating null byte '\0'),
+ * If an error occurred Return: -1.
+ */
+SECUREC_API int vsprintf_s(char *strDest, size_t destMax, const char *format,
+                           va_list argList) SECUREC_ATTRIBUTE(3, 0);
+#endif
+
+#if SECUREC_ENABLE_SPRINTF
+/*
+ * Description: The sprintf_s function is equivalent to the sprintf function except for the parameter destMax
+ * and the explicit runtime-constraints violation
+ * Parameter: strDest -  produce output according to a format ,write to the character string strDest.
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null byte '\0')
+ * Parameter: format - format string
+ * Return:    the number of characters printed(not including the terminating null byte '\0'),
+ * If an error occurred Return: -1.
+*/
+SECUREC_API int sprintf_s(char *strDest, size_t destMax, const char *format, ...) SECUREC_ATTRIBUTE(3, 4);
+#endif
+
+#if SECUREC_ENABLE_VSNPRINTF
+/*
+ * Description: The vsnprintf_s function is equivalent to the vsnprintf function except for
+ * the parameter destMax/count and the explicit runtime-constraints violation
+ * Parameter: strDest -  produce output according to a format ,write to the character string strDest.
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null  byte '\0')
+ * Parameter: count - do not write more than count bytes to strDest(not including the terminating null  byte '\0')
+ * Parameter: format - format string
+ * Parameter: argList - instead of  a variable number of arguments
+ * Return:    the number of characters printed(not including the terminating null byte '\0'),
+ * If an error occurred Return: -1.Pay special attention to returning -1 when truncation occurs.
+ */
+SECUREC_API int vsnprintf_s(char *strDest, size_t destMax, size_t count, const char *format,
+                            va_list argList) SECUREC_ATTRIBUTE(4, 0);
+#endif
+
+#if SECUREC_ENABLE_SNPRINTF
+/*
+ * Description: The snprintf_s function is equivalent to the snprintf function except for
+ * the parameter destMax/count and the explicit runtime-constraints violation
+ * Parameter: strDest - produce output according to a format ,write to the character string strDest.
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null  byte '\0')
+ * Parameter: count - do not write more than count bytes to strDest(not including the terminating null  byte '\0')
+ * Parameter: format - format string
+ * Return:    the number of characters printed(not including the terminating null byte '\0'),
+ * If an error occurred Return: -1.Pay special attention to returning -1 when truncation occurs.
+ */
+SECUREC_API int snprintf_s(char *strDest, size_t destMax, size_t count, const char *format,
+                           ...) SECUREC_ATTRIBUTE(4, 5);
+#endif
+
+#if SECUREC_SNPRINTF_TRUNCATED
+/*
+ * Description: The vsnprintf_truncated_s function is equivalent to the vsnprintf_s function except
+ * no count parameter and return value
+ * Parameter: strDest -  produce output according to a format ,write to the character string strDest
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null  byte '\0')
+ * Parameter: format - format string
+ * Parameter: argList - instead of  a variable  number of arguments
+ * Return:    the number of characters printed(not including the terminating null byte '\0'),
+ * If an error occurred Return: -1.Pay special attention to returning destMax - 1 when truncation occurs
+*/
+SECUREC_API int vsnprintf_truncated_s(char *strDest, size_t destMax, const char *format,
+                                      va_list argList) SECUREC_ATTRIBUTE(3, 0);
+
+/*
+ * Description: The snprintf_truncated_s function is equivalent to the snprintf_s function except
+ * no count parameter and return value
+ * Parameter: strDest - produce output according to a format,write to the character string strDest.
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null byte '\0')
+ * Parameter: format - format string
+ * Return:    the number of characters printed(not including the terminating null byte '\0'),
+ * If an error occurred Return: -1.Pay special attention to returning destMax - 1 when truncation occurs.
+ */
+SECUREC_API int snprintf_truncated_s(char *strDest, size_t destMax,
+                                     const char *format, ...) SECUREC_ATTRIBUTE(3, 4);
+#endif
+
+#if SECUREC_ENABLE_SCANF
+/*
+ * Description: The scanf_s function is equivalent to fscanf_s with the argument stdin
+ * interposed before the arguments to scanf_s
+ * Parameter: format - format string
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int scanf_s(const char *format, ...);
+#endif
+
+#if SECUREC_ENABLE_VSCANF
+/*
+ * Description: The vscanf_s function is equivalent to scanf_s, with the variable argument list replaced by argList
+ * Parameter: format - format string
+ * Parameter: argList - instead of a variable number of arguments
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int vscanf_s(const char *format, va_list argList);
+#endif
+
+#if SECUREC_ENABLE_SSCANF
+/*
+ * Description: The sscanf_s function is equivalent to fscanf_s, except that input is obtained from a
+ * string (specified by the argument buffer) rather than from a stream
+ * Parameter: buffer - read character from buffer
+ * Parameter: format - format string
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int sscanf_s(const char *buffer, const char *format, ...);
+#endif
+
+#if SECUREC_ENABLE_VSSCANF
+/*
+ * Description: The vsscanf_s function is equivalent to sscanf_s, with the variable argument list
+ * replaced by argList
+ * Parameter: buffer -  read character from buffer
+ * Parameter: format - format string
+ * Parameter: argList - instead of a variable number of arguments
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int vsscanf_s(const char *buffer, const char *format, va_list argList);
+#endif
+
+#if SECUREC_ENABLE_FSCANF
+/*
+ * Description: The fscanf_s function is equivalent to fscanf except that the c, s, and [ conversion specifiers
+ * apply to a pair of arguments (unless assignment suppression is indicated by a *)
+ * Parameter: stream - stdio file stream
+ * Parameter: format - format string
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int fscanf_s(FILE *stream, const char *format, ...);
+#endif
+
+#if SECUREC_ENABLE_VFSCANF
+/*
+ * Description: The vfscanf_s function is equivalent to fscanf_s, with the variable argument list
+ * replaced by argList
+ * Parameter: stream - stdio file stream
+ * Parameter: format - format string
+ * Parameter: argList - instead of a variable number of arguments
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int vfscanf_s(FILE *stream, const char *format, va_list argList);
+#endif
+
+#if SECUREC_ENABLE_STRTOK
+/*
+ * Description: The strtok_s function parses a string into a sequence of strToken,
+ * replace all characters in strToken string that match to strDelimit set with 0.
+ * On the first call to strtok_s the string to be parsed should be specified in strToken.
+ * In each subsequent call that should parse the same string, strToken should be NULL
+ * Parameter: strToken - the string to be delimited
+ * Parameter: strDelimit - specifies a set of characters that delimit the tokens in the parsed string
+ * Parameter: context - is a pointer to a char * variable that is used internally by strtok_s function
+ * Return:  On the first call returns the address of the first non \0 character, otherwise NULL is returned.
+ * In subsequent calls, the strtoken is set to NULL, and the context set is the same as the previous call,
+ * return NULL if the *context string length is equal 0, otherwise return *context.
+ */
+SECUREC_API char *strtok_s(char *strToken, const char *strDelimit, char **context);
+#endif
+
+#if SECUREC_ENABLE_GETS && !SECUREC_IN_KERNEL
+/*
+ * Description: The gets_s function reads at most one less than the number of characters specified
+ * by destMax from the stream pointed to by stdin, into the array pointed to by buffer
+ * Parameter: buffer - destination address
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null character)
+ * Return:    buffer if there was no runtime-constraint violation,If an error occurred Return: NULL.
+ */
+SECUREC_API char *gets_s(char *buffer, size_t destMax);
+#endif
+
+#if SECUREC_ENABLE_WCHAR_FUNC
+#if SECUREC_ENABLE_MEMCPY
+/*
+ * Description: The wmemcpy_s function copies n successive wide characters from the object pointed to
+ * by src into the object pointed to by dest.
+ * Parameter: dest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer
+ * Parameter: src - source address
+ * Parameter: count - copies count wide characters from the  src
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t wmemcpy_s(wchar_t *dest, size_t destMax, const wchar_t *src, size_t count);
+#endif
+
+#if SECUREC_ENABLE_MEMMOVE
+/*
+ * Description: The wmemmove_s function copies n successive wide characters from the object
+ * pointed to by src into the object pointed to by dest.
+ * Parameter: dest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer
+ * Parameter: src - source address
+ * Parameter: count - copies count wide characters from the  src
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t wmemmove_s(wchar_t *dest, size_t destMax, const wchar_t *src, size_t count);
+#endif
+
+#if SECUREC_ENABLE_STRCPY
+/*
+ * Description: The wcscpy_s function copies the wide string pointed to by strSrc(including the terminating
+ * null wide character) into the array pointed to by strDest
+ * Parameter: strDest - destination address
+ * Parameter: destMax - The maximum length of destination buffer
+ * Parameter: strSrc - source address
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t wcscpy_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc);
+#endif
+
+#if SECUREC_ENABLE_STRNCPY
+/*
+ * Description: The wcsncpy_s function copies not more than n successive wide characters (not including the
+ * terminating null wide character) from the array pointed to by strSrc to the array pointed to by strDest
+ * Parameter: strDest - destination address
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating wide character)
+ * Parameter: strSrc - source address
+ * Parameter: count - copies count wide characters from the src
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t wcsncpy_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc, size_t count);
+#endif
+
+#if SECUREC_ENABLE_STRCAT
+/*
+ * Description: The wcscat_s function appends a copy of the wide string pointed to by strSrc (including the
+ * terminating null wide character) to the end of the wide string pointed to by strDest
+ * Parameter: strDest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating wide character)
+ * Parameter: strSrc - source address
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t wcscat_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc);
+#endif
+
+#if SECUREC_ENABLE_STRNCAT
+/*
+ * Description: The wcsncat_s function appends not more than n successive wide characters (not including the
+ * terminating null wide character) from the array pointed to by strSrc to the end of the wide string pointed to
+ * by strDest.
+ * Parameter: strDest - destination  address
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating wide character)
+ * Parameter: strSrc - source  address
+ * Parameter: count - copies count wide characters from the  src
+ * Return:    EOK if there was no runtime-constraint violation
+ */
+SECUREC_API errno_t wcsncat_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc, size_t count);
+#endif
+
+#if SECUREC_ENABLE_STRTOK
+/*
+ * Description: The wcstok_s function is the wide-character equivalent of the strtok_s function
+ * Parameter: strToken - the string to be delimited
+ * Parameter: strDelimit - specifies a set of characters that delimit the tokens in the parsed string
+ * Parameter: context - is a pointer to a char * variable that is used internally by strtok_s function
+ * Return:    a pointer to the first character of a token, or a null pointer if there is no token
+ * or there is a runtime-constraint violation.
+ */
+SECUREC_API wchar_t *wcstok_s(wchar_t *strToken, const wchar_t *strDelimit, wchar_t **context);
+#endif
+
+#if SECUREC_ENABLE_VSPRINTF
+/*
+ * Description: The vswprintf_s function is the wide-character equivalent of the vsprintf_s function
+ * Parameter: strDest - produce output according to a format,write to the character string strDest
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null)
+ * Parameter: format - format string
+ * Parameter: argList - instead of a variable number of arguments
+ * Return:    the number of characters printed(not including the terminating null wide character),
+ * If an error occurred Return: -1.
+ */
+SECUREC_API int vswprintf_s(wchar_t *strDest, size_t destMax, const wchar_t *format, va_list argList);
+#endif
+
+#if SECUREC_ENABLE_SPRINTF
+/*
+ * Description: The swprintf_s function is the wide-character equivalent of the sprintf_s function
+ * Parameter: strDest - produce output according to a format,write to the character string strDest
+ * Parameter: destMax - The maximum length of destination buffer(including the terminating null)
+ * Parameter: format - format string
+ * Return:    the number of characters printed(not including the terminating null wide character),
+ * If an error occurred Return: -1.
+ */
+SECUREC_API int swprintf_s(wchar_t *strDest, size_t destMax, const wchar_t *format, ...);
+#endif
+
+#if SECUREC_ENABLE_FSCANF
+/*
+ * Description: The fwscanf_s function is the wide-character equivalent of the fscanf_s function
+ * Parameter: stream - stdio file stream
+ * Parameter: format - format string
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int fwscanf_s(FILE *stream, const wchar_t *format, ...);
+#endif
+
+#if SECUREC_ENABLE_VFSCANF
+/*
+ * Description: The vfwscanf_s function is the wide-character equivalent of the vfscanf_s function
+ * Parameter: stream - stdio file stream
+ * Parameter: format - format string
+ * Parameter: argList - instead of  a variable number of arguments
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int vfwscanf_s(FILE *stream, const wchar_t *format, va_list argList);
+#endif
+
+#if SECUREC_ENABLE_SCANF
+/*
+ * Description: The wscanf_s function is the wide-character equivalent of the scanf_s function
+ * Parameter: format - format string
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int wscanf_s(const wchar_t *format, ...);
+#endif
+
+#if SECUREC_ENABLE_VSCANF
+/*
+ * Description: The vwscanf_s function is the wide-character equivalent of the vscanf_s function
+ * Parameter: format - format string
+ * Parameter: argList - instead of  a variable number of arguments
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int vwscanf_s(const wchar_t *format, va_list argList);
+#endif
+
+#if SECUREC_ENABLE_SSCANF
+/*
+ * Description: The swscanf_s function is the wide-character equivalent of the sscanf_s function
+ * Parameter: buffer - read character from buffer
+ * Parameter: format - format string
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int swscanf_s(const wchar_t *buffer, const wchar_t *format, ...);
+#endif
+
+#if SECUREC_ENABLE_VSSCANF
+/*
+ * Description: The vswscanf_s function is the wide-character equivalent of the vsscanf_s function
+ * Parameter: buffer -  read character from  buffer
+ * Parameter: format - format string
+ * Parameter: argList - instead of  a variable number of arguments
+ * Return:    the number of input items assigned, If an error occurred Return: -1.
+ */
+SECUREC_API int vswscanf_s(const wchar_t *buffer, const wchar_t *format, va_list argList);
+#endif
+#endif /* SECUREC_ENABLE_WCHAR_FUNC */
+#endif
+
+/* Those functions are used by macro,must declare hare, also for without function declaration warning */
+extern errno_t strncpy_error(char *strDest, size_t destMax, const char *strSrc, size_t count);
+extern errno_t strcpy_error(char *strDest, size_t destMax, const char *strSrc);
+
+#if SECUREC_WITH_PERFORMANCE_ADDONS
+/* Those functions are used by macro */
+extern errno_t memset_sOptAsm(void *dest, size_t destMax, int c, size_t count);
+extern errno_t memset_sOptTc(void *dest, size_t destMax, int c, size_t count);
+extern errno_t memcpy_sOptAsm(void *dest, size_t destMax, const void *src, size_t count);
+extern errno_t memcpy_sOptTc(void *dest, size_t destMax, const void *src, size_t count);
+
+/* The strcpy_sp is a macro, not a function in performance optimization mode. */
+#define strcpy_sp(dest, destMax, src)  ((__builtin_constant_p((destMax)) && \
+    __builtin_constant_p((src))) ?  \
+    SECUREC_STRCPY_SM((dest), (destMax), (src)) : \
+    strcpy_s((dest), (destMax), (src)))
+
+/* The strncpy_sp is a macro, not a function in performance optimization mode. */
+#define strncpy_sp(dest, destMax, src, count)  ((__builtin_constant_p((count)) && \
+    __builtin_constant_p((destMax)) && \
+    __builtin_constant_p((src))) ?  \
+    SECUREC_STRNCPY_SM((dest), (destMax), (src), (count)) : \
+    strncpy_s((dest), (destMax), (src), (count)))
+
+/* The strcat_sp is a macro, not a function in performance optimization mode. */
+#define strcat_sp(dest, destMax, src) ((__builtin_constant_p((destMax)) && \
+    __builtin_constant_p((src))) ?  \
+    SECUREC_STRCAT_SM((dest), (destMax), (src)) : \
+    strcat_s((dest), (destMax), (src)))
+
+/* The strncat_sp is a macro, not a function in performance optimization mode. */
+#define strncat_sp(dest, destMax, src, count) ((__builtin_constant_p((count)) &&  \
+    __builtin_constant_p((destMax)) && \
+    __builtin_constant_p((src))) ?  \
+    SECUREC_STRNCAT_SM((dest), (destMax), (src), (count)) : \
+    strncat_s((dest), (destMax), (src), (count)))
+
+/* The memcpy_sp is a macro, not a function in performance optimization mode. */
+#define memcpy_sp(dest, destMax, src, count)  (__builtin_constant_p((count)) ? \
+    (SECUREC_MEMCPY_SM((dest), (destMax), (src), (count))) : \
+    (__builtin_constant_p((destMax)) ? \
+    (((size_t)(destMax) > 0 && \
+    (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_MEM_MAX_LEN)) ? \
+    memcpy_sOptTc((dest), (destMax), (src), (count)) : ERANGE) : \
+    memcpy_sOptAsm((dest), (destMax), (src), (count))))
+
+/* The memset_sp is a macro, not a function in performance optimization mode. */
+#define memset_sp(dest, destMax, c, count)  (__builtin_constant_p((count)) ? \
+    (SECUREC_MEMSET_SM((dest), (destMax), (c), (count))) : \
+    (__builtin_constant_p((destMax)) ? \
+    (((((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_MEM_MAX_LEN)) ? \
+    memset_sOptTc((dest), (destMax), (c), (count)) : ERANGE) : \
+    memset_sOptAsm((dest), (destMax), (c), (count))))
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/lib/libsecurec/include/securectype.h b/lib/libsecurec/include/securectype.h
new file mode 100644
index 0000000..b1b3159
--- /dev/null
+++ b/lib/libsecurec/include/securectype.h
@@ -0,0 +1,585 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: Define internal used macro and data type. The marco of SECUREC_ON_64BITS
+ *              will be determined in this header file, which is a switch for part
+ *              of code. Some macro are used to suppress warning by MS compiler.
+ * Create: 2014-02-25
+ * Notes: User can change the value of SECUREC_STRING_MAX_LEN and SECUREC_MEM_MAX_LEN
+ *        macro to meet their special need, but The maximum value should not exceed 2G.
+ */
+/*
+ * [Standardize-exceptions]: Performance-sensitive
+ * [reason]: Strict parameter verification has been done before use
+ */
+
+#ifndef SECURECTYPE_H_A7BBB686_AADA_451B_B9F9_44DACDAE18A7
+#define SECURECTYPE_H_A7BBB686_AADA_451B_B9F9_44DACDAE18A7
+
+#ifndef SECUREC_USING_STD_SECURE_LIB
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#if defined(__STDC_WANT_SECURE_LIB__) && (!__STDC_WANT_SECURE_LIB__)
+/* Security functions have been provided since vs2005, default use of system library functions */
+#define SECUREC_USING_STD_SECURE_LIB    0
+#else
+#define SECUREC_USING_STD_SECURE_LIB    1
+#endif
+#else
+#define SECUREC_USING_STD_SECURE_LIB    0
+#endif
+#endif
+
+/* Compatibility with older Secure C versions, shielding VC symbol redefinition warning */
+#if defined(_MSC_VER) && (_MSC_VER >= 1400) && (!SECUREC_USING_STD_SECURE_LIB)
+#ifndef SECUREC_DISABLE_CRT_FUNC
+#define SECUREC_DISABLE_CRT_FUNC        1
+#endif
+#ifndef SECUREC_DISABLE_CRT_IMP
+#define SECUREC_DISABLE_CRT_IMP         1
+#endif
+#else /*  MSC VER */
+#ifndef SECUREC_DISABLE_CRT_FUNC
+#define SECUREC_DISABLE_CRT_FUNC        0
+#endif
+#ifndef SECUREC_DISABLE_CRT_IMP
+#define SECUREC_DISABLE_CRT_IMP         0
+#endif
+#endif
+
+#if SECUREC_DISABLE_CRT_FUNC
+#ifdef __STDC_WANT_SECURE_LIB__
+#undef __STDC_WANT_SECURE_LIB__
+#endif
+#define __STDC_WANT_SECURE_LIB__        0
+#endif
+
+#if SECUREC_DISABLE_CRT_IMP
+#ifdef _CRTIMP_ALTERNATIVE
+#undef _CRTIMP_ALTERNATIVE
+#endif
+#define _CRTIMP_ALTERNATIVE     /* Comment Microsoft *_s function */
+#endif
+
+/* Compile in kernel under macro control */
+#ifndef SECUREC_IN_KERNEL
+#ifdef __KERNEL__
+#define SECUREC_IN_KERNEL               0
+#else
+#define SECUREC_IN_KERNEL               0
+#endif
+#endif
+
+/* make kernel symbols of functions available to loadable modules */
+#ifndef SECUREC_EXPORT_KERNEL_SYMBOL
+#if SECUREC_IN_KERNEL
+#define SECUREC_EXPORT_KERNEL_SYMBOL    1
+#else
+#define SECUREC_EXPORT_KERNEL_SYMBOL    0
+#endif
+#endif
+
+#if SECUREC_IN_KERNEL
+#ifndef SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_ENABLE_SCANF_FILE       0
+#endif
+#ifndef SECUREC_ENABLE_WCHAR_FUNC
+#define SECUREC_ENABLE_WCHAR_FUNC       0
+#endif
+#else /* SECUREC_IN_KERNEL */
+#ifndef SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_ENABLE_SCANF_FILE       1
+#endif
+#ifndef SECUREC_ENABLE_WCHAR_FUNC
+#define SECUREC_ENABLE_WCHAR_FUNC       1
+#endif
+#endif
+
+/* Default secure function declaration, default declarations for non-standard functions */
+#ifndef SECUREC_SNPRINTF_TRUNCATED
+#define SECUREC_SNPRINTF_TRUNCATED      1
+#endif
+
+#if SECUREC_USING_STD_SECURE_LIB
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+/* Declare secure functions that are not available in the VS compiler */
+#ifndef SECUREC_ENABLE_MEMSET
+#define SECUREC_ENABLE_MEMSET           1
+#endif
+/* VS 2005 have vsnprintf_s function */
+#ifndef SECUREC_ENABLE_VSNPRINTF
+#define SECUREC_ENABLE_VSNPRINTF        0
+#endif
+#ifndef SECUREC_ENABLE_SNPRINTF
+/* VS 2005 have vsnprintf_s function Adapt the snprintf_s of the security function */
+#define snprintf_s _snprintf_s
+#define SECUREC_ENABLE_SNPRINTF         0
+#endif
+/* Before VS 2010 do not have v functions */
+#if _MSC_VER <= 1600 || defined(SECUREC_FOR_V_SCANFS)
+#ifndef SECUREC_ENABLE_VFSCANF
+#define SECUREC_ENABLE_VFSCANF          1
+#endif
+#ifndef SECUREC_ENABLE_VSCANF
+#define SECUREC_ENABLE_VSCANF           1
+#endif
+#ifndef SECUREC_ENABLE_VSSCANF
+#define SECUREC_ENABLE_VSSCANF          1
+#endif
+#endif
+
+#else /* MSC VER */
+#ifndef SECUREC_ENABLE_MEMSET
+#define SECUREC_ENABLE_MEMSET           0
+#endif
+#ifndef SECUREC_ENABLE_SNPRINTF
+#define SECUREC_ENABLE_SNPRINTF         0
+#endif
+#ifndef SECUREC_ENABLE_VSNPRINTF
+#define SECUREC_ENABLE_VSNPRINTF        0
+#endif
+#endif
+
+#ifndef SECUREC_ENABLE_MEMMOVE
+#define SECUREC_ENABLE_MEMMOVE          0
+#endif
+#ifndef SECUREC_ENABLE_MEMCPY
+#define SECUREC_ENABLE_MEMCPY           0
+#endif
+#ifndef SECUREC_ENABLE_STRCPY
+#define SECUREC_ENABLE_STRCPY           0
+#endif
+#ifndef SECUREC_ENABLE_STRNCPY
+#define SECUREC_ENABLE_STRNCPY          0
+#endif
+#ifndef SECUREC_ENABLE_STRCAT
+#define SECUREC_ENABLE_STRCAT           0
+#endif
+#ifndef SECUREC_ENABLE_STRNCAT
+#define SECUREC_ENABLE_STRNCAT          0
+#endif
+#ifndef SECUREC_ENABLE_SPRINTF
+#define SECUREC_ENABLE_SPRINTF          0
+#endif
+#ifndef SECUREC_ENABLE_VSPRINTF
+#define SECUREC_ENABLE_VSPRINTF          0
+#endif
+#ifndef SECUREC_ENABLE_SSCANF
+#define SECUREC_ENABLE_SSCANF           0
+#endif
+#ifndef SECUREC_ENABLE_VSSCANF
+#define SECUREC_ENABLE_VSSCANF          0
+#endif
+#ifndef SECUREC_ENABLE_SCANF
+#define SECUREC_ENABLE_SCANF            0
+#endif
+#ifndef SECUREC_ENABLE_VSCANF
+#define SECUREC_ENABLE_VSCANF           0
+#endif
+
+#ifndef SECUREC_ENABLE_FSCANF
+#define SECUREC_ENABLE_FSCANF           0
+#endif
+#ifndef SECUREC_ENABLE_VFSCANF
+#define SECUREC_ENABLE_VFSCANF          0
+#endif
+#ifndef SECUREC_ENABLE_STRTOK
+#define SECUREC_ENABLE_STRTOK           0
+#endif
+#ifndef SECUREC_ENABLE_GETS
+#define SECUREC_ENABLE_GETS             0
+#endif
+
+#else /* SECUREC USE STD SECURE LIB */
+
+#ifndef SECUREC_ENABLE_MEMSET
+#define SECUREC_ENABLE_MEMSET           1
+#endif
+#ifndef SECUREC_ENABLE_MEMMOVE
+#define SECUREC_ENABLE_MEMMOVE          1
+#endif
+#ifndef SECUREC_ENABLE_MEMCPY
+#define SECUREC_ENABLE_MEMCPY           1
+#endif
+#ifndef SECUREC_ENABLE_STRCPY
+#define SECUREC_ENABLE_STRCPY           1
+#endif
+#ifndef SECUREC_ENABLE_STRNCPY
+#define SECUREC_ENABLE_STRNCPY          1
+#endif
+#ifndef SECUREC_ENABLE_STRCAT
+#define SECUREC_ENABLE_STRCAT           1
+#endif
+#ifndef SECUREC_ENABLE_STRNCAT
+#define SECUREC_ENABLE_STRNCAT          1
+#endif
+#ifndef SECUREC_ENABLE_SPRINTF
+#define SECUREC_ENABLE_SPRINTF          1
+#endif
+#ifndef SECUREC_ENABLE_VSPRINTF
+#define SECUREC_ENABLE_VSPRINTF          1
+#endif
+#ifndef SECUREC_ENABLE_SNPRINTF
+#define SECUREC_ENABLE_SNPRINTF         1
+#endif
+#ifndef SECUREC_ENABLE_VSNPRINTF
+#define SECUREC_ENABLE_VSNPRINTF        1
+#endif
+#ifndef SECUREC_ENABLE_SSCANF
+#define SECUREC_ENABLE_SSCANF           1
+#endif
+#ifndef SECUREC_ENABLE_VSSCANF
+#define SECUREC_ENABLE_VSSCANF          1
+#endif
+#ifndef SECUREC_ENABLE_SCANF
+#if SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_ENABLE_SCANF            1
+#else
+#define SECUREC_ENABLE_SCANF            0
+#endif
+#endif
+#ifndef SECUREC_ENABLE_VSCANF
+#if SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_ENABLE_VSCANF           1
+#else
+#define SECUREC_ENABLE_VSCANF           0
+#endif
+#endif
+
+#ifndef SECUREC_ENABLE_FSCANF
+#if SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_ENABLE_FSCANF           1
+#else
+#define SECUREC_ENABLE_FSCANF           0
+#endif
+#endif
+#ifndef SECUREC_ENABLE_VFSCANF
+#if SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_ENABLE_VFSCANF          1
+#else
+#define SECUREC_ENABLE_VFSCANF          0
+#endif
+#endif
+
+#ifndef SECUREC_ENABLE_STRTOK
+#define SECUREC_ENABLE_STRTOK           1
+#endif
+#ifndef SECUREC_ENABLE_GETS
+#define SECUREC_ENABLE_GETS             1
+#endif
+#endif /* SECUREC_USE_STD_SECURE_LIB */
+
+#if !SECUREC_ENABLE_SCANF_FILE
+#if SECUREC_ENABLE_FSCANF
+#undef SECUREC_ENABLE_FSCANF
+#define SECUREC_ENABLE_FSCANF           0
+#endif
+#if SECUREC_ENABLE_VFSCANF
+#undef SECUREC_ENABLE_VFSCANF
+#define SECUREC_ENABLE_VFSCANF          0
+#endif
+#if SECUREC_ENABLE_SCANF
+#undef SECUREC_ENABLE_SCANF
+#define SECUREC_ENABLE_SCANF            0
+#endif
+#if SECUREC_ENABLE_FSCANF
+#undef SECUREC_ENABLE_FSCANF
+#define SECUREC_ENABLE_FSCANF           0
+#endif
+
+#endif
+
+#if SECUREC_IN_KERNEL
+#include <linux/kernel.h>
+#include <linux/module.h>
+#else
+#ifndef SECUREC_HAVE_STDIO_H
+#define SECUREC_HAVE_STDIO_H 1
+#endif
+#ifndef SECUREC_HAVE_STRING_H
+#define SECUREC_HAVE_STRING_H 1
+#endif
+#ifndef SECUREC_HAVE_STDLIB_H
+#define SECUREC_HAVE_STDLIB_H 1
+#endif
+#if SECUREC_HAVE_STDIO_H
+#include <stdio.h>
+#endif
+#if SECUREC_HAVE_STRING_H
+#include <string.h>
+#endif
+#if SECUREC_HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#endif
+
+/*
+ * If you need high performance, enable the SECUREC_WITH_PERFORMANCE_ADDONS macro, default is enable.
+ * The macro is automatically closed on the windows platform and linux kernel
+ */
+#ifndef SECUREC_WITH_PERFORMANCE_ADDONS
+#if SECUREC_IN_KERNEL
+#define SECUREC_WITH_PERFORMANCE_ADDONS 0
+#else
+#define SECUREC_WITH_PERFORMANCE_ADDONS 1
+#endif
+#endif
+
+/* If enable SECUREC_COMPATIBLE_WIN_FORMAT, the output format will be compatible to Windows. */
+#if (defined(_WIN32) || defined(_WIN64) || defined(_MSC_VER)) && !defined(SECUREC_COMPATIBLE_LINUX_FORMAT)
+#ifndef SECUREC_COMPATIBLE_WIN_FORMAT
+#define SECUREC_COMPATIBLE_WIN_FORMAT
+#endif
+#endif
+
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+/* On windows platform, can't use optimized function for there is no __builtin_constant_p like function */
+/* If need optimized macro, can define this: define __builtin_constant_p(x) 0 */
+#ifdef SECUREC_WITH_PERFORMANCE_ADDONS
+#undef SECUREC_WITH_PERFORMANCE_ADDONS
+#define SECUREC_WITH_PERFORMANCE_ADDONS 0
+#endif
+#endif
+
+#if defined(__VXWORKS__) || defined(__vxworks) || defined(__VXWORKS) || defined(_VXWORKS_PLATFORM_)  || \
+    defined(SECUREC_VXWORKS_VERSION_5_4)
+#ifndef SECUREC_VXWORKS_PLATFORM
+#define SECUREC_VXWORKS_PLATFORM
+#endif
+#endif
+
+/* If enable SECUREC_COMPATIBLE_LINUX_FORMAT, the output format will be compatible to Linux. */
+#if !defined(SECUREC_COMPATIBLE_WIN_FORMAT) && !defined(SECUREC_VXWORKS_PLATFORM)
+#ifndef SECUREC_COMPATIBLE_LINUX_FORMAT
+#define SECUREC_COMPATIBLE_LINUX_FORMAT
+#endif
+#endif
+
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+#ifndef SECUREC_HAVE_STDDEF_H
+#define SECUREC_HAVE_STDDEF_H 1
+#endif
+/* Some system may no stddef.h */
+#if SECUREC_HAVE_STDDEF_H
+#if !SECUREC_IN_KERNEL
+#include <stddef.h>
+#endif
+#endif
+#endif
+
+/*
+ * Add  the -DSECUREC_SUPPORT_FORMAT_WARNING=1  compiler option to supoort  -Wformat=2.
+ * Default does not check the format is that the same data type in the actual code.
+ * In the product is different in the original data type definition of VxWorks and Linux.
+ */
+#ifndef SECUREC_SUPPORT_FORMAT_WARNING
+#define SECUREC_SUPPORT_FORMAT_WARNING 0
+#endif
+
+#if SECUREC_SUPPORT_FORMAT_WARNING
+#define SECUREC_ATTRIBUTE(x, y)  __attribute__((format(printf, (x), (y))))
+#else
+#define SECUREC_ATTRIBUTE(x, y)
+#endif
+
+/*
+ * Add the -DSECUREC_SUPPORT_BUILTIN_EXPECT=0 compiler option, if compiler can not support __builtin_expect.
+ */
+#ifndef SECUREC_SUPPORT_BUILTIN_EXPECT
+#define SECUREC_SUPPORT_BUILTIN_EXPECT 1
+#endif
+
+#if SECUREC_SUPPORT_BUILTIN_EXPECT && defined(__GNUC__) && ((__GNUC__ > 3) || \
+    (defined(__GNUC_MINOR__) && (__GNUC__ == 3 && __GNUC_MINOR__ > 3)))
+/*
+ * This is a built-in function that can be used without a declaration, if warning for declaration not found occurred,
+ * you can add -DSECUREC_NEED_BUILTIN_EXPECT_DECLARE to compiler options
+ */
+#ifdef SECUREC_NEED_BUILTIN_EXPECT_DECLARE
+long __builtin_expect(long exp, long c);
+#endif
+
+#define SECUREC_LIKELY(x) __builtin_expect(!!(x), 1)
+#define SECUREC_UNLIKELY(x) __builtin_expect(!!(x), 0)
+#else
+#define SECUREC_LIKELY(x) (x)
+#define SECUREC_UNLIKELY(x) (x)
+#endif
+
+/* Define the max length of the string */
+#ifndef SECUREC_STRING_MAX_LEN
+#define SECUREC_STRING_MAX_LEN 0x7fffffffUL
+#endif
+#define SECUREC_WCHAR_STRING_MAX_LEN (SECUREC_STRING_MAX_LEN / sizeof(wchar_t))
+
+/* Add SECUREC_MEM_MAX_LEN for memcpy and memmove */
+#ifndef SECUREC_MEM_MAX_LEN
+#define SECUREC_MEM_MAX_LEN 0x7fffffffUL
+#endif
+#define SECUREC_WCHAR_MEM_MAX_LEN (SECUREC_MEM_MAX_LEN / sizeof(wchar_t))
+
+#if SECUREC_STRING_MAX_LEN > 0x7fffffffUL
+#error "max string is 2G"
+#endif
+
+#if (defined(__GNUC__) && defined(__SIZEOF_POINTER__))
+#if (__SIZEOF_POINTER__ != 4) && (__SIZEOF_POINTER__ != 8)
+#error "unsupported system"
+#endif
+#endif
+
+#if defined(_WIN64) || defined(WIN64) || defined(__LP64__) || defined(_LP64)
+#define SECUREC_ON_64BITS
+#endif
+
+#if (!defined(SECUREC_ON_64BITS) && defined(__GNUC__) && defined(__SIZEOF_POINTER__))
+#if __SIZEOF_POINTER__ == 8
+#define SECUREC_ON_64BITS
+#endif
+#endif
+
+#if defined(__SVR4) || defined(__svr4__)
+#define SECUREC_ON_SOLARIS
+#endif
+
+#if (defined(__hpux) || defined(_AIX) || defined(SECUREC_ON_SOLARIS))
+#define SECUREC_ON_UNIX
+#endif
+
+/*
+ * Codes should run under the macro SECUREC_COMPATIBLE_LINUX_FORMAT in unknown system on default,
+ * and strtold.
+ * The function strtold is referenced first at ISO9899:1999(C99), and some old compilers can
+ * not support these functions. Here provides a macro to open these functions:
+ * SECUREC_SUPPORT_STRTOLD  -- If defined, strtold will be used
+ */
+#ifndef SECUREC_SUPPORT_STRTOLD
+#define SECUREC_SUPPORT_STRTOLD 0
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT))
+#if defined(__USE_ISOC99)  || \
+    (defined(_AIX) && defined(_ISOC99_SOURCE)) || \
+    (defined(__hpux) && defined(__ia64)) || \
+    (defined(SECUREC_ON_SOLARIS) && (!defined(_STRICT_STDC) && !defined(__XOPEN_OR_POSIX)) || \
+    defined(_STDC_C99) || defined(__EXTENSIONS__))
+#undef  SECUREC_SUPPORT_STRTOLD
+#define SECUREC_SUPPORT_STRTOLD 1
+#endif
+#endif
+#if ((defined(SECUREC_WRLINUX_BELOW4) || defined(_WRLINUX_BELOW4_)))
+#undef  SECUREC_SUPPORT_STRTOLD
+#define SECUREC_SUPPORT_STRTOLD 0
+#endif
+#endif
+
+#if SECUREC_WITH_PERFORMANCE_ADDONS
+
+#ifndef SECUREC_TWO_MIN
+#define SECUREC_TWO_MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+/* For strncpy_s performance optimization */
+#define SECUREC_STRNCPY_SM(dest, destMax, src, count) \
+    (((void *)(dest) != NULL && (const void *)(src) != NULL && (size_t)(destMax) > 0 && \
+    (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN) && \
+    (SECUREC_TWO_MIN((size_t)(count), strlen(src)) + 1) <= (size_t)(destMax)) ? \
+    (((size_t)(count) < strlen(src)) ? (memcpy((dest), (src), (count)), *((char *)(dest) + (count)) = '\0', EOK) : \
+    (memcpy((dest), (src), strlen(src) + 1), EOK)) : (strncpy_error((dest), (destMax), (src), (count))))
+
+#define SECUREC_STRCPY_SM(dest, destMax, src) \
+    (((void *)(dest) != NULL && (const void *)(src) != NULL && (size_t)(destMax) > 0 && \
+    (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN) && \
+    (strlen(src) + 1) <= (size_t)(destMax)) ? (memcpy((dest), (src), strlen(src) + 1), EOK) : \
+    (strcpy_error((dest), (destMax), (src))))
+
+/* For strcat_s performance optimization */
+#if defined(__GNUC__)
+#define SECUREC_STRCAT_SM(dest, destMax, src) ({ \
+    int catRet_ = EOK; \
+    if ((void *)(dest) != NULL && (const void *)(src) != NULL && (size_t)(destMax) > 0 && \
+        (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN)) { \
+        char *catTmpDst_ = (char *)(dest); \
+        size_t catRestSize_ = (destMax); \
+        while (catRestSize_ > 0 && *catTmpDst_ != '\0') { \
+            ++catTmpDst_; \
+            --catRestSize_; \
+        } \
+        if (catRestSize_ == 0) { \
+            catRet_ = EINVAL; \
+        } else if ((strlen(src) + 1) <= catRestSize_) { \
+            memcpy(catTmpDst_, (src), strlen(src) + 1); \
+            catRet_ = EOK; \
+        } else { \
+            catRet_ = ERANGE; \
+        } \
+        if (catRet_ != EOK) { \
+            catRet_ = strcat_s((dest), (destMax), (src)); \
+        } \
+    } else { \
+        catRet_ = strcat_s((dest), (destMax), (src)); \
+    } \
+    catRet_; \
+})
+#else
+#define SECUREC_STRCAT_SM(dest, destMax, src) strcat_s((dest), (destMax), (src))
+#endif
+
+/* For strncat_s performance optimization */
+#if defined(__GNUC__)
+#define SECUREC_STRNCAT_SM(dest, destMax, src, count) ({ \
+    int ncatRet_ = EOK; \
+    if ((void *)(dest) != NULL && (const void *)(src) != NULL && (size_t)(destMax) > 0 && \
+        (((unsigned long long)(destMax) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN)  && \
+        (((unsigned long long)(count) & (unsigned long long)(-2)) < SECUREC_STRING_MAX_LEN)) { \
+        char *ncatTmpDest_ = (char *)(dest); \
+        size_t ncatRestSize_ = (size_t)(destMax); \
+        while (ncatRestSize_ > 0 && *ncatTmpDest_ != '\0') { \
+            ++ncatTmpDest_; \
+            --ncatRestSize_; \
+        } \
+        if (ncatRestSize_ == 0) { \
+            ncatRet_ = EINVAL; \
+        } else if ((SECUREC_TWO_MIN((count), strlen(src)) + 1) <= ncatRestSize_) { \
+            if ((size_t)(count) < strlen(src)) { \
+                memcpy(ncatTmpDest_, (src), (count)); \
+                *(ncatTmpDest_ + (count)) = '\0'; \
+            } else { \
+                memcpy(ncatTmpDest_, (src), strlen(src) + 1); \
+            } \
+        } else { \
+            ncatRet_ = ERANGE; \
+        } \
+        if (ncatRet_ != EOK) { \
+            ncatRet_ = strncat_s((dest), (destMax), (src), (count)); \
+        } \
+    } else { \
+        ncatRet_ = strncat_s((dest), (destMax), (src), (count)); \
+    } \
+    ncatRet_; \
+})
+#else
+#define SECUREC_STRNCAT_SM(dest, destMax, src, count) strncat_s((dest), (destMax), (src), (count))
+#endif
+
+/* This macro do not check buffer overlap by default */
+#define  SECUREC_MEMCPY_SM(dest, destMax, src, count) \
+    (!(((size_t)(destMax) == 0) || \
+        (((unsigned long long)(destMax) & (unsigned long long)(-2)) > SECUREC_MEM_MAX_LEN) || \
+        ((size_t)(count) > (size_t)(destMax)) || ((void *)(dest)) == NULL || ((const void *)(src) == NULL)) ? \
+        (memcpy((dest), (src), (count)), EOK) : \
+        (memcpy_s((dest), (destMax), (src), (count))))
+
+#define  SECUREC_MEMSET_SM(dest, destMax, c, count) \
+    (!((((unsigned long long)(destMax) & (unsigned long long)(-2)) > SECUREC_MEM_MAX_LEN) || \
+        ((void *)(dest) == NULL) || ((size_t)(count) > (size_t)(destMax))) ? \
+        (memset((dest), (c), (count)), EOK) : \
+        (memset_s((dest), (destMax), (c), (count))))
+
+#endif
+#endif
+
diff --git a/lib/libsecurec/src/fscanf_s.c b/lib/libsecurec/src/fscanf_s.c
new file mode 100644
index 0000000..d3c7f06
--- /dev/null
+++ b/lib/libsecurec/src/fscanf_s.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: fscanf_s function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The fscanf_s function is equivalent to fscanf except that the c, s,
+ *    and [ conversion specifiers apply to a pair of arguments (unless assignment suppression is indicated by a*)
+ *    The fscanf function reads data from the current position of stream into
+ *    the locations given by argument (if any). Each argument must be a pointer
+ *    to a variable of a type that corresponds to a type specifier in format.
+ *    format controls the interpretation of the input fields and has the same
+ *    form and function as the format argument for scanf.
+ *
+ * <INPUT PARAMETERS>
+ *    stream              Pointer to FILE structure.
+ *    format              Format control string, see Format Specifications.
+ *    ...                 Optional arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    ...                 The converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Each of these functions returns the number of fields successfully converted
+ *    and assigned; the return value does not include fields that were read but
+ *    not assigned. A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int fscanf_s(FILE *stream, const char *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vfscanf_s(stream, format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+
diff --git a/lib/libsecurec/src/fwscanf_s.c b/lib/libsecurec/src/fwscanf_s.c
new file mode 100644
index 0000000..bd0f12a
--- /dev/null
+++ b/lib/libsecurec/src/fwscanf_s.c
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: fwscanf_s function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The fwscanf_s function  is  the  wide-character  equivalent  of the fscanf_s function
+ *    The fwscanf_s function reads data from the current position of stream into
+ *    the locations given by argument (if any). Each argument must be a pointer
+ *    to a variable of a type that corresponds to a type specifier in format.
+ *    format controls the interpretation of the input fields and has the same
+ *    form and function as the format argument for scanf.
+ *
+ * <INPUT PARAMETERS>
+ *    stream                   Pointer to FILE structure.
+ *    format                   Format control string, see Format Specifications.
+ *    ...                      Optional arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    ...                      The converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Each of these functions returns the number of fields successfully converted
+ *    and assigned; the return value does not include fields that were read but
+ *    not assigned. A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int fwscanf_s(FILE *stream, const wchar_t *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vfwscanf_s(stream, format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+
diff --git a/lib/libsecurec/src/gets_s.c b/lib/libsecurec/src/gets_s.c
new file mode 100644
index 0000000..d12495a
--- /dev/null
+++ b/lib/libsecurec/src/gets_s.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: gets_s function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+/*
+ * The parameter size is buffer size in byte
+ */
+SECUREC_INLINE void SecTrimCRLF(char *buffer, size_t size)
+{
+    size_t len = strlen(buffer);
+    --len; /* Unsigned integer wrapping is accepted and is checked afterwards */
+    while (len < size && (buffer[len] == '\r' || buffer[len] == '\n')) {
+        buffer[len] = '\0';
+        --len; /* Unsigned integer wrapping is accepted and is checked next loop */
+    }
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The gets_s function reads at most one less than the number of characters
+ *    specified by destMax from the std input stream, into the array pointed to by buffer
+ *    The line consists of all characters up to and including
+ *    the first newline character ('\n'). gets_s then replaces the newline
+ *    character with a null character ('\0') before returning the line.
+ *    If the first character read is the end-of-file character, a null character
+ *    is stored at the beginning of buffer and NULL is returned.
+ *
+ * <INPUT PARAMETERS>
+ *    buffer                         Storage location for input string.
+ *    destMax                        The size of the buffer.
+ *
+ * <OUTPUT PARAMETERS>
+ *    buffer                         is updated
+ *
+ * <RETURN VALUE>
+ *    buffer                         Successful operation
+ *    NULL                           Improper parameter or read fail
+ */
+char *gets_s(char *buffer, size_t destMax)
+{
+#ifdef SECUREC_COMPATIBLE_WIN_FORMAT
+    size_t bufferSize = ((destMax == (size_t)(-1)) ? SECUREC_STRING_MAX_LEN : destMax);
+#else
+    size_t bufferSize = destMax;
+#endif
+
+    if (buffer == NULL || bufferSize == 0 || bufferSize > SECUREC_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_PARAMTER("gets_s");
+        return NULL;
+    }
+
+    if (fgets(buffer, (int)bufferSize, SECUREC_STREAM_STDIN) != NULL) {
+        SecTrimCRLF(buffer, bufferSize);
+        return buffer;
+    }
+
+    return NULL;
+}
+
diff --git a/lib/libsecurec/src/input.inl b/lib/libsecurec/src/input.inl
new file mode 100644
index 0000000..9727d5e
--- /dev/null
+++ b/lib/libsecurec/src/input.inl
@@ -0,0 +1,2229 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: Used by secureinput_a.c and secureinput_w.c to include.
+ *              This file provides a template function for ANSI and UNICODE compiling by
+ *              different type definition. The functions of SecInputS or
+ *              SecInputSW provides internal implementation for scanf family API, such as sscanf_s, fscanf_s.
+ * Create: 2014-02-25
+ * Notes: The formatted input processing results of integers on different platforms are different.
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Performance-sensitive
+ * [reason] Always used in the performance critical path,
+ *          and sufficient input validation is performed before calling
+ */
+#ifndef INPUT_INL_5D13A042_DC3F_4ED9_A8D1_882811274C27
+#define INPUT_INL_5D13A042_DC3F_4ED9_A8D1_882811274C27
+
+#if SECUREC_IN_KERNEL
+#if !defined(SECUREC_CTYPE_MACRO_ADAPT)
+#include <linux/ctype.h>
+#endif
+#else
+#if !defined(SECUREC_SYSAPI4VXWORKS) && !defined(SECUREC_CTYPE_MACRO_ADAPT)
+#include <ctype.h>
+#ifdef SECUREC_FOR_WCHAR
+#include <wctype.h>             /* For iswspace */
+#endif
+#endif
+#endif
+
+#ifndef EOF
+#define EOF  (-1)
+#endif
+
+#define SECUREC_NUM_WIDTH_SHORT                 0
+#define SECUREC_NUM_WIDTH_INT                   1
+#define SECUREC_NUM_WIDTH_LONG                  2
+#define SECUREC_NUM_WIDTH_LONG_LONG             3 /* Also long double */
+
+#define SECUREC_BUFFERED_BLOK_SIZE              1024U
+
+#if defined(SECUREC_VXWORKS_PLATFORM) && !defined(va_copy) && !defined(__va_copy)
+/* The name is the same as system macro. */
+#define __va_copy(dest, src) do { \
+    size_t destSize_ = (size_t)sizeof(dest); \
+    size_t srcSize_ = (size_t)sizeof(src); \
+    if (destSize_ != srcSize_) { \
+        SECUREC_MEMCPY_WARP_OPT((dest), (src), sizeof(va_list)); \
+    } else { \
+        SECUREC_MEMCPY_WARP_OPT(&(dest), &(src), sizeof(va_list)); \
+    } \
+} SECUREC_WHILE_ZERO
+#endif
+
+#define SECUREC_MULTI_BYTE_MAX_LEN              6
+
+/* Compatibility macro name cannot be modifie */
+#ifndef UNALIGNED
+#if !(defined(_M_IA64)) && !(defined(_M_AMD64))
+#define UNALIGNED
+#else
+#define UNALIGNED __unaligned
+#endif
+#endif
+
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+/* Max 64bit value is 0xffffffffffffffff */
+#define SECUREC_MAX_64BITS_VALUE                18446744073709551615ULL
+#define SECUREC_MAX_64BITS_VALUE_DIV_TEN        1844674407370955161ULL
+#define SECUREC_MAX_64BITS_VALUE_CUT_LAST_DIGIT 18446744073709551610ULL
+#define SECUREC_MIN_64BITS_NEG_VALUE            9223372036854775808ULL
+#define SECUREC_MAX_64BITS_POS_VALUE            9223372036854775807ULL
+#define SECUREC_MIN_32BITS_NEG_VALUE            2147483648UL
+#define SECUREC_MAX_32BITS_POS_VALUE            2147483647UL
+#define SECUREC_MAX_32BITS_VALUE                4294967295UL
+#define SECUREC_MAX_32BITS_VALUE_INC            4294967296UL
+#define SECUREC_MAX_32BITS_VALUE_DIV_TEN        429496729UL
+#define SECUREC_LONG_BIT_NUM                    ((unsigned int)(sizeof(long) << 3U))
+/* Use ULL to clean up cl6x compilation alerts */
+#define SECUREC_MAX_LONG_POS_VALUE              ((unsigned long)(1ULL << (SECUREC_LONG_BIT_NUM - 1)) - 1)
+#define SECUREC_MIN_LONG_NEG_VALUE              ((unsigned long)(1ULL << (SECUREC_LONG_BIT_NUM - 1)))
+
+/* Covert to long long to clean up cl6x compilation alerts */
+#define SECUREC_LONG_HEX_BEYOND_MAX(number)     (((unsigned long long)(number) >> (SECUREC_LONG_BIT_NUM - 4U)) > 0)
+#define SECUREC_LONG_OCTAL_BEYOND_MAX(number)   (((unsigned long long)(number) >> (SECUREC_LONG_BIT_NUM - 3U)) > 0)
+
+#define SECUREC_QWORD_HEX_BEYOND_MAX(number)    (((number) >> (64U - 4U)) > 0)
+#define SECUREC_QWORD_OCTAL_BEYOND_MAX(number)  (((number) >> (64U - 3U)) > 0)
+
+#define SECUREC_LP64_BIT_WIDTH                  64
+#define SECUREC_LP32_BIT_WIDTH                  32
+
+#define SECUREC_CONVERT_IS_SIGNED(conv) ((conv) == 'd' || (conv) == 'i')
+#endif
+
+#define SECUREC_BRACE                           '{'     /* [ to { */
+#define SECUREC_FILED_WIDTH_ENOUGH(spec) ((spec)->widthSet == 0 || (spec)->width > 0)
+#define SECUREC_FILED_WIDTH_DEC(spec) do { \
+    if ((spec)->widthSet != 0) { \
+        --(spec)->width; \
+    } \
+} SECUREC_WHILE_ZERO
+
+#ifdef SECUREC_FOR_WCHAR
+/* Bits for all wchar, size is 65536/8, only supports wide characters with a maximum length of two bytes */
+#define SECUREC_BRACKET_TABLE_SIZE    8192
+#define SECUREC_EOF WEOF
+#define SECUREC_MB_LEN 16       /* Max. # bytes in multibyte char  ,see MB_LEN_MAX */
+#else
+/* Bits for all char, size is 256/8 */
+#define SECUREC_BRACKET_TABLE_SIZE    32
+#define SECUREC_EOF EOF
+#endif
+
+#if SECUREC_HAVE_WCHART
+#define SECUREC_ARRAY_WIDTH_IS_WRONG(spec) ((spec).arrayWidth == 0 || \
+    ((spec).isWCharOrLong <= 0 && (spec).arrayWidth > SECUREC_STRING_MAX_LEN) || \
+    ((spec).isWCharOrLong > 0 && (spec).arrayWidth > SECUREC_WCHAR_STRING_MAX_LEN))
+#else
+#define SECUREC_ARRAY_WIDTH_IS_WRONG(spec) ((spec).arrayWidth == 0 || (spec).arrayWidth > SECUREC_STRING_MAX_LEN)
+#endif
+
+#ifdef SECUREC_ON_64BITS
+/* Use 0xffffffffUL mask to pass integer as array length */
+#define SECUREC_GET_ARRAYWIDTH(argList) (((size_t)va_arg((argList), size_t)) & 0xffffffffUL)
+#else /* !SECUREC_ON_64BITS */
+#define SECUREC_GET_ARRAYWIDTH(argList) ((size_t)va_arg((argList), size_t))
+#endif
+
+typedef struct {
+#ifdef SECUREC_FOR_WCHAR
+    unsigned char *table; /* Default NULL */
+#else
+    unsigned char table[SECUREC_BRACKET_TABLE_SIZE]; /* Array length is large enough in application scenarios */
+#endif
+    unsigned char mask; /* Default 0 */
+} SecBracketTable;
+
+#ifdef SECUREC_FOR_WCHAR
+#define SECUREC_INIT_BRACKET_TABLE { NULL, 0 }
+#else
+#define SECUREC_INIT_BRACKET_TABLE { {0}, 0 }
+#endif
+
+#if SECUREC_ENABLE_SCANF_FLOAT
+typedef struct {
+    size_t floatStrTotalLen;       /* Initialization must be length of buffer in charater */
+    size_t floatStrUsedLen;        /* Store float string len */
+    SecChar *floatStr;             /* Initialization must point to buffer */
+    SecChar *allocatedFloatStr;    /* Initialization must be NULL  to store alloced point */
+    SecChar buffer[SECUREC_FLOAT_BUFSIZE + 1];
+} SecFloatSpec;
+#endif
+
+#define SECUREC_NUMBER_STATE_DEFAULT 0U
+#define SECUREC_NUMBER_STATE_STARTED 1U
+
+typedef struct {
+    SecInt ch;            /* Char read from input */
+    int charCount;        /* Number of characters processed */
+    void *argPtr;         /* Variable parameter pointer, point to the end of the string */
+    size_t arrayWidth;    /* Length of pointer Variable parameter, in charaters */
+    SecUnsignedInt64 number64; /* Store input number64 value */
+    unsigned long number; /* Store input number32 value */
+    int numberWidth;      /* 0 = SHORT, 1 = int, > 1  long or L_DOUBLE */
+    int numberArgType;       /* 1 for 64-bit integer, 0 otherwise. use it as decode function index */
+    unsigned int negative;         /* 0 is positive */
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    unsigned int beyondMax;        /* Non-zero means beyond */
+#endif
+    unsigned int numberState; /* Identifies whether to start processing numbers, 1 is can input number */
+    int width;            /* Width number in format */
+    int widthSet;         /* 0 is not set width in format */
+    int convChr;          /* Lowercase format conversion characters */
+    int oriConvChr;       /* Store  original format conversion, convChr may change when parsing integers */
+    signed char isWCharOrLong;  /* -1/0 not wchar or long, 1 for wchar or long */
+    unsigned char suppress;     /* 0 is not have %* in format */
+} SecScanSpec;
+
+#ifdef SECUREC_FOR_WCHAR
+#define SECUREC_GETC fgetwc
+#define SECUREC_UN_GETC ungetwc
+/* Only supports wide characters with a maximum length of two bytes in format string */
+#define SECUREC_BRACKET_CHAR_MASK 0xffffU
+#else
+#define SECUREC_GETC fgetc
+#define SECUREC_UN_GETC ungetc
+#define SECUREC_BRACKET_CHAR_MASK 0xffU
+#endif
+
+#define SECUREC_CHAR_SIZE ((unsigned int)(sizeof(SecChar)))
+/* To avoid 648, mask high bit: 0x00ffffff 0x0000ffff or 0x00000000 */
+#define SECUREC_CHAR_MASK_HIGH (((((((((unsigned int)(-1) >> SECUREC_CHAR_SIZE) >> SECUREC_CHAR_SIZE) >> \
+    SECUREC_CHAR_SIZE) >> SECUREC_CHAR_SIZE) >> \
+    SECUREC_CHAR_SIZE) >> SECUREC_CHAR_SIZE) >> \
+    SECUREC_CHAR_SIZE) >> SECUREC_CHAR_SIZE)
+
+/* For char is 0xff, wcahr_t is 0xffff or 0xffffffff. */
+#define SECUREC_CHAR_MASK (~((((((((((unsigned int)(-1) & SECUREC_CHAR_MASK_HIGH) << \
+    SECUREC_CHAR_SIZE) << SECUREC_CHAR_SIZE) << \
+    SECUREC_CHAR_SIZE) << SECUREC_CHAR_SIZE) << \
+    SECUREC_CHAR_SIZE) << SECUREC_CHAR_SIZE) << \
+    SECUREC_CHAR_SIZE) << SECUREC_CHAR_SIZE))
+
+/* According wchar_t has multiple bytes, so use sizeof */
+#define SECUREC_GET_CHAR(stream, outCh) do { \
+    if ((stream)->count >= sizeof(SecChar)) { \
+        *(outCh) = (SecInt)(SECUREC_CHAR_MASK & \
+            (unsigned int)(int)(*((const SecChar *)(const void *)(stream)->cur))); \
+        (stream)->cur += sizeof(SecChar); \
+        (stream)->count -= sizeof(SecChar); \
+    } else { \
+        *(outCh) = SECUREC_EOF; \
+    } \
+} SECUREC_WHILE_ZERO
+
+#define SECUREC_UN_GET_CHAR(stream) do { \
+    if ((stream)->cur > (stream)->base) { \
+        (stream)->cur -= sizeof(SecChar); \
+        (stream)->count += sizeof(SecChar); \
+    } \
+} SECUREC_WHILE_ZERO
+
+/* Convert wchar_t to int and then to unsigned int  to keep data clearing warning */
+#define SECUREC_TO_LOWERCASE(chr) ((int)((unsigned int)(int)(chr) | (unsigned int)('a' - 'A')))
+
+/* Record a flag for each bit */
+#define SECUREC_BRACKET_INDEX(x)  ((unsigned int)(x) >> 3U)
+#define SECUREC_BRACKET_VALUE(x)  ((unsigned char)(1U << ((unsigned int)(x) & 7U)))
+#if SECUREC_IN_KERNEL
+#define SECUREC_CONVERT_IS_UNSIGNED(conv) ((conv) == 'x' || (conv) == 'o' || (conv) == 'u')
+#endif
+
+/*
+ * Set char in %[xxx] into table, only supports wide characters with a maximum length of two bytes
+ */
+SECUREC_INLINE void SecBracketSetBit(unsigned char *table, SecUnsignedChar ch)
+{
+    unsigned int tableIndex = SECUREC_BRACKET_INDEX(((unsigned int)(int)ch & SECUREC_BRACKET_CHAR_MASK));
+    unsigned int tableValue = SECUREC_BRACKET_VALUE(((unsigned int)(int)ch & SECUREC_BRACKET_CHAR_MASK));
+    /* Do not use   |=   optimize this code, it will cause compiling warning */
+    table[tableIndex] = (unsigned char)(table[tableIndex] | tableValue);
+}
+
+SECUREC_INLINE void SecBracketSetBitRange(unsigned char *table, SecUnsignedChar startCh, SecUnsignedChar endCh)
+{
+    SecUnsignedChar expCh;
+    /* %[a-z] %[a-a] Format %[a-\xff] end is 0xFF, condition (expCh <= endChar) cause dead loop */
+    for (expCh = startCh; expCh < endCh; ++expCh) {
+        SecBracketSetBit(table, expCh);
+    }
+    SecBracketSetBit(table, endCh);
+}
+/*
+ * Determine whether the expression can be satisfied
+ */
+SECUREC_INLINE int SecCanInputForBracket(int convChr, SecInt ch, const SecBracketTable *bracketTable)
+{
+    unsigned int tableIndex = SECUREC_BRACKET_INDEX(((unsigned int)(int)ch & SECUREC_BRACKET_CHAR_MASK));
+    unsigned int tableValue = SECUREC_BRACKET_VALUE(((unsigned int)(int)ch & SECUREC_BRACKET_CHAR_MASK));
+#ifdef SECUREC_FOR_WCHAR
+    if (((unsigned int)(int)ch & (~(SECUREC_BRACKET_CHAR_MASK))) != 0) {
+        /* The value of the wide character exceeds the size of two bytes */
+        return 0;
+    }
+    return (int)(convChr == SECUREC_BRACE &&
+        (((unsigned int)bracketTable->table[tableIndex] ^ (unsigned int)bracketTable->mask) & tableValue) != 0);
+#else
+    return (int)(convChr == SECUREC_BRACE &&
+        (((unsigned int)bracketTable->table[tableIndex] ^ (unsigned int)bracketTable->mask) & tableValue) != 0);
+#endif
+}
+
+/*
+ * String input ends when blank character is encountered
+ */
+SECUREC_INLINE int SecCanInputString(int convChr, SecInt ch)
+{
+    return (int)(convChr == 's' &&
+        (!(ch >= SECUREC_CHAR('\t') && ch <= SECUREC_CHAR('\r')) && ch != SECUREC_CHAR(' ')));
+}
+
+/*
+ * Can input a character when format is %c
+ */
+SECUREC_INLINE int SecCanInputCharacter(int convChr)
+{
+    return (int)(convChr == 'c');
+}
+
+/*
+ * Determine if it is a 64-bit pointer  function
+ * Return 0 is not ,1 is 64bit pointer
+ */
+SECUREC_INLINE int SecNumberArgType(size_t sizeOfVoidStar)
+{
+    /* Point size is 4 or 8 , Under the 64 bit system, the value not 0 */
+    /* To clear e778 */
+    if ((sizeOfVoidStar & sizeof(SecInt64)) != 0) {
+        return 1;
+    }
+    return 0;
+}
+SECUREC_INLINE int SecIsDigit(SecInt ch);
+SECUREC_INLINE int SecIsXdigit(SecInt ch);
+SECUREC_INLINE int SecIsSpace(SecInt ch);
+SECUREC_INLINE SecInt SecSkipSpaceChar(SecFileStream *stream, int *counter);
+SECUREC_INLINE SecInt SecGetChar(SecFileStream *stream, int *counter);
+SECUREC_INLINE void SecUnGetChar(SecInt ch, SecFileStream *stream, int *counter);
+
+#if SECUREC_ENABLE_SCANF_FLOAT
+
+/*
+ * Convert a floating point string to a floating point number
+ */
+SECUREC_INLINE int SecAssignNarrowFloat(const char *floatStr, const SecScanSpec *spec)
+{
+    char *endPtr = NULL;
+    double d;
+#if SECUREC_SUPPORT_STRTOLD
+    if (spec->numberWidth == SECUREC_NUM_WIDTH_LONG_LONG) {
+        long double d2 = strtold(floatStr, &endPtr);
+        if (endPtr == floatStr) {
+            return -1;
+        }
+        *(long double UNALIGNED *)(spec->argPtr) = d2;
+        return 0;
+    }
+#endif
+    d = strtod(floatStr, &endPtr);
+    /* cannot detect if endPtr points to the end of floatStr,because strtod handles only two characters for 1.E */
+    if (endPtr == floatStr) {
+        return -1;
+    }
+    if (spec->numberWidth > SECUREC_NUM_WIDTH_INT) {
+        *(double UNALIGNED *)(spec->argPtr) = (double)d;
+    } else {
+        *(float UNALIGNED *)(spec->argPtr) = (float)d;
+    }
+    return 0;
+}
+
+#ifdef SECUREC_FOR_WCHAR
+/*
+ * Convert a floating point wchar string to a floating point number
+ * Success  ret 0
+ */
+SECUREC_INLINE int SecAssignWideFloat(const SecFloatSpec *floatSpec, const SecScanSpec *spec)
+{
+    int retVal;
+    /* Convert float string */
+    size_t mbsLen;
+    size_t tempFloatStrLen = (size_t)(floatSpec->floatStrUsedLen + 1) * sizeof(wchar_t);
+    char *tempFloatStr = (char *)SECUREC_MALLOC(tempFloatStrLen);
+    if (tempFloatStr == NULL) {
+        return -1;
+    }
+    tempFloatStr[0] = '\0';
+    SECUREC_MASK_MSVC_CRT_WARNING
+    mbsLen = wcstombs(tempFloatStr, floatSpec->floatStr, tempFloatStrLen - 1);
+    SECUREC_END_MASK_MSVC_CRT_WARNING
+    /* This condition must satisfy mbsLen is not -1 */
+    if (mbsLen >= tempFloatStrLen) {
+        SECUREC_FREE(tempFloatStr);
+        return -1;
+    }
+    tempFloatStr[mbsLen] = '\0';
+    retVal = SecAssignNarrowFloat(tempFloatStr, spec);
+    SECUREC_FREE(tempFloatStr);
+    return retVal;
+}
+#endif
+
+SECUREC_INLINE int SecAssignFloat(const SecFloatSpec *floatSpec, const SecScanSpec *spec)
+{
+#ifdef SECUREC_FOR_WCHAR
+    return SecAssignWideFloat(floatSpec, spec);
+#else
+    return SecAssignNarrowFloat(floatSpec->floatStr, spec);
+#endif
+}
+
+/*
+ * Init SecFloatSpec before parse format
+ */
+SECUREC_INLINE void SecInitFloatSpec(SecFloatSpec *floatSpec)
+{
+    floatSpec->floatStr = floatSpec->buffer;
+    floatSpec->allocatedFloatStr = NULL;
+    floatSpec->floatStrTotalLen = sizeof(floatSpec->buffer) / sizeof(floatSpec->buffer[0]);
+    floatSpec->floatStrUsedLen = 0;
+}
+
+SECUREC_INLINE void SecFreeFloatSpec(SecFloatSpec *floatSpec, int *doneCount)
+{
+    /* 2014.3.6 add, clear the stack data */
+    if (memset_s(floatSpec->buffer, sizeof(floatSpec->buffer), 0, sizeof(floatSpec->buffer)) != EOK) {
+        *doneCount = 0; /* This code just to meet the coding requirements */
+    }
+    /* The pFloatStr can be alloced in SecExtendFloatLen function, clear and free it */
+    if (floatSpec->allocatedFloatStr != NULL) {
+        size_t bufferSize = floatSpec->floatStrTotalLen * sizeof(SecChar);
+        if (memset_s(floatSpec->allocatedFloatStr, bufferSize, 0, bufferSize) != EOK) {
+            *doneCount = 0; /* This code just to meet the coding requirements */
+        }
+        SECUREC_FREE(floatSpec->allocatedFloatStr);
+        floatSpec->allocatedFloatStr = NULL;
+        floatSpec->floatStr = NULL;
+    }
+}
+
+/*
+ * Splice floating point string
+ * Return 0 OK
+ */
+SECUREC_INLINE int SecExtendFloatLen(SecFloatSpec *floatSpec)
+{
+    if (floatSpec->floatStrUsedLen >= floatSpec->floatStrTotalLen) {
+        /* Buffer size is len x sizeof(SecChar) */
+        size_t oriSize = floatSpec->floatStrTotalLen * sizeof(SecChar);
+        /* Add one character to clear tool warning */
+        size_t nextSize = (oriSize * 2) + sizeof(SecChar); /* Multiply 2 to extend buffer size */
+
+        /* Prevents integer overflow, the maximum length of SECUREC_MAX_WIDTH_LEN is enough */
+        if (nextSize <= (size_t)SECUREC_MAX_WIDTH_LEN) {
+            void *nextBuffer = (void *)SECUREC_MALLOC(nextSize);
+            if (nextBuffer == NULL) {
+                return -1;
+            }
+            if (memcpy_s(nextBuffer, nextSize, floatSpec->floatStr, oriSize) != EOK) {
+                SECUREC_FREE(nextBuffer);   /* This is a dead code, just to meet the coding requirements */
+                return -1;
+            }
+            /* Clear old buffer memory */
+            if (memset_s(floatSpec->floatStr, oriSize, 0, oriSize) != EOK) {
+                SECUREC_FREE(nextBuffer);   /* This is a dead code, just to meet the coding requirements */
+                return -1;
+            }
+            /* Free old allocated buffer */
+            if (floatSpec->allocatedFloatStr != NULL) {
+                SECUREC_FREE(floatSpec->allocatedFloatStr);
+            }
+            floatSpec->allocatedFloatStr = (SecChar *)(nextBuffer);    /* Use to clear free on stack warning */
+            floatSpec->floatStr = (SecChar *)(nextBuffer);
+            floatSpec->floatStrTotalLen = nextSize / sizeof(SecChar); /* Get buffer total len in character */
+            return 0;
+        }
+        return -1; /* Next size is beyond max */
+    }
+    return 0;
+}
+
+/* Do not use localeconv()->decimal_pointif  onlay support  '.' */
+SECUREC_INLINE int SecIsFloatDecimal(SecChar ch)
+{
+    return (int)(ch == SECUREC_CHAR('.'));
+}
+
+SECUREC_INLINE int SecInputFloatSign(SecFileStream *stream, SecScanSpec *spec, SecFloatSpec *floatSpec)
+{
+    if (!SECUREC_FILED_WIDTH_ENOUGH(spec)) {
+        return 0;
+    }
+    spec->ch = SecGetChar(stream, &(spec->charCount));
+    if (spec->ch == SECUREC_CHAR('+') || spec->ch == SECUREC_CHAR('-')) {
+        SECUREC_FILED_WIDTH_DEC(spec); /* Make sure the count after un get char is correct */
+        if (spec->ch == SECUREC_CHAR('-')) {
+            floatSpec->floatStr[floatSpec->floatStrUsedLen] = SECUREC_CHAR('-');
+            ++floatSpec->floatStrUsedLen;
+            if (SecExtendFloatLen(floatSpec) != 0) {
+                return -1;
+            }
+        }
+    } else {
+        SecUnGetChar(spec->ch, stream, &(spec->charCount));
+    }
+    return 0;
+}
+
+SECUREC_INLINE int SecInputFloatDigit(SecFileStream *stream, SecScanSpec *spec, SecFloatSpec *floatSpec)
+{
+    /* Now get integral part */
+    while (SECUREC_FILED_WIDTH_ENOUGH(spec)) {
+        spec->ch = SecGetChar(stream, &(spec->charCount));
+        if (SecIsDigit(spec->ch) == 0) {
+            SecUnGetChar(spec->ch, stream, &(spec->charCount));
+            return 0;
+        }
+        SECUREC_FILED_WIDTH_DEC(spec); /* Must be behind un get char, otherwise the logic is incorrect */
+        spec->numberState = SECUREC_NUMBER_STATE_STARTED;
+        floatSpec->floatStr[floatSpec->floatStrUsedLen] = (SecChar)spec->ch;
+        ++floatSpec->floatStrUsedLen;
+        if (SecExtendFloatLen(floatSpec) != 0) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+/*
+* Scan value of exponent.
+* Return 0 OK
+*/
+SECUREC_INLINE int SecInputFloatE(SecFileStream *stream, SecScanSpec *spec, SecFloatSpec *floatSpec)
+{
+    if (SecInputFloatSign(stream, spec, floatSpec) == -1) {
+        return -1;
+    }
+    if (SecInputFloatDigit(stream, spec, floatSpec) != 0) {
+        return -1;
+    }
+    return 0;
+}
+
+SECUREC_INLINE int SecInputFloatFractional(SecFileStream *stream, SecScanSpec *spec, SecFloatSpec *floatSpec)
+{
+    if (SECUREC_FILED_WIDTH_ENOUGH(spec)) {
+        spec->ch = SecGetChar(stream, &(spec->charCount));
+        if (SecIsFloatDecimal((SecChar)spec->ch) == 0) {
+            SecUnGetChar(spec->ch, stream, &(spec->charCount));
+            return 0;
+        }
+        SECUREC_FILED_WIDTH_DEC(spec); /* Must be behind un get char, otherwise the logic is incorrect */
+        /* Now check for decimal */
+        floatSpec->floatStr[floatSpec->floatStrUsedLen] = (SecChar)spec->ch;
+        ++floatSpec->floatStrUsedLen;
+        if (SecExtendFloatLen(floatSpec) != 0) {
+            return -1;
+        }
+        if (SecInputFloatDigit(stream, spec, floatSpec) != 0) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+SECUREC_INLINE int SecInputFloatExponent(SecFileStream *stream, SecScanSpec *spec, SecFloatSpec *floatSpec)
+{
+    /* Now get exponent part */
+    if (spec->numberState == SECUREC_NUMBER_STATE_STARTED && SECUREC_FILED_WIDTH_ENOUGH(spec)) {
+        spec->ch = SecGetChar(stream, &(spec->charCount));
+        if (spec->ch != SECUREC_CHAR('e') && spec->ch != SECUREC_CHAR('E')) {
+            SecUnGetChar(spec->ch, stream, &(spec->charCount));
+            return 0;
+        }
+        SECUREC_FILED_WIDTH_DEC(spec); /* Must be behind un get char, otherwise the logic is incorrect */
+        floatSpec->floatStr[floatSpec->floatStrUsedLen] = SECUREC_CHAR('e');
+        ++floatSpec->floatStrUsedLen;
+        if (SecExtendFloatLen(floatSpec) != 0) {
+            return -1;
+        }
+        if (SecInputFloatE(stream, spec, floatSpec) != 0) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+/*
+* Scan %f.
+* Return 0 OK
+*/
+SECUREC_INLINE int SecInputFloat(SecFileStream *stream, SecScanSpec *spec, SecFloatSpec *floatSpec)
+{
+    floatSpec->floatStrUsedLen = 0;
+
+    /* The following code sequence is strict */
+    if (SecInputFloatSign(stream, spec, floatSpec) != 0) {
+        return -1;
+    }
+    if (SecInputFloatDigit(stream, spec, floatSpec) != 0) {
+        return -1;
+    }
+    if (SecInputFloatFractional(stream, spec, floatSpec) != 0) {
+        return -1;
+    }
+    if (SecInputFloatExponent(stream, spec, floatSpec) != 0) {
+        return -1;
+    }
+
+    /* Make sure  have a string terminator, buffer is large enough */
+    floatSpec->floatStr[floatSpec->floatStrUsedLen] = SECUREC_CHAR('\0');
+    if (spec->numberState == SECUREC_NUMBER_STATE_STARTED) {
+        return 0;
+    }
+    return -1;
+}
+#endif
+
+#if (!defined(SECUREC_FOR_WCHAR) && SECUREC_HAVE_WCHART && SECUREC_HAVE_MBTOWC) || \
+    (!defined(SECUREC_FOR_WCHAR) && defined(SECUREC_COMPATIBLE_VERSION))
+/* only multi-bytes string need isleadbyte() function */
+SECUREC_INLINE int SecIsLeadByte(SecInt ch)
+{
+    unsigned int c = (unsigned int)ch;
+#if !(defined(_MSC_VER) || defined(_INC_WCTYPE))
+    return (int)(c & 0x80U); /* Use bitwise operation to check if the most significant bit is 1 */
+#else
+    return (int)isleadbyte((int)(c & 0xffU)); /* Use bitwise operations to limit character values to valid ranges */
+#endif
+}
+#endif
+
+/*
+ * Parsing whether it is a wide character
+ */
+SECUREC_INLINE void SecUpdateWcharFlagByType(SecUnsignedChar ch, SecScanSpec *spec)
+{
+    if (spec->isWCharOrLong != 0) {
+        /* Wide character identifiers have been explicitly set by l or h flag */
+        return;
+    }
+
+    /* Set default flag */
+#if defined(SECUREC_FOR_WCHAR) && defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+    spec->isWCharOrLong = 1;  /* On windows wide char version %c %s %[ is wide char */
+#else
+    spec->isWCharOrLong = -1; /* On linux all version %c %s %[ is multi char */
+#endif
+
+    if (ch == SECUREC_CHAR('C') || ch == SECUREC_CHAR('S')) {
+#if defined(SECUREC_FOR_WCHAR) && defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+        spec->isWCharOrLong = -1; /* On windows wide char version %C %S is multi char */
+#else
+        spec->isWCharOrLong = 1;  /* On linux all version %C %S is wide char */
+#endif
+    }
+
+    return;
+}
+/*
+ * Decode  %l %ll
+ */
+SECUREC_INLINE void SecDecodeScanQualifierL(const SecUnsignedChar **format, SecScanSpec *spec)
+{
+    const SecUnsignedChar *fmt = *format;
+    if (*(fmt + 1) == SECUREC_CHAR('l')) {
+        spec->numberArgType = 1;
+        spec->numberWidth = SECUREC_NUM_WIDTH_LONG_LONG;
+        ++fmt;
+    } else {
+        spec->numberWidth = SECUREC_NUM_WIDTH_LONG;
+#if defined(SECUREC_ON_64BITS) && !(defined(SECUREC_COMPATIBLE_WIN_FORMAT))
+        /* On window 64 system sizeof long is 32bit */
+        spec->numberArgType = 1;
+#endif
+        spec->isWCharOrLong = 1;
+    }
+    *format = fmt;
+}
+
+/*
+ * Decode  %I %I43 %I64 %Id %Ii %Io ...
+ * Set finishFlag to  1  finish Flag
+ */
+SECUREC_INLINE void SecDecodeScanQualifierI(const SecUnsignedChar **format, SecScanSpec *spec, int *finishFlag)
+{
+    const SecUnsignedChar *fmt = *format;
+    if ((*(fmt + 1) == SECUREC_CHAR('6')) &&
+        (*(fmt + 2) == SECUREC_CHAR('4'))) { /* Offset 2 for I64 */
+        spec->numberArgType = 1;
+        *format = *format + 2; /* Add 2 to skip I64 point to '4' next loop will inc */
+    } else if ((*(fmt + 1) == SECUREC_CHAR('3')) &&
+                (*(fmt + 2) == SECUREC_CHAR('2'))) { /* Offset 2 for I32 */
+        *format = *format + 2; /* Add 2 to skip I32 point to '2' next loop will inc */
+    } else if ((*(fmt + 1) == SECUREC_CHAR('d')) ||
+                (*(fmt + 1) == SECUREC_CHAR('i')) ||
+                (*(fmt + 1) == SECUREC_CHAR('o')) ||
+                (*(fmt + 1) == SECUREC_CHAR('x')) ||
+                (*(fmt + 1) == SECUREC_CHAR('X'))) {
+        spec->numberArgType = SecNumberArgType(sizeof(void *));
+    } else {
+        /* For %I */
+        spec->numberArgType = SecNumberArgType(sizeof(void *));
+        *finishFlag = 1;
+    }
+}
+
+SECUREC_INLINE int SecDecodeScanWidth(const SecUnsignedChar **format, SecScanSpec *spec)
+{
+    const SecUnsignedChar *fmt = *format;
+    while (SecIsDigit((SecInt)(int)(*fmt)) != 0) {
+        spec->widthSet = 1;
+        if (SECUREC_MUL_TEN_ADD_BEYOND_MAX(spec->width)) {
+            return -1;
+        }
+        spec->width = (int)SECUREC_MUL_TEN((unsigned int)spec->width) + (unsigned char)(*fmt - SECUREC_CHAR('0'));
+        ++fmt;
+    }
+    *format = fmt;
+    return 0;
+}
+
+/*
+ * Init default flags for each format. do not init ch this variable is context-dependent
+ */
+SECUREC_INLINE void SecSetDefaultScanSpec(SecScanSpec *spec)
+{
+    /* The ch and charCount member variables cannot be initialized here */
+    spec->argPtr = NULL;
+    spec->arrayWidth = 0;
+    spec->number64 = 0;
+    spec->number = 0;
+    spec->numberWidth = SECUREC_NUM_WIDTH_INT;    /* 0 = SHORT, 1 = int, > 1  long or L_DOUBLE */
+    spec->numberArgType = 0;                         /* 1 for 64-bit integer, 0 otherwise */
+    spec->width = 0;
+    spec->widthSet = 0;
+    spec->convChr = 0;
+    spec->oriConvChr = 0;
+    spec->isWCharOrLong = 0;
+    spec->suppress = 0;
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    spec->beyondMax = 0;
+#endif
+    spec->negative = 0;
+    spec->numberState = SECUREC_NUMBER_STATE_DEFAULT;
+}
+
+/*
+ * Decode qualifier %I %L %h ...
+ * Set finishFlag to  1  finish Flag
+ */
+SECUREC_INLINE void  SecDecodeScanQualifier(const SecUnsignedChar **format, SecScanSpec *spec, int *finishFlag)
+{
+    switch (**format) {
+        case SECUREC_CHAR('F'): /* fall-through */ /* FALLTHRU */
+        case SECUREC_CHAR('N'):
+            break;
+        case SECUREC_CHAR('h'):
+            --spec->numberWidth; /* The h for SHORT , hh for CHAR */
+            spec->isWCharOrLong = -1;
+            break;
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+        case SECUREC_CHAR('j'):
+            spec->numberWidth = SECUREC_NUM_WIDTH_LONG_LONG;  /* For intmax_t or uintmax_t */
+            spec->numberArgType = 1;
+            break;
+        case SECUREC_CHAR('t'): /* fall-through */ /* FALLTHRU */
+#endif
+#if SECUREC_IN_KERNEL
+        case SECUREC_CHAR('Z'): /* fall-through */ /* FALLTHRU */
+#endif
+        case SECUREC_CHAR('z'):
+#ifdef SECUREC_ON_64BITS
+            spec->numberWidth = SECUREC_NUM_WIDTH_LONG_LONG;
+            spec->numberArgType = 1;
+#else
+            spec->numberWidth = SECUREC_NUM_WIDTH_LONG;
+#endif
+            break;
+        case SECUREC_CHAR('L'):    /* For long double */ /* fall-through */ /* FALLTHRU */
+        case SECUREC_CHAR('q'):
+            spec->numberWidth = SECUREC_NUM_WIDTH_LONG_LONG;
+            spec->numberArgType = 1;
+            break;
+        case SECUREC_CHAR('l'):
+            SecDecodeScanQualifierL(format, spec);
+            break;
+        case SECUREC_CHAR('w'):
+            spec->isWCharOrLong = 1;
+            break;
+        case SECUREC_CHAR('*'):
+            spec->suppress = 1;
+            break;
+        case SECUREC_CHAR('I'):
+            SecDecodeScanQualifierI(format, spec, finishFlag);
+            break;
+        default:
+            *finishFlag = 1;
+            break;
+    }
+}
+/*
+ * Decode width and qualifier in format
+ */
+SECUREC_INLINE int SecDecodeScanFlag(const SecUnsignedChar **format, SecScanSpec *spec)
+{
+    const SecUnsignedChar *fmt = *format;
+    int finishFlag = 0;
+
+    do {
+        ++fmt; /*  First skip % , next  seek fmt */
+        /* May %*6d , so put it inside the loop */
+        if (SecDecodeScanWidth(&fmt, spec) != 0) {
+            return -1;
+        }
+        SecDecodeScanQualifier(&fmt, spec, &finishFlag);
+    } while (finishFlag == 0);
+    *format = fmt;
+    return 0;
+}
+
+/*
+ * Judging whether a zeroing buffer is needed according to different formats
+ */
+SECUREC_INLINE int SecDecodeClearFormat(const SecUnsignedChar *format, int *convChr)
+{
+    const SecUnsignedChar *fmt = format;
+    /* To lowercase */
+    int ch = SECUREC_TO_LOWERCASE(*fmt);
+    if (!(ch == 'c' || ch == 's' || ch == SECUREC_BRACE)) {
+        return -1;     /* First argument is not a string type */
+    }
+    if (ch == SECUREC_BRACE) {
+#if !(defined(SECUREC_COMPATIBLE_WIN_FORMAT))
+        if (*fmt == SECUREC_CHAR('{')) {
+            return -1;
+        }
+#endif
+        ++fmt;
+        if (*fmt == SECUREC_CHAR('^')) {
+            ++fmt;
+        }
+        if (*fmt == SECUREC_CHAR(']')) {
+            ++fmt;
+        }
+        while (*fmt != SECUREC_CHAR('\0') && *fmt != SECUREC_CHAR(']')) {
+            ++fmt;
+        }
+        if (*fmt == SECUREC_CHAR('\0')) {
+            return -1; /* Trunc'd format string */
+        }
+    }
+    *convChr = ch;
+    return 0;
+}
+
+/*
+ * Add L'\0' for wchar string , add '\0' for char string
+ */
+SECUREC_INLINE void SecAddEndingZero(void *ptr, const SecScanSpec *spec)
+{
+    if (spec->suppress == 0) {
+        *(char *)ptr = '\0';
+#if SECUREC_HAVE_WCHART
+        if (spec->isWCharOrLong > 0) {
+            *(wchar_t UNALIGNED *)ptr = L'\0';
+        }
+#endif
+    }
+}
+
+SECUREC_INLINE void SecDecodeClearArg(SecScanSpec *spec, va_list argList)
+{
+    va_list argListSave; /* Backup for argList value, this variable don't need initialized */
+    (void)SECUREC_MEMSET_FUNC_OPT(&argListSave, 0, sizeof(va_list)); /* To clear e530 argListSave not initialized */
+#if defined(va_copy)
+    va_copy(argListSave, argList);
+#elif defined(__va_copy)        /* For vxworks */
+    __va_copy(argListSave, argList);
+#else
+    argListSave = argList;
+#endif
+    spec->argPtr = (void *)va_arg(argListSave, void *);
+    /* Get the next argument, size of the array in characters */
+    /* Use 0xffffffffUL mask to Support  pass integer as array length */
+    spec->arrayWidth = ((size_t)(va_arg(argListSave, size_t))) & 0xffffffffUL;
+    va_end(argListSave);
+    /* To clear e438 last value assigned not used , the compiler will optimize this code */
+    (void)argListSave;
+}
+
+#ifdef SECUREC_FOR_WCHAR
+/*
+ *  Clean up the first %s %c buffer to zero for wchar version
+ */
+void SecClearDestBufW(const wchar_t *buffer, const wchar_t *format, va_list argList)
+#else
+/*
+ *  Clean up the first %s %c buffer to zero for char version
+ */
+void SecClearDestBuf(const char *buffer, const char *format, va_list argList)
+#endif
+{
+    SecScanSpec spec;
+    int convChr = 0;
+    const SecUnsignedChar *fmt = (const SecUnsignedChar *)format;
+
+    /* Find first % */
+    while (*fmt != SECUREC_CHAR('\0') && *fmt != SECUREC_CHAR('%')) {
+        ++fmt;
+    }
+    if (*fmt == SECUREC_CHAR('\0')) {
+        return;
+    }
+
+    SecSetDefaultScanSpec(&spec);
+    if (SecDecodeScanFlag(&fmt, &spec) != 0) {
+        return;
+    }
+
+    /* Update wchar flag for %S %C */
+    SecUpdateWcharFlagByType(*fmt, &spec);
+    if (spec.suppress != 0) {
+        return;
+    }
+
+    if (SecDecodeClearFormat(fmt, &convChr) != 0) {
+        return;
+    }
+
+    if (*buffer != SECUREC_CHAR('\0') && convChr != 's') {
+        /*
+         * When buffer not empty just clear %s.
+         * Example call sscanf by  argment of (" \n", "%s", s, sizeof(s))
+         */
+        return;
+    }
+
+    SecDecodeClearArg(&spec, argList);
+    /* There is no need to judge the upper limit */
+    if (spec.arrayWidth == 0 || spec.argPtr == NULL) {
+        return;
+    }
+    /* Clear one char */
+    SecAddEndingZero(spec.argPtr, &spec);
+    return;
+}
+
+/*
+ *  Assign number  to output buffer
+ */
+SECUREC_INLINE void SecAssignNumber(const SecScanSpec *spec)
+{
+    void *argPtr = spec->argPtr;
+    if (spec->numberArgType != 0) {
+#if defined(SECUREC_VXWORKS_PLATFORM)
+#if defined(SECUREC_VXWORKS_PLATFORM_COMP)
+        *(SecInt64 UNALIGNED *)argPtr = (SecInt64)(spec->number64);
+#else
+        /* Take number64 as unsigned number unsigned to int clear Compile warning */
+        *(SecInt64 UNALIGNED *)argPtr = *(SecUnsignedInt64 *)(&(spec->number64));
+#endif
+#else
+        /* Take number64 as unsigned number */
+        *(SecInt64 UNALIGNED *)argPtr = (SecInt64)(spec->number64);
+#endif
+        return;
+    }
+    if (spec->numberWidth > SECUREC_NUM_WIDTH_INT) {
+        /* Take number as unsigned number */
+        *(long UNALIGNED *)argPtr = (long)(spec->number);
+    } else if (spec->numberWidth == SECUREC_NUM_WIDTH_INT) {
+        *(int UNALIGNED *)argPtr = (int)(spec->number);
+    } else if (spec->numberWidth == SECUREC_NUM_WIDTH_SHORT) {
+        /* Take number as unsigned number */
+        *(short UNALIGNED *)argPtr = (short)(spec->number);
+    } else {  /* < 0 for hh format modifier */
+        /* Take number as unsigned number */
+        *(char UNALIGNED *)argPtr = (char)(spec->number);
+    }
+}
+
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+/*
+ *  Judge the long bit width
+ */
+SECUREC_INLINE int SecIsLongBitEqual(int bitNum)
+{
+    return (int)((unsigned int)bitNum == SECUREC_LONG_BIT_NUM);
+}
+#endif
+
+/*
+ * Convert hexadecimal characters to decimal value
+ */
+SECUREC_INLINE int SecHexValueOfChar(SecInt ch)
+{
+    /* Use isdigt Causing tool false alarms */
+    return (int)((ch >= '0' && ch <= '9') ? ((unsigned char)ch - '0') :
+            ((((unsigned char)ch | (unsigned char)('a' - 'A')) - ('a')) + 10)); /* Adding 10 is to hex value */
+}
+
+/*
+ * Parse decimal character to integer for 32bit .
+ */
+static void SecDecodeNumberDecimal(SecScanSpec *spec)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    unsigned long decimalEdge = SECUREC_MAX_32BITS_VALUE_DIV_TEN;
+#ifdef SECUREC_ON_64BITS
+    if (SecIsLongBitEqual(SECUREC_LP64_BIT_WIDTH) != 0) {
+        decimalEdge = (unsigned long)SECUREC_MAX_64BITS_VALUE_DIV_TEN;
+    }
+#endif
+    if (spec->number > decimalEdge) {
+        spec->beyondMax = 1;
+    }
+#endif
+    spec->number = SECUREC_MUL_TEN(spec->number);
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (spec->number == SECUREC_MUL_TEN(decimalEdge)) {
+        /* This code is specially converted to unsigned long type for compatibility */
+        SecUnsignedInt64 number64As = (unsigned long)SECUREC_MAX_64BITS_VALUE - spec->number;
+        if (number64As < (SecUnsignedInt64)(SecUnsignedInt)spec->ch - (SecUnsignedInt)SECUREC_CHAR('0')) {
+            spec->beyondMax = 1;
+        }
+    }
+#endif
+    spec->number += ((unsigned long)(SecUnsignedInt)spec->ch - (SecUnsignedInt)SECUREC_CHAR('0'));
+}
+
+/*
+ * Parse Hex character to integer for 32bit .
+ */
+static void SecDecodeNumberHex(SecScanSpec *spec)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (SECUREC_LONG_HEX_BEYOND_MAX(spec->number)) {
+        spec->beyondMax = 1;
+    }
+#endif
+    spec->number = SECUREC_MUL_SIXTEEN(spec->number);
+    spec->number += (unsigned long)(unsigned int)SecHexValueOfChar(spec->ch);
+}
+
+/*
+ * Parse Octal character to integer for 32bit .
+ */
+static void SecDecodeNumberOctal(SecScanSpec *spec)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (SECUREC_LONG_OCTAL_BEYOND_MAX(spec->number)) {
+        spec->beyondMax = 1;
+    }
+#endif
+    spec->number = SECUREC_MUL_EIGHT(spec->number);
+    spec->number += ((unsigned long)(SecUnsignedInt)spec->ch - (SecUnsignedInt)SECUREC_CHAR('0'));
+}
+
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+/* Compatible with integer negative values other than int */
+SECUREC_INLINE void SecFinishNumberNegativeOther(SecScanSpec *spec)
+{
+    if (SECUREC_CONVERT_IS_SIGNED(spec->oriConvChr)) {
+        if (spec->number > SECUREC_MIN_LONG_NEG_VALUE) {
+            spec->number = SECUREC_MIN_LONG_NEG_VALUE;
+        } else {
+            spec->number = (unsigned long)(0U - spec->number); /* Wrap with unsigned long numbers */
+        }
+        if (spec->beyondMax != 0) {
+            if (spec->numberWidth < SECUREC_NUM_WIDTH_INT) {
+                spec->number = 0;
+            }
+            if (spec->numberWidth == SECUREC_NUM_WIDTH_LONG) {
+                spec->number = SECUREC_MIN_LONG_NEG_VALUE;
+            }
+        }
+    } else { /* For o, u, x, X, p */
+        spec->number = (unsigned long)(0U - spec->number); /* Wrap with unsigned long numbers */
+        if (spec->beyondMax != 0) {
+            spec->number = (unsigned long)SECUREC_MAX_64BITS_VALUE;
+        }
+    }
+}
+/* Compatible processing of integer negative numbers */
+SECUREC_INLINE void SecFinishNumberNegativeInt(SecScanSpec *spec)
+{
+    if (SECUREC_CONVERT_IS_SIGNED(spec->oriConvChr)) {
+#ifdef SECUREC_ON_64BITS
+        if (SecIsLongBitEqual(SECUREC_LP64_BIT_WIDTH) != 0) {
+            if ((spec->number > SECUREC_MIN_64BITS_NEG_VALUE)) {
+                spec->number = 0;
+            } else {
+                spec->number = (unsigned int)(0U - (unsigned int)spec->number); /* Wrap with unsigned int numbers */
+            }
+        }
+#else
+        if (SecIsLongBitEqual(SECUREC_LP32_BIT_WIDTH) != 0) {
+            if ((spec->number > SECUREC_MIN_32BITS_NEG_VALUE)) {
+                spec->number = SECUREC_MIN_32BITS_NEG_VALUE;
+            } else {
+                spec->number = (unsigned int)(0U - (unsigned int)spec->number); /* Wrap with unsigned int numbers */
+            }
+        }
+#endif
+        if (spec->beyondMax != 0) {
+#ifdef SECUREC_ON_64BITS
+            if (SecIsLongBitEqual(SECUREC_LP64_BIT_WIDTH) != 0) {
+                spec->number = 0;
+            }
+#else
+            if (SecIsLongBitEqual(SECUREC_LP32_BIT_WIDTH) != 0) {
+                spec->number = SECUREC_MIN_32BITS_NEG_VALUE;
+            }
+#endif
+        }
+    } else {            /* For o, u, x, X ,p */
+#ifdef SECUREC_ON_64BITS
+        if (spec->number > SECUREC_MAX_32BITS_VALUE_INC) {
+            spec->number = SECUREC_MAX_32BITS_VALUE;
+        } else {
+            spec->number = (unsigned int)(0U - (unsigned int)spec->number); /* Wrap with unsigned int numbers */
+        }
+#else
+        spec->number = (unsigned int)(0U - (unsigned int)spec->number); /* Wrap with unsigned int numbers */
+#endif
+        if (spec->beyondMax != 0) {
+            spec->number = (unsigned long)SECUREC_MAX_64BITS_VALUE;
+        }
+    }
+}
+
+/* Compatible with integer positive values other than int */
+SECUREC_INLINE void SecFinishNumberPositiveOther(SecScanSpec *spec)
+{
+    if (SECUREC_CONVERT_IS_SIGNED(spec->oriConvChr)) {
+        if (spec->number > SECUREC_MAX_LONG_POS_VALUE) {
+            spec->number = SECUREC_MAX_LONG_POS_VALUE;
+        }
+        if ((spec->beyondMax != 0 && spec->numberWidth < SECUREC_NUM_WIDTH_INT)) {
+            spec->number = (unsigned long)SECUREC_MAX_64BITS_VALUE;
+        }
+        if (spec->beyondMax != 0 && spec->numberWidth == SECUREC_NUM_WIDTH_LONG) {
+            spec->number = SECUREC_MAX_LONG_POS_VALUE;
+        }
+    } else {
+        if (spec->beyondMax != 0) {
+            spec->number = (unsigned long)SECUREC_MAX_64BITS_VALUE;
+        }
+    }
+}
+
+/* Compatible processing of integer positive numbers */
+SECUREC_INLINE void SecFinishNumberPositiveInt(SecScanSpec *spec)
+{
+    if (SECUREC_CONVERT_IS_SIGNED(spec->oriConvChr)) {
+#ifdef SECUREC_ON_64BITS
+        if (SecIsLongBitEqual(SECUREC_LP64_BIT_WIDTH) != 0) {
+            if (spec->number > SECUREC_MAX_64BITS_POS_VALUE) {
+                spec->number = (unsigned long)SECUREC_MAX_64BITS_VALUE;
+            }
+        }
+        if (spec->beyondMax != 0 && SecIsLongBitEqual(SECUREC_LP64_BIT_WIDTH) != 0) {
+            spec->number = (unsigned long)SECUREC_MAX_64BITS_VALUE;
+        }
+#else
+        if (SecIsLongBitEqual(SECUREC_LP32_BIT_WIDTH) != 0) {
+            if (spec->number > SECUREC_MAX_32BITS_POS_VALUE) {
+                spec->number = SECUREC_MAX_32BITS_POS_VALUE;
+            }
+        }
+        if (spec->beyondMax != 0 && SecIsLongBitEqual(SECUREC_LP32_BIT_WIDTH) != 0) {
+            spec->number = SECUREC_MAX_32BITS_POS_VALUE;
+        }
+#endif
+    } else {            /* For o,u,x,X,p */
+        if (spec->beyondMax != 0) {
+            spec->number = SECUREC_MAX_32BITS_VALUE;
+        }
+    }
+}
+
+#endif
+
+/*
+ * Parse decimal character to integer for 64bit .
+ */
+static void SecDecodeNumber64Decimal(SecScanSpec *spec)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (spec->number64 > SECUREC_MAX_64BITS_VALUE_DIV_TEN) {
+        spec->beyondMax = 1;
+    }
+#endif
+    spec->number64 = SECUREC_MUL_TEN(spec->number64);
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (spec->number64 == SECUREC_MAX_64BITS_VALUE_CUT_LAST_DIGIT) {
+        SecUnsignedInt64 number64As = (SecUnsignedInt64)SECUREC_MAX_64BITS_VALUE - spec->number64;
+        if (number64As < (SecUnsignedInt64)(SecUnsignedInt)spec->ch - (SecUnsignedInt)SECUREC_CHAR('0')) {
+            spec->beyondMax = 1;
+        }
+    }
+#endif
+    spec->number64 += ((SecUnsignedInt64)(SecUnsignedInt)spec->ch - (SecUnsignedInt)SECUREC_CHAR('0'));
+}
+
+/*
+ * Parse Hex character to integer for 64bit .
+ */
+static void SecDecodeNumber64Hex(SecScanSpec *spec)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (SECUREC_QWORD_HEX_BEYOND_MAX(spec->number64)) {
+        spec->beyondMax = 1;
+    }
+#endif
+    spec->number64 = SECUREC_MUL_SIXTEEN(spec->number64);
+    spec->number64 += (SecUnsignedInt64)(unsigned int)SecHexValueOfChar(spec->ch);
+}
+
+/*
+ * Parse Octal character to integer for 64bit .
+ */
+static void SecDecodeNumber64Octal(SecScanSpec *spec)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (SECUREC_QWORD_OCTAL_BEYOND_MAX(spec->number64)) {
+        spec->beyondMax = 1;
+    }
+#endif
+    spec->number64 = SECUREC_MUL_EIGHT(spec->number64);
+    spec->number64 += ((SecUnsignedInt64)(SecUnsignedInt)spec->ch - (SecUnsignedInt)SECUREC_CHAR('0'));
+}
+
+#define SECUREC_DECODE_NUMBER_FUNC_NUM 2
+
+/*
+ * Parse 64-bit integer formatted input, return 0 when ch is a number.
+ */
+SECUREC_INLINE int SecDecodeNumber(SecScanSpec *spec)
+{
+    /* Function name cannot add address symbol, causing 546 alarm */
+    static void (* const secDecodeNumberHex[SECUREC_DECODE_NUMBER_FUNC_NUM])(SecScanSpec *spec) = {
+        SecDecodeNumberHex, SecDecodeNumber64Hex
+    };
+    static void (* const secDecodeNumberOctal[SECUREC_DECODE_NUMBER_FUNC_NUM])(SecScanSpec *spec) = {
+        SecDecodeNumberOctal, SecDecodeNumber64Octal
+    };
+    static void (* const secDecodeNumberDecimal[SECUREC_DECODE_NUMBER_FUNC_NUM])(SecScanSpec *spec) = {
+        SecDecodeNumberDecimal, SecDecodeNumber64Decimal
+    };
+    if (spec->convChr == 'x' || spec->convChr == 'p') {
+        if (SecIsXdigit(spec->ch) != 0) {
+            (*secDecodeNumberHex[spec->numberArgType])(spec);
+        } else {
+            return -1;
+        }
+        return 0;
+    }
+    if (SecIsDigit(spec->ch) == 0) {
+        return -1;
+    }
+    if (spec->convChr == 'o') {
+        if (spec->ch < SECUREC_CHAR('8')) { /* Octal maximum limit '8' */
+            (*secDecodeNumberOctal[spec->numberArgType])(spec);
+        } else {
+            return -1;
+        }
+    } else { /* The convChr is 'd' */
+        (*secDecodeNumberDecimal[spec->numberArgType])(spec);
+    }
+    return 0;
+}
+
+/*
+ * Complete the final 32-bit integer formatted input
+ */
+static void SecFinishNumber(SecScanSpec *spec)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (spec->negative != 0) {
+        if (spec->numberWidth == SECUREC_NUM_WIDTH_INT) {
+            SecFinishNumberNegativeInt(spec);
+        } else {
+            SecFinishNumberNegativeOther(spec);
+        }
+    } else {
+        if (spec->numberWidth == SECUREC_NUM_WIDTH_INT) {
+            SecFinishNumberPositiveInt(spec);
+        } else {
+            SecFinishNumberPositiveOther(spec);
+        }
+    }
+#else
+    if (spec->negative != 0) {
+#if defined(__hpux)
+        if (spec->oriConvChr != 'p') {
+            spec->number = (unsigned long)(0U - spec->number); /* Wrap with unsigned long numbers */
+        }
+#else
+        spec->number = (unsigned long)(0U - spec->number); /* Wrap with unsigned long numbers */
+#endif
+    }
+#endif
+    return;
+}
+
+/*
+ * Complete the final 64-bit integer formatted input
+ */
+static void SecFinishNumber64(SecScanSpec *spec)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && !(defined(SECUREC_ON_UNIX)))
+    if (spec->negative != 0) {
+        if (SECUREC_CONVERT_IS_SIGNED(spec->oriConvChr)) {
+            if (spec->number64 > SECUREC_MIN_64BITS_NEG_VALUE) {
+                spec->number64 = SECUREC_MIN_64BITS_NEG_VALUE;
+            } else {
+                spec->number64 = (SecUnsignedInt64)(0U - spec->number64); /* Wrap with unsigned int64 numbers */
+            }
+            if (spec->beyondMax != 0) {
+                spec->number64 = SECUREC_MIN_64BITS_NEG_VALUE;
+            }
+        } else {                /* For o, u, x, X, p */
+            spec->number64 = (SecUnsignedInt64)(0U - spec->number64); /* Wrap with unsigned int64 numbers */
+            if (spec->beyondMax != 0) {
+                spec->number64 = SECUREC_MAX_64BITS_VALUE;
+            }
+        }
+    } else {
+        if (SECUREC_CONVERT_IS_SIGNED(spec->oriConvChr)) {
+            if (spec->number64 > SECUREC_MAX_64BITS_POS_VALUE) {
+                spec->number64 = SECUREC_MAX_64BITS_POS_VALUE;
+            }
+            if (spec->beyondMax != 0) {
+                spec->number64 = SECUREC_MAX_64BITS_POS_VALUE;
+            }
+        } else {
+            if (spec->beyondMax != 0) {
+                spec->number64 = SECUREC_MAX_64BITS_VALUE;
+            }
+        }
+    }
+#else
+    if (spec->negative != 0) {
+#if defined(__hpux)
+        if (spec->oriConvChr != 'p') {
+            spec->number64 = (SecUnsignedInt64)(0U - spec->number64); /* Wrap with unsigned int64 numbers */
+        }
+#else
+        spec->number64 = (SecUnsignedInt64)(0U - spec->number64); /* Wrap with unsigned int64 numbers */
+#endif
+    }
+#endif
+    return;
+}
+
+#if SECUREC_ENABLE_SCANF_FILE
+
+/*
+ *  Adjust the pointer position of the file stream
+ */
+SECUREC_INLINE void SecSeekStream(SecFileStream *stream)
+{
+    if (stream->count == 0) {
+        if (feof(stream->pf) != 0) {
+            /* File pointer at the end of file, don't need to seek back */
+            stream->base[0] = '\0';
+            return;
+        }
+    }
+    /* Seek to original position, for file read, but nothing to input */
+    if (fseek(stream->pf, stream->oriFilePos, SEEK_SET) != 0) {
+        /* Seek failed, ignore it */
+        stream->oriFilePos = 0;
+        return;
+    }
+
+    if (stream->fileRealRead > 0) { /* Do not seek without input data */
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+        size_t residue = stream->fileRealRead % SECUREC_BUFFERED_BLOK_SIZE;
+        size_t loops;
+        for (loops = 0; loops < (stream->fileRealRead / SECUREC_BUFFERED_BLOK_SIZE); ++loops) {
+            if (fread(stream->base, (size_t)SECUREC_BUFFERED_BLOK_SIZE, (size_t)1, stream->pf) != (size_t)1) {
+                break;
+            }
+        }
+        if (residue != 0) {
+            long curFilePos;
+            if (fread(stream->base, residue, (size_t)1, stream->pf) != (size_t)1) {
+                return;
+            }
+            curFilePos = ftell(stream->pf);
+            if (curFilePos < stream->oriFilePos ||
+                (size_t)(unsigned long)(curFilePos - stream->oriFilePos) < stream->fileRealRead) {
+                /* Try to remedy the problem */
+                long adjustNum = (long)(stream->fileRealRead - (size_t)(unsigned long)(curFilePos - stream->oriFilePos));
+                (void)fseek(stream->pf, adjustNum, SEEK_CUR);
+            }
+        }
+#else
+        /* Seek from oriFilePos. Regardless of the integer sign problem, call scanf will not read very large data */
+        if (fseek(stream->pf, (long)stream->fileRealRead, SEEK_CUR) != 0) {
+            /* Seek failed, ignore it */
+            stream->oriFilePos = 0;
+            return;
+        }
+#endif
+    }
+    return;
+}
+
+/*
+ *  Adjust the pointer position of the file stream and free memory
+ */
+SECUREC_INLINE void SecAdjustStream(SecFileStream *stream)
+{
+    if ((stream->flag & SECUREC_FILE_STREAM_FLAG) != 0 && stream->base != NULL) {
+        SecSeekStream(stream);
+        SECUREC_FREE(stream->base);
+        stream->base = NULL;
+    }
+    return;
+}
+#endif
+
+SECUREC_INLINE void SecSkipSpaceFormat(const SecUnsignedChar **format)
+{
+    const SecUnsignedChar *fmt = *format;
+    while (SecIsSpace((SecInt)(int)(*fmt)) != 0) {
+        ++fmt;
+    }
+    *format = fmt;
+}
+
+#if !defined(SECUREC_FOR_WCHAR) && defined(SECUREC_COMPATIBLE_VERSION)
+/*
+ * Handling multi-character characters
+ */
+SECUREC_INLINE int SecDecodeLeadByte(SecScanSpec *spec, const SecUnsignedChar **format, SecFileStream *stream)
+{
+#if SECUREC_HAVE_MBTOWC
+    const SecUnsignedChar *fmt = *format;
+    int ch1 = (int)spec->ch;
+    int ch2 = SecGetChar(stream, &(spec->charCount));
+    spec->ch = (SecInt)ch2;
+    if (*fmt == SECUREC_CHAR('\0') || (int)(*fmt) != ch2) {
+        /* in console mode, ungetc twice may cause problem */
+        SecUnGetChar(ch2, stream, &(spec->charCount));
+        SecUnGetChar(ch1, stream, &(spec->charCount));
+        return -1;
+    }
+    ++fmt;
+    if ((unsigned int)MB_CUR_MAX >= SECUREC_UTF8_BOM_HEADER_SIZE &&
+        (((unsigned char)ch1 & SECUREC_UTF8_LEAD_1ST) == SECUREC_UTF8_LEAD_1ST) &&
+        (((unsigned char)ch2 & SECUREC_UTF8_LEAD_2ND) == SECUREC_UTF8_LEAD_2ND)) {
+        /* This char is very likely to be a UTF-8 char */
+        wchar_t tempWChar;
+        char temp[SECUREC_MULTI_BYTE_MAX_LEN];
+        int ch3 = (int)SecGetChar(stream, &(spec->charCount));
+        spec->ch = (SecInt)ch3;
+        if (*fmt == SECUREC_CHAR('\0') || (int)(*fmt) != ch3) {
+            SecUnGetChar(ch3, stream, &(spec->charCount));
+            return -1;
+        }
+        temp[0] = (char)ch1;
+        temp[1] = (char)ch2; /* 1 index of second character */
+        temp[2] = (char)ch3; /* 2 index of third character */
+        temp[3] = '\0';      /* 3 of string terminator position */
+        if (mbtowc(&tempWChar, temp, sizeof(temp)) > 0) {
+            /* Succeed */
+            ++fmt;
+            --spec->charCount;
+        } else {
+            SecUnGetChar(ch3, stream, &(spec->charCount));
+        }
+    }
+    --spec->charCount;    /* Only count as one character read */
+    *format = fmt;
+    return 0;
+#else
+    SecUnGetChar(spec->ch, stream, &(spec->charCount));
+    (void)format; /* To clear e438 last value assigned not used , the compiler will optimize this code */
+    return -1;
+#endif
+}
+
+SECUREC_INLINE int SecFilterWcharInFormat(SecScanSpec *spec, const SecUnsignedChar **format, SecFileStream *stream)
+{
+    if (SecIsLeadByte(spec->ch) != 0) {
+        if (SecDecodeLeadByte(spec, format, stream) != 0) {
+            return -1;
+        }
+    }
+    return 0;
+}
+#endif
+
+/*
+ *  Resolving sequence of characters from %[ format, format wile point to ']'
+ */
+SECUREC_INLINE int SecSetupBracketTable(const SecUnsignedChar **format, SecBracketTable *bracketTable)
+{
+    const SecUnsignedChar *fmt = *format;
+    SecUnsignedChar prevChar = 0;
+#if !(defined(SECUREC_COMPATIBLE_WIN_FORMAT))
+    if (*fmt == SECUREC_CHAR('{')) {
+        return -1;
+    }
+#endif
+    /* For building "table" data */
+    ++fmt; /* Skip [ */
+    bracketTable->mask = 0; /* Set all bits to 0 */
+    if (*fmt == SECUREC_CHAR('^')) {
+        ++fmt;
+        bracketTable->mask = (unsigned char)0xffU; /* Use 0xffU to set all bits to 1 */
+    }
+    if (*fmt == SECUREC_CHAR(']')) {
+        prevChar = SECUREC_CHAR(']');
+        ++fmt;
+        SecBracketSetBit(bracketTable->table, SECUREC_CHAR(']'));
+    }
+    while (*fmt != SECUREC_CHAR('\0') && *fmt != SECUREC_CHAR(']')) {
+        SecUnsignedChar expCh = *fmt;
+        ++fmt;
+        if (expCh != SECUREC_CHAR('-') || prevChar == 0 || *fmt == SECUREC_CHAR(']')) {
+            /* Normal character */
+            prevChar = expCh;
+            SecBracketSetBit(bracketTable->table, expCh);
+        } else {
+            /* For %[a-z] */
+            expCh = *fmt;   /* Get end of range */
+            ++fmt;
+            if (prevChar <= expCh) {  /* %[a-z] %[a-a] */
+                SecBracketSetBitRange(bracketTable->table, prevChar, expCh);
+            } else {
+                /* For %[z-a] */
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+                /* Swap start and end characters */
+                SecBracketSetBitRange(bracketTable->table, expCh, prevChar);
+#else
+                SecBracketSetBit(bracketTable->table, SECUREC_CHAR('-'));
+                SecBracketSetBit(bracketTable->table, expCh);
+#endif
+            }
+            prevChar = 0;
+        }
+    }
+    *format = fmt;
+    return 0;
+}
+
+#ifdef SECUREC_FOR_WCHAR
+SECUREC_INLINE int SecInputForWchar(SecScanSpec *spec)
+{
+    void *endPtr = spec->argPtr;
+    if (spec->isWCharOrLong > 0) {
+        *(wchar_t UNALIGNED *)endPtr = (wchar_t)spec->ch;
+        endPtr = (wchar_t *)endPtr + 1;
+        --spec->arrayWidth;
+    } else {
+#if SECUREC_HAVE_WCTOMB
+        int temp;
+        char tmpBuf[SECUREC_MB_LEN + 1];
+        SECUREC_MASK_MSVC_CRT_WARNING temp = wctomb(tmpBuf, (wchar_t)spec->ch);
+        SECUREC_END_MASK_MSVC_CRT_WARNING
+        if (temp <= 0 || (size_t)(unsigned int)temp > sizeof(tmpBuf)) {
+            /* If wctomb  error, then ignore character */
+            return 0;
+        }
+        if (((size_t)(unsigned int)temp) > spec->arrayWidth) {
+            return -1;
+        }
+        if (memcpy_s(endPtr, spec->arrayWidth, tmpBuf, (size_t)(unsigned int)temp) != EOK) {
+            return -1;
+        }
+        endPtr = (char *)endPtr + temp;
+        spec->arrayWidth -= (size_t)(unsigned int)temp;
+#else
+        return -1;
+#endif
+    }
+    spec->argPtr = endPtr;
+    return 0;
+}
+#endif
+
+#ifndef SECUREC_FOR_WCHAR
+#if SECUREC_HAVE_WCHART
+SECUREC_INLINE wchar_t SecConvertInputCharToWchar(SecScanSpec *spec, SecFileStream *stream)
+{
+    wchar_t tempWChar = L'?';   /* Set default char is ? */
+#if SECUREC_HAVE_MBTOWC
+    char temp[SECUREC_MULTI_BYTE_MAX_LEN + 1];
+    temp[0] = (char)spec->ch;
+    temp[1] = '\0';
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+    if (SecIsLeadByte(spec->ch) != 0) {
+        spec->ch = SecGetChar(stream, &(spec->charCount));
+        temp[1] = (char)spec->ch;
+        temp[2] = '\0'; /* 2 of string terminator position */
+    }
+    if (mbtowc(&tempWChar, temp, sizeof(temp)) <= 0) {
+        /* No string termination error for tool */
+        tempWChar = L'?';
+    }
+#else
+    if (SecIsLeadByte(spec->ch) != 0) {
+        int convRes = 0;
+        int di = 1;
+        /* On Linux like system, the string is encoded in UTF-8 */
+        while (convRes <= 0 && di < (int)MB_CUR_MAX && di < SECUREC_MULTI_BYTE_MAX_LEN) {
+            spec->ch = SecGetChar(stream, &(spec->charCount));
+            temp[di] = (char)spec->ch;
+            ++di;
+            temp[di] = '\0';
+            convRes = mbtowc(&tempWChar, temp, sizeof(temp));
+        }
+        if (convRes <= 0) {
+            tempWChar = L'?';
+        }
+    } else {
+        if (mbtowc(&tempWChar, temp, sizeof(temp)) <= 0) {
+            tempWChar = L'?';
+        }
+    }
+#endif
+#else
+    (void)spec;      /* To clear e438 last value assigned not used , the compiler will optimize this code */
+    (void)stream;    /* To clear e438 last value assigned not used , the compiler will optimize this code */
+#endif /* SECUREC_HAVE_MBTOWC */
+
+    return tempWChar;
+}
+#endif /* SECUREC_HAVE_WCHART */
+
+SECUREC_INLINE int SecInputForChar(SecScanSpec *spec, SecFileStream *stream)
+{
+    void *endPtr = spec->argPtr;
+    if (spec->isWCharOrLong > 0) {
+#if SECUREC_HAVE_WCHART
+        *(wchar_t UNALIGNED *)endPtr = SecConvertInputCharToWchar(spec, stream);
+        endPtr = (wchar_t *)endPtr + 1;
+        --spec->arrayWidth;
+#else
+    (void)stream;    /* To clear e438 last value assigned not used , the compiler will optimize this code */
+    return -1;
+#endif
+    } else {
+        *(char *)endPtr = (char)spec->ch;
+        endPtr = (char *)endPtr + 1;
+        --spec->arrayWidth;
+    }
+    spec->argPtr = endPtr;
+    return 0;
+}
+#endif
+
+/*
+ * Scan digital part of %d %i %o %u %x %p.
+ * Return 0 OK
+ */
+SECUREC_INLINE int SecInputNumberDigital(SecFileStream *stream, SecScanSpec *spec)
+{
+    static void (* const secFinishNumber[SECUREC_DECODE_NUMBER_FUNC_NUM])(SecScanSpec *spec) = {
+        SecFinishNumber, SecFinishNumber64
+    };
+    while (SECUREC_FILED_WIDTH_ENOUGH(spec)) {
+        spec->ch = SecGetChar(stream, &(spec->charCount));
+        /* Decode ch to number */
+        if (SecDecodeNumber(spec) != 0) {
+            SecUnGetChar(spec->ch, stream, &(spec->charCount));
+            break;
+        }
+        SECUREC_FILED_WIDTH_DEC(spec); /* Must be behind un get char, otherwise the logic is incorrect */
+        spec->numberState = SECUREC_NUMBER_STATE_STARTED;
+    }
+    /* Handling integer negative numbers and beyond max */
+    (*secFinishNumber[spec->numberArgType])(spec);
+    if (spec->numberState == SECUREC_NUMBER_STATE_STARTED) {
+        return 0;
+    }
+    return -1;
+}
+
+/*
+ * Scan %d %i %o %u %x %p.
+ * Return 0 OK
+ */
+SECUREC_INLINE int SecInputNumber(SecFileStream *stream, SecScanSpec *spec)
+{
+    /* Character already read */
+    if (spec->ch == SECUREC_CHAR('+') || spec->ch == SECUREC_CHAR('-')) {
+        if (spec->ch == SECUREC_CHAR('-')) {
+            spec->negative = 1;
+#if SECUREC_IN_KERNEL
+            /* In kernel Refuse to enter negative number */
+            if (SECUREC_CONVERT_IS_UNSIGNED(spec->oriConvChr)) {
+                return -1;
+            }
+#endif
+        }
+        SECUREC_FILED_WIDTH_DEC(spec); /* Do not need to check width here, must be greater than 0 */
+        spec->ch = SecGetChar(stream, &(spec->charCount)); /* Eat + or - */
+        spec->ch = SecGetChar(stream, &(spec->charCount)); /* Get next character, used for the '0' judgments */
+        SecUnGetChar(spec->ch, stream, &(spec->charCount)); /* Not sure if it was actually read, so push back */
+    }
+
+    if (spec->oriConvChr == 'i') {
+        spec->convChr = 'd'; /* The i could be d, o, or x, use d as default */
+    }
+
+    if (spec->ch == SECUREC_CHAR('0') && (spec->oriConvChr == 'x' || spec->oriConvChr == 'i') &&
+        SECUREC_FILED_WIDTH_ENOUGH(spec)) {
+        /* Input string begin with 0, may be 0x123  0X123  0123  0x  01  0yy  09  0  0ab 00 */
+        SECUREC_FILED_WIDTH_DEC(spec);
+        spec->ch = SecGetChar(stream, &(spec->charCount)); /* ch is '0' */
+
+        /* Read only '0' due to width limitation */
+        if (!SECUREC_FILED_WIDTH_ENOUGH(spec)) {
+            /* The number or number64 in spec has been set 0 */
+            return 0;
+        }
+
+        spec->ch = SecGetChar(stream, &(spec->charCount)); /* Get next char to check x or X, do not dec width */
+        if ((SecChar)spec->ch == SECUREC_CHAR('x') || (SecChar)spec->ch == SECUREC_CHAR('X')) {
+            spec->convChr = 'x';
+            SECUREC_FILED_WIDTH_DEC(spec); /* Make incorrect width for x or X */
+        } else {
+            if (spec->oriConvChr == 'i') {
+                spec->convChr = 'o';
+            }
+            /* For "0y" "08" "01" "0a" ... ,push the 'y' '8' '1' 'a'  back */
+            SecUnGetChar(spec->ch, stream, &(spec->charCount));
+            /* Since 0 has been read, it indicates that a valid character has been read */
+            spec->numberState = SECUREC_NUMBER_STATE_STARTED;
+        }
+    }
+    return SecInputNumberDigital(stream, spec);
+}
+
+/*
+ * Scan %c %s %[
+ * Return 0 OK
+ */
+SECUREC_INLINE int SecInputString(SecFileStream *stream, SecScanSpec *spec,
+    const SecBracketTable *bracketTable, int *doneCount)
+{
+    void *startPtr = spec->argPtr;
+    int suppressed = 0;
+    int errNoMem = 0;
+
+    while (SECUREC_FILED_WIDTH_ENOUGH(spec)) {
+        SECUREC_FILED_WIDTH_DEC(spec);
+        spec->ch = SecGetChar(stream, &(spec->charCount));
+        /*
+         * The char condition or string condition and bracket condition.
+         * Only supports wide characters with a maximum length of two bytes
+         */
+        if (spec->ch != SECUREC_EOF && (SecCanInputCharacter(spec->convChr) != 0 ||
+            SecCanInputString(spec->convChr, spec->ch) != 0 ||
+            SecCanInputForBracket(spec->convChr, spec->ch, bracketTable) != 0)) {
+            if (spec->suppress != 0) {
+                /* Used to identify processed data for %*, use argPtr to identify will cause 613, so use suppressed */
+                suppressed = 1;
+                continue;
+            }
+            /* Now suppress is not set */
+            if (spec->arrayWidth == 0) {
+                errNoMem = 1; /* We have exhausted the user's buffer */
+                break;
+            }
+#ifdef SECUREC_FOR_WCHAR
+            errNoMem = SecInputForWchar(spec);
+#else
+            errNoMem = SecInputForChar(spec, stream);
+#endif
+            if (errNoMem != 0) {
+                break;
+            }
+        } else {
+            SecUnGetChar(spec->ch, stream, &(spec->charCount));
+            break;
+        }
+    }
+
+    if (errNoMem != 0) {
+        /* In case of error, blank out the input buffer */
+        SecAddEndingZero(startPtr, spec);
+        return -1;
+    }
+    if ((spec->suppress != 0 && suppressed == 0) ||
+        (spec->suppress == 0 && startPtr == spec->argPtr)) {
+        /* No input was scanned */
+        return -1;
+    }
+    if (spec->convChr != 'c') {
+        /* Add null-terminate for strings */
+        SecAddEndingZero(spec->argPtr, spec);
+    }
+    if (spec->suppress == 0) {
+        *doneCount = *doneCount + 1;
+    }
+    return 0;
+}
+
+#ifdef SECUREC_FOR_WCHAR
+/*
+ * Alloce buffer for wchar version of %[.
+ * Return 0 OK
+ */
+SECUREC_INLINE int SecAllocBracketTable(SecBracketTable *bracketTable)
+{
+    if (bracketTable->table == NULL) {
+        /* Table should be freed after use */
+        bracketTable->table = (unsigned char *)SECUREC_MALLOC(SECUREC_BRACKET_TABLE_SIZE);
+        if (bracketTable->table == NULL) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+/*
+ * Free buffer for wchar version of %[
+ */
+SECUREC_INLINE void SecFreeBracketTable(SecBracketTable *bracketTable)
+{
+    if (bracketTable->table != NULL) {
+        SECUREC_FREE(bracketTable->table);
+        bracketTable->table = NULL;
+    }
+}
+#endif
+
+#ifdef SECUREC_FOR_WCHAR
+/*
+ *  Formatting input core functions for wchar version.Called by a function such as vswscanf_s
+ */
+int SecInputSW(SecFileStream *stream, const wchar_t *cFormat, va_list argList)
+#else
+/*
+ * Formatting input core functions for char version.Called by a function such as vsscanf_s
+ */
+int SecInputS(SecFileStream *stream, const char *cFormat, va_list argList)
+#endif
+{
+    const SecUnsignedChar *format = (const SecUnsignedChar *)cFormat;
+    SecBracketTable bracketTable = SECUREC_INIT_BRACKET_TABLE;
+    SecScanSpec spec;
+    int doneCount = 0;
+    int formatError = 0;
+    int paraIsNull = 0;
+    int match = 0; /* When % is found , inc this value */
+    int errRet = 0;
+#if SECUREC_ENABLE_SCANF_FLOAT
+    SecFloatSpec floatSpec;
+    SecInitFloatSpec(&floatSpec);
+#endif
+    spec.ch = 0; /* Need to initialize to 0 */
+    spec.charCount = 0; /* Need to initialize to 0 */
+
+    /* Format must not NULL, use err < 1 to claer 845 */
+    while (errRet < 1 && *format != SECUREC_CHAR('\0')) {
+        /* Skip space in format and space in input */
+        if (SecIsSpace((SecInt)(int)(*format)) != 0) {
+            /* Read first no space char */
+            spec.ch = SecSkipSpaceChar(stream, &(spec.charCount));
+            /* Read the EOF cannot be returned directly here, because the case of " %n" needs to be handled */
+            /* Put fist no space char backup. put EOF back is also OK, and to modify the character count */
+            SecUnGetChar(spec.ch, stream, &(spec.charCount));
+            SecSkipSpaceFormat(&format);
+            continue;
+        }
+
+        if (*format != SECUREC_CHAR('%')) {
+            spec.ch = SecGetChar(stream, &(spec.charCount));
+            if ((int)(*format) != (int)(spec.ch)) {
+                SecUnGetChar(spec.ch, stream, &(spec.charCount));
+                break;
+            }
+            ++format;
+#if !defined(SECUREC_FOR_WCHAR) && defined(SECUREC_COMPATIBLE_VERSION)
+            if (SecFilterWcharInFormat(&spec, &format, stream) != 0) {
+                break;
+            }
+#endif
+            continue;
+        }
+
+        /* Now *format is % */
+        /* Set default value for each % */
+        SecSetDefaultScanSpec(&spec);
+        if (SecDecodeScanFlag(&format, &spec) != 0) {
+            formatError = 1;
+            ++errRet;
+            continue;
+        }
+        if (!SECUREC_FILED_WIDTH_ENOUGH(&spec)) {
+            /* 0 width in format */
+            ++errRet;
+            continue;
+        }
+
+        /* Update wchar flag for %S %C */
+        SecUpdateWcharFlagByType(*format, &spec);
+
+        spec.convChr = SECUREC_TO_LOWERCASE(*format);
+        spec.oriConvChr = spec.convChr; /* convChr may be modified to handle integer logic */
+        if (spec.convChr != 'n') {
+            if (spec.convChr != 'c' && spec.convChr != SECUREC_BRACE) {
+                spec.ch = SecSkipSpaceChar(stream, &(spec.charCount));
+            } else {
+                spec.ch = SecGetChar(stream, &(spec.charCount));
+            }
+            if (spec.ch == SECUREC_EOF) {
+                ++errRet;
+                continue;
+            }
+        }
+
+        /* Now no 0 width in format and get one char from input */
+        switch (spec.oriConvChr) {
+            case 'c': /* Also 'C' */
+                if (spec.widthSet == 0) {
+                    spec.widthSet = 1;
+                    spec.width = 1;
+                }
+                /* fall-through */ /* FALLTHRU */
+            case 's': /* Also 'S': */
+                /* fall-through */ /* FALLTHRU */
+            case SECUREC_BRACE:
+                /* Unset last char to stream */
+                SecUnGetChar(spec.ch, stream, &(spec.charCount));
+                /* Check dest buffer and size */
+                if (spec.suppress == 0) {
+                    spec.argPtr = (void *)va_arg(argList, void *);
+                    if (spec.argPtr == NULL) {
+                        paraIsNull = 1;
+                        ++errRet;
+                        continue;
+                    }
+                    /* Get the next argument, size of the array in characters */
+                    spec.arrayWidth = SECUREC_GET_ARRAYWIDTH(argList);
+                    if (SECUREC_ARRAY_WIDTH_IS_WRONG(spec)) {
+                        /* Do not clear buffer just go error */
+                        ++errRet;
+                        continue;
+                    }
+                    /* One element is needed for '\0' for %s and %[ */
+                    if (spec.convChr != 'c') {
+                        --spec.arrayWidth;
+                    }
+                } else {
+                    /* Set argPtr to  NULL  is necessary, in supress mode we don't use argPtr to store data */
+                    spec.argPtr = NULL;
+                }
+
+                if (spec.convChr == SECUREC_BRACE) {
+                    /* Malloc when first %[ is meet  for wchar version */
+#ifdef SECUREC_FOR_WCHAR
+                    if (SecAllocBracketTable(&bracketTable) != 0) {
+                        ++errRet;
+                        continue;
+                    }
+#endif
+                    (void)SECUREC_MEMSET_FUNC_OPT(bracketTable.table, 0, (size_t)SECUREC_BRACKET_TABLE_SIZE);
+                    if (SecSetupBracketTable(&format, &bracketTable) != 0) {
+                        ++errRet;
+                        continue;
+                    }
+
+                    if (*format == SECUREC_CHAR('\0')) {
+                        /* Default add string terminator */
+                        SecAddEndingZero(spec.argPtr, &spec);
+                        ++errRet;
+                        /* Truncated format */
+                        continue;
+                    }
+                }
+
+                /* Set completed.  Now read string or character */
+                if (SecInputString(stream, &spec, &bracketTable, &doneCount) != 0) {
+                    ++errRet;
+                    continue;
+                }
+                break;
+            case 'p':
+                /* Make %hp same as %p */
+                spec.numberWidth = SECUREC_NUM_WIDTH_INT;
+#ifdef SECUREC_ON_64BITS
+                spec.numberArgType = 1;
+#endif
+                /* fall-through */ /* FALLTHRU */
+            case 'o': /* fall-through */ /* FALLTHRU */
+            case 'u': /* fall-through */ /* FALLTHRU */
+            case 'd': /* fall-through */ /* FALLTHRU */
+            case 'i': /* fall-through */ /* FALLTHRU */
+            case 'x':
+                /* Unset last char to stream */
+                SecUnGetChar(spec.ch, stream, &(spec.charCount));
+                if (SecInputNumber(stream, &spec) != 0) {
+                    ++errRet;
+                    continue;
+                }
+                if (spec.suppress == 0) {
+                    spec.argPtr = (void *)va_arg(argList, void *);
+                    if (spec.argPtr == NULL) {
+                        paraIsNull = 1;
+                        ++errRet;
+                        continue;
+                    }
+                    SecAssignNumber(&spec);
+                    ++doneCount;
+                }
+                break;
+            case 'n': /* Char count */
+                if (spec.suppress == 0) {
+                    spec.argPtr = (void *)va_arg(argList, void *);
+                    if (spec.argPtr == NULL) {
+                        paraIsNull = 1;
+                        ++errRet;
+                        continue;
+                    }
+                    spec.number = (unsigned long)(unsigned int)(spec.charCount);
+                    spec.numberArgType = 0;
+                    SecAssignNumber(&spec);
+                }
+                break;
+            case 'e': /* fall-through */ /* FALLTHRU */
+            case 'f': /* fall-through */ /* FALLTHRU */
+            case 'g': /* Scan a float */
+                /* Unset last char to stream */
+                SecUnGetChar(spec.ch, stream, &(spec.charCount));
+#if SECUREC_ENABLE_SCANF_FLOAT
+                if (SecInputFloat(stream, &spec, &floatSpec) != 0) {
+                    ++errRet;
+                    continue;
+                }
+                if (spec.suppress == 0) {
+                    spec.argPtr = (void *)va_arg(argList, void *);
+                    if (spec.argPtr == NULL) {
+                        ++errRet;
+                        paraIsNull = 1;
+                        continue;
+                    }
+                    if (SecAssignFloat(&floatSpec, &spec) != 0) {
+                        ++errRet;
+                        continue;
+                    }
+                    ++doneCount;
+                }
+                break;
+#else /* SECUREC_ENABLE_SCANF_FLOAT */
+                ++errRet;
+                continue;
+#endif
+            default:
+                if ((int)(*format) != (int)spec.ch) {
+                    SecUnGetChar(spec.ch, stream, &(spec.charCount));
+                    formatError = 1;
+                    ++errRet;
+                    continue;
+                } else {
+                    --match; /* Compensate for the self-increment of the following code */
+                }
+                break;
+        }
+        ++match;
+        ++format;
+    }
+
+#ifdef SECUREC_FOR_WCHAR
+    SecFreeBracketTable(&bracketTable);
+#endif
+
+#if SECUREC_ENABLE_SCANF_FLOAT
+    SecFreeFloatSpec(&floatSpec, &doneCount);
+#endif
+
+#if SECUREC_ENABLE_SCANF_FILE
+    SecAdjustStream(stream);
+#endif
+
+    if (spec.ch == SECUREC_EOF) {
+        return ((doneCount != 0 || match != 0) ? doneCount : SECUREC_SCANF_EINVAL);
+    }
+    if (formatError != 0 || paraIsNull != 0) {
+        /* Invalid Input Format or parameter, but not meet EOF */
+        return SECUREC_SCANF_ERROR_PARA;
+    }
+    return doneCount;
+}
+
+#if SECUREC_ENABLE_SCANF_FILE
+/*
+ *  Get char from stream use std function
+ */
+SECUREC_INLINE SecInt SecGetCharFromStream(const SecFileStream *stream)
+{
+    SecInt ch;
+    ch = SECUREC_GETC(stream->pf);
+    return ch;
+}
+
+/*
+ * Try to read the BOM header, when meet a BOM head, discard it, then data is Aligned to base
+ */
+SECUREC_INLINE void SecReadAndSkipBomHeader(SecFileStream *stream)
+{
+    /* Use size_t type conversion  to clean e747 */
+    stream->count = fread(stream->base, (size_t)1, (size_t)SECUREC_BOM_HEADER_SIZE, stream->pf);
+    if (stream->count > SECUREC_BOM_HEADER_SIZE) {
+        stream->count = 0;
+    }
+    if (SECUREC_BEGIN_WITH_BOM(stream->base, stream->count)) {
+        /* It's BOM header, discard it */
+        stream->count = 0;
+    }
+}
+
+/*
+ *  Get char  from file stream or buffer
+ */
+SECUREC_INLINE SecInt SecGetCharFromFile(SecFileStream *stream)
+{
+    SecInt ch;
+    if (stream->count < sizeof(SecChar)) {
+        /* Load file to buffer */
+        size_t len;
+        if (stream->base != NULL) {
+            /* Put the last unread data in the buffer head */
+            for (len = 0; len < stream->count; ++len) {
+                stream->base[len] = stream->cur[len];
+            }
+        } else {
+            stream->oriFilePos = ftell(stream->pf);   /* Save original file read position */
+            if (stream->oriFilePos == -1) {
+                /* It may be a pipe stream */
+                stream->flag = SECUREC_PIPE_STREAM_FLAG;
+                return SecGetCharFromStream(stream);
+            }
+            /* Reserve the length of BOM head */
+            stream->base = (char *)SECUREC_MALLOC(SECUREC_BUFFERED_BLOK_SIZE +
+                SECUREC_BOM_HEADER_SIZE + sizeof(SecChar)); /* To store '\0' and aligned to wide char */
+            if (stream->base == NULL) {
+                return SECUREC_EOF;
+            }
+            /* First read file */
+            if (stream->oriFilePos == 0) {
+                /* Make sure the data is aligned to base */
+                SecReadAndSkipBomHeader(stream);
+            }
+        }
+
+        /* Skip existing data and read data */
+        len = fread(stream->base + stream->count, (size_t)1, (size_t)SECUREC_BUFFERED_BLOK_SIZE, stream->pf);
+        if (len > SECUREC_BUFFERED_BLOK_SIZE) { /* It won't happen, */
+            len = 0;
+        }
+        stream->count += len;
+        stream->cur = stream->base;
+        stream->flag |= SECUREC_LOAD_FILE_TO_MEM_FLAG;
+        stream->base[stream->count] = '\0';   /* For tool Warning string null */
+    }
+
+    SECUREC_GET_CHAR(stream, &ch);
+    if (ch != SECUREC_EOF) {
+        stream->fileRealRead += sizeof(SecChar);
+    }
+    return ch;
+}
+#endif
+
+/*
+ *  Get char  for wchar version
+ */
+SECUREC_INLINE SecInt SecGetChar(SecFileStream *stream, int *counter)
+{
+    *counter = *counter + 1; /* Always plus 1 */
+    /* The main scenario is scanf str */
+    if ((stream->flag & SECUREC_MEM_STR_FLAG) != 0) {
+        SecInt ch;
+        SECUREC_GET_CHAR(stream, &ch);
+        return ch;
+    }
+#if SECUREC_ENABLE_SCANF_FILE
+    if ((stream->flag & SECUREC_FILE_STREAM_FLAG) != 0) {
+        return SecGetCharFromFile(stream);
+    }
+    if ((stream->flag & SECUREC_PIPE_STREAM_FLAG) != 0) {
+        return SecGetCharFromStream(stream);
+    }
+#endif
+    return SECUREC_EOF;
+}
+
+/*
+ *  Unget Public realizatio char for wchar and char version
+ */
+SECUREC_INLINE void SecUnGetCharImpl(SecInt ch, SecFileStream *stream)
+{
+    if ((stream->flag & SECUREC_MEM_STR_FLAG) != 0) {
+        SECUREC_UN_GET_CHAR(stream);
+        return;
+    }
+#if SECUREC_ENABLE_SCANF_FILE
+    if ((stream->flag & SECUREC_LOAD_FILE_TO_MEM_FLAG) != 0) {
+        SECUREC_UN_GET_CHAR(stream);
+        if (stream->fileRealRead > 0) {
+            stream->fileRealRead -= sizeof(SecChar);
+        }
+        return;
+    }
+    if ((stream->flag & SECUREC_PIPE_STREAM_FLAG) != 0) {
+        (void)SECUREC_UN_GETC(ch, stream->pf);
+        return;
+    }
+#else
+    (void)ch; /* To clear e438 last value assigned not used , the compiler will optimize this code */
+#endif
+}
+
+/*
+ *  Unget char  for char version
+ */
+SECUREC_INLINE void SecUnGetChar(SecInt ch, SecFileStream *stream, int *counter)
+{
+    *counter = *counter - 1; /* Always mius 1 */
+    if (ch != SECUREC_EOF) {
+        SecUnGetCharImpl(ch, stream);
+    }
+}
+
+/*
+ *  Skip space char by isspace
+ */
+SECUREC_INLINE SecInt SecSkipSpaceChar(SecFileStream *stream, int *counter)
+{
+    SecInt ch;
+    do {
+        ch = SecGetChar(stream, counter);
+        if (ch == SECUREC_EOF) {
+            break;
+        }
+    } while (SecIsSpace(ch) != 0);
+    return ch;
+}
+#endif /* INPUT_INL_5D13A042_DC3F_4ED9_A8D1_882811274C27 */
+
diff --git a/lib/libsecurec/src/memcpy_s.c b/lib/libsecurec/src/memcpy_s.c
new file mode 100644
index 0000000..a7fd487
--- /dev/null
+++ b/lib/libsecurec/src/memcpy_s.c
@@ -0,0 +1,555 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: memcpy_s function
+ * Create: 2014-02-25
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Portability
+ * [reason] Use unsafe function to implement security function to maintain platform compatibility.
+ *          And sufficient input validation is performed before calling
+ */
+
+#include "securecutil.h"
+
+#if SECUREC_WITH_PERFORMANCE_ADDONS
+#ifndef SECUREC_MEMCOPY_THRESHOLD_SIZE
+#define SECUREC_MEMCOPY_THRESHOLD_SIZE 64UL
+#endif
+
+#define SECUREC_SMALL_MEM_COPY(dest, src, count) do { \
+    if (SECUREC_ADDR_ALIGNED_8(dest) && SECUREC_ADDR_ALIGNED_8(src)) { \
+        /* Use struct assignment */ \
+        switch (count) { \
+            case 1: \
+                *(unsigned char *)(dest) = *(const unsigned char *)(src); \
+                break; \
+            case 2: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 2); \
+                break; \
+            case 3: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 3); \
+                break; \
+            case 4: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 4); \
+                break; \
+            case 5: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 5); \
+                break; \
+            case 6: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 6); \
+                break; \
+            case 7: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 7); \
+                break; \
+            case 8: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 8); \
+                break; \
+            case 9: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 9); \
+                break; \
+            case 10: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 10); \
+                break; \
+            case 11: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 11); \
+                break; \
+            case 12: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 12); \
+                break; \
+            case 13: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 13); \
+                break; \
+            case 14: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 14); \
+                break; \
+            case 15: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 15); \
+                break; \
+            case 16: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 16); \
+                break; \
+            case 17: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 17); \
+                break; \
+            case 18: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 18); \
+                break; \
+            case 19: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 19); \
+                break; \
+            case 20: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 20); \
+                break; \
+            case 21: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 21); \
+                break; \
+            case 22: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 22); \
+                break; \
+            case 23: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 23); \
+                break; \
+            case 24: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 24); \
+                break; \
+            case 25: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 25); \
+                break; \
+            case 26: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 26); \
+                break; \
+            case 27: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 27); \
+                break; \
+            case 28: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 28); \
+                break; \
+            case 29: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 29); \
+                break; \
+            case 30: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 30); \
+                break; \
+            case 31: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 31); \
+                break; \
+            case 32: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 32); \
+                break; \
+            case 33: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 33); \
+                break; \
+            case 34: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 34); \
+                break; \
+            case 35: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 35); \
+                break; \
+            case 36: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 36); \
+                break; \
+            case 37: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 37); \
+                break; \
+            case 38: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 38); \
+                break; \
+            case 39: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 39); \
+                break; \
+            case 40: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 40); \
+                break; \
+            case 41: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 41); \
+                break; \
+            case 42: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 42); \
+                break; \
+            case 43: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 43); \
+                break; \
+            case 44: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 44); \
+                break; \
+            case 45: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 45); \
+                break; \
+            case 46: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 46); \
+                break; \
+            case 47: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 47); \
+                break; \
+            case 48: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 48); \
+                break; \
+            case 49: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 49); \
+                break; \
+            case 50: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 50); \
+                break; \
+            case 51: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 51); \
+                break; \
+            case 52: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 52); \
+                break; \
+            case 53: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 53); \
+                break; \
+            case 54: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 54); \
+                break; \
+            case 55: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 55); \
+                break; \
+            case 56: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 56); \
+                break; \
+            case 57: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 57); \
+                break; \
+            case 58: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 58); \
+                break; \
+            case 59: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 59); \
+                break; \
+            case 60: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 60); \
+                break; \
+            case 61: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 61); \
+                break; \
+            case 62: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 62); \
+                break; \
+            case 63: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 63); \
+                break; \
+            case 64: \
+                SECUREC_COPY_VALUE_BY_STRUCT((dest), (src), 64); \
+                break; \
+            default: \
+                /* Do nothing */ \
+                break; \
+        } /* END switch */ \
+    } else { \
+        unsigned char *tmpDest_ = (unsigned char *)(dest); \
+        const unsigned char *tmpSrc_ = (const unsigned char *)(src); \
+        switch (count) { \
+            case 64: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 63: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 62: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 61: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 60: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 59: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 58: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 57: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 56: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 55: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 54: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 53: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 52: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 51: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 50: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 49: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 48: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 47: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 46: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 45: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 44: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 43: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 42: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 41: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 40: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 39: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 38: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 37: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 36: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 35: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 34: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 33: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 32: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 31: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 30: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 29: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 28: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 27: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 26: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 25: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 24: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 23: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 22: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 21: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 20: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 19: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 18: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 17: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 16: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 15: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 14: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 13: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 12: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 11: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 10: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 9: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 8: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 7: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 6: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 5: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 4: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 3: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 2: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 1: \
+                *(tmpDest_++) = *(tmpSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            default: \
+                /* Do nothing */ \
+                break; \
+        } \
+    } \
+} SECUREC_WHILE_ZERO
+
+/*
+ * Performance optimization
+ */
+#define SECUREC_MEMCPY_OPT(dest, src, count) do { \
+    if ((count) > SECUREC_MEMCOPY_THRESHOLD_SIZE) { \
+        SECUREC_MEMCPY_WARP_OPT((dest), (src), (count)); \
+    } else { \
+        SECUREC_SMALL_MEM_COPY((dest), (src), (count)); \
+    } \
+} SECUREC_WHILE_ZERO
+#endif
+
+/*
+ * Handling errors
+ */
+SECUREC_INLINE errno_t SecMemcpyError(void *dest, size_t destMax, const void *src, size_t count)
+{
+    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("memcpy_s");
+        return ERANGE;
+    }
+    if (dest == NULL || src == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("memcpy_s");
+        if (dest != NULL) {
+            (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    if (count > destMax) {
+        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
+        SECUREC_ERROR_INVALID_RANGE("memcpy_s");
+        return ERANGE_AND_RESET;
+    }
+    if (SECUREC_MEMORY_IS_OVERLAP(dest, src, count)) {
+        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
+        SECUREC_ERROR_BUFFER_OVERLAP("memcpy_s");
+        return EOVERLAP_AND_RESET;
+    }
+    /* Count is 0 or dest equal src also ret EOK */
+    return EOK;
+}
+
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+    /*
+     * The fread API in windows will call memcpy_s and pass 0xffffffff to destMax.
+     * To avoid the failure of fread, we don't check desMax limit.
+     */
+#define SECUREC_MEMCPY_PARAM_OK(dest, destMax, src, count) (SECUREC_LIKELY((count) <= (destMax) && \
+    (dest) != NULL && (src) != NULL && \
+    (count) > 0 && SECUREC_MEMORY_NO_OVERLAP((dest), (src), (count))))
+#else
+#define SECUREC_MEMCPY_PARAM_OK(dest, destMax, src, count) (SECUREC_LIKELY((count) <= (destMax) && \
+    (dest) != NULL && (src) != NULL && (destMax) <= SECUREC_MEM_MAX_LEN && \
+    (count) > 0 && SECUREC_MEMORY_NO_OVERLAP((dest), (src), (count))))
+#endif
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The memcpy_s function copies n characters from the object pointed to by src into the object pointed to by dest
+ *
+ * <INPUT PARAMETERS>
+ *    dest                      Destination buffer.
+ *    destMax                   Size of the destination buffer.
+ *    src                       Buffer to copy from.
+ *    count                     Number of characters to copy
+ *
+ * <OUTPUT PARAMETERS>
+ *    dest buffer               is updated.
+ *
+ * <RETURN VALUE>
+ *    EOK                      Success
+ *    EINVAL                   dest is  NULL and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN
+ *    EINVAL_AND_RESET         dest != NULL and src is NULL and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN
+ *    ERANGE                   destMax > SECUREC_MEM_MAX_LEN or destMax is 0
+ *    ERANGE_AND_RESET         count > destMax and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN
+ *                             and dest  !=  NULL  and src != NULL
+ *    EOVERLAP_AND_RESET       dest buffer and source buffer are overlapped and
+ *                             count <= destMax destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN and dest  !=  NULL
+ *                             and src != NULL  and dest != src
+ *
+ *    if an error occurred, dest will be filled with 0.
+ *    If the source and destination overlap, the behavior of memcpy_s is undefined.
+ *    Use memmove_s to handle overlapping regions.
+ */
+errno_t memcpy_s(void *dest, size_t destMax, const void *src, size_t count)
+{
+    if (SECUREC_MEMCPY_PARAM_OK(dest, destMax, src, count)) {
+        SECUREC_MEMCPY_WARP_OPT(dest, src, count);
+        return EOK;
+    }
+    /* Meet some runtime violation, return error code */
+    return SecMemcpyError(dest, destMax, src, count);
+}
+
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(memcpy_s);
+#endif
+
+#if SECUREC_WITH_PERFORMANCE_ADDONS
+/*
+ * Performance optimization
+ */
+errno_t memcpy_sOptAsm(void *dest, size_t destMax, const void *src, size_t count)
+{
+    if (SECUREC_MEMCPY_PARAM_OK(dest, destMax, src, count)) {
+        SECUREC_MEMCPY_OPT(dest, src, count);
+        return EOK;
+    }
+    /* Meet some runtime violation, return error code */
+    return SecMemcpyError(dest, destMax, src, count);
+}
+
+/* Trim judgement on "destMax <= SECUREC_MEM_MAX_LEN" */
+errno_t memcpy_sOptTc(void *dest, size_t destMax, const void *src, size_t count)
+{
+    if (SECUREC_LIKELY(count <= destMax && dest != NULL && src != NULL && \
+                       count > 0 && SECUREC_MEMORY_NO_OVERLAP((dest), (src), (count)))) {
+        SECUREC_MEMCPY_OPT(dest, src, count);
+        return EOK;
+    }
+    /* Meet some runtime violation, return error code */
+    return SecMemcpyError(dest, destMax, src, count);
+}
+#endif
+
diff --git a/lib/libsecurec/src/memmove_s.c b/lib/libsecurec/src/memmove_s.c
new file mode 100644
index 0000000..f231f05
--- /dev/null
+++ b/lib/libsecurec/src/memmove_s.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: memmove_s function
+ * Create: 2014-02-25
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Portability
+ * [reason] Use unsafe function to implement security function to maintain platform compatibility.
+ *          And sufficient input validation is performed before calling
+ */
+
+#include "securecutil.h"
+
+#ifdef SECUREC_NOT_CALL_LIBC_CORE_API
+/*
+ * Implementing memory data movement
+ */
+SECUREC_INLINE void SecUtilMemmove(void *dst, const void *src, size_t count)
+{
+    unsigned char *pDest = (unsigned char *)dst;
+    const unsigned char *pSrc = (const unsigned char *)src;
+    size_t maxCount = count;
+
+    if (dst <= src || pDest >= (pSrc + maxCount)) {
+        /*
+         * Non-Overlapping Buffers
+         * Copy from lower addresses to higher addresses
+         */
+        while (maxCount > 0) {
+            --maxCount;
+            *pDest = *pSrc;
+            ++pDest;
+            ++pSrc;
+        }
+    } else {
+        /*
+         * Overlapping Buffers
+         * Copy from higher addresses to lower addresses
+         */
+        pDest = pDest + maxCount - 1;
+        pSrc = pSrc + maxCount - 1;
+        while (maxCount > 0) {
+            --maxCount;
+            *pDest = *pSrc;
+            --pDest;
+            --pSrc;
+        }
+    }
+}
+#endif
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The memmove_s function copies count bytes of characters from src to dest.
+ *    This function can be assigned correctly when memory overlaps.
+ * <INPUT PARAMETERS>
+ *    dest                    Destination object.
+ *    destMax                 Size of the destination buffer.
+ *    src                     Source object.
+ *    count                   Number of characters to copy.
+ *
+ * <OUTPUT PARAMETERS>
+ *    dest buffer             is updated.
+ *
+ * <RETURN VALUE>
+ *    EOK                     Success
+ *    EINVAL                  dest is  NULL and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN
+ *    EINVAL_AND_RESET        dest != NULL and src is NULL and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN
+ *    ERANGE                  destMax > SECUREC_MEM_MAX_LEN or destMax is 0
+ *    ERANGE_AND_RESET        count > destMax and dest  !=  NULL and src != NULL and destMax != 0
+ *                            and destMax <= SECUREC_MEM_MAX_LEN
+ *
+ *    If an error occurred, dest will  be filled with 0 when dest and destMax valid.
+ *    If some regions of the source area and the destination overlap, memmove_s
+ *    ensures that the original source bytes in the overlapping region are copied
+ *    before being overwritten.
+ */
+errno_t memmove_s(void *dest, size_t destMax, const void *src, size_t count)
+{
+    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("memmove_s");
+        return ERANGE;
+    }
+    if (dest == NULL || src == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("memmove_s");
+        if (dest != NULL) {
+            (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    if (count > destMax) {
+        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
+        SECUREC_ERROR_INVALID_RANGE("memmove_s");
+        return ERANGE_AND_RESET;
+    }
+    if (dest == src) {
+        return EOK;
+    }
+
+    if (count > 0) {
+#ifdef SECUREC_NOT_CALL_LIBC_CORE_API
+        SecUtilMemmove(dest, src, count);
+#else
+        /* Use underlying memmove for performance consideration */
+        (void)memmove(dest, src, count);
+#endif
+    }
+    return EOK;
+}
+
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(memmove_s);
+#endif
+
diff --git a/lib/libsecurec/src/memset_s.c b/lib/libsecurec/src/memset_s.c
new file mode 100644
index 0000000..d9a657f
--- /dev/null
+++ b/lib/libsecurec/src/memset_s.c
@@ -0,0 +1,510 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: memset_s function
+ * Create: 2014-02-25
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Portability
+ * [reason] Use unsafe function to implement security function to maintain platform compatibility.
+ *          And sufficient input validation is performed before calling
+ */
+
+#include "securecutil.h"
+
+#define SECUREC_MEMSET_PARAM_OK(dest, destMax, count) (SECUREC_LIKELY((destMax) <= SECUREC_MEM_MAX_LEN && \
+    (dest) != NULL && (count) <= (destMax)))
+
+#if SECUREC_WITH_PERFORMANCE_ADDONS
+
+/* Use union to clear strict-aliasing warning */
+typedef union {
+    SecStrBuf32 buf32;
+    SecStrBuf31 buf31;
+    SecStrBuf30 buf30;
+    SecStrBuf29 buf29;
+    SecStrBuf28 buf28;
+    SecStrBuf27 buf27;
+    SecStrBuf26 buf26;
+    SecStrBuf25 buf25;
+    SecStrBuf24 buf24;
+    SecStrBuf23 buf23;
+    SecStrBuf22 buf22;
+    SecStrBuf21 buf21;
+    SecStrBuf20 buf20;
+    SecStrBuf19 buf19;
+    SecStrBuf18 buf18;
+    SecStrBuf17 buf17;
+    SecStrBuf16 buf16;
+    SecStrBuf15 buf15;
+    SecStrBuf14 buf14;
+    SecStrBuf13 buf13;
+    SecStrBuf12 buf12;
+    SecStrBuf11 buf11;
+    SecStrBuf10 buf10;
+    SecStrBuf9 buf9;
+    SecStrBuf8 buf8;
+    SecStrBuf7 buf7;
+    SecStrBuf6 buf6;
+    SecStrBuf5 buf5;
+    SecStrBuf4 buf4;
+    SecStrBuf3 buf3;
+    SecStrBuf2 buf2;
+} SecStrBuf32Union;
+/* C standard initializes the first member of the consortium. */
+static const SecStrBuf32 g_allZero = {{
+    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
+    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
+    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
+    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U
+}};
+static const SecStrBuf32 g_allFF = {{
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+}};
+
+/* Clear conversion warning strict aliasing" */
+SECUREC_INLINE const SecStrBuf32Union *SecStrictAliasingCast(const SecStrBuf32 *buf)
+{
+    return (const SecStrBuf32Union *)buf;
+}
+
+#ifndef SECUREC_MEMSET_THRESHOLD_SIZE
+#define SECUREC_MEMSET_THRESHOLD_SIZE 32UL
+#endif
+
+#define SECUREC_UNALIGNED_SET(dest, c, count) do { \
+    unsigned char *pDest_ = (unsigned char *)(dest); \
+    switch (count) { \
+        case 32: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 31: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 30: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 29: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 28: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 27: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 26: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 25: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 24: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 23: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 22: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 21: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 20: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 19: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 18: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 17: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 16: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 15: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 14: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 13: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 12: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 11: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 10: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 9: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 8: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 7: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 6: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 5: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 4: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 3: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 2: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        case 1: \
+            *(pDest_++) = (unsigned char)(c); \
+            /* fall-through */ /* FALLTHRU */ \
+        default: \
+            /* Do nothing */ \
+            break; \
+    } \
+} SECUREC_WHILE_ZERO
+
+#define SECUREC_SET_VALUE_BY_STRUCT(dest, dataName, n) do { \
+    *(SecStrBuf##n *)(dest) = *(const SecStrBuf##n *)(&((SecStrictAliasingCast(&(dataName)))->buf##n)); \
+} SECUREC_WHILE_ZERO
+
+#define SECUREC_ALIGNED_SET_OPT_ZERO_FF(dest, c, count) do { \
+    switch (c) { \
+        case 0: \
+            switch (count) { \
+                case 1: \
+                    *(unsigned char *)(dest) = (unsigned char)0; \
+                    break; \
+                case 2: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 2); \
+                    break; \
+                case 3: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 3); \
+                    break; \
+                case 4: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 4); \
+                    break; \
+                case 5: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 5); \
+                    break; \
+                case 6: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 6); \
+                    break; \
+                case 7: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 7); \
+                    break; \
+                case 8: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 8); \
+                    break; \
+                case 9: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 9); \
+                    break; \
+                case 10: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 10); \
+                    break; \
+                case 11: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 11); \
+                    break; \
+                case 12: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 12); \
+                    break; \
+                case 13: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 13); \
+                    break; \
+                case 14: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 14); \
+                    break; \
+                case 15: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 15); \
+                    break; \
+                case 16: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 16); \
+                    break; \
+                case 17: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 17); \
+                    break; \
+                case 18: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 18); \
+                    break; \
+                case 19: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 19); \
+                    break; \
+                case 20: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 20); \
+                    break; \
+                case 21: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 21); \
+                    break; \
+                case 22: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 22); \
+                    break; \
+                case 23: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 23); \
+                    break; \
+                case 24: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 24); \
+                    break; \
+                case 25: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 25); \
+                    break; \
+                case 26: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 26); \
+                    break; \
+                case 27: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 27); \
+                    break; \
+                case 28: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 28); \
+                    break; \
+                case 29: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 29); \
+                    break; \
+                case 30: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 30); \
+                    break; \
+                case 31: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 31); \
+                    break; \
+                case 32: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allZero, 32); \
+                    break; \
+                default: \
+                    /* Do nothing */ \
+                    break; \
+            } \
+            break; \
+        case 0xFF: \
+            switch (count) { \
+                case 1: \
+                    *(unsigned char *)(dest) = (unsigned char)0xffU; \
+                    break; \
+                case 2: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 2); \
+                    break; \
+                case 3: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 3); \
+                    break; \
+                case 4: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 4); \
+                    break; \
+                case 5: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 5); \
+                    break; \
+                case 6: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 6); \
+                    break; \
+                case 7: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 7); \
+                    break; \
+                case 8: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 8); \
+                    break; \
+                case 9: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 9); \
+                    break; \
+                case 10: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 10); \
+                    break; \
+                case 11: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 11); \
+                    break; \
+                case 12: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 12); \
+                    break; \
+                case 13: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 13); \
+                    break; \
+                case 14: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 14); \
+                    break; \
+                case 15: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 15); \
+                    break; \
+                case 16: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 16); \
+                    break; \
+                case 17: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 17); \
+                    break; \
+                case 18: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 18); \
+                    break; \
+                case 19: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 19); \
+                    break; \
+                case 20: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 20); \
+                    break; \
+                case 21: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 21); \
+                    break; \
+                case 22: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 22); \
+                    break; \
+                case 23: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 23); \
+                    break; \
+                case 24: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 24); \
+                    break; \
+                case 25: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 25); \
+                    break; \
+                case 26: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 26); \
+                    break; \
+                case 27: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 27); \
+                    break; \
+                case 28: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 28); \
+                    break; \
+                case 29: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 29); \
+                    break; \
+                case 30: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 30); \
+                    break; \
+                case 31: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 31); \
+                    break; \
+                case 32: \
+                    SECUREC_SET_VALUE_BY_STRUCT((dest), g_allFF, 32); \
+                    break; \
+                default: \
+                    /* Do nothing */ \
+                    break; \
+            } \
+            break; \
+        default: \
+            SECUREC_UNALIGNED_SET((dest), (c), (count)); \
+            break; \
+    } /* END switch */ \
+} SECUREC_WHILE_ZERO
+
+#define SECUREC_SMALL_MEM_SET(dest, c, count) do { \
+    if (SECUREC_ADDR_ALIGNED_8((dest))) { \
+        SECUREC_ALIGNED_SET_OPT_ZERO_FF((dest), (c), (count)); \
+    } else { \
+        SECUREC_UNALIGNED_SET((dest), (c), (count)); \
+    } \
+} SECUREC_WHILE_ZERO
+
+/*
+ * Performance optimization
+ */
+#define SECUREC_MEMSET_OPT(dest, c, count) do { \
+    if ((count) > SECUREC_MEMSET_THRESHOLD_SIZE) { \
+        SECUREC_MEMSET_PREVENT_DSE((dest), (c), (count)); \
+    } else { \
+        SECUREC_SMALL_MEM_SET((dest), (c), (count)); \
+    } \
+} SECUREC_WHILE_ZERO
+#endif
+
+/*
+ * Handling errors
+ */
+SECUREC_INLINE errno_t SecMemsetError(void *dest, size_t destMax, int c)
+{
+    /* Check destMax is 0 compatible with _sp macro */
+    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("memset_s");
+        return ERANGE;
+    }
+    if (dest == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("memset_s");
+        return EINVAL;
+    }
+    SECUREC_MEMSET_PREVENT_DSE(dest, c, destMax); /* Set entire buffer to value c */
+    SECUREC_ERROR_INVALID_RANGE("memset_s");
+    return ERANGE_AND_RESET;
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The memset_s function copies the value of c (converted to an unsigned char)
+ *     into each of the first count characters of the object pointed to by dest.
+ *
+ * <INPUT PARAMETERS>
+ *    dest                Pointer to destination.
+ *    destMax             The size of the buffer.
+ *    c                   Character to set.
+ *    count               Number of characters.
+ *
+ * <OUTPUT PARAMETERS>
+ *    dest buffer         is updated.
+ *
+ * <RETURN VALUE>
+ *    EOK                 Success
+ *    EINVAL              dest == NULL and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN
+ *    ERANGE              destMax > SECUREC_MEM_MAX_LEN or (destMax is 0 and count > destMax)
+ *    ERANGE_AND_RESET    count > destMax and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN and dest != NULL
+ *
+ *    if return ERANGE_AND_RESET then fill dest to c ,fill length is destMax
+ */
+errno_t memset_s(void *dest, size_t destMax, int c, size_t count)
+{
+    if (SECUREC_MEMSET_PARAM_OK(dest, destMax, count)) {
+        SECUREC_MEMSET_PREVENT_DSE(dest, c, count);
+        return EOK;
+    }
+    /* Meet some runtime violation, return error code */
+    return SecMemsetError(dest, destMax, c);
+}
+
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(memset_s);
+#endif
+
+#if SECUREC_WITH_PERFORMANCE_ADDONS
+/*
+ * Performance optimization
+ */
+errno_t memset_sOptAsm(void *dest, size_t destMax, int c, size_t count)
+{
+    if (SECUREC_MEMSET_PARAM_OK(dest, destMax, count)) {
+        SECUREC_MEMSET_OPT(dest, c, count);
+        return EOK;
+    }
+    /* Meet some runtime violation, return error code */
+    return SecMemsetError(dest, destMax, c);
+}
+
+/*
+ * Performance optimization, trim judgement on "destMax <= SECUREC_MEM_MAX_LEN"
+ */
+errno_t memset_sOptTc(void *dest, size_t destMax, int c, size_t count)
+{
+    if (SECUREC_LIKELY(count <= destMax && dest != NULL)) {
+        SECUREC_MEMSET_OPT(dest, c, count);
+        return EOK;
+    }
+    /* Meet some runtime violation, return error code */
+    return SecMemsetError(dest, destMax, c);
+}
+#endif
+
diff --git a/lib/libsecurec/src/output.inl b/lib/libsecurec/src/output.inl
new file mode 100644
index 0000000..9392efa
--- /dev/null
+++ b/lib/libsecurec/src/output.inl
@@ -0,0 +1,1720 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: Used by secureprintoutput_a.c and secureprintoutput_w.c to include.
+ *              This file provides a template function for ANSI and UNICODE compiling
+ *              by different type definition. The functions of SecOutputS or
+ *              SecOutputSW  provides internal implementation for printf family API, such as sprintf, swprintf_s.
+ * Create: 2014-02-25
+ * Notes: see www.cplusplus.com/reference/cstdio/printf/
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Portability
+ * [reason] Use unsafe function to implement security function to maintain platform compatibility.
+ *          And sufficient input validation is performed before calling
+ */
+#ifndef OUTPUT_INL_2B263E9C_43D8_44BB_B17A_6D2033DECEE5
+#define OUTPUT_INL_2B263E9C_43D8_44BB_B17A_6D2033DECEE5
+
+#ifndef SECUREC_ENABLE_SPRINTF_LONG_DOUBLE
+/* Some compilers do not support long double */
+#define SECUREC_ENABLE_SPRINTF_LONG_DOUBLE 1
+#endif
+
+#define SECUREC_NULL_STRING_SIZE            8
+#define SECUREC_STATE_TABLE_SIZE            337
+
+#if defined(SECUREC_VXWORKS_VERSION_5_4) && !defined(SECUREC_ON_64BITS)
+#define SECUREC_DIV_QUOTIENT_OCTAL(val64)     ((val64) >> 3ULL)
+#define SECUREC_DIV_RESIDUE_OCTAL(val64)      ((val64) & 7ULL)
+
+#define SECUREC_DIV_QUOTIENT_HEX(val64)       ((val64) >> 4ULL)
+#define SECUREC_DIV_RESIDUE_HEX(val64)        ((val64) & 0xfULL)
+#endif
+
+#define SECUREC_RADIX_OCTAL                 8U
+#define SECUREC_RADIX_DECIMAL               10U
+#define SECUREC_RADIX_HEX                   16U
+#define SECUREC_PREFIX_LEN                  2
+/* Size include '+' and '\0' */
+#define SECUREC_FLOAT_BUF_EXT               2
+
+/* Sign extend or Zero-extend */
+#define SECUREC_GET_LONG_FROM_ARG(attr) ((((attr).flags & SECUREC_FLAG_SIGNED) != 0) ? \
+    (SecInt64)(long)va_arg(argList, long) : \
+    (SecInt64)(unsigned long)va_arg(argList, long))
+
+/* Sign extend or Zero-extend */
+#define SECUREC_GET_CHAR_FROM_ARG(attr) ((((attr).flags & SECUREC_FLAG_SIGNED) != 0) ? \
+    SecUpdateNegativeChar(&(attr), ((char)va_arg(argList, int))) : \
+    (SecInt64)(unsigned char)va_arg(argList, int))
+
+/* Sign extend or Zero-extend */
+#define SECUREC_GET_SHORT_FROM_ARG(attr) ((((attr).flags & SECUREC_FLAG_SIGNED) != 0) ? \
+    (SecInt64)(short)va_arg(argList, int) : \
+    (SecInt64)(unsigned short)va_arg(argList, int))
+
+/* Sign extend or Zero-extend */
+#define SECUREC_GET_INT_FROM_ARG(attr) ((((attr).flags & SECUREC_FLAG_SIGNED) != 0) ? \
+    (SecInt64)(int)va_arg(argList, int) : \
+    (SecInt64)(unsigned int)va_arg(argList, int))
+
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+/* Sign extend or Zero-extend. No suitable macros were found to handle the branch */
+#define SECUREC_GET_SIZE_FROM_ARG(attr) ((((attr).flags & SECUREC_FLAG_SIGNED) != 0) ? \
+    ((SecIsSameSize(sizeof(size_t), sizeof(long)) != 0) ? (SecInt64)(long)va_arg(argList, long) : \
+    ((SecIsSameSize(sizeof(size_t), sizeof(long long)) != 0) ? (SecInt64)(long long)va_arg(argList, long long) : \
+    (SecInt64)(int)va_arg(argList, int))) : \
+    (SecInt64)(size_t)va_arg(argList, size_t))
+#endif
+
+/* Format output buffer pointer and available size */
+typedef struct {
+    int count;
+    SecChar *cur;
+} SecPrintfStream;
+
+typedef union {
+    /* Integer formatting refers to the end of the buffer, plus 1 to prevent tool alarms */
+    char str[SECUREC_BUFFER_SIZE + 1];
+#if SECUREC_HAVE_WCHART
+    wchar_t wStr[SECUREC_WCHAR_BUFFER_SIZE]; /* Just for %lc */
+#endif
+} SecBuffer;
+
+typedef union {
+    char *str;                  /* Not a null terminated  string */
+#if SECUREC_HAVE_WCHART
+    wchar_t *wStr;
+#endif
+} SecFormatBuf;
+
+typedef struct {
+    const char *digits;                 /* Point to the hexadecimal subset */
+    SecFormatBuf text;                  /* Point to formatted string */
+    int textLen;                        /* Length of the text */
+    int textIsWide;                     /* Flag for text is wide chars ; 0 is not wide char */
+    unsigned int radix;                 /* Use for output number , default set to 10 */
+    unsigned int flags;
+    int fldWidth;
+    int precision;
+    int dynWidth;                       /* %*   1 width from variable parameter ;0 not */
+    int dynPrecision;                   /* %.*  1 precision from variable parameter ;0 not */
+    int padding;                        /* Padding len */
+    int prefixLen;                      /* Length of prefix, 0 or 1 or 2 */
+    SecChar prefix[SECUREC_PREFIX_LEN]; /* Prefix is  0 or 0x */
+    SecBuffer buffer;
+} SecFormatAttr;
+
+#if SECUREC_ENABLE_SPRINTF_FLOAT
+#ifdef SECUREC_STACK_SIZE_LESS_THAN_1K
+#define SECUREC_FMT_STR_LEN                 8
+#else
+#define SECUREC_FMT_STR_LEN                 16
+#endif
+typedef struct {
+    char buffer[SECUREC_FMT_STR_LEN];
+    char *fmtStr;                     /* Initialization must point to buffer */
+    char *allocatedFmtStr;            /* Initialization must be NULL  to store allocated point */
+    char *floatBuffer;                /* Use heap memory if the SecFormatAttr.buffer is not enough */
+    int bufferSize;                   /* The size of floatBuffer */
+} SecFloatAdapt;
+#endif
+
+/* Use 20 to Align the data */
+#define SECUREC_DIGITS_BUF_SIZE  20
+/* The serial number of 'x' or 'X' is 16 */
+#define SECUREC_NUMBER_OF_X  16
+/* Some systems can not use pointers to point to string literals, but can use string arrays. */
+/* For example, when handling code under uboot, there is a problem with the pointer */
+static const char g_itoaUpperDigits[SECUREC_DIGITS_BUF_SIZE] = "0123456789ABCDEFX";
+static const char g_itoaLowerDigits[SECUREC_DIGITS_BUF_SIZE] = "0123456789abcdefx";
+
+#if SECUREC_ENABLE_SPRINTF_FLOAT
+/* Call system sprintf to format float value */
+SECUREC_INLINE int SecFormatFloat(char *strDest, const char *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    SECUREC_MASK_VSPRINTF_WARNING
+    ret = vsprintf(strDest, format, argList);
+    SECUREC_END_MASK_VSPRINTF_WARNING
+    va_end(argList);
+    (void)argList; /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+
+#if defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && SECUREC_ENABLE_SPRINTF_LONG_DOUBLE
+/* Out put long double value to dest */
+SECUREC_INLINE void SecFormatLongDouble(SecFormatAttr *attr, const SecFloatAdapt *floatAdapt, long double ldValue)
+{
+    int fldWidth = (((attr->flags & SECUREC_FLAG_LEFT) != 0) ? (-attr->fldWidth) : attr->fldWidth);
+    if (attr->dynWidth != 0 && attr->dynPrecision != 0) {
+        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, attr->precision, ldValue);
+    } else if (attr->dynWidth != 0) {
+        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, ldValue);
+    } else if (attr->dynPrecision != 0) {
+        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, attr->precision, ldValue);
+    } else {
+        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, ldValue);
+    }
+    if (attr->textLen < 0 || attr->textLen >= floatAdapt->bufferSize) {
+        attr->textLen = 0;
+    }
+}
+#endif
+
+/* Out put double value to dest */
+SECUREC_INLINE void SecFormatDouble(SecFormatAttr *attr, const SecFloatAdapt *floatAdapt, double dValue)
+{
+    int fldWidth = (((attr->flags & SECUREC_FLAG_LEFT) != 0) ? (-attr->fldWidth) : attr->fldWidth);
+    if (attr->dynWidth != 0 && attr->dynPrecision != 0) {
+        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, attr->precision, dValue);
+    } else if (attr->dynWidth != 0) {
+        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, dValue);
+    } else if (attr->dynPrecision != 0) {
+        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, attr->precision, dValue);
+    } else {
+        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, dValue);
+    }
+    if (attr->textLen < 0 || attr->textLen >= floatAdapt->bufferSize) {
+        attr->textLen = 0;
+    }
+}
+#endif
+
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+/* To clear e506 warning */
+SECUREC_INLINE int SecIsSameSize(size_t sizeA, size_t sizeB)
+{
+    return (int)(sizeA == sizeB);
+}
+#endif
+
+#ifndef SECUREC_ON_64BITS
+/*
+ * Compiler Optimized Division 8.
+ * The text.str point to buffer end, must be Large enough
+ */
+SECUREC_INLINE void SecNumber32ToOctalString(SecUnsignedInt32 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt32 val32 = number;
+    do {
+        --attr->text.str;
+        /* Just use lowerDigits for 0 - 9 */
+        *(attr->text.str) = g_itoaLowerDigits[val32 % SECUREC_RADIX_OCTAL];
+        val32 /= SECUREC_RADIX_OCTAL;
+    } while (val32 != 0);
+}
+
+#ifdef _AIX
+/*
+ * Compiler Optimized Division 10.
+ * The text.str point to buffer end, must be Large enough
+ */
+SECUREC_INLINE void SecNumber32ToDecString(SecUnsignedInt32 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt32 val32 = number;
+    do {
+        --attr->text.str;
+        /* Just use lowerDigits for 0 - 9 */
+        *(attr->text.str) = g_itoaLowerDigits[val32 % SECUREC_RADIX_DECIMAL];
+        val32 /= SECUREC_RADIX_DECIMAL;
+    } while (val32 != 0);
+}
+#endif
+/*
+ * Compiler Optimized Division 16.
+ * The text.str point to buffer end, must be Large enough
+ */
+SECUREC_INLINE void SecNumber32ToHexString(SecUnsignedInt32 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt32 val32 = number;
+    do {
+        --attr->text.str;
+        *(attr->text.str) = attr->digits[val32 % SECUREC_RADIX_HEX];
+        val32 /= SECUREC_RADIX_HEX;
+    } while (val32 != 0);
+}
+
+#ifndef _AIX
+/* Use fast div 10 */
+SECUREC_INLINE void SecNumber32ToDecStringFast(SecUnsignedInt32 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt32 val32 = number;
+    do {
+        SecUnsignedInt32 quotient;
+        SecUnsignedInt32 remain;
+        --attr->text.str;
+        *(attr->text.str) = g_itoaLowerDigits[val32 % SECUREC_RADIX_DECIMAL];
+        quotient = (val32 >> 1U) + (val32 >> 2U); /* Fast div  magic 2 */
+        quotient = quotient + (quotient >> 4U); /* Fast div  magic 4 */
+        quotient = quotient + (quotient >> 8U); /* Fast div  magic 8 */
+        quotient = quotient + (quotient >> 16U); /* Fast div  magic 16 */
+        quotient = quotient >> 3U; /* Fast div  magic 3 */
+        remain = val32 - SECUREC_MUL_TEN(quotient);
+        val32 = (remain > 9U) ? (quotient + 1U) : quotient; /* Fast div  magic 9 */
+    } while (val32 != 0);
+}
+#endif
+
+SECUREC_INLINE void SecNumber32ToString(SecUnsignedInt32 number, SecFormatAttr *attr)
+{
+    switch (attr->radix) {
+        case SECUREC_RADIX_HEX:
+            SecNumber32ToHexString(number, attr);
+            break;
+        case SECUREC_RADIX_OCTAL:
+            SecNumber32ToOctalString(number, attr);
+            break;
+        case SECUREC_RADIX_DECIMAL:
+#ifdef _AIX
+            /* The compiler will optimize div 10 */
+            SecNumber32ToDecString(number, attr);
+#else
+            SecNumber32ToDecStringFast(number, attr);
+#endif
+            break;
+        default:
+            /* Do nothing */
+            break;
+    }
+}
+#endif
+
+#if defined(SECUREC_USE_SPECIAL_DIV64) || (defined(SECUREC_VXWORKS_VERSION_5_4) && !defined(SECUREC_ON_64BITS))
+/*
+ * This function just to clear warning, on sume vxworks compiler shift 32 bit make warnings
+ */
+SECUREC_INLINE SecUnsignedInt64 SecU64Shr32(SecUnsignedInt64 number)
+{
+    return (((number) >> 16U) >> 16U); /* Two shifts of 16 bits to realize shifts of 32 bits */
+}
+/*
+ * Fast divide by 10 algorithm.
+ * Calculation divisor multiply  0xcccccccccccccccdULL, resultHi64 >> 3 as quotient
+ */
+SECUREC_INLINE void SecU64Div10(SecUnsignedInt64 divisor, SecUnsignedInt64 *quotient, SecUnsignedInt32 *residue)
+{
+    SecUnsignedInt64 mask = 0xffffffffULL; /* Use 0xffffffffULL as 32 bit mask */
+    SecUnsignedInt64 magicHi = 0xccccccccULL; /* Fast divide 10 magic numbers high 32bit 0xccccccccULL */
+    SecUnsignedInt64 magicLow = 0xcccccccdULL; /* Fast divide 10 magic numbers low 32bit  0xcccccccdULL */
+    SecUnsignedInt64 divisorHi = (SecUnsignedInt64)(SecU64Shr32(divisor)); /* High 32 bit use  */
+    SecUnsignedInt64 divisorLow = (SecUnsignedInt64)(divisor & mask); /* Low 32 bit mask */
+    SecUnsignedInt64 factorHi = divisorHi * magicHi;
+    SecUnsignedInt64 factorLow1 = divisorHi * magicLow;
+    SecUnsignedInt64 factorLow2 = divisorLow * magicHi;
+    SecUnsignedInt64 factorLow3 = divisorLow * magicLow;
+    SecUnsignedInt64 carry = (factorLow1 & mask) + (factorLow2 & mask) + SecU64Shr32(factorLow3);
+    SecUnsignedInt64 resultHi64 = factorHi + SecU64Shr32(factorLow1) + SecU64Shr32(factorLow2) + SecU64Shr32(carry);
+
+    *quotient = resultHi64 >> 3U; /* Fast divide 10 magic numbers 3 */
+    *residue = (SecUnsignedInt32)(divisor - ((*quotient) * 10)); /* Quotient mul 10 */
+    return;
+}
+#if defined(SECUREC_VXWORKS_VERSION_5_4) && !defined(SECUREC_ON_64BITS)
+/*
+ * Divide function for VXWORKS
+ */
+SECUREC_INLINE int SecU64Div32(SecUnsignedInt64 divisor, SecUnsignedInt32 radix,
+    SecUnsignedInt64 *quotient, SecUnsignedInt32 *residue)
+{
+    switch (radix) {
+        case SECUREC_RADIX_DECIMAL:
+            SecU64Div10(divisor, quotient, residue);
+            break;
+        case SECUREC_RADIX_HEX:
+            *quotient = SECUREC_DIV_QUOTIENT_HEX(divisor);
+            *residue = (SecUnsignedInt32)SECUREC_DIV_RESIDUE_HEX(divisor);
+            break;
+        case SECUREC_RADIX_OCTAL:
+            *quotient = SECUREC_DIV_QUOTIENT_OCTAL(divisor);
+            *residue = (SecUnsignedInt32)SECUREC_DIV_RESIDUE_OCTAL(divisor);
+            break;
+        default:
+            return -1; /* This does not happen in the current file */
+    }
+    return 0;
+}
+SECUREC_INLINE void SecNumber64ToStringSpecial(SecUnsignedInt64 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt64 val64 = number;
+    do {
+        SecUnsignedInt32 digit = 0; /* Ascii value of digit */
+        SecUnsignedInt64 quotient = 0;
+        if (SecU64Div32(val64, (SecUnsignedInt32)attr->radix, &quotient, &digit) != 0) {
+            /* Just break, when enter this function, no error is returned */
+            break;
+        }
+        --attr->text.str;
+        *(attr->text.str) = attr->digits[digit];
+        val64 = quotient;
+    } while (val64 != 0);
+}
+#endif
+#endif
+
+#if defined(SECUREC_ON_64BITS) || !defined(SECUREC_VXWORKS_VERSION_5_4)
+#if defined(SECUREC_USE_SPECIAL_DIV64)
+/* The compiler does not provide 64 bit division problems */
+SECUREC_INLINE void SecNumber64ToDecString(SecUnsignedInt64 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt64 val64 = number;
+    do {
+        SecUnsignedInt64 quotient = 0;
+        SecUnsignedInt32 digit = 0;
+        SecU64Div10(val64, &quotient, &digit);
+        --attr->text.str;
+        /* Just use lowerDigits for 0 - 9 */
+        *(attr->text.str) = g_itoaLowerDigits[digit];
+        val64 = quotient;
+    } while (val64 != 0);
+}
+#else
+/*
+ * Compiler Optimized Division 10.
+ * The text.str point to buffer end, must be Large enough
+ */
+SECUREC_INLINE void SecNumber64ToDecString(SecUnsignedInt64 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt64 val64 = number;
+    do {
+        --attr->text.str;
+        /* Just use lowerDigits for 0 - 9 */
+        *(attr->text.str) = g_itoaLowerDigits[val64 % SECUREC_RADIX_DECIMAL];
+        val64 /= SECUREC_RADIX_DECIMAL;
+    } while (val64 != 0);
+}
+#endif
+
+/*
+ * Compiler Optimized Division 8.
+ * The text.str point to buffer end, must be Large enough
+ */
+SECUREC_INLINE void SecNumber64ToOctalString(SecUnsignedInt64 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt64 val64 = number;
+    do {
+        --attr->text.str;
+        /* Just use lowerDigits for 0 - 9 */
+        *(attr->text.str) = g_itoaLowerDigits[val64 % SECUREC_RADIX_OCTAL];
+        val64 /= SECUREC_RADIX_OCTAL;
+    } while (val64 != 0);
+}
+/*
+ * Compiler Optimized Division 16.
+ * The text.str point to buffer end, must be Large enough
+ */
+SECUREC_INLINE void SecNumber64ToHexString(SecUnsignedInt64 number, SecFormatAttr *attr)
+{
+    SecUnsignedInt64 val64 = number;
+    do {
+        --attr->text.str;
+        *(attr->text.str) = attr->digits[val64 % SECUREC_RADIX_HEX];
+        val64 /= SECUREC_RADIX_HEX;
+    } while (val64 != 0);
+}
+
+SECUREC_INLINE void SecNumber64ToString(SecUnsignedInt64 number, SecFormatAttr *attr)
+{
+    switch (attr->radix) {
+        /* The compiler will optimize div 10 */
+        case SECUREC_RADIX_DECIMAL:
+            SecNumber64ToDecString(number, attr);
+            break;
+        case SECUREC_RADIX_OCTAL:
+            SecNumber64ToOctalString(number, attr);
+            break;
+        case SECUREC_RADIX_HEX:
+            SecNumber64ToHexString(number, attr);
+            break;
+        default:
+            /* Do nothing */
+            break;
+    }
+}
+#endif
+
+/*
+ * Converting integers to string
+ */
+SECUREC_INLINE void SecNumberToString(SecUnsignedInt64 number, SecFormatAttr *attr)
+{
+#ifdef SECUREC_ON_64BITS
+    SecNumber64ToString(number, attr);
+#else /* For 32 bits system */
+    if (number <= 0xffffffffUL) { /* Use 0xffffffffUL to check if the value is in the 32-bit range */
+        /* In most case, the value to be converted is small value */
+        SecUnsignedInt32 n32Tmp = (SecUnsignedInt32)number;
+        SecNumber32ToString(n32Tmp, attr);
+    } else {
+        /* The value to be converted is greater than 4G */
+#if defined(SECUREC_VXWORKS_VERSION_5_4)
+        SecNumber64ToStringSpecial(number, attr);
+#else
+        SecNumber64ToString(number, attr);
+#endif
+    }
+#endif
+}
+
+SECUREC_INLINE int SecIsNumberNeedTo32Bit(const SecFormatAttr *attr)
+{
+    return (int)(((attr->flags & SECUREC_FLAG_I64) == 0) &&
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+            ((attr->flags & SECUREC_FLAG_INTMAX) == 0) &&
+#endif
+#ifdef SECUREC_ON_64BITS
+            ((attr->flags & SECUREC_FLAG_PTRDIFF) == 0) &&
+            ((attr->flags & SECUREC_FLAG_SIZE) == 0) &&
+#if !defined(SECUREC_COMPATIBLE_WIN_FORMAT)  /* on window 64 system sizeof long is 32bit */
+            ((attr->flags & SECUREC_FLAG_LONG) == 0) &&
+#endif
+#endif
+            ((attr->flags & SECUREC_FLAG_LONGLONG) == 0));
+}
+
+SECUREC_INLINE void SecNumberToBuffer(SecFormatAttr *attr, SecInt64 num64)
+{
+    SecUnsignedInt64 number;
+    /* Check for negative; copy into number */
+    if ((attr->flags & SECUREC_FLAG_SIGNED) != 0 && num64 < 0) {
+        number = (SecUnsignedInt64)(0 - (SecUnsignedInt64)num64); /* Wrap with unsigned int64 numbers */
+        attr->flags |= SECUREC_FLAG_NEGATIVE;
+    } else {
+        number = (SecUnsignedInt64)num64;
+    }
+    if (SecIsNumberNeedTo32Bit(attr) != 0) {
+        number = (number & (SecUnsignedInt64)0xffffffffUL);  /* Use 0xffffffff as 32 bit mask */
+    }
+
+    /* The text.str must be point to buffer.str, this pointer is used outside the function */
+    attr->text.str = &attr->buffer.str[SECUREC_BUFFER_SIZE];
+
+    if (number == 0) {
+        /* Turn off hex prefix default, and textLen is zero */
+        attr->prefixLen = 0;
+        attr->textLen = 0;
+        return;
+    }
+
+    /* Convert integer to string. It must be invoked when number > 0, otherwise the following logic is incorrect */
+    SecNumberToString(number, attr);
+    /* Compute length of number,  text.str must be in buffer.str */
+    attr->textLen = (int)(size_t)((char *)&attr->buffer.str[SECUREC_BUFFER_SIZE] - attr->text.str);
+}
+
+/*
+ * Write one character to dest buffer
+ */
+SECUREC_INLINE void SecWriteChar(SecPrintfStream *stream, SecChar ch, int *charsOut)
+{
+    /* Count must be reduced first, In order to identify insufficient length */
+    --stream->count;
+    if (stream->count >= 0) {
+        *(stream->cur) = ch;
+        ++stream->cur;
+        *charsOut = *charsOut + 1;
+        return;
+    }
+    /* No enough length */
+    *charsOut = -1;
+}
+
+/*
+* Write multiple identical characters.
+*/
+SECUREC_INLINE void SecWriteMultiChar(SecPrintfStream *stream, SecChar ch, int num, int *charsOut)
+{
+    int count;
+    for (count = num; count > 0; --count) {
+        --stream->count; /* count may be negative,indicating insufficient space */
+        if (stream->count < 0) {
+            *charsOut = -1;
+            return;
+        }
+        *(stream->cur) = ch;
+        ++stream->cur;
+    }
+    *charsOut = *charsOut + num;
+}
+
+/*
+* Write string function, where this function is called, make sure that len is greater than 0
+*/
+SECUREC_INLINE void SecWriteString(SecPrintfStream *stream, const SecChar *str, int len, int *charsOut)
+{
+    const SecChar *tmp = str;
+    int count;
+    for (count = len; count > 0; --count) {
+        --stream->count; /* count may be negative,indicating insufficient space */
+        if (stream->count < 0) {
+            *charsOut = -1;
+            return;
+        }
+        *(stream->cur) = *tmp;
+        ++stream->cur;
+        ++tmp;
+    }
+    *charsOut = *charsOut + len;
+}
+
+/* Use loop copy char or wchar_t string */
+SECUREC_INLINE void SecWriteStringByLoop(SecPrintfStream *stream, const SecChar *str, int len)
+{
+    int i;
+    const SecChar *tmp = str;
+    for (i = 0; i < len; ++i) {
+        *stream->cur = *tmp;
+        ++stream->cur;
+        ++tmp;
+    }
+    stream->count -= len;
+}
+
+SECUREC_INLINE void SecWriteStringOpt(SecPrintfStream *stream, const SecChar *str, int len)
+{
+    if (len < 12) { /* Performance optimization for mobile number length 12 */
+        SecWriteStringByLoop(stream, str, len);
+    } else {
+        size_t count = (size_t)(unsigned int)len * sizeof(SecChar);
+        SECUREC_MEMCPY_WARP_OPT(stream->cur, str, count);
+        stream->cur += len;
+        stream->count -= len;
+    }
+}
+
+/*
+ * Return if buffer length is enough
+ * The count variable can be reduced to 0, and the external function complements the \0 terminator.
+ */
+SECUREC_INLINE int SecIsStreamBufEnough(const SecPrintfStream *stream, int needLen)
+{
+    return (int)(stream->count >= needLen);
+}
+
+/* Write text string */
+SECUREC_INLINE void SecWriteTextOpt(SecPrintfStream *stream, const SecChar *str, int len, int *charsOut)
+{
+    if (SecIsStreamBufEnough(stream, len) != 0) {
+        SecWriteStringOpt(stream, str, len);
+        *charsOut += len;
+    } else {
+        SecWriteString(stream, str, len, charsOut);
+    }
+}
+
+/* Write left padding */
+SECUREC_INLINE void SecWriteLeftPadding(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
+{
+    if ((attr->flags & (SECUREC_FLAG_LEFT | SECUREC_FLAG_LEADZERO)) == 0 && attr->padding > 0) {
+        /* Pad on left with blanks */
+        SecWriteMultiChar(stream, SECUREC_CHAR(' '), attr->padding, charsOut);
+    }
+}
+
+/* Write prefix */
+SECUREC_INLINE void SecWritePrefix(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
+{
+    if (attr->prefixLen > 0) {
+        SecWriteString(stream, attr->prefix, attr->prefixLen, charsOut);
+    }
+}
+
+/* Write leading zeros */
+SECUREC_INLINE void SecWriteLeadingZero(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
+{
+    if ((attr->flags & SECUREC_FLAG_LEADZERO) != 0 && (attr->flags & SECUREC_FLAG_LEFT) == 0 &&
+        attr->padding > 0) {
+        SecWriteMultiChar(stream, SECUREC_CHAR('0'), attr->padding, charsOut);
+    }
+}
+
+/* Write right padding */
+SECUREC_INLINE void SecWriteRightPadding(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
+{
+    if (*charsOut >= 0 && (attr->flags & SECUREC_FLAG_LEFT) != 0 && attr->padding > 0) {
+        /* Pad on right with blanks */
+        SecWriteMultiChar(stream, SECUREC_CHAR(' '), attr->padding, charsOut);
+    }
+}
+
+#ifdef SECUREC_FOR_WCHAR
+#define SECUREC_TEXT_CHAR_PTR(text)  ((text).wStr)
+#define SECUREC_NEED_CONVERT_TEXT(attr) ((attr)->textIsWide == 0)
+#if SECUREC_HAVE_MBTOWC
+#define SECUREC_WRITE_TEXT_AFTER_CONVERT(stream, attr, charsOut) SecWriteTextAfterMbtowc((stream), (attr), (charsOut))
+#else
+#define SECUREC_WRITE_TEXT_AFTER_CONVERT(stream, attr, charsOut) (*(charsOut) = -1)
+#endif
+#else
+#define SECUREC_TEXT_CHAR_PTR(text)  ((text).str)
+#define SECUREC_NEED_CONVERT_TEXT(attr) ((attr)->textIsWide != 0)
+#if SECUREC_HAVE_WCTOMB
+#define SECUREC_WRITE_TEXT_AFTER_CONVERT(stream, attr, charsOut) SecWriteTextAfterWctomb((stream), (attr), (charsOut))
+#else
+#define SECUREC_WRITE_TEXT_AFTER_CONVERT(stream, attr, charsOut) (*(charsOut) = -1)
+#endif
+#endif
+
+#ifdef SECUREC_FOR_WCHAR
+#if SECUREC_HAVE_MBTOWC
+SECUREC_INLINE void SecWriteTextAfterMbtowc(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
+{
+    const char *p = attr->text.str;
+    int count = attr->textLen;
+    while (count > 0) {
+        wchar_t wChar = L'\0';
+        int retVal = mbtowc(&wChar, p, (size_t)MB_CUR_MAX);
+        if (retVal <= 0) {
+            *charsOut = -1;
+            break;
+        }
+        SecWriteChar(stream, wChar, charsOut);
+        if (*charsOut == -1) {
+            break;
+        }
+        p += retVal;
+        count -= retVal;
+    }
+}
+#endif
+#else  /* Not SECUREC_FOR_WCHAR */
+#if SECUREC_HAVE_WCTOMB
+SECUREC_INLINE void SecWriteTextAfterWctomb(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
+{
+    const wchar_t *p = attr->text.wStr;
+    int count = attr->textLen;
+    while (count > 0) {
+        char tmpBuf[SECUREC_MB_LEN + 1];
+        SECUREC_MASK_MSVC_CRT_WARNING
+        int retVal = wctomb(tmpBuf, *p);
+        SECUREC_END_MASK_MSVC_CRT_WARNING
+        if (retVal <= 0) {
+            *charsOut = -1;
+            break;
+        }
+        SecWriteString(stream, tmpBuf, retVal, charsOut);
+        if (*charsOut == -1) {
+            break;
+        }
+        --count;
+        ++p;
+    }
+}
+#endif
+#endif
+
+#if SECUREC_ENABLE_SPRINTF_FLOAT
+/*
+ * Write text of float
+ * Using independent functions to optimize the expansion of inline functions by the compiler
+ */
+SECUREC_INLINE void SecWriteFloatText(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
+{
+#ifdef SECUREC_FOR_WCHAR
+#if SECUREC_HAVE_MBTOWC
+    SecWriteTextAfterMbtowc(stream, attr, charsOut);
+#else
+    *charsOut = -1;
+    (void)stream; /* To clear e438 last value assigned not used , the compiler will optimize this code */
+    (void)attr;   /* To clear e438 last value assigned not used , the compiler will optimize this code */
+#endif
+#else /* Not SECUREC_FOR_WCHAR */
+    SecWriteString(stream, attr->text.str, attr->textLen, charsOut);
+#endif
+}
+#endif
+
+/* Write text of integer or string ... */
+SECUREC_INLINE void SecWriteText(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
+{
+    if (SECUREC_NEED_CONVERT_TEXT(attr)) {
+        SECUREC_WRITE_TEXT_AFTER_CONVERT(stream, attr, charsOut);
+    } else {
+        SecWriteTextOpt(stream, SECUREC_TEXT_CHAR_PTR(attr->text), attr->textLen, charsOut);
+    }
+}
+
+#define SECUREC_FMT_STATE_OFFSET  256
+
+SECUREC_INLINE SecFmtState SecDecodeState(SecChar ch, SecFmtState lastState)
+{
+    static const unsigned char stateTable[SECUREC_STATE_TABLE_SIZE] = {
+        /*
+         * Type
+         * 0:    nospecial meaning;
+         * 1:    '%'
+         * 2:    '.'
+         * 3:    '*'
+         * 4:    '0'
+         * 5:    '1' ... '9'
+         * 6:    ' ', '+', '-', '#'
+         * 7:    'h', 'l', 'L', 'w' , 'N', 'z', 'q', 't', 'j'
+         * 8:    'd', 'o', 'u', 'i', 'x', 'X', 'e', 'f', 'g', 'E', 'F', 'G', 's', 'c', '[', 'p'
+         */
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x00,
+        0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x08, 0x08, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00,
+        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07, 0x08, 0x07, 0x00, 0x07, 0x00, 0x00, 0x08,
+        0x08, 0x07, 0x00, 0x08, 0x07, 0x08, 0x00, 0x07, 0x08, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
+        /* Fill zero  for normal char 128 byte for 0x80 - 0xff */
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        /*
+         * State
+         * 0: normal
+         * 1: percent
+         * 2: flag
+         * 3: width
+         * 4: dot
+         * 5: precis
+         * 6: size
+         * 7: type
+         * 8: invalid
+         */
+        0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x01, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x01, 0x00, 0x00, 0x04, 0x04, 0x04, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x03, 0x03, 0x08, 0x05,
+        0x08, 0x08, 0x00, 0x00, 0x00, 0x02, 0x02, 0x03, 0x05, 0x05, 0x08, 0x00, 0x00, 0x00, 0x03, 0x03,
+        0x03, 0x05, 0x05, 0x08, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00,
+        0x00
+    };
+
+#ifdef SECUREC_FOR_WCHAR
+    /* Convert to unsigned char to clear gcc 4.3.4 warning */
+    unsigned char fmtType = (unsigned char)((((unsigned int)(int)(ch)) <= (unsigned int)(int)(L'~')) ? \
+        (stateTable[(unsigned char)(ch)]) : 0);
+    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
+        (unsigned char)(lastState) + SECUREC_FMT_STATE_OFFSET]);
+#else
+    unsigned char fmtType = stateTable[(unsigned char)(ch)];
+    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
+        (unsigned char)(lastState) + SECUREC_FMT_STATE_OFFSET]);
+#endif
+}
+
+SECUREC_INLINE void SecDecodeFlags(SecChar ch, SecFormatAttr *attr)
+{
+    switch (ch) {
+        case SECUREC_CHAR(' '):
+            attr->flags |= SECUREC_FLAG_SIGN_SPACE;
+            break;
+        case SECUREC_CHAR('+'):
+            attr->flags |= SECUREC_FLAG_SIGN;
+            break;
+        case SECUREC_CHAR('-'):
+            attr->flags |= SECUREC_FLAG_LEFT;
+            break;
+        case SECUREC_CHAR('0'):
+            attr->flags |= SECUREC_FLAG_LEADZERO;   /* Add zero th the front */
+            break;
+        case SECUREC_CHAR('#'):
+            attr->flags |= SECUREC_FLAG_ALTERNATE;  /* Output %x with 0x */
+            break;
+        default:
+            /* Do nothing */
+            break;
+    }
+    return;
+}
+
+/*
+ * Decoded size identifier in format string to Reduce the number of lines of function code
+ */
+SECUREC_INLINE int SecDecodeSizeI(SecFormatAttr *attr, const SecChar **format)
+{
+#ifdef SECUREC_ON_64BITS
+    attr->flags |= SECUREC_FLAG_I64;    /* %I  to  INT64 */
+#endif
+    if ((**format == SECUREC_CHAR('6')) && (*((*format) + 1) == SECUREC_CHAR('4'))) {
+        (*format) += 2; /* Add 2 to skip I64 */
+        attr->flags |= SECUREC_FLAG_I64;    /* %I64  to  INT64 */
+    } else if ((**format == SECUREC_CHAR('3')) && (*((*format) + 1) == SECUREC_CHAR('2'))) {
+        (*format) += 2; /* Add 2 to skip I32 */
+        attr->flags &= ~SECUREC_FLAG_I64;   /* %I64  to  INT32 */
+    } else if ((**format == SECUREC_CHAR('d')) || (**format == SECUREC_CHAR('i')) ||
+        (**format == SECUREC_CHAR('o')) || (**format == SECUREC_CHAR('u')) ||
+        (**format == SECUREC_CHAR('x')) || (**format == SECUREC_CHAR('X'))) {
+        /* Do nothing */
+    } else {
+        /* Compatibility  code for "%I" just print I */
+        return -1;
+    }
+    return 0;
+}
+
+/*
+ * Decoded size identifier in format string, and skip format to next charater
+ */
+SECUREC_INLINE int SecDecodeSize(SecChar ch, SecFormatAttr *attr, const SecChar **format)
+{
+    switch (ch) {
+        case SECUREC_CHAR('l'):
+            if (**format == SECUREC_CHAR('l')) {
+                *format = *format + 1;
+                attr->flags |= SECUREC_FLAG_LONGLONG; /* For long long */
+            } else {
+                attr->flags |= SECUREC_FLAG_LONG;     /* For long int or wchar_t */
+            }
+            break;
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+        case SECUREC_CHAR('z'): /* fall-through */ /* FALLTHRU */
+        case SECUREC_CHAR('Z'):
+            attr->flags |= SECUREC_FLAG_SIZE;
+            break;
+        case SECUREC_CHAR('j'):
+            attr->flags |= SECUREC_FLAG_INTMAX;
+            break;
+#endif
+        case SECUREC_CHAR('t'):
+            attr->flags |= SECUREC_FLAG_PTRDIFF;
+            break;
+        case SECUREC_CHAR('q'): /* fall-through */ /* FALLTHRU */
+        case SECUREC_CHAR('L'):
+            attr->flags |= (SECUREC_FLAG_LONGLONG | SECUREC_FLAG_LONG_DOUBLE);
+            break;
+        case SECUREC_CHAR('I'):
+            if (SecDecodeSizeI(attr, format) != 0) {
+                /* Compatibility  code for "%I" just print I */
+                return -1;
+            }
+            break;
+        case SECUREC_CHAR('h'):
+            if (**format == SECUREC_CHAR('h')) {
+                *format = *format + 1;
+                attr->flags |= SECUREC_FLAG_CHAR;   /* For char */
+            } else {
+                attr->flags |= SECUREC_FLAG_SHORT;  /* For short int */
+            }
+            break;
+        case SECUREC_CHAR('w'):
+            attr->flags |= SECUREC_FLAG_WIDECHAR;   /* For wide char */
+            break;
+        default:
+            /* Do nothing */
+            break;
+    }
+    return 0;
+}
+
+/*
+ * Decoded char type identifier
+ */
+SECUREC_INLINE void SecDecodeTypeC(SecFormatAttr *attr, unsigned int c)
+{
+    attr->textLen = 1; /* Only 1 wide character */
+
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT)) && !(defined(__hpux)) && !(defined(SECUREC_ON_SOLARIS))
+    attr->flags &= ~SECUREC_FLAG_LEADZERO;
+#endif
+
+#ifdef SECUREC_FOR_WCHAR
+    if ((attr->flags & SECUREC_FLAG_SHORT) != 0) {
+        /* Get  multibyte character from argument */
+        attr->buffer.str[0] = (char)c;
+        attr->text.str = attr->buffer.str;
+        attr->textIsWide = 0;
+    } else {
+        attr->buffer.wStr[0] = (wchar_t)c;
+        attr->text.wStr = attr->buffer.wStr;
+        attr->textIsWide = 1;
+    }
+#else /* Not SECUREC_FOR_WCHAR */
+    if ((attr->flags & (SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) != 0) {
+#if SECUREC_HAVE_WCHART
+        attr->buffer.wStr[0] = (wchar_t)c;
+        attr->text.wStr = attr->buffer.wStr;
+        attr->textIsWide = 1;
+#else
+        attr->textLen = 0; /* Ignore unsupported characters */
+        attr->fldWidth = 0; /* No paddings  */
+#endif
+    } else {
+        /* Get  multibyte character from argument */
+        attr->buffer.str[0] = (char)c;
+        attr->text.str = attr->buffer.str;
+        attr->textIsWide = 0;
+    }
+#endif
+}
+
+#ifdef SECUREC_FOR_WCHAR
+#define SECUREC_IS_NARROW_STRING(attr) (((attr)->flags & SECUREC_FLAG_SHORT) != 0)
+#else
+#define SECUREC_IS_NARROW_STRING(attr) (((attr)->flags & (SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) == 0)
+#endif
+
+SECUREC_INLINE void SecDecodeTypeSchar(SecFormatAttr *attr)
+{
+    size_t textLen;
+    if (attr->text.str == NULL) {
+        /*
+         * Literal string to print null ptr, define it as array rather than const text area
+         * To avoid gcc warning with pointing const text with variable
+         */
+        static char strNullString[SECUREC_NULL_STRING_SIZE] = "(null)";
+        attr->text.str = strNullString;
+    }
+    if (attr->precision == -1) {
+        /* Precision NOT assigned */
+        /* The strlen performance is high when the string length is greater than 32 */
+        textLen = strlen(attr->text.str);
+        if (textLen > SECUREC_STRING_MAX_LEN) {
+            textLen = 0;
+        }
+    } else {
+        /* Precision assigned */
+        SECUREC_CALC_STR_LEN(attr->text.str, (size_t)(unsigned int)attr->precision, &textLen);
+    }
+    attr->textLen = (int)textLen;
+}
+
+SECUREC_INLINE void SecDecodeTypeSwchar(SecFormatAttr *attr)
+{
+#if SECUREC_HAVE_WCHART
+    size_t textLen;
+    attr->textIsWide = 1;
+    if (attr->text.wStr == NULL) {
+        /*
+         * Literal string to print null ptr, define it as array rather than const text area
+         * To avoid gcc warning with pointing const text with variable
+         */
+        static wchar_t wStrNullString[SECUREC_NULL_STRING_SIZE] = { L'(', L'n', L'u', L'l', L'l', L')', L'\0', L'\0' };
+        attr->text.wStr = wStrNullString;
+    }
+    /* The textLen in wchar_t,when precision is -1, it is unlimited  */
+    SECUREC_CALC_WSTR_LEN(attr->text.wStr, (size_t)(unsigned int)attr->precision, &textLen);
+    if (textLen > SECUREC_WCHAR_STRING_MAX_LEN) {
+        textLen = 0;
+    }
+    attr->textLen = (int)textLen;
+#else
+    attr->textLen = 0;
+#endif
+}
+
+/*
+ * Decoded string identifier
+ */
+SECUREC_INLINE void SecDecodeTypeS(SecFormatAttr *attr, char *argPtr)
+{
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT))
+#if (!defined(SECUREC_ON_UNIX))
+    attr->flags &= ~SECUREC_FLAG_LEADZERO;
+#endif
+#if (defined(SECUREC_FOR_WCHAR))
+    if ((attr->flags & SECUREC_FLAG_LONG) == 0) {
+        attr->flags |= SECUREC_FLAG_SHORT;
+    }
+#endif
+#endif
+    attr->text.str = argPtr;
+    if (SECUREC_IS_NARROW_STRING(attr)) {
+        /* The textLen now contains length in multibyte chars */
+        SecDecodeTypeSchar(attr);
+    } else {
+        /* The textLen now contains length in wide chars */
+        SecDecodeTypeSwchar(attr);
+    }
+}
+
+/*
+ * Check precision in format
+ */
+SECUREC_INLINE int SecDecodePrecision(SecChar ch, SecFormatAttr *attr)
+{
+    if (attr->dynPrecision == 0) {
+        /* Add digit to current precision */
+        if (SECUREC_MUL_TEN_ADD_BEYOND_MAX(attr->precision)) {
+            return -1;
+        }
+        attr->precision = (int)SECUREC_MUL_TEN((unsigned int)attr->precision) +
+            (unsigned char)(ch - SECUREC_CHAR('0'));
+    } else {
+        if (attr->precision < 0) {
+            attr->precision = -1;
+        }
+        if (attr->precision > SECUREC_MAX_WIDTH_LEN) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+/*
+ * Check width in format
+ */
+SECUREC_INLINE int SecDecodeWidth(SecChar ch, SecFormatAttr *attr, SecFmtState lastState)
+{
+    if (attr->dynWidth == 0) {
+        if (lastState != STAT_WIDTH) {
+            attr->fldWidth = 0;
+        }
+        if (SECUREC_MUL_TEN_ADD_BEYOND_MAX(attr->fldWidth)) {
+            return -1;
+        }
+        attr->fldWidth = (int)SECUREC_MUL_TEN((unsigned int)attr->fldWidth) +
+            (unsigned char)(ch - SECUREC_CHAR('0'));
+    } else {
+        if (attr->fldWidth < 0) {
+            attr->flags |= SECUREC_FLAG_LEFT;
+            attr->fldWidth = (-attr->fldWidth);
+        }
+        if (attr->fldWidth > SECUREC_MAX_WIDTH_LEN) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+/*
+ * The sprintf_s function processes the wide character as a parameter for %C
+ * The swprintf_s function processes the multiple character as a parameter for %C
+ */
+SECUREC_INLINE void SecUpdateWcharFlags(SecFormatAttr *attr)
+{
+    if ((attr->flags & (SECUREC_FLAG_SHORT | SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) == 0) {
+#ifdef SECUREC_FOR_WCHAR
+        attr->flags |= SECUREC_FLAG_SHORT;
+#else
+        attr->flags |= SECUREC_FLAG_WIDECHAR;
+#endif
+    }
+}
+/*
+ * When encountering %S, current just same as %C
+ */
+SECUREC_INLINE void SecUpdateWstringFlags(SecFormatAttr *attr)
+{
+    SecUpdateWcharFlags(attr);
+}
+
+#if SECUREC_IN_KERNEL
+SECUREC_INLINE void SecUpdatePointFlagsForKernel(SecFormatAttr *attr)
+{
+    /* Width is not set */
+    if (attr->fldWidth <= 0) {
+        attr->flags |= SECUREC_FLAG_LEADZERO;
+        attr->fldWidth = 2 * sizeof(void *);  /* 2 x byte number is the length of hex */
+    }
+    if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
+        /* Alternate form means '0x' prefix */
+        attr->prefix[0] = SECUREC_CHAR('0');
+        attr->prefix[1] = SECUREC_CHAR('x');
+        attr->prefixLen = SECUREC_PREFIX_LEN;
+    }
+    attr->flags |= SECUREC_FLAG_LONG;  /* Converting a long */
+}
+#endif
+
+SECUREC_INLINE void SecUpdatePointFlags(SecFormatAttr *attr)
+{
+    attr->flags |= SECUREC_FLAG_POINTER;
+#if SECUREC_IN_KERNEL
+    SecUpdatePointFlagsForKernel(attr);
+#else
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM)) && (!defined(SECUREC_ON_UNIX))
+#if defined(SECUREC_VXWORKS_PLATFORM)
+    attr->precision = 1;
+#else
+    attr->precision = 0;
+#endif
+    attr->flags |= SECUREC_FLAG_ALTERNATE; /* "0x" is not default prefix in UNIX */
+    attr->digits = g_itoaLowerDigits;
+#else /* On unix or win */
+#if defined(_AIX) || defined(SECUREC_ON_SOLARIS)
+    attr->precision = 1;
+#else
+    attr->precision = 2 * sizeof(void *);  /* 2 x byte number is the length of hex */
+#endif
+#if defined(SECUREC_ON_UNIX)
+    attr->digits = g_itoaLowerDigits;
+#else
+    attr->digits = g_itoaUpperDigits;
+#endif
+#endif
+
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+    attr->flags &= ~SECUREC_FLAG_LEADZERO;
+#endif
+
+#ifdef SECUREC_ON_64BITS
+    attr->flags |= SECUREC_FLAG_I64;   /* Converting an int64 */
+#else
+    attr->flags |= SECUREC_FLAG_LONG;  /* Converting a long */
+#endif
+    /* Set up for %#p on different system */
+    if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
+        /* Alternate form means '0x' prefix */
+        attr->prefix[0] = SECUREC_CHAR('0');
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM))
+        attr->prefix[1] = SECUREC_CHAR('x');
+#else
+        attr->prefix[1] = (SecChar)(attr->digits[SECUREC_NUMBER_OF_X]);
+#endif
+#if defined(_AIX) || defined(SECUREC_ON_SOLARIS)
+        attr->prefixLen = 0;
+#else
+        attr->prefixLen = SECUREC_PREFIX_LEN;
+#endif
+    }
+#endif
+}
+
+SECUREC_INLINE void SecUpdateXpxFlags(SecFormatAttr *attr, SecChar ch)
+{
+    /* Use unsigned lower hex output for 'x' */
+    attr->digits = g_itoaLowerDigits;
+    attr->radix = SECUREC_RADIX_HEX;
+    switch (ch) {
+        case SECUREC_CHAR('p'):
+            /* Print a pointer */
+            SecUpdatePointFlags(attr);
+            break;
+        case SECUREC_CHAR('X'): /* fall-through */ /* FALLTHRU */
+            /* Unsigned upper hex output */
+            attr->digits = g_itoaUpperDigits;
+            /* fall-through */ /* FALLTHRU */
+        default:
+            /* For %#x or %#X */
+            if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
+                /* Alternate form means '0x' prefix */
+                attr->prefix[0] = SECUREC_CHAR('0');
+                attr->prefix[1] = (SecChar)(attr->digits[SECUREC_NUMBER_OF_X]);
+                attr->prefixLen = SECUREC_PREFIX_LEN;
+            }
+            break;
+    }
+}
+
+SECUREC_INLINE void SecUpdateOudiFlags(SecFormatAttr *attr, SecChar ch)
+{
+    /* Do not set digits here */
+    switch (ch) {
+        case SECUREC_CHAR('i'): /* fall-through */ /* FALLTHRU */
+        case SECUREC_CHAR('d'): /* fall-through */ /* FALLTHRU */
+            /* For signed decimal output */
+            attr->flags |= SECUREC_FLAG_SIGNED;
+            /* fall-through */ /* FALLTHRU */
+        case SECUREC_CHAR('u'):
+            attr->radix = SECUREC_RADIX_DECIMAL;
+            attr->digits = g_itoaLowerDigits;
+            break;
+        case SECUREC_CHAR('o'):
+            /* For unsigned octal output */
+            attr->radix = SECUREC_RADIX_OCTAL;
+            attr->digits = g_itoaLowerDigits;
+            if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
+                /* Alternate form means force a leading 0 */
+                attr->flags |= SECUREC_FLAG_FORCE_OCTAL;
+            }
+            break;
+        default:
+            /* Do nothing */
+            break;
+    }
+}
+
+#if SECUREC_ENABLE_SPRINTF_FLOAT
+SECUREC_INLINE void SecFreeFloatBuffer(SecFloatAdapt *floatAdapt)
+{
+    if (floatAdapt->floatBuffer != NULL) {
+        SECUREC_FREE(floatAdapt->floatBuffer);
+    }
+    if (floatAdapt->allocatedFmtStr != NULL) {
+        SECUREC_FREE(floatAdapt->allocatedFmtStr);
+    }
+    floatAdapt->floatBuffer = NULL;
+    floatAdapt->allocatedFmtStr = NULL;
+    floatAdapt->fmtStr = NULL;
+    floatAdapt->bufferSize = 0;
+}
+
+SECUREC_INLINE void SecSeekToFrontPercent(const SecChar **format)
+{
+    const SecChar *fmt = *format;
+    while (*fmt != SECUREC_CHAR('%')) { /* Must meet '%' */
+        --fmt;
+    }
+    *format = fmt;
+}
+
+/* Init float format, return 0 is OK */
+SECUREC_INLINE int SecInitFloatFmt(SecFloatAdapt *floatFmt, const SecChar *format)
+{
+    const SecChar *fmt = format - 2;  /* Sub 2 to the position before 'f' or 'g' */
+    int fmtStrLen;
+    int i;
+
+    SecSeekToFrontPercent(&fmt);
+    /* Now fmt point to '%' */
+    fmtStrLen = (int)(size_t)(format - fmt) + 1;   /* With ending terminator */
+    if (fmtStrLen > (int)sizeof(floatFmt->buffer)) {
+        /* When buffer is NOT enough, alloc a new buffer */
+        floatFmt->allocatedFmtStr = (char *)SECUREC_MALLOC((size_t)((unsigned int)fmtStrLen));
+        if (floatFmt->allocatedFmtStr == NULL) {
+            return -1;
+        }
+        floatFmt->fmtStr = floatFmt->allocatedFmtStr;
+    } else {
+        floatFmt->fmtStr = floatFmt->buffer;
+        floatFmt->allocatedFmtStr = NULL; /* Must set to NULL, later code free memory based on this identity */
+    }
+
+    for (i = 0; i < fmtStrLen - 1; ++i) {
+        /* Convert wchar to char */
+        floatFmt->fmtStr[i] = (char)(fmt[i]);  /* Copy the format string */
+    }
+    floatFmt->fmtStr[fmtStrLen - 1] = '\0';
+
+    return 0;
+}
+
+/* Init float buffer and format, return 0 is OK */
+SECUREC_INLINE int SecInitFloatBuffer(SecFloatAdapt *floatAdapt, const SecChar *format, SecFormatAttr *attr)
+{
+    floatAdapt->allocatedFmtStr = NULL;
+    floatAdapt->fmtStr = NULL;
+    floatAdapt->floatBuffer = NULL;
+    /* Compute the precision value */
+    if (attr->precision < 0) {
+        attr->precision = SECUREC_FLOAT_DEFAULT_PRECISION;
+    }
+    /*
+     * Calc buffer size to store double value
+     * The maximum length of SECUREC_MAX_WIDTH_LEN is enough
+     */
+    if ((attr->flags & SECUREC_FLAG_LONG_DOUBLE) != 0) {
+        if (attr->precision > (SECUREC_MAX_WIDTH_LEN - SECUREC_FLOAT_BUFSIZE_LB)) {
+            return -1;
+        }
+        /* Long double needs to meet the basic print length */
+        floatAdapt->bufferSize = SECUREC_FLOAT_BUFSIZE_LB + attr->precision + SECUREC_FLOAT_BUF_EXT;
+    } else {
+        if (attr->precision > (SECUREC_MAX_WIDTH_LEN - SECUREC_FLOAT_BUFSIZE)) {
+            return -1;
+        }
+        /* Double needs to meet the basic print length */
+        floatAdapt->bufferSize = SECUREC_FLOAT_BUFSIZE + attr->precision + SECUREC_FLOAT_BUF_EXT;
+    }
+    if (attr->fldWidth > floatAdapt->bufferSize) {
+        floatAdapt->bufferSize = attr->fldWidth + SECUREC_FLOAT_BUF_EXT;
+    }
+
+    if (floatAdapt->bufferSize > SECUREC_BUFFER_SIZE) {
+        /* The current value of SECUREC_BUFFER_SIZE could not store the formatted float string */
+        floatAdapt->floatBuffer = (char *)SECUREC_MALLOC(((size_t)(unsigned int)floatAdapt->bufferSize));
+        if (floatAdapt->floatBuffer == NULL) {
+            return -1;
+        }
+        attr->text.str = floatAdapt->floatBuffer;
+    } else {
+        attr->text.str = attr->buffer.str; /* Output buffer for float string with default size */
+    }
+
+    if (SecInitFloatFmt(floatAdapt, format) != 0) {
+        if (floatAdapt->floatBuffer != NULL) {
+            SECUREC_FREE(floatAdapt->floatBuffer);
+            floatAdapt->floatBuffer = NULL;
+        }
+        return -1;
+    }
+    return 0;
+}
+#endif
+
+SECUREC_INLINE SecInt64 SecUpdateNegativeChar(SecFormatAttr *attr, char ch)
+{
+    SecInt64 num64 = ch; /* Sign extend */
+    if (num64 >= 128) { /* 128 on some platform, char is always unsigned */
+        unsigned char tmp = (unsigned char)(~((unsigned char)ch));
+        num64 = tmp + 1;
+        attr->flags |= SECUREC_FLAG_NEGATIVE;
+    }
+    return num64;
+}
+
+/*
+ * If the precision is not satisfied, zero is added before the string
+ */
+SECUREC_INLINE void SecNumberSatisfyPrecision(SecFormatAttr *attr)
+{
+    int precision;
+    if (attr->precision < 0) {
+        precision = 1; /* Default precision 1 */
+    } else {
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+        attr->flags &= ~SECUREC_FLAG_LEADZERO;
+#else
+        if ((attr->flags & SECUREC_FLAG_POINTER) == 0) {
+            attr->flags &= ~SECUREC_FLAG_LEADZERO;
+        }
+#endif
+        if (attr->precision > SECUREC_MAX_PRECISION) {
+            attr->precision = SECUREC_MAX_PRECISION;
+        }
+        precision = attr->precision;
+    }
+    while (attr->textLen < precision) {
+        --attr->text.str;
+        *(attr->text.str) = '0';
+        ++attr->textLen;
+    }
+}
+
+/*
+ * Add leading zero for %#o
+ */
+SECUREC_INLINE void SecNumberForceOctal(SecFormatAttr *attr)
+{
+    /* Force a leading zero if FORCEOCTAL flag set */
+    if ((attr->flags & SECUREC_FLAG_FORCE_OCTAL) != 0 &&
+        (attr->textLen == 0 || attr->text.str[0] != '0')) {
+        --attr->text.str;
+        *(attr->text.str) = '0';
+        ++attr->textLen;
+    }
+}
+
+SECUREC_INLINE void SecUpdateSignedNumberPrefix(SecFormatAttr *attr)
+{
+    if ((attr->flags & SECUREC_FLAG_SIGNED) == 0) {
+        return;
+    }
+    if ((attr->flags & SECUREC_FLAG_NEGATIVE) != 0) {
+        /* Prefix is '-' */
+        attr->prefix[0] = SECUREC_CHAR('-');
+        attr->prefixLen = 1;
+        return;
+    }
+    if ((attr->flags & SECUREC_FLAG_SIGN) != 0) {
+        /* Prefix is '+' */
+        attr->prefix[0] = SECUREC_CHAR('+');
+        attr->prefixLen = 1;
+        return;
+    }
+    if ((attr->flags & SECUREC_FLAG_SIGN_SPACE) != 0) {
+        /* Prefix is ' ' */
+        attr->prefix[0] = SECUREC_CHAR(' ');
+        attr->prefixLen = 1;
+        return;
+    }
+    return;
+}
+
+SECUREC_INLINE void SecNumberCompatZero(SecFormatAttr *attr)
+{
+#if SECUREC_IN_KERNEL
+    if ((attr->flags & SECUREC_FLAG_POINTER) != 0) {
+        static char strNullPointer[SECUREC_NULL_STRING_SIZE] = "(null)";
+        attr->text.str = strNullPointer;
+        attr->textLen = 6; /* Length of (null) is 6 */
+        attr->flags &= ~SECUREC_FLAG_LEADZERO;
+        attr->prefixLen = 0;
+        if (attr->precision >= 0 && attr->precision < attr->textLen) {
+            attr->textLen = attr->precision;
+        }
+    }
+    if ((attr->flags & SECUREC_FLAG_POINTER) == 0 && attr->radix == SECUREC_RADIX_HEX &&
+        (attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
+        /* Add 0x prefix for %x or %X, the prefix string has been set before */
+        attr->prefixLen = SECUREC_PREFIX_LEN;
+    }
+#elif defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && (!defined(SECUREC_ON_UNIX))
+    if ((attr->flags & SECUREC_FLAG_POINTER) != 0) {
+        static char strNullPointer[SECUREC_NULL_STRING_SIZE] = "(nil)";
+        attr->text.str = strNullPointer;
+        attr->textLen = 5; /* Length of (nil) is 5 */
+        attr->flags &= ~SECUREC_FLAG_LEADZERO;
+    }
+#elif defined(SECUREC_VXWORKS_PLATFORM) || defined(__hpux)
+    if ((attr->flags & SECUREC_FLAG_POINTER) != 0 && (attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
+        /* Add 0x prefix for %p, the prefix string has been set before */
+        attr->prefixLen = SECUREC_PREFIX_LEN;
+    }
+#endif
+    (void)attr; /* To clear e438 last value assigned not used , the compiler will optimize this code */
+}
+
+/*
+ * Formatting output core function
+ */
+SECUREC_INLINE int SecOutput(SecPrintfStream *stream, const SecChar *cFormat, va_list argList)
+{
+    const SecChar *format = cFormat;
+    int charsOut;               /* Characters written */
+    int noOutput = 0; /* Must be initialized or compiler alerts */
+    SecFmtState state;
+    SecFormatAttr formatAttr;
+
+    formatAttr.flags = 0;
+    formatAttr.textIsWide = 0;    /* Flag for buffer contains wide chars */
+    formatAttr.fldWidth = 0;
+    formatAttr.precision = 0;
+    formatAttr.dynWidth = 0;
+    formatAttr.dynPrecision = 0;
+    formatAttr.digits = g_itoaUpperDigits;
+    formatAttr.radix = SECUREC_RADIX_DECIMAL;
+    formatAttr.padding = 0;
+    formatAttr.textLen = 0;
+    formatAttr.text.str = NULL;
+    formatAttr.prefixLen = 0;
+    formatAttr.prefix[0] = SECUREC_CHAR('\0');
+    formatAttr.prefix[1] = SECUREC_CHAR('\0');
+    charsOut = 0;
+    state = STAT_NORMAL;        /* Starting state */
+
+    /* Loop each format character */
+    while (*format != SECUREC_CHAR('\0') && charsOut >= 0) {
+        SecFmtState lastState = state;
+        SecChar ch = *format; /* Currently read character */
+        ++format;
+        state = SecDecodeState(ch, lastState);
+        switch (state) {
+            case STAT_NORMAL:
+                SecWriteChar(stream, ch, &charsOut);
+                continue;
+            case STAT_PERCENT:
+                /* Set default values */
+                noOutput = 0;
+                formatAttr.prefixLen = 0;
+                formatAttr.textLen = 0;
+                formatAttr.flags = 0;
+                formatAttr.fldWidth = 0;
+                formatAttr.precision = -1;
+                formatAttr.textIsWide = 0;
+                formatAttr.dynWidth = 0;
+                formatAttr.dynPrecision = 0;
+                break;
+            case STAT_FLAG:
+                /* Set flag based on which flag character */
+                SecDecodeFlags(ch, &formatAttr);
+                break;
+            case STAT_WIDTH:
+                /* Update width value */
+                if (ch == SECUREC_CHAR('*')) {
+                    /* get width from arg list */
+                    formatAttr.fldWidth = (int)va_arg(argList, int);
+                    formatAttr.dynWidth = 1;
+                }
+                if (SecDecodeWidth(ch, &formatAttr, lastState) != 0) {
+                    return -1;
+                }
+                break;
+            case STAT_DOT:
+                formatAttr.precision = 0;
+                break;
+            case STAT_PRECIS:
+                /* Update precision value */
+                if (ch == SECUREC_CHAR('*')) {
+                    /* Get precision from arg list */
+                    formatAttr.precision = (int)va_arg(argList, int);
+                    formatAttr.dynPrecision = 1;
+                }
+                if (SecDecodePrecision(ch, &formatAttr) != 0) {
+                    return -1;
+                }
+                break;
+            case STAT_SIZE:
+                /* Read a size specifier, set the formatAttr.flags based on it, and skip format to next character */
+                if (SecDecodeSize(ch, &formatAttr, &format) != 0) {
+                    /* Compatibility  code for "%I" just print I */
+                    SecWriteChar(stream, ch, &charsOut);
+                    state = STAT_NORMAL;
+                    continue;
+                }
+                break;
+            case STAT_TYPE:
+                switch (ch) {
+                    case SECUREC_CHAR('C'): /* Wide char */
+                        SecUpdateWcharFlags(&formatAttr);
+                        /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('c'): {
+                        unsigned int cValue = (unsigned int)va_arg(argList, int);
+                        SecDecodeTypeC(&formatAttr, cValue);
+                        break;
+                    }
+                    case SECUREC_CHAR('S'):    /* Wide char string */
+                        SecUpdateWstringFlags(&formatAttr);
+                        /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('s'): {
+                        char *argPtr = (char *)va_arg(argList, char *);
+                        SecDecodeTypeS(&formatAttr, argPtr);
+                        break;
+                    }
+                    case SECUREC_CHAR('G'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('g'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('E'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('F'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('e'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('f'): {
+#if SECUREC_ENABLE_SPRINTF_FLOAT
+                        /* Add following code to call system sprintf API for float number */
+                        SecFloatAdapt floatAdapt;
+                        noOutput = 1; /* It's no more data needs to be written */
+
+                        /* Now format is pointer to the next character of 'f' */
+                        if (SecInitFloatBuffer(&floatAdapt, format, &formatAttr) != 0) {
+                            break;
+                        }
+
+                        if ((formatAttr.flags & SECUREC_FLAG_LONG_DOUBLE) != 0) {
+#if defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && SECUREC_ENABLE_SPRINTF_LONG_DOUBLE
+                            long double tmp = (long double)va_arg(argList, long double);
+                            SecFormatLongDouble(&formatAttr, &floatAdapt, tmp);
+#else
+                            double tmp = (double)va_arg(argList, double);
+                            SecFormatDouble(&formatAttr, &floatAdapt, tmp);
+#endif
+                        } else {
+                            double tmp = (double)va_arg(argList, double);
+                            SecFormatDouble(&formatAttr, &floatAdapt, tmp);
+                        }
+
+                        /* Only need write formatted float string */
+                        SecWriteFloatText(stream, &formatAttr, &charsOut);
+                        SecFreeFloatBuffer(&floatAdapt);
+                        break;
+#else
+                        return -1;
+#endif
+                    }
+                    case SECUREC_CHAR('X'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('p'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('x'): /* fall-through */ /* FALLTHRU */
+                        SecUpdateXpxFlags(&formatAttr, ch);
+                        /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('i'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('d'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('u'): /* fall-through */ /* FALLTHRU */
+                    case SECUREC_CHAR('o'): {
+                        SecInt64 num64;
+                        SecUpdateOudiFlags(&formatAttr, ch);
+                        /* Read argument into variable num64. Be careful, depend on the order of judgment */
+                        if ((formatAttr.flags & SECUREC_FLAG_I64) != 0 ||
+                            (formatAttr.flags & SECUREC_FLAG_LONGLONG) != 0) {
+                            num64 = (SecInt64)va_arg(argList, SecInt64); /* Maximum Bit Width sign bit unchanged */
+                        } else if ((formatAttr.flags & SECUREC_FLAG_LONG) != 0) {
+                            num64 = SECUREC_GET_LONG_FROM_ARG(formatAttr);
+                        } else if ((formatAttr.flags & SECUREC_FLAG_CHAR) != 0) {
+                            num64 = SECUREC_GET_CHAR_FROM_ARG(formatAttr);
+                        } else if ((formatAttr.flags & SECUREC_FLAG_SHORT) != 0) {
+                            num64 = SECUREC_GET_SHORT_FROM_ARG(formatAttr);
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+                        } else if ((formatAttr.flags & SECUREC_FLAG_PTRDIFF) != 0) {
+                            num64 = (ptrdiff_t)va_arg(argList, ptrdiff_t);  /* Sign extend */
+                        } else if ((formatAttr.flags & SECUREC_FLAG_SIZE) != 0) {
+                            num64 = SECUREC_GET_SIZE_FROM_ARG(formatAttr);
+                        } else if ((formatAttr.flags & SECUREC_FLAG_INTMAX) != 0) {
+                            num64 = (SecInt64)va_arg(argList, SecInt64);
+#endif
+                        } else {
+                            num64 = SECUREC_GET_INT_FROM_ARG(formatAttr);
+                        }
+
+                        /* The order of the following calls must be correct */
+                        SecNumberToBuffer(&formatAttr, num64);
+                        SecNumberSatisfyPrecision(&formatAttr);
+                        SecNumberForceOctal(&formatAttr);
+                        SecUpdateSignedNumberPrefix(&formatAttr);
+                        if (num64 == 0) {
+                            SecNumberCompatZero(&formatAttr);
+                        }
+                        break;
+                    }
+                    default:
+                        /* Do nothing */
+                        break;
+                }
+
+                if (noOutput == 0) {
+                    /* Calculate amount of padding */
+                    formatAttr.padding = (formatAttr.fldWidth - formatAttr.textLen) - formatAttr.prefixLen;
+
+                    /* Put out the padding, prefix, and text, in the correct order */
+                    SecWriteLeftPadding(stream, &formatAttr, &charsOut);
+                    SecWritePrefix(stream, &formatAttr, &charsOut);
+                    SecWriteLeadingZero(stream, &formatAttr, &charsOut);
+                    SecWriteText(stream, &formatAttr, &charsOut);
+                    SecWriteRightPadding(stream, &formatAttr, &charsOut);
+                }
+                break;
+            case STAT_INVALID: /* fall-through */ /* FALLTHRU */
+            default:
+                return -1;  /* Input format is wrong(STAT_INVALID), directly return */
+        }
+    }
+
+    if (state != STAT_NORMAL && state != STAT_TYPE) {
+        return -1;
+    }
+
+    return charsOut;            /* The number of characters written */
+}
+
+/*
+ * Output one zero character zero into the SecPrintfStream structure
+ * If there is not enough space, make sure f->count is less than 0
+ */
+SECUREC_INLINE int SecPutZeroChar(SecPrintfStream *stream)
+{
+    --stream->count;
+    if (stream->count >= 0) {
+        *(stream->cur) = SECUREC_CHAR('\0');
+        ++stream->cur;
+        return 0;
+    }
+    return -1;
+}
+
+/*
+ * Multi character formatted output implementation
+ */
+#ifdef SECUREC_FOR_WCHAR
+int SecVswprintfImpl(wchar_t *string, size_t count, const wchar_t *format, va_list argList)
+#else
+int SecVsnprintfImpl(char *string, size_t count, const char *format, va_list argList)
+#endif
+{
+    SecPrintfStream stream;
+    int retVal;
+
+    stream.count = (int)count; /* The count include \0 character, must be greater than zero */
+    stream.cur = string;
+
+    retVal = SecOutput(&stream, format, argList);
+    if (retVal >= 0) {
+        if (SecPutZeroChar(&stream) == 0) {
+            return retVal;
+        }
+    }
+    if (stream.count < 0) {
+        /* The buffer was too small, then truncate */
+        string[count - 1] = SECUREC_CHAR('\0');
+        return SECUREC_PRINTF_TRUNCATE;
+    }
+    string[0] = SECUREC_CHAR('\0'); /* Empty the dest string */
+    return -1;
+}
+#endif /* OUTPUT_INL_2B263E9C_43D8_44BB_B17A_6D2033DECEE5 */
+
diff --git a/lib/libsecurec/src/scanf_s.c b/lib/libsecurec/src/scanf_s.c
new file mode 100644
index 0000000..fa5470b
--- /dev/null
+++ b/lib/libsecurec/src/scanf_s.c
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: scanf_s function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The scanf_s function is equivalent to fscanf_s with the argument stdin interposed before the arguments to scanf_s
+ *     The scanf_s function reads data from the standard input stream stdin and
+ *    writes the data into the location that's given by argument. Each argument
+ *    must be a pointer to a variable of a type that corresponds to a type specifier
+ *    in format. If copying occurs between strings that overlap, the behavior is
+ *    undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    format                  Format control string.
+ *    ...                       Optional arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    ...                       The converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Returns the number of fields successfully converted and assigned;
+ *    the return value does not include fields that were read but not assigned.
+ *    A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int scanf_s(const char *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vscanf_s(format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+
diff --git a/lib/libsecurec/src/secinput.h b/lib/libsecurec/src/secinput.h
new file mode 100644
index 0000000..176ee05
--- /dev/null
+++ b/lib/libsecurec/src/secinput.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: Define macro, data struct, and declare function prototype,
+ *              which is used by input.inl, secureinput_a.c and secureinput_w.c.
+ * Create: 2014-02-25
+ */
+
+#ifndef SEC_INPUT_H_E950DA2C_902F_4B15_BECD_948E99090D9C
+#define SEC_INPUT_H_E950DA2C_902F_4B15_BECD_948E99090D9C
+#include "securecutil.h"
+
+#define SECUREC_SCANF_EINVAL             (-1)
+#define SECUREC_SCANF_ERROR_PARA         (-2)
+
+/* For internal stream flag */
+#define SECUREC_MEM_STR_FLAG             0x01U
+#define SECUREC_FILE_STREAM_FLAG         0x02U
+#define SECUREC_PIPE_STREAM_FLAG         0x04U
+#define SECUREC_LOAD_FILE_TO_MEM_FLAG    0x08U
+
+#define SECUREC_UCS_BOM_HEADER_SIZE      2U
+#define SECUREC_UCS_BOM_HEADER_BE_1ST    0xfeU
+#define SECUREC_UCS_BOM_HEADER_BE_2ST    0xffU
+#define SECUREC_UCS_BOM_HEADER_LE_1ST    0xffU
+#define SECUREC_UCS_BOM_HEADER_LE_2ST    0xfeU
+#define SECUREC_UTF8_BOM_HEADER_SIZE     3U
+#define SECUREC_UTF8_BOM_HEADER_1ST      0xefU
+#define SECUREC_UTF8_BOM_HEADER_2ND      0xbbU
+#define SECUREC_UTF8_BOM_HEADER_3RD      0xbfU
+#define SECUREC_UTF8_LEAD_1ST            0xe0U
+#define SECUREC_UTF8_LEAD_2ND            0x80U
+
+#define SECUREC_BEGIN_WITH_UCS_BOM(s, len) ((len) == SECUREC_UCS_BOM_HEADER_SIZE && \
+    (((unsigned char)((s)[0]) == SECUREC_UCS_BOM_HEADER_LE_1ST && \
+    (unsigned char)((s)[1]) == SECUREC_UCS_BOM_HEADER_LE_2ST) || \
+    ((unsigned char)((s)[0]) == SECUREC_UCS_BOM_HEADER_BE_1ST && \
+    (unsigned char)((s)[1]) == SECUREC_UCS_BOM_HEADER_BE_2ST)))
+
+#define SECUREC_BEGIN_WITH_UTF8_BOM(s, len) ((len) == SECUREC_UTF8_BOM_HEADER_SIZE && \
+    (unsigned char)((s)[0]) == SECUREC_UTF8_BOM_HEADER_1ST && \
+    (unsigned char)((s)[1]) == SECUREC_UTF8_BOM_HEADER_2ND && \
+    (unsigned char)((s)[2]) == SECUREC_UTF8_BOM_HEADER_3RD)
+
+#ifdef SECUREC_FOR_WCHAR
+#define SECUREC_BOM_HEADER_SIZE SECUREC_UCS_BOM_HEADER_SIZE
+#define SECUREC_BEGIN_WITH_BOM(s, len) SECUREC_BEGIN_WITH_UCS_BOM((s), (len))
+#else
+#define SECUREC_BOM_HEADER_SIZE SECUREC_UTF8_BOM_HEADER_SIZE
+#define SECUREC_BEGIN_WITH_BOM(s, len) SECUREC_BEGIN_WITH_UTF8_BOM((s), (len))
+#endif
+
+typedef struct {
+    unsigned int flag;          /* Mark the properties of input stream */
+    char *base;                 /* The pointer to the header of buffered string */
+    const char *cur;            /* The pointer to next read position */
+    size_t count;               /* The size of buffered string in bytes */
+#if SECUREC_ENABLE_SCANF_FILE
+    FILE *pf;                   /* The file pointer */
+    size_t fileRealRead;
+    long oriFilePos;            /* The original position of file offset when fscanf is called */
+#endif
+} SecFileStream;
+
+#if SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_FILE_STREAM_INIT_FILE(stream, fp) do { \
+    (stream)->pf = (fp); \
+    (stream)->fileRealRead = 0; \
+    (stream)->oriFilePos = 0; \
+} SECUREC_WHILE_ZERO
+#else
+/* Disable file */
+#define SECUREC_FILE_STREAM_INIT_FILE(stream, fp)
+#endif
+
+/* This initialization for eliminating redundant initialization. */
+#define SECUREC_FILE_STREAM_FROM_STRING(stream, buf, cnt) do { \
+    (stream)->flag = SECUREC_MEM_STR_FLAG; \
+    (stream)->base = NULL; \
+    (stream)->cur = (buf); \
+    (stream)->count = (cnt); \
+    SECUREC_FILE_STREAM_INIT_FILE((stream), NULL); \
+} SECUREC_WHILE_ZERO
+
+/* This initialization for eliminating redundant initialization. */
+#define SECUREC_FILE_STREAM_FROM_FILE(stream, fp) do { \
+    (stream)->flag = SECUREC_FILE_STREAM_FLAG; \
+    (stream)->base = NULL; \
+    (stream)->cur = NULL; \
+    (stream)->count = 0; \
+    SECUREC_FILE_STREAM_INIT_FILE((stream), (fp)); \
+} SECUREC_WHILE_ZERO
+
+/* This initialization for eliminating redundant initialization. */
+#define SECUREC_FILE_STREAM_FROM_STDIN(stream) do { \
+    (stream)->flag = SECUREC_PIPE_STREAM_FLAG; \
+    (stream)->base = NULL; \
+    (stream)->cur = NULL; \
+    (stream)->count = 0; \
+    SECUREC_FILE_STREAM_INIT_FILE((stream), SECUREC_STREAM_STDIN); \
+} SECUREC_WHILE_ZERO
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+int SecInputS(SecFileStream *stream, const char *cFormat, va_list argList);
+void SecClearDestBuf(const char *buffer, const char *format, va_list argList);
+#ifdef SECUREC_FOR_WCHAR
+int SecInputSW(SecFileStream *stream, const wchar_t *cFormat, va_list argList);
+void SecClearDestBufW(const wchar_t *buffer, const wchar_t *format, va_list argList);
+#endif
+
+/* 20150105 For software and hardware decoupling,such as UMG */
+#ifdef SECUREC_SYSAPI4VXWORKS
+#ifdef feof
+#undef feof
+#endif
+extern int feof(FILE *stream);
+#endif
+
+#if defined(SECUREC_SYSAPI4VXWORKS) || defined(SECUREC_CTYPE_MACRO_ADAPT)
+#ifndef isspace
+#define isspace(c) (((c) == ' ') || ((c) == '\t') || ((c) == '\r') || ((c) == '\n'))
+#endif
+#ifndef iswspace
+#define iswspace(c) (((c) == L' ') || ((c) == L'\t') || ((c) == L'\r') || ((c) == L'\n'))
+#endif
+#ifndef isascii
+#define isascii(c) (((unsigned char)(c)) <= 0x7f)
+#endif
+#ifndef isupper
+#define isupper(c) ((c) >= 'A' && (c) <= 'Z')
+#endif
+#ifndef islower
+#define islower(c) ((c) >= 'a' && (c) <= 'z')
+#endif
+#ifndef isalpha
+#define isalpha(c) (isupper(c) || (islower(c)))
+#endif
+#ifndef isdigit
+#define isdigit(c) ((c) >= '0' && (c) <= '9')
+#endif
+#ifndef isxupper
+#define isxupper(c) ((c) >= 'A' && (c) <= 'F')
+#endif
+#ifndef isxlower
+#define isxlower(c) ((c) >= 'a' && (c) <= 'f')
+#endif
+#ifndef isxdigit
+#define isxdigit(c) (isdigit(c) || isxupper(c) || isxlower(c))
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+/* Reserved file operation macro interface, s is FILE *, i is fileno zero. */
+#ifndef SECUREC_LOCK_FILE
+#define SECUREC_LOCK_FILE(s)
+#endif
+
+#ifndef SECUREC_UNLOCK_FILE
+#define SECUREC_UNLOCK_FILE(s)
+#endif
+
+#ifndef SECUREC_LOCK_STDIN
+#define SECUREC_LOCK_STDIN(i, s)
+#endif
+
+#ifndef SECUREC_UNLOCK_STDIN
+#define SECUREC_UNLOCK_STDIN(i, s)
+#endif
+#endif
+
diff --git a/lib/libsecurec/src/securecutil.c b/lib/libsecurec/src/securecutil.c
new file mode 100644
index 0000000..7518eb3
--- /dev/null
+++ b/lib/libsecurec/src/securecutil.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: Provides internal functions used by this library, such as memory
+ *              copy and memory move. Besides, include some helper function for
+ *              printf family API, such as SecVsnprintfImpl
+ * Create: 2014-02-25
+ */
+
+/* Avoid duplicate header files,not include securecutil.h */
+#include "securecutil.h"
+
+#if defined(ANDROID) && !defined(SECUREC_CLOSE_ANDROID_HANDLE) && (SECUREC_HAVE_WCTOMB || SECUREC_HAVE_MBTOWC)
+#include <wchar.h>
+#if SECUREC_HAVE_WCTOMB
+/*
+ * Convert wide characters to narrow multi-bytes
+ */
+int wctomb(char *s, wchar_t wc)
+{
+    return (int)wcrtomb(s, wc, NULL);
+}
+#endif
+
+#if SECUREC_HAVE_MBTOWC
+/*
+ * Converting narrow multi-byte characters to wide characters
+ * mbrtowc returns -1 or -2 upon failure, unlike mbtowc, which only returns -1
+ * When the return value is less than zero, we treat it as a failure
+ */
+int mbtowc(wchar_t *pwc, const char *s, size_t n)
+{
+    return (int)mbrtowc(pwc, s, n, NULL);
+}
+#endif
+#endif
+
+/* The V100R001C01 version num is 0x5 (High 8 bits) */
+#define SECUREC_C_VERSION     0x500U
+#define SECUREC_SPC_VERSION   0xbU
+#define SECUREC_VERSION_STR   "V100R001C01SPC011B003"
+
+/*
+ * Get version string and version number.
+ * The rules for version number are as follows:
+ * 1) SPC verNumber<->verStr like:
+ * 0x201<->C01
+ * 0x202<->C01SPC001   Redefine numbers after this version
+ * 0x502<->C01SPC002
+ * 0x503<->C01SPC003
+ * ...
+ * 0X50a<->SPC010
+ * 0X50b<->SPC011
+ * ...
+ * 0x700<->C02
+ * 0x701<->C01SPC001
+ * 0x702<->C02SPC002
+ * ...
+ * 2) CP verNumber<->verStr like:
+ * 0X601<->CP0001
+ * 0X602<->CP0002
+ * ...
+ */
+const char *GetHwSecureCVersion(unsigned short *verNumber)
+{
+    if (verNumber != NULL) {
+        *verNumber = (unsigned short)(SECUREC_C_VERSION | SECUREC_SPC_VERSION);
+    }
+    return SECUREC_VERSION_STR;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(GetHwSecureCVersion);
+#endif
+
diff --git a/lib/libsecurec/src/securecutil.h b/lib/libsecurec/src/securecutil.h
new file mode 100644
index 0000000..ea52ee7
--- /dev/null
+++ b/lib/libsecurec/src/securecutil.h
@@ -0,0 +1,574 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: Define macro, data struct, and declare internal used function prototype,
+ *              which is used by secure functions.
+ * Create: 2014-02-25
+ */
+
+#ifndef SECURECUTIL_H_46C86578_F8FF_4E49_8E64_9B175241761F
+#define SECURECUTIL_H_46C86578_F8FF_4E49_8E64_9B175241761F
+#include "securec.h"
+
+#if (defined(_MSC_VER)) && (_MSC_VER >= 1400)
+/* Shield compilation alerts using discarded functions and Constant  expression to maximize code compatibility */
+#define SECUREC_MASK_MSVC_CRT_WARNING __pragma(warning(push)) \
+    __pragma(warning(disable : 4996 4127))
+#define SECUREC_END_MASK_MSVC_CRT_WARNING  __pragma(warning(pop))
+#else
+#define SECUREC_MASK_MSVC_CRT_WARNING
+#define SECUREC_END_MASK_MSVC_CRT_WARNING
+#endif
+#define SECUREC_WHILE_ZERO SECUREC_MASK_MSVC_CRT_WARNING while (0) SECUREC_END_MASK_MSVC_CRT_WARNING
+
+/* Automatically identify the platform that supports strnlen function, and use this function to improve performance */
+#ifndef SECUREC_HAVE_STRNLEN
+#if (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 700) || (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200809L)
+#if SECUREC_IN_KERNEL
+#define SECUREC_HAVE_STRNLEN 0
+#else
+#if defined(__GLIBC__) && __GLIBC__ >= 2 && defined(__GLIBC_MINOR__) && __GLIBC_MINOR__ >= 10
+#define SECUREC_HAVE_STRNLEN 1
+#else
+#define SECUREC_HAVE_STRNLEN 0
+#endif
+#endif
+#else
+#define SECUREC_HAVE_STRNLEN 0
+#endif
+#endif
+
+#if SECUREC_IN_KERNEL
+/* In kernel disable functions */
+#ifndef SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_ENABLE_SCANF_FILE 0
+#endif
+#ifndef SECUREC_ENABLE_SCANF_FLOAT
+#define SECUREC_ENABLE_SCANF_FLOAT 0
+#endif
+#ifndef SECUREC_ENABLE_SPRINTF_FLOAT
+#define SECUREC_ENABLE_SPRINTF_FLOAT 0
+#endif
+#ifndef SECUREC_HAVE_MBTOWC
+#define SECUREC_HAVE_MBTOWC 0
+#endif
+#ifndef SECUREC_HAVE_WCTOMB
+#define SECUREC_HAVE_WCTOMB 0
+#endif
+#ifndef SECUREC_HAVE_WCHART
+#define SECUREC_HAVE_WCHART 0
+#endif
+#else /* Not in kernel */
+/* Systems that do not support file, can define this macro to 0. */
+#ifndef SECUREC_ENABLE_SCANF_FILE
+#define SECUREC_ENABLE_SCANF_FILE 1
+#endif
+#ifndef SECUREC_ENABLE_SCANF_FLOAT
+#define SECUREC_ENABLE_SCANF_FLOAT 1
+#endif
+/* Systems that do not support float, can define this macro to 0. */
+#ifndef SECUREC_ENABLE_SPRINTF_FLOAT
+#define SECUREC_ENABLE_SPRINTF_FLOAT 1
+#endif
+#ifndef SECUREC_HAVE_MBTOWC
+#define SECUREC_HAVE_MBTOWC 1
+#endif
+#ifndef SECUREC_HAVE_WCTOMB
+#define SECUREC_HAVE_WCTOMB 1
+#endif
+#ifndef SECUREC_HAVE_WCHART
+#define SECUREC_HAVE_WCHART 1
+#endif
+#endif
+
+#ifndef SECUREC_ENABLE_INLINE
+#define SECUREC_ENABLE_INLINE 0
+#endif
+
+#ifndef SECUREC_INLINE
+#if SECUREC_ENABLE_INLINE
+#define SECUREC_INLINE static inline
+#else
+#define SECUREC_INLINE static
+#endif
+#endif
+
+#ifndef SECUREC_WARP_OUTPUT
+#if SECUREC_IN_KERNEL
+#define SECUREC_WARP_OUTPUT 1
+#else
+#define SECUREC_WARP_OUTPUT 1 // 1vsnprintf_s
+#endif
+#endif
+
+#ifndef SECUREC_STREAM_STDIN
+#define SECUREC_STREAM_STDIN stdin
+#endif
+
+#define SECUREC_MUL_SIXTEEN(x)              ((x) << 4U)
+#define SECUREC_MUL_EIGHT(x)                ((x) << 3U)
+#define SECUREC_MUL_TEN(x)                  ((((x) << 2U) + (x)) << 1U)
+/* Limited format input and output width, use signed integer */
+#define SECUREC_MAX_WIDTH_LEN_DIV_TEN       21474836
+#define SECUREC_MAX_WIDTH_LEN               (SECUREC_MAX_WIDTH_LEN_DIV_TEN * 10)
+/* Is the x multiplied by 10 greater than */
+#define SECUREC_MUL_TEN_ADD_BEYOND_MAX(x)   (((x) > SECUREC_MAX_WIDTH_LEN_DIV_TEN))
+
+#define SECUREC_FLOAT_BUFSIZE               (309 + 40)  /* Max length of double value */
+#define SECUREC_FLOAT_BUFSIZE_LB            (4932 + 40) /* Max length of long double value */
+#define SECUREC_FLOAT_DEFAULT_PRECISION     6
+
+/* This macro does not handle pointer equality or integer overflow */
+#define SECUREC_MEMORY_NO_OVERLAP(dest, src, count) \
+    (((src) < (dest) && ((const char *)(src) + (count)) <= (char *)(dest)) || \
+    ((dest) < (src) && ((char *)(dest) + (count)) <= (const char *)(src)))
+
+#define SECUREC_MEMORY_IS_OVERLAP(dest, src, count) \
+    (((src) < (dest) && ((const char *)(src) + (count)) > (char *)(dest)) || \
+    ((dest) < (src) && ((char *)(dest) + (count)) > (const char *)(src)))
+
+/*
+ * Check whether the strings overlap, len is the length of the string not include terminator
+ * Length is related to data type char or wchar , do not force conversion of types
+ */
+#define SECUREC_STRING_NO_OVERLAP(dest, src, len) \
+    (((src) < (dest) && ((src) + (len)) < (dest)) || \
+    ((dest) < (src) && ((dest) + (len)) < (src)))
+
+/*
+ * Check whether the strings overlap for strcpy wcscpy function, dest len and src Len are not include terminator
+ * Length is related to data type char or wchar , do not force conversion of types
+ */
+#define SECUREC_STRING_IS_OVERLAP(dest, src, len) \
+    (((src) < (dest) && ((src) + (len)) >= (dest)) || \
+    ((dest) < (src) && ((dest) + (len)) >= (src)))
+
+/*
+ * Check whether the strings overlap for strcat wcscat function, dest len and src Len are not include terminator
+ * Length is related to data type char or wchar , do not force conversion of types
+ */
+#define SECUREC_CAT_STRING_IS_OVERLAP(dest, destLen, src, srcLen) \
+    (((dest) < (src) && ((dest) + (destLen) + (srcLen)) >= (src)) || \
+    ((src) < (dest) && ((src) + (srcLen)) >= (dest)))
+
+#if SECUREC_HAVE_STRNLEN
+#define SECUREC_CALC_STR_LEN(str, maxLen, outLen) do { \
+    *(outLen) = strnlen((str), (maxLen)); \
+} SECUREC_WHILE_ZERO
+#define SECUREC_CALC_STR_LEN_OPT(str, maxLen, outLen) do { \
+    if ((maxLen) > 8) { \
+        /* Optimization or len less then 8 */ \
+        if (*((str) + 0) == '\0') { \
+            *(outLen) = 0; \
+        } else if (*((str) + 1) == '\0') { \
+            *(outLen) = 1; \
+        } else if (*((str) + 2) == '\0') { \
+            *(outLen) = 2; \
+        } else if (*((str) + 3) == '\0') { \
+            *(outLen) = 3; \
+        } else if (*((str) + 4) == '\0') { \
+            *(outLen) = 4; \
+        } else if (*((str) + 5) == '\0') { \
+            *(outLen) = 5; \
+        } else if (*((str) + 6) == '\0') { \
+            *(outLen) = 6; \
+        } else if (*((str) + 7) == '\0') { \
+            *(outLen) = 7; \
+        } else if (*((str) + 8) == '\0') { \
+            /* Optimization with a length of 8 */ \
+            *(outLen) = 8; \
+        } else { \
+            /* The offset is 8 because the performance of 8 byte alignment is high */ \
+            *(outLen) = 8 + strnlen((str) + 8, (maxLen) - 8); \
+        } \
+    } else { \
+        SECUREC_CALC_STR_LEN((str), (maxLen), (outLen)); \
+    } \
+} SECUREC_WHILE_ZERO
+#else
+#define SECUREC_CALC_STR_LEN(str, maxLen, outLen) do { \
+    const char *strEnd_ = (const char *)(str); \
+    size_t availableSize_ = (size_t)(maxLen); \
+    while (availableSize_ > 0 && *strEnd_ != '\0') { \
+        --availableSize_; \
+        ++strEnd_; \
+    } \
+    *(outLen) = (size_t)(strEnd_ - (str)); \
+} SECUREC_WHILE_ZERO
+#define SECUREC_CALC_STR_LEN_OPT SECUREC_CALC_STR_LEN
+#endif
+
+#define SECUREC_CALC_WSTR_LEN(str, maxLen, outLen) do { \
+    const wchar_t *strEnd_ = (const wchar_t *)(str); \
+    size_t len_ = 0; \
+    while (len_ < (maxLen) && *strEnd_ != L'\0') { \
+        ++len_; \
+        ++strEnd_; \
+    } \
+    *(outLen) = len_; \
+} SECUREC_WHILE_ZERO
+
+/*
+ * Performance optimization, product may disable inline function.
+ * Using function pointer for MEMSET to prevent compiler optimization when cleaning up memory.
+ */
+#ifdef SECUREC_USE_ASM
+#define SECUREC_MEMSET_FUNC_OPT  memset_opt
+#define SECUREC_MEMCPY_FUNC_OPT  memcpy_opt
+#else
+#define SECUREC_MEMSET_FUNC_OPT  memset
+#define SECUREC_MEMCPY_FUNC_OPT  memcpy
+#endif
+
+#define SECUREC_MEMCPY_WARP_OPT(dest, src, count)    (void)SECUREC_MEMCPY_FUNC_OPT((dest), (src), (count))
+
+#ifndef SECUREC_MEMSET_BARRIER
+#if defined(__GNUC__)
+/* Can be turned off for scenarios that do not use memory barrier */
+#define SECUREC_MEMSET_BARRIER 1
+#else
+#define SECUREC_MEMSET_BARRIER 0
+#endif
+#endif
+
+#ifndef SECUREC_MEMSET_INDIRECT_USE
+/* Can be turned off for scenarios that do not allow pointer calls */
+#define SECUREC_MEMSET_INDIRECT_USE 1
+#endif
+
+#if SECUREC_MEMSET_BARRIER
+#define SECUREC_MEMORY_BARRIER(dest) __asm__ __volatile__("": : "r"(dest) : "memory")
+#else
+#define SECUREC_MEMORY_BARRIER(dest)
+#endif
+
+#if SECUREC_MEMSET_BARRIER
+#define SECUREC_MEMSET_PREVENT_DSE(dest, value, count)  do { \
+        (void)SECUREC_MEMSET_FUNC_OPT(dest, value, count); \
+        SECUREC_MEMORY_BARRIER(dest); \
+} SECUREC_WHILE_ZERO
+#elif SECUREC_MEMSET_INDIRECT_USE
+#define SECUREC_MEMSET_PREVENT_DSE(dest, value, count)  do { \
+    void *(* const volatile fn_)(void *s_, int c_, size_t n_) = SECUREC_MEMSET_FUNC_OPT; \
+    (void)(*fn_)((dest), (value), (count)); \
+} SECUREC_WHILE_ZERO
+#else
+#define SECUREC_MEMSET_PREVENT_DSE(dest, value, count)  (void)SECUREC_MEMSET_FUNC_OPT((dest), (value), (count))
+#endif
+
+#ifdef SECUREC_FORMAT_OUTPUT_INPUT
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT) || defined(__ARMCC_VERSION)
+typedef __int64 SecInt64;
+typedef unsigned __int64 SecUnsignedInt64;
+#if defined(__ARMCC_VERSION)
+typedef unsigned int SecUnsignedInt32;
+#else
+typedef unsigned __int32 SecUnsignedInt32;
+#endif
+#else
+typedef unsigned int SecUnsignedInt32;
+typedef long long SecInt64;
+typedef unsigned long long SecUnsignedInt64;
+#endif
+
+#ifdef SECUREC_FOR_WCHAR
+#if defined(SECUREC_VXWORKS_PLATFORM) && !defined(__WINT_TYPE__)
+typedef wchar_t wint_t;
+#endif
+#ifndef WEOF
+#define WEOF ((wchar_t)(-1))
+#endif
+#define SECUREC_CHAR(x) L ## x
+typedef wchar_t SecChar;
+typedef wchar_t SecUnsignedChar;
+typedef wint_t SecInt;
+typedef wint_t SecUnsignedInt;
+#else /*  no SECUREC_FOR_WCHAR */
+#define SECUREC_CHAR(x) (x)
+typedef char SecChar;
+typedef unsigned char SecUnsignedChar;
+typedef int SecInt;
+typedef unsigned int SecUnsignedInt;
+#endif
+#endif
+
+/*
+ * Determine whether the address is 8-byte aligned
+ * Some systems do not have uintptr_t type, so  use NULL to clear tool alarm 507
+ */
+#define SECUREC_ADDR_ALIGNED_8(addr) ((((size_t)(addr)) & 7U) == 0) /* Use 7 to check aligned 8 */
+
+/*
+ * If you define the memory allocation function, you need to define the function prototype.
+ * You can define this macro as a header file.
+ */
+#if defined(SECUREC_MALLOC_PROTOTYPE)
+SECUREC_MALLOC_PROTOTYPE
+#endif
+
+#ifndef SECUREC_MALLOC
+#define SECUREC_MALLOC(x) malloc((size_t)(x))
+#endif
+
+#ifndef SECUREC_FREE
+#define SECUREC_FREE(x)   free((void *)(x))
+#endif
+
+/* Improve performance with struct assignment, buf1 is not defined to avoid tool false positive */
+#define SECUREC_COPY_VALUE_BY_STRUCT(dest, src, n) do { \
+    *(SecStrBuf##n *)(void *)(dest) = *(const SecStrBuf##n *)(const void *)(src); \
+} SECUREC_WHILE_ZERO
+
+typedef struct {
+    unsigned char buf[2]; /* Performance optimization code structure assignment length 2 bytes */
+} SecStrBuf2;
+typedef struct {
+    unsigned char buf[3]; /* Performance optimization code structure assignment length 3 bytes */
+} SecStrBuf3;
+typedef struct {
+    unsigned char buf[4]; /* Performance optimization code structure assignment length 4 bytes */
+} SecStrBuf4;
+typedef struct {
+    unsigned char buf[5]; /* Performance optimization code structure assignment length 5 bytes */
+} SecStrBuf5;
+typedef struct {
+    unsigned char buf[6]; /* Performance optimization code structure assignment length 6 bytes */
+} SecStrBuf6;
+typedef struct {
+    unsigned char buf[7]; /* Performance optimization code structure assignment length 7 bytes */
+} SecStrBuf7;
+typedef struct {
+    unsigned char buf[8]; /* Performance optimization code structure assignment length 8 bytes */
+} SecStrBuf8;
+typedef struct {
+    unsigned char buf[9]; /* Performance optimization code structure assignment length 9 bytes */
+} SecStrBuf9;
+typedef struct {
+    unsigned char buf[10]; /* Performance optimization code structure assignment length 10 bytes */
+} SecStrBuf10;
+typedef struct {
+    unsigned char buf[11]; /* Performance optimization code structure assignment length 11 bytes */
+} SecStrBuf11;
+typedef struct {
+    unsigned char buf[12]; /* Performance optimization code structure assignment length 12 bytes */
+} SecStrBuf12;
+typedef struct {
+    unsigned char buf[13]; /* Performance optimization code structure assignment length 13 bytes */
+} SecStrBuf13;
+typedef struct {
+    unsigned char buf[14]; /* Performance optimization code structure assignment length 14 bytes */
+} SecStrBuf14;
+typedef struct {
+    unsigned char buf[15]; /* Performance optimization code structure assignment length 15 bytes */
+} SecStrBuf15;
+typedef struct {
+    unsigned char buf[16]; /* Performance optimization code structure assignment length 16 bytes */
+} SecStrBuf16;
+typedef struct {
+    unsigned char buf[17]; /* Performance optimization code structure assignment length 17 bytes */
+} SecStrBuf17;
+typedef struct {
+    unsigned char buf[18]; /* Performance optimization code structure assignment length 18 bytes */
+} SecStrBuf18;
+typedef struct {
+    unsigned char buf[19]; /* Performance optimization code structure assignment length 19 bytes */
+} SecStrBuf19;
+typedef struct {
+    unsigned char buf[20]; /* Performance optimization code structure assignment length 20 bytes */
+} SecStrBuf20;
+typedef struct {
+    unsigned char buf[21]; /* Performance optimization code structure assignment length 21 bytes */
+} SecStrBuf21;
+typedef struct {
+    unsigned char buf[22]; /* Performance optimization code structure assignment length 22 bytes */
+} SecStrBuf22;
+typedef struct {
+    unsigned char buf[23]; /* Performance optimization code structure assignment length 23 bytes */
+} SecStrBuf23;
+typedef struct {
+    unsigned char buf[24]; /* Performance optimization code structure assignment length 24 bytes */
+} SecStrBuf24;
+typedef struct {
+    unsigned char buf[25]; /* Performance optimization code structure assignment length 25 bytes */
+} SecStrBuf25;
+typedef struct {
+    unsigned char buf[26]; /* Performance optimization code structure assignment length 26 bytes */
+} SecStrBuf26;
+typedef struct {
+    unsigned char buf[27]; /* Performance optimization code structure assignment length 27 bytes */
+} SecStrBuf27;
+typedef struct {
+    unsigned char buf[28]; /* Performance optimization code structure assignment length 28 bytes */
+} SecStrBuf28;
+typedef struct {
+    unsigned char buf[29]; /* Performance optimization code structure assignment length 29 bytes */
+} SecStrBuf29;
+typedef struct {
+    unsigned char buf[30]; /* Performance optimization code structure assignment length 30 bytes */
+} SecStrBuf30;
+typedef struct {
+    unsigned char buf[31]; /* Performance optimization code structure assignment length 31 bytes */
+} SecStrBuf31;
+typedef struct {
+    unsigned char buf[32]; /* Performance optimization code structure assignment length 32 bytes */
+} SecStrBuf32;
+typedef struct {
+    unsigned char buf[33]; /* Performance optimization code structure assignment length 33 bytes */
+} SecStrBuf33;
+typedef struct {
+    unsigned char buf[34]; /* Performance optimization code structure assignment length 34 bytes */
+} SecStrBuf34;
+typedef struct {
+    unsigned char buf[35]; /* Performance optimization code structure assignment length 35 bytes */
+} SecStrBuf35;
+typedef struct {
+    unsigned char buf[36]; /* Performance optimization code structure assignment length 36 bytes */
+} SecStrBuf36;
+typedef struct {
+    unsigned char buf[37]; /* Performance optimization code structure assignment length 37 bytes */
+} SecStrBuf37;
+typedef struct {
+    unsigned char buf[38]; /* Performance optimization code structure assignment length 38 bytes */
+} SecStrBuf38;
+typedef struct {
+    unsigned char buf[39]; /* Performance optimization code structure assignment length 39 bytes */
+} SecStrBuf39;
+typedef struct {
+    unsigned char buf[40]; /* Performance optimization code structure assignment length 40 bytes */
+} SecStrBuf40;
+typedef struct {
+    unsigned char buf[41]; /* Performance optimization code structure assignment length 41 bytes */
+} SecStrBuf41;
+typedef struct {
+    unsigned char buf[42]; /* Performance optimization code structure assignment length 42 bytes */
+} SecStrBuf42;
+typedef struct {
+    unsigned char buf[43]; /* Performance optimization code structure assignment length 43 bytes */
+} SecStrBuf43;
+typedef struct {
+    unsigned char buf[44]; /* Performance optimization code structure assignment length 44 bytes */
+} SecStrBuf44;
+typedef struct {
+    unsigned char buf[45]; /* Performance optimization code structure assignment length 45 bytes */
+} SecStrBuf45;
+typedef struct {
+    unsigned char buf[46]; /* Performance optimization code structure assignment length 46 bytes */
+} SecStrBuf46;
+typedef struct {
+    unsigned char buf[47]; /* Performance optimization code structure assignment length 47 bytes */
+} SecStrBuf47;
+typedef struct {
+    unsigned char buf[48]; /* Performance optimization code structure assignment length 48 bytes */
+} SecStrBuf48;
+typedef struct {
+    unsigned char buf[49]; /* Performance optimization code structure assignment length 49 bytes */
+} SecStrBuf49;
+typedef struct {
+    unsigned char buf[50]; /* Performance optimization code structure assignment length 50 bytes */
+} SecStrBuf50;
+typedef struct {
+    unsigned char buf[51]; /* Performance optimization code structure assignment length 51 bytes */
+} SecStrBuf51;
+typedef struct {
+    unsigned char buf[52]; /* Performance optimization code structure assignment length 52 bytes */
+} SecStrBuf52;
+typedef struct {
+    unsigned char buf[53]; /* Performance optimization code structure assignment length 53 bytes */
+} SecStrBuf53;
+typedef struct {
+    unsigned char buf[54]; /* Performance optimization code structure assignment length 54 bytes */
+} SecStrBuf54;
+typedef struct {
+    unsigned char buf[55]; /* Performance optimization code structure assignment length 55 bytes */
+} SecStrBuf55;
+typedef struct {
+    unsigned char buf[56]; /* Performance optimization code structure assignment length 56 bytes */
+} SecStrBuf56;
+typedef struct {
+    unsigned char buf[57]; /* Performance optimization code structure assignment length 57 bytes */
+} SecStrBuf57;
+typedef struct {
+    unsigned char buf[58]; /* Performance optimization code structure assignment length 58 bytes */
+} SecStrBuf58;
+typedef struct {
+    unsigned char buf[59]; /* Performance optimization code structure assignment length 59 bytes */
+} SecStrBuf59;
+typedef struct {
+    unsigned char buf[60]; /* Performance optimization code structure assignment length 60 bytes */
+} SecStrBuf60;
+typedef struct {
+    unsigned char buf[61]; /* Performance optimization code structure assignment length 61 bytes */
+} SecStrBuf61;
+typedef struct {
+    unsigned char buf[62]; /* Performance optimization code structure assignment length 62 bytes */
+} SecStrBuf62;
+typedef struct {
+    unsigned char buf[63]; /* Performance optimization code structure assignment length 63 bytes */
+} SecStrBuf63;
+typedef struct {
+    unsigned char buf[64]; /* Performance optimization code structure assignment length 64 bytes */
+} SecStrBuf64;
+
+/*
+ * User can change the error handler by modify the following definition,
+ * such as logging the detail error in file.
+ */
+#if defined(_DEBUG) || defined(DEBUG)
+#if defined(SECUREC_ERROR_HANDLER_BY_ASSERT)
+#define SECUREC_ERROR_INVALID_PARAMTER(msg) assert(msg "invalid argument" == NULL)
+#define SECUREC_ERROR_INVALID_RANGE(msg)    assert(msg "invalid dest buffer size" == NULL)
+#define SECUREC_ERROR_BUFFER_OVERLAP(msg)   assert(msg "buffer overlap" == NULL)
+#elif defined(SECUREC_ERROR_HANDLER_BY_PRINTF)
+#if SECUREC_IN_KERNEL
+#define SECUREC_ERROR_INVALID_PARAMTER(msg) printk("%s invalid argument\n", msg)
+#define SECUREC_ERROR_INVALID_RANGE(msg)    printk("%s invalid dest buffer size\n", msg)
+#define SECUREC_ERROR_BUFFER_OVERLAP(msg)   printk("%s buffer overlap\n", msg)
+#else
+#define SECUREC_ERROR_INVALID_PARAMTER(msg) printf("%s invalid argument\n", msg)
+#define SECUREC_ERROR_INVALID_RANGE(msg)    printf("%s invalid dest buffer size\n", msg)
+#define SECUREC_ERROR_BUFFER_OVERLAP(msg)   printf("%s buffer overlap\n", msg)
+#endif
+#elif defined(SECUREC_ERROR_HANDLER_BY_FILE_LOG)
+#define SECUREC_ERROR_INVALID_PARAMTER(msg) LogSecureCRuntimeError(msg " EINVAL\n")
+#define SECUREC_ERROR_INVALID_RANGE(msg)    LogSecureCRuntimeError(msg " ERANGE\n")
+#define SECUREC_ERROR_BUFFER_OVERLAP(msg)   LogSecureCRuntimeError(msg " EOVERLAP\n")
+#endif
+#endif
+
+/* Default handler is none */
+#ifndef SECUREC_ERROR_INVALID_PARAMTER
+#define SECUREC_ERROR_INVALID_PARAMTER(msg)
+#endif
+#ifndef SECUREC_ERROR_INVALID_RANGE
+#define SECUREC_ERROR_INVALID_RANGE(msg)
+#endif
+#ifndef SECUREC_ERROR_BUFFER_OVERLAP
+#define SECUREC_ERROR_BUFFER_OVERLAP(msg)
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Assembly language memory copy and memory set for X86 or MIPS ... */
+#ifdef SECUREC_USE_ASM
+void *memcpy_opt(void *dest, const void *src, size_t n);
+void *memset_opt(void *s, int c, size_t n);
+#endif
+
+#if defined(SECUREC_ERROR_HANDLER_BY_FILE_LOG)
+void LogSecureCRuntimeError(const char *errDetail);
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif
+
diff --git a/lib/libsecurec/src/secureinput_a.c b/lib/libsecurec/src/secureinput_a.c
new file mode 100644
index 0000000..e79868f
--- /dev/null
+++ b/lib/libsecurec/src/secureinput_a.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: By defining data type for ANSI string and including "input.inl",
+ *              this file generates real underlying function used by scanf family API.
+ * Create: 2014-02-25
+ */
+
+#define SECUREC_FORMAT_OUTPUT_INPUT 1
+#ifdef SECUREC_FOR_WCHAR
+#undef SECUREC_FOR_WCHAR
+#endif
+
+#include "secinput.h"
+
+#include "input.inl"
+
+SECUREC_INLINE int SecIsDigit(SecInt ch)
+{
+    /* SecInt to unsigned char clear  571, use bit mask to clear negative return of ch */
+    return isdigit((int)((unsigned int)(unsigned char)(ch) & 0xffU));
+}
+SECUREC_INLINE int SecIsXdigit(SecInt ch)
+{
+    return isxdigit((int)((unsigned int)(unsigned char)(ch) & 0xffU));
+}
+SECUREC_INLINE int SecIsSpace(SecInt ch)
+{
+    return isspace((int)((unsigned int)(unsigned char)(ch) & 0xffU));
+}
+
diff --git a/lib/libsecurec/src/secureinput_w.c b/lib/libsecurec/src/secureinput_w.c
new file mode 100644
index 0000000..12c9ef8
--- /dev/null
+++ b/lib/libsecurec/src/secureinput_w.c
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: By defining data type for UNICODE string and including "input.inl",
+ *             this file generates real underlying function used by scanf family API.
+ * Create: 2014-02-25
+ */
+
+/* If some platforms don't have wchar.h, don't include it */
+#if !(defined(SECUREC_VXWORKS_PLATFORM))
+/* If there is no macro below, it will cause vs2010 compiling alarm */
+#if defined(_MSC_VER) && (_MSC_VER >= 1400)
+#ifndef __STDC_WANT_SECURE_LIB__
+/* The order of adjustment is to eliminate alarm of Duplicate Block */
+#define __STDC_WANT_SECURE_LIB__ 0
+#endif
+#ifndef _CRTIMP_ALTERNATIVE
+#define _CRTIMP_ALTERNATIVE     /* Comment microsoft *_s function */
+#endif
+#endif
+#include <wchar.h>
+#endif
+
+/* Disable wchar func to clear vs warning */
+#define SECUREC_ENABLE_WCHAR_FUNC       0
+#define SECUREC_FORMAT_OUTPUT_INPUT     1
+
+#ifndef SECUREC_FOR_WCHAR
+#define SECUREC_FOR_WCHAR
+#endif
+
+#include "secinput.h"
+
+#include "input.inl"
+
+SECUREC_INLINE unsigned int SecWcharHighBits(SecInt ch)
+{
+    /* Convert int to unsigned int clear 571 */
+    return ((unsigned int)(int)ch & (~0xffU));
+}
+
+SECUREC_INLINE unsigned char SecWcharLowByte(SecInt ch)
+{
+    /* Convert int to unsigned int clear 571 */
+    return (unsigned char)((unsigned int)(int)ch & 0xffU);
+}
+
+SECUREC_INLINE int SecIsDigit(SecInt ch)
+{
+    if (SecWcharHighBits(ch) != 0) {
+        return 0; /* Same as isdigit */
+    }
+    return isdigit((int)SecWcharLowByte(ch));
+}
+
+SECUREC_INLINE int SecIsXdigit(SecInt ch)
+{
+    if (SecWcharHighBits(ch) != 0) {
+        return 0; /* Same as isxdigit */
+    }
+    return isxdigit((int)SecWcharLowByte(ch));
+}
+
+SECUREC_INLINE int SecIsSpace(SecInt ch)
+{
+    return iswspace((wint_t)(int)(ch));
+}
+
diff --git a/lib/libsecurec/src/secureprintoutput.h b/lib/libsecurec/src/secureprintoutput.h
new file mode 100644
index 0000000..a00b10d
--- /dev/null
+++ b/lib/libsecurec/src/secureprintoutput.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: Define macro, enum, data struct, and declare internal used function
+ *              prototype, which is used by output.inl, secureprintoutput_w.c and
+ *              secureprintoutput_a.c.
+ * Create: 2014-02-25
+ */
+
+#ifndef SECUREPRINTOUTPUT_H_E950DA2C_902F_4B15_BECD_948E99090D9C
+#define SECUREPRINTOUTPUT_H_E950DA2C_902F_4B15_BECD_948E99090D9C
+#include "securecutil.h"
+
+/* Shield compilation alerts about using sprintf without format attribute to format float value. */
+#ifndef SECUREC_HANDLE_WFORMAT
+#define SECUREC_HANDLE_WFORMAT 1
+#endif
+
+#if SECUREC_HANDLE_WFORMAT && defined(__GNUC__) && ((__GNUC__ >= 5) || \
+    (defined(__GNUC_MINOR__) && (__GNUC__ == 4 && __GNUC_MINOR__ > 7)))
+#if defined(__clang__)
+#define SECUREC_MASK_WFORMAT_WARNING  _Pragma("GCC diagnostic push") \
+    _Pragma("GCC diagnostic ignored \"-Wformat-nonliteral\"")
+#else
+#define SECUREC_MASK_WFORMAT_WARNING  _Pragma("GCC diagnostic push") \
+    _Pragma("GCC diagnostic ignored \"-Wformat-nonliteral\"") \
+    _Pragma("GCC diagnostic ignored \"-Wmissing-format-attribute\"") \
+    _Pragma("GCC diagnostic ignored \"-Wsuggest-attribute=format\"")
+#endif
+#define SECUREC_END_MASK_WFORMAT_WARNING  _Pragma("GCC diagnostic pop")
+#else
+#define SECUREC_MASK_WFORMAT_WARNING
+#define SECUREC_END_MASK_WFORMAT_WARNING
+#endif
+
+#define SECUREC_MASK_VSPRINTF_WARNING  SECUREC_MASK_WFORMAT_WARNING \
+    SECUREC_MASK_MSVC_CRT_WARNING
+
+#define SECUREC_END_MASK_VSPRINTF_WARNING  SECUREC_END_MASK_WFORMAT_WARNING \
+    SECUREC_END_MASK_MSVC_CRT_WARNING
+
+/*
+ * Flag definitions.
+ * Using macros instead of enumerations is because some of the enumerated types under the compiler are 16bit.
+ */
+#define SECUREC_FLAG_SIGN           0x00001U
+#define SECUREC_FLAG_SIGN_SPACE     0x00002U
+#define SECUREC_FLAG_LEFT           0x00004U
+#define SECUREC_FLAG_LEADZERO       0x00008U
+#define SECUREC_FLAG_LONG           0x00010U
+#define SECUREC_FLAG_SHORT          0x00020U
+#define SECUREC_FLAG_SIGNED         0x00040U
+#define SECUREC_FLAG_ALTERNATE      0x00080U
+#define SECUREC_FLAG_NEGATIVE       0x00100U
+#define SECUREC_FLAG_FORCE_OCTAL    0x00200U
+#define SECUREC_FLAG_LONG_DOUBLE    0x00400U
+#define SECUREC_FLAG_WIDECHAR       0x00800U
+#define SECUREC_FLAG_LONGLONG       0x01000U
+#define SECUREC_FLAG_CHAR           0x02000U
+#define SECUREC_FLAG_POINTER        0x04000U
+#define SECUREC_FLAG_I64            0x08000U
+#define SECUREC_FLAG_PTRDIFF        0x10000U
+#define SECUREC_FLAG_SIZE           0x20000U
+#ifdef  SECUREC_COMPATIBLE_LINUX_FORMAT
+#define SECUREC_FLAG_INTMAX         0x40000U
+#endif
+
+/* State definitions. Identify the status of the current format */
+typedef enum {
+    STAT_NORMAL,
+    STAT_PERCENT,
+    STAT_FLAG,
+    STAT_WIDTH,
+    STAT_DOT,
+    STAT_PRECIS,
+    STAT_SIZE,
+    STAT_TYPE,
+    STAT_INVALID
+} SecFmtState;
+
+#ifndef SECUREC_BUFFER_SIZE
+#if SECUREC_IN_KERNEL
+#define SECUREC_BUFFER_SIZE    32
+#elif defined(SECUREC_STACK_SIZE_LESS_THAN_1K)
+/*
+ * SECUREC BUFFER SIZE Can not be less than 23
+ * The length of the octal representation of 64-bit integers with zero lead
+ */
+#define SECUREC_BUFFER_SIZE    256
+#else
+#define SECUREC_BUFFER_SIZE    512
+#endif
+#endif
+#if SECUREC_BUFFER_SIZE < 23
+#error SECUREC_BUFFER_SIZE Can not be less than 23
+#endif
+/* Buffer size for wchar, use 4 to make the compiler aligns as 8 bytes as possible */
+#define SECUREC_WCHAR_BUFFER_SIZE 4
+
+#define SECUREC_MAX_PRECISION  SECUREC_BUFFER_SIZE
+/* Max. # bytes in multibyte char,see MB_LEN_MAX */
+#define SECUREC_MB_LEN 16
+/* The return value of the internal function, which is returned when truncated */
+#define SECUREC_PRINTF_TRUNCATE (-2)
+
+#define SECUREC_VSPRINTF_PARAM_ERROR(format, strDest, destMax, maxLimit) \
+    ((format) == NULL || (strDest) == NULL || (destMax) == 0 || (destMax) > (maxLimit))
+
+#define SECUREC_VSPRINTF_CLEAR_DEST(strDest, destMax, maxLimit) do { \
+    if ((strDest) != NULL && (destMax) > 0 && (destMax) <= (maxLimit)) { \
+        *(strDest) = '\0'; \
+    } \
+} SECUREC_WHILE_ZERO
+
+#ifdef SECUREC_COMPATIBLE_WIN_FORMAT
+#define SECUREC_VSNPRINTF_PARAM_ERROR(format, strDest, destMax, count, maxLimit) \
+    (((format) == NULL || (strDest) == NULL || (destMax) == 0 || (destMax) > (maxLimit)) || \
+    ((count) > (SECUREC_STRING_MAX_LEN - 1) && (count) != (size_t)(-1)))
+
+#else
+#define SECUREC_VSNPRINTF_PARAM_ERROR(format, strDest, destMax, count, maxLimit) \
+    (((format) == NULL || (strDest) == NULL || (destMax) == 0 || (destMax) > (maxLimit)) || \
+    ((count) > (SECUREC_STRING_MAX_LEN - 1)))
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#ifdef SECUREC_FOR_WCHAR
+int SecVswprintfImpl(wchar_t *string, size_t count, const wchar_t *format, va_list argList);
+#else
+int SecVsnprintfImpl(char *string, size_t count, const char *format, va_list argList);
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/lib/libsecurec/src/secureprintoutput_a.c b/lib/libsecurec/src/secureprintoutput_a.c
new file mode 100644
index 0000000..b2b4b6a
--- /dev/null
+++ b/lib/libsecurec/src/secureprintoutput_a.c
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: By defining corresponding macro for ANSI string and including "output.inl",
+ *              this file generates real underlying function used by printf family API.
+ * Create: 2014-02-25
+ */
+
+#define SECUREC_FORMAT_OUTPUT_INPUT 1
+
+#ifdef SECUREC_FOR_WCHAR
+#undef SECUREC_FOR_WCHAR
+#endif
+
+#include "secureprintoutput.h"
+#if SECUREC_WARP_OUTPUT
+#define SECUREC_FORMAT_FLAG_TABLE_SIZE 128
+SECUREC_INLINE const char *SecSkipKnownFlags(const char *format)
+{
+    static const unsigned char flagTable[SECUREC_FORMAT_FLAG_TABLE_SIZE] = {
+        /*
+         * Known flag is  "0123456789 +-#hlLwZzjqt*I$"
+         */
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
+        0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
+    };
+    const char *fmt = format;
+    while (*fmt != '\0') {
+        char fmtChar = *fmt;
+        if ((unsigned char)fmtChar > 0x7f) { /* 0x7f is upper limit of format char value */
+            break;
+        }
+        if (flagTable[(unsigned char)fmtChar] == 0) {
+            break;
+        }
+        ++fmt;
+    }
+    return fmt;
+}
+
+SECUREC_INLINE int SecFormatContainN(const char *format)
+{
+    const char *fmt = format;
+    while (*fmt != '\0') {
+        ++fmt;
+        /* Skip normal char */
+        if (*(fmt - 1) != '%') {
+            continue;
+        }
+        /* Meet %% */
+        if (*fmt == '%') {
+            ++fmt; /* Point to  the character after the %. Correct handling %%xx */
+            continue;
+        }
+        /* Now parse %..., fmt point to the character after the % */
+        fmt = SecSkipKnownFlags(fmt);
+        if (*fmt == 'n') {
+            return 1;
+        }
+    }
+    return 0;
+}
+/*
+ * Multi character formatted output implementation, the count include \0 character, must be greater than zero
+ */
+int SecVsnprintfImpl(char *string, size_t count, const char *format, va_list argList)
+{
+    int retVal;
+    if (SecFormatContainN(format) != 0) {
+        string[0] = '\0';
+        return -1;
+    }
+    SECUREC_MASK_VSPRINTF_WARNING
+    retVal = vsnprintf(string, count, format, argList);
+    SECUREC_END_MASK_VSPRINTF_WARNING
+    if (retVal >= (int)count) { /* The size_t to int is ok, count max is SECUREC_STRING_MAX_LEN */
+        /* The buffer was too small; we return truncation */
+        string[count - 1] = '\0';
+        return SECUREC_PRINTF_TRUNCATE;
+    }
+    if (retVal < 0) {
+        string[0] = '\0'; /* Empty the dest strDest */
+        return -1;
+    }
+    return retVal;
+}
+#else
+#if SECUREC_IN_KERNEL
+#include <linux/ctype.h>
+#endif
+
+#ifndef EOF
+#define EOF (-1)
+#endif
+
+#include "output.inl"
+
+#endif
+
diff --git a/lib/libsecurec/src/secureprintoutput_w.c b/lib/libsecurec/src/secureprintoutput_w.c
new file mode 100644
index 0000000..672c018
--- /dev/null
+++ b/lib/libsecurec/src/secureprintoutput_w.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: By defining corresponding macro for UNICODE string and including "output.inl",
+ *              this file generates real underlying function used by printf family API.
+ * Create: 2014-02-25
+ */
+
+/* If some platforms don't have wchar.h, don't include it */
+#if !(defined(SECUREC_VXWORKS_PLATFORM))
+/* If there is no macro above, it will cause compiling alarm */
+#if defined(_MSC_VER) && (_MSC_VER >= 1400)
+#ifndef _CRTIMP_ALTERNATIVE
+#define _CRTIMP_ALTERNATIVE     /* Comment microsoft *_s function */
+#endif
+#ifndef __STDC_WANT_SECURE_LIB__
+#define __STDC_WANT_SECURE_LIB__ 0
+#endif
+#endif
+#include <wchar.h>
+#endif
+
+/* Disable wchar func to clear vs warning */
+#define SECUREC_ENABLE_WCHAR_FUNC   0
+#define SECUREC_FORMAT_OUTPUT_INPUT 1
+
+#ifndef SECUREC_FOR_WCHAR
+#define SECUREC_FOR_WCHAR
+#endif
+
+#include "secureprintoutput.h"
+
+#include "output.inl"
+
diff --git a/lib/libsecurec/src/snprintf_s.c b/lib/libsecurec/src/snprintf_s.c
new file mode 100644
index 0000000..e9b94f3
--- /dev/null
+++ b/lib/libsecurec/src/snprintf_s.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: snprintf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+#if SECUREC_ENABLE_SNPRINTF
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The snprintf_s function is equivalent to the snprintf function
+ *    except for the parameter destMax/count and the explicit runtime-constraints violation
+ *    The snprintf_s function formats and stores count or fewer characters in
+ *    strDest and appends a terminating null. Each argument (if any) is converted
+ *    and output according to the corresponding format specification in format.
+ *    The formatting is consistent with the printf family of functions; If copying
+ *    occurs between strings that overlap, the behavior is undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                 Storage location for the output.
+ *    destMax                 The size of the storage location for output. Size
+ *                                 in bytes for snprintf_s or size in words for snwprintf_s.
+ *    count                    Maximum number of character to store.
+ *    format                  Format-control string.
+ *    ...                        Optional arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                 is updated
+ *
+ * <RETURN VALUE>
+ *    return  the number of characters written, not including the terminating null
+ *    return -1 if an  error occurs.
+ *    return -1 if count < destMax and the output string  has been truncated
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ *
+ */
+int snprintf_s(char *strDest, size_t destMax, size_t count, const char *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vsnprintf_s(strDest, destMax, count, format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(snprintf_s);
+#endif
+#endif
+
+#if SECUREC_SNPRINTF_TRUNCATED
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The snprintf_truncated_s function is equivalent to the snprintf function
+ *    except for the parameter destMax/count and the explicit runtime-constraints violation
+ *    The snprintf_truncated_s function formats and stores count or fewer characters in
+ *    strDest and appends a terminating null. Each argument (if any) is converted
+ *    and output according to the corresponding format specification in format.
+ *    The formatting is consistent with the printf family of functions; If copying
+ *    occurs between strings that overlap, the behavior is undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                 Storage location for the output.
+ *    destMax                 The size of the storage location for output. Size
+ *                                 in bytes for snprintf_truncated_s or size in words for snwprintf_s.
+ *    format                  Format-control string.
+ *    ...                        Optional arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                 is updated
+ *
+ * <RETURN VALUE>
+ *    return  the number of characters written, not including the terminating null
+ *    return -1 if an  error occurs.
+ *    return destMax-1 if output string  has been truncated
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ *
+ */
+int snprintf_truncated_s(char *strDest, size_t destMax, const char *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vsnprintf_truncated_s(strDest, destMax, format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(snprintf_truncated_s);
+#endif
+
+#endif
+
diff --git a/lib/libsecurec/src/sprintf_s.c b/lib/libsecurec/src/sprintf_s.c
new file mode 100644
index 0000000..0cf3fca
--- /dev/null
+++ b/lib/libsecurec/src/sprintf_s.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: sprintf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The sprintf_s function is equivalent to the sprintf function
+ *    except for the parameter destMax and the explicit runtime-constraints violation
+ *    The sprintf_s function formats and stores a series of characters and values
+ *    in strDest. Each argument (if any) is converted and output according to
+ *    the corresponding format specification in format. The format consists of
+ *    ordinary characters and has the same form and function as the format argument
+ *    for printf. A null character is appended after the last character written.
+ *    If copying occurs between strings that overlap, the behavior is undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                 Storage location for output.
+ *    destMax                Maximum number of characters to store.
+ *    format                  Format-control string.
+ *    ...                        Optional arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                 is updated
+ *
+ * <RETURN VALUE>
+ *    return the number of bytes stored in strDest, not counting the terminating null character.
+ *    return -1 if an error occurred.
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+int sprintf_s(char *strDest, size_t destMax, const char *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vsprintf_s(strDest, destMax, format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(sprintf_s);
+#endif
+
diff --git a/lib/libsecurec/src/sscanf_s.c b/lib/libsecurec/src/sscanf_s.c
new file mode 100644
index 0000000..b441329
--- /dev/null
+++ b/lib/libsecurec/src/sscanf_s.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: sscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The sscanf_s function is equivalent to fscanf_s,
+ *     except that input is obtained from a string (specified by the argument buffer) rather than from a stream
+ *    The sscanf function reads data from buffer into the location given by each
+ *    argument. Every argument must be a pointer to a variable with a type that
+ *    corresponds to a type specifier in format. The format argument controls the
+ *    interpretation of the input fields and has the same form and function as
+ *    the format argument for the scanf function.
+ *    If copying takes place between strings that overlap, the behavior is undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    buffer                 Stored data.
+ *    format                 Format control string, see Format Specifications.
+ *    ...                    Optional arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    ...                    The converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Each of these functions returns the number of fields successfully converted
+ *    and assigned; the return value does not include fields that were read but
+ *    not assigned.
+ *    A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int sscanf_s(const char *buffer, const char *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vsscanf_s(buffer, format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(sscanf_s);
+#endif
+
diff --git a/lib/libsecurec/src/strcat_s.c b/lib/libsecurec/src/strcat_s.c
new file mode 100644
index 0000000..f835e7b
--- /dev/null
+++ b/lib/libsecurec/src/strcat_s.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: strcat_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+/*
+ * Befor this function, the basic parameter checking has been done
+ */
+SECUREC_INLINE errno_t SecDoCat(char *strDest, size_t destMax, const char *strSrc)
+{
+    size_t destLen;
+    size_t srcLen;
+    size_t maxSrcLen;
+    SECUREC_CALC_STR_LEN(strDest, destMax, &destLen);
+    /* Only optimize strSrc, do not apply this function to strDest */
+    maxSrcLen = destMax - destLen;
+    SECUREC_CALC_STR_LEN_OPT(strSrc, maxSrcLen, &srcLen);
+
+    if (SECUREC_CAT_STRING_IS_OVERLAP(strDest, destLen, strSrc, srcLen)) {
+        strDest[0] = '\0';
+        if (strDest + destLen <= strSrc && destLen == destMax) {
+            SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
+            return EINVAL_AND_RESET;
+        }
+        SECUREC_ERROR_BUFFER_OVERLAP("strcat_s");
+        return EOVERLAP_AND_RESET;
+    }
+    if (srcLen + destLen >= destMax || strDest == strSrc) {
+        strDest[0] = '\0';
+        if (destLen == destMax) {
+            SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
+            return EINVAL_AND_RESET;
+        }
+        SECUREC_ERROR_INVALID_RANGE("strcat_s");
+        return ERANGE_AND_RESET;
+    }
+    SECUREC_MEMCPY_WARP_OPT(strDest + destLen, strSrc, srcLen + 1); /* Single character length  include \0 */
+    return EOK;
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *  The strcat_s function appends a copy of the string pointed to by strSrc (including the terminating null character)
+ *  to the end of the  string pointed to by strDest.
+ *  The initial character of strSrc overwrites the terminating null character of strDest.
+ *  strcat_s will return EOVERLAP_AND_RESET if the source and destination strings overlap.
+ *
+ *  Note that the second parameter is the total size of the buffer, not the
+ *  remaining size.
+ *
+ * <INPUT PARAMETERS>
+ *  strDest             Null-terminated destination string buffer.
+ *  destMax             Size of the destination string buffer.
+ *  strSrc              Null-terminated source string buffer.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest             is updated
+ *
+ * <RETURN VALUE>
+ *    EOK                 Success
+ *    EINVAL              strDest is  NULL and destMax != 0 and destMax <= SECUREC_STRING_MAX_LEN
+ *    EINVAL_AND_RESET    (strDest unterminated  and all other parameters are valid) or
+ *                        (strDest != NULL and strSrc is NULL and destMax != 0 and destMax <= SECUREC_STRING_MAX_LEN)
+ *    ERANGE              destMax is 0 and destMax > SECUREC_STRING_MAX_LEN
+ *    ERANGE_AND_RESET      strDest have not enough space  and all other parameters are valid  and not overlap
+ *    EOVERLAP_AND_RESET   dest buffer and source buffer are overlapped and all  parameters are valid
+ *
+ *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+errno_t strcat_s(char *strDest, size_t destMax, const char *strSrc)
+{
+    if (destMax == 0 || destMax > SECUREC_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("strcat_s");
+        return ERANGE;
+    }
+    if (strDest == NULL || strSrc == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
+        if (strDest != NULL) {
+            strDest[0] = '\0';
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    return SecDoCat(strDest, destMax, strSrc);
+}
+
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(strcat_s);
+#endif
+
diff --git a/lib/libsecurec/src/strcpy_s.c b/lib/libsecurec/src/strcpy_s.c
new file mode 100644
index 0000000..ca1b2dd
--- /dev/null
+++ b/lib/libsecurec/src/strcpy_s.c
@@ -0,0 +1,353 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: strcpy_s  function
+ * Create: 2014-02-25
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Performance-sensitive
+ * [reason] Always used in the performance critical path,
+ *          and sufficient input validation is performed before calling
+ */
+
+#include "securecutil.h"
+
+#ifndef SECUREC_STRCPY_WITH_PERFORMANCE
+#define SECUREC_STRCPY_WITH_PERFORMANCE 1
+#endif
+
+#define SECUREC_STRCPY_PARAM_OK(strDest, destMax, strSrc) ((destMax) > 0 && \
+    (destMax) <= SECUREC_STRING_MAX_LEN && (strDest) != NULL && (strSrc) != NULL && (strDest) != (strSrc))
+
+#if (!SECUREC_IN_KERNEL) && SECUREC_STRCPY_WITH_PERFORMANCE
+#ifndef SECUREC_STRCOPY_THRESHOLD_SIZE
+#define SECUREC_STRCOPY_THRESHOLD_SIZE   32UL
+#endif
+/* The purpose of converting to void is to clean up the alarm */
+#define SECUREC_SMALL_STR_COPY(strDest, strSrc, lenWithTerm) do { \
+    if (SECUREC_ADDR_ALIGNED_8(strDest) && SECUREC_ADDR_ALIGNED_8(strSrc)) { \
+        /* Use struct assignment */ \
+        switch (lenWithTerm) { \
+            case 1: \
+                *(strDest) = *(strSrc); \
+                break; \
+            case 2: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 2); \
+                break; \
+            case 3: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 3); \
+                break; \
+            case 4: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 4); \
+                break; \
+            case 5: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 5); \
+                break; \
+            case 6: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 6); \
+                break; \
+            case 7: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 7); \
+                break; \
+            case 8: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 8); \
+                break; \
+            case 9: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 9); \
+                break; \
+            case 10: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 10); \
+                break; \
+            case 11: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 11); \
+                break; \
+            case 12: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 12); \
+                break; \
+            case 13: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 13); \
+                break; \
+            case 14: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 14); \
+                break; \
+            case 15: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 15); \
+                break; \
+            case 16: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 16); \
+                break; \
+            case 17: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 17); \
+                break; \
+            case 18: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 18); \
+                break; \
+            case 19: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 19); \
+                break; \
+            case 20: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 20); \
+                break; \
+            case 21: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 21); \
+                break; \
+            case 22: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 22); \
+                break; \
+            case 23: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 23); \
+                break; \
+            case 24: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 24); \
+                break; \
+            case 25: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 25); \
+                break; \
+            case 26: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 26); \
+                break; \
+            case 27: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 27); \
+                break; \
+            case 28: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 28); \
+                break; \
+            case 29: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 29); \
+                break; \
+            case 30: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 30); \
+                break; \
+            case 31: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 31); \
+                break; \
+            case 32: \
+                SECUREC_COPY_VALUE_BY_STRUCT((strDest), (strSrc), 32); \
+                break; \
+            default: \
+                /* Do nothing */ \
+                break; \
+        } /* END switch */ \
+    } else { \
+        char *tmpStrDest_ = (char *)(strDest); \
+        const char *tmpStrSrc_ = (const char *)(strSrc); \
+        switch (lenWithTerm) { \
+            case 32: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 31: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 30: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 29: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 28: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 27: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 26: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 25: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 24: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 23: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 22: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 21: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 20: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 19: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 18: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 17: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 16: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 15: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 14: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 13: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 12: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 11: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 10: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 9: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 8: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 7: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 6: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 5: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 4: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 3: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 2: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            case 1: \
+                *(tmpStrDest_++) = *(tmpStrSrc_++); \
+                /* fall-through */ /* FALLTHRU */ \
+            default: \
+                /* Do nothing */ \
+                break; \
+        } \
+    } \
+} SECUREC_WHILE_ZERO
+#endif
+
+#if SECUREC_IN_KERNEL || (!SECUREC_STRCPY_WITH_PERFORMANCE)
+#define SECUREC_STRCPY_OPT(dest, src, lenWithTerm) SECUREC_MEMCPY_WARP_OPT((dest), (src), (lenWithTerm))
+#else
+/*
+ * Performance optimization. lenWithTerm  include '\0'
+ */
+#define SECUREC_STRCPY_OPT(dest, src, lenWithTerm) do { \
+    if ((lenWithTerm) > SECUREC_STRCOPY_THRESHOLD_SIZE) { \
+        SECUREC_MEMCPY_WARP_OPT((dest), (src), (lenWithTerm)); \
+    } else { \
+        SECUREC_SMALL_STR_COPY((dest), (src), (lenWithTerm)); \
+    } \
+} SECUREC_WHILE_ZERO
+#endif
+
+/*
+ * Check Src Range
+ */
+SECUREC_INLINE errno_t CheckSrcRange(char *strDest, size_t destMax, const char *strSrc)
+{
+    size_t tmpDestMax = destMax;
+    const char *tmpSrc = strSrc;
+    /* Use destMax as boundary checker and destMax must be greater than zero */
+    while (*tmpSrc != '\0' && tmpDestMax > 0) {
+        ++tmpSrc;
+        --tmpDestMax;
+    }
+    if (tmpDestMax == 0) {
+        strDest[0] = '\0';
+        SECUREC_ERROR_INVALID_RANGE("strcpy_s");
+        return ERANGE_AND_RESET;
+    }
+    return EOK;
+}
+
+/*
+ * Handling errors
+ */
+errno_t strcpy_error(char *strDest, size_t destMax, const char *strSrc)
+{
+    if (destMax == 0 || destMax > SECUREC_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("strcpy_s");
+        return ERANGE;
+    }
+    if (strDest == NULL || strSrc == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("strcpy_s");
+        if (strDest != NULL) {
+            strDest[0] = '\0';
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    return CheckSrcRange(strDest, destMax, strSrc);
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The strcpy_s function copies the string pointed to  strSrc
+ *          (including the terminating null character) into the array pointed to by strDest
+ *    The destination string must be large enough to hold the source string,
+ *    including the terminating null character. strcpy_s will return EOVERLAP_AND_RESET
+ *    if the source and destination strings overlap.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                          Location of destination string buffer
+ *    destMax                        Size of the destination string buffer.
+ *    strSrc                            Null-terminated source string buffer.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                         is updated.
+ *
+ * <RETURN VALUE>
+ *    EOK                               Success
+ *    EINVAL                          strDest is  NULL and destMax != 0 and destMax <= SECUREC_STRING_MAX_LEN
+ *    EINVAL_AND_RESET       strDest !=  NULL and strSrc is NULL and destMax != 0 and destMax <= SECUREC_STRING_MAX_LEN
+ *    ERANGE                         destMax is 0 and destMax > SECUREC_STRING_MAX_LEN
+ *    ERANGE_AND_RESET      strDest have not enough space  and all other parameters are valid  and not overlap
+ *    EOVERLAP_AND_RESET   dest buffer and source buffer are overlapped and all  parameters are valid
+ *
+ *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+errno_t strcpy_s(char *strDest, size_t destMax, const char *strSrc)
+{
+    if (SECUREC_STRCPY_PARAM_OK(strDest, destMax, strSrc)) {
+        size_t srcStrLen;
+        SECUREC_CALC_STR_LEN(strSrc, destMax, &srcStrLen);
+        ++srcStrLen; /* The length include '\0' */
+
+        if (srcStrLen <= destMax) {
+            /* Use mem overlap check include '\0' */
+            if (SECUREC_MEMORY_NO_OVERLAP(strDest, strSrc, srcStrLen)) {
+                /* Performance optimization srcStrLen include '\0' */
+                SECUREC_STRCPY_OPT(strDest, strSrc, srcStrLen);
+                return EOK;
+            } else {
+                strDest[0] = '\0';
+                SECUREC_ERROR_BUFFER_OVERLAP("strcpy_s");
+                return EOVERLAP_AND_RESET;
+            }
+        }
+    }
+    return strcpy_error(strDest, destMax, strSrc);
+}
+
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(strcpy_s);
+#endif
+
diff --git a/lib/libsecurec/src/strncat_s.c b/lib/libsecurec/src/strncat_s.c
new file mode 100644
index 0000000..6686d29
--- /dev/null
+++ b/lib/libsecurec/src/strncat_s.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: strncat_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+/*
+ * Befor this function, the basic parameter checking has been done
+ */
+SECUREC_INLINE errno_t SecDoCatLimit(char *strDest, size_t destMax, const char *strSrc, size_t count)
+{
+    size_t destLen;
+    size_t srcLen;
+    SECUREC_CALC_STR_LEN(strDest, destMax, &destLen);
+    /*
+     * The strSrc is no longer optimized. The reason is that when count is small,
+     * the efficiency of strnlen is higher than that of self realization.
+     */
+    SECUREC_CALC_STR_LEN(strSrc, count, &srcLen);
+
+    if (SECUREC_CAT_STRING_IS_OVERLAP(strDest, destLen, strSrc, srcLen)) {
+        strDest[0] = '\0';
+        if (strDest + destLen <= strSrc && destLen == destMax) {
+            SECUREC_ERROR_INVALID_PARAMTER("strncat_s");
+            return EINVAL_AND_RESET;
+        }
+        SECUREC_ERROR_BUFFER_OVERLAP("strncat_s");
+        return EOVERLAP_AND_RESET;
+    }
+    if (srcLen + destLen >= destMax || strDest == strSrc) {
+        strDest[0] = '\0';
+        if (destLen == destMax) {
+            SECUREC_ERROR_INVALID_PARAMTER("strncat_s");
+            return EINVAL_AND_RESET;
+        }
+        SECUREC_ERROR_INVALID_RANGE("strncat_s");
+        return ERANGE_AND_RESET;
+    }
+    SECUREC_MEMCPY_WARP_OPT(strDest + destLen, strSrc, srcLen);    /* No terminator */
+    *(strDest + destLen + srcLen) = '\0';
+    return EOK;
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The strncat_s function appends not more than n successive  characters
+ *    (not including the terminating null  character)
+ *     from the array pointed to by strSrc to the end of the  string pointed to by strDest
+ *    The strncat_s function try to append the first D characters of strSrc to
+ *    the end of strDest, where D is the lesser of count and the length of strSrc.
+ *    If appending those D characters will fit within strDest (whose size is given
+ *    as destMax) and still leave room for a null terminator, then those characters
+ *    are appended, starting at the original terminating null of strDest, and a
+ *    new terminating null is appended; otherwise, strDest[0] is set to the null
+ *    character.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest            Null-terminated destination string.
+ *    destMax            Size of the destination buffer.
+ *    strSrc             Null-terminated source string.
+ *    count              Number of character to append, or truncate.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest            is updated
+ *
+ * <RETURN VALUE>
+ *    EOK                Success
+ *    EINVAL             strDest is  NULL and destMax != 0 and destMax <= SECUREC_STRING_MAX_LEN
+ *    EINVAL_AND_RESET      (strDest unterminated  and all other parameters are valid)or
+ *                        (strDest !=  NULL and strSrc is NULL and destMax != 0 and destMax <= SECUREC_STRING_MAX_LEN)
+ *    ERANGE                         destMax is 0 and destMax > SECUREC_STRING_MAX_LEN
+ *    ERANGE_AND_RESET      strDest have not enough space  and all other parameters are valid  and not overlap
+ *    EOVERLAP_AND_RESET   dest buffer and source buffer are overlapped and all  parameters are valid
+ *
+ *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+errno_t strncat_s(char *strDest, size_t destMax, const char *strSrc, size_t count)
+{
+    if (destMax == 0 || destMax > SECUREC_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("strncat_s");
+        return ERANGE;
+    }
+
+    if (strDest == NULL || strSrc == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("strncat_s");
+        if (strDest != NULL) {
+            strDest[0] = '\0';
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    if (count > SECUREC_STRING_MAX_LEN) {
+#ifdef  SECUREC_COMPATIBLE_WIN_FORMAT
+        if (count == (size_t)(-1)) {
+            /* Windows internal functions may pass in -1 when calling this function */
+            return SecDoCatLimit(strDest, destMax, strSrc, destMax);
+        }
+#endif
+        strDest[0] = '\0';
+        SECUREC_ERROR_INVALID_RANGE("strncat_s");
+        return ERANGE_AND_RESET;
+    }
+    return SecDoCatLimit(strDest, destMax, strSrc, count);
+}
+
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(strncat_s);
+#endif
+
diff --git a/lib/libsecurec/src/strncpy_s.c b/lib/libsecurec/src/strncpy_s.c
new file mode 100644
index 0000000..5f4c5b7
--- /dev/null
+++ b/lib/libsecurec/src/strncpy_s.c
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: strncpy_s  function
+ * Create: 2014-02-25
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Performance-sensitive
+ * [reason] Always used in the performance critical path,
+ *          and sufficient input validation is performed before calling
+ */
+
+#include "securecutil.h"
+
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+#define SECUREC_STRNCPY_PARAM_OK(strDest, destMax, strSrc, count) \
+    (((destMax) > 0 && (destMax) <= SECUREC_STRING_MAX_LEN && (strDest) != NULL && (strSrc) != NULL && \
+    ((count) <= SECUREC_STRING_MAX_LEN || (count) == ((size_t)(-1))) && (count) > 0))
+#else
+#define SECUREC_STRNCPY_PARAM_OK(strDest, destMax, strSrc, count) \
+    (((destMax) > 0 && (destMax) <= SECUREC_STRING_MAX_LEN && (strDest) != NULL && (strSrc) != NULL && \
+    (count) <= SECUREC_STRING_MAX_LEN && (count) > 0))
+#endif
+
+/*
+ * Check Src Count Range
+ */
+SECUREC_INLINE errno_t CheckSrcCountRange(char *strDest, size_t destMax, const char *strSrc, size_t count)
+{
+    size_t tmpDestMax = destMax;
+    size_t tmpCount = count;
+    const char *endPos = strSrc;
+
+    /* Use destMax and  count as boundary checker and destMax must be greater than zero */
+    while (*(endPos) != '\0' && tmpDestMax > 0 && tmpCount > 0) {
+        ++endPos;
+        --tmpCount;
+        --tmpDestMax;
+    }
+    if (tmpDestMax == 0) {
+        strDest[0] = '\0';
+        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
+        return ERANGE_AND_RESET;
+    }
+    return EOK;
+}
+
+/*
+ * Handling errors, when dest equal src return EOK
+ */
+errno_t strncpy_error(char *strDest, size_t destMax, const char *strSrc, size_t count)
+{
+    if (destMax == 0 || destMax > SECUREC_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
+        return ERANGE;
+    }
+    if (strDest == NULL || strSrc == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("strncpy_s");
+        if (strDest != NULL) {
+            strDest[0] = '\0';
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    if (count > SECUREC_STRING_MAX_LEN) {
+        strDest[0] = '\0';      /* Clear dest string */
+        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
+        return ERANGE_AND_RESET;
+    }
+    if (count == 0) {
+        strDest[0] = '\0';
+        return EOK;
+    }
+    return CheckSrcCountRange(strDest, destMax, strSrc, count);
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *   The strncpy_s function copies not more than n successive characters (not including the terminating null character)
+ *                     from the array pointed to by strSrc to the array pointed to by strDest.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                          Destination string.
+ *    destMax                          The size of the destination string, in characters.
+ *    strSrc                            Source string.
+ *    count                              Number of characters to be copied.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                           is updated
+ *
+ * <RETURN VALUE>
+ *    EOK                               Success
+ *    EINVAL                          strDest is  NULL and destMax != 0 and destMax <= SECUREC_STRING_MAX_LEN
+ *    EINVAL_AND_RESET       strDest !=  NULL and strSrc is NULL and destMax != 0 and destMax <= SECUREC_STRING_MAX_LEN
+ *    ERANGE                         destMax is 0 and destMax > SECUREC_STRING_MAX_LEN
+ *    ERANGE_AND_RESET      strDest have not enough space  and all other parameters are valid  and not overlap
+ *    EOVERLAP_AND_RESET   dest buffer and source buffer are overlapped and all  parameters are valid
+ *
+ *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+errno_t strncpy_s(char *strDest, size_t destMax, const char *strSrc, size_t count)
+{
+    if (SECUREC_STRNCPY_PARAM_OK(strDest, destMax, strSrc, count)) {
+        size_t minCpLen;        /* Use it to store the maxi length limit */
+        if (count < destMax) {
+            SECUREC_CALC_STR_LEN(strSrc, count, &minCpLen); /* No ending terminator */
+        } else {
+            size_t tmpCount = destMax;
+#ifdef  SECUREC_COMPATIBLE_WIN_FORMAT
+            if (count == ((size_t)(-1))) {
+                tmpCount = destMax - 1;
+            }
+#endif
+            SECUREC_CALC_STR_LEN(strSrc, tmpCount, &minCpLen); /* No ending terminator */
+            if (minCpLen == destMax) {
+                strDest[0] = '\0';
+                SECUREC_ERROR_INVALID_RANGE("strncpy_s");
+                return ERANGE_AND_RESET;
+            }
+        }
+        if (SECUREC_STRING_NO_OVERLAP(strDest, strSrc, minCpLen) || strDest == strSrc) {
+            /* Not overlap */
+            SECUREC_MEMCPY_WARP_OPT(strDest, strSrc, minCpLen);    /* Copy string without terminator */
+            strDest[minCpLen] = '\0';
+            return EOK;
+        } else {
+            strDest[0] = '\0';
+            SECUREC_ERROR_BUFFER_OVERLAP("strncpy_s");
+            return EOVERLAP_AND_RESET;
+        }
+    }
+    return strncpy_error(strDest, destMax, strSrc, count);
+}
+
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(strncpy_s);
+#endif
+
diff --git a/lib/libsecurec/src/strtok_s.c b/lib/libsecurec/src/strtok_s.c
new file mode 100644
index 0000000..cd5dcd2
--- /dev/null
+++ b/lib/libsecurec/src/strtok_s.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: strtok_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+SECUREC_INLINE int SecIsInDelimit(char ch, const char *strDelimit)
+{
+    const char *ctl = strDelimit;
+    while (*ctl != '\0' && *ctl != ch) {
+        ++ctl;
+    }
+    return (int)(*ctl != '\0');
+}
+
+/*
+ * Find beginning of token (skip over leading delimiters).
+ * Note that there is no token if this loop sets string to point to the terminal null.
+ */
+SECUREC_INLINE char *SecFindBegin(char *strToken, const char *strDelimit)
+{
+    char *token = strToken;
+    while (*token != '\0') {
+        if (SecIsInDelimit(*token, strDelimit) != 0) {
+            ++token;
+            continue;
+        }
+        /* Don't find any delimiter in string header, break the loop */
+        break;
+    }
+    return token;
+}
+
+/*
+ * Find rest of token
+ */
+SECUREC_INLINE char *SecFindRest(char *strToken, const char *strDelimit)
+{
+    /* Find the rest of the token. If it is not the end of the string, put a null there */
+    char *token = strToken;
+    while (*token != '\0') {
+        if (SecIsInDelimit(*token, strDelimit) != 0) {
+            /* Find a delimiter, set string terminator */
+            *token = '\0';
+            ++token;
+            break;
+        }
+        ++token;
+    }
+    return token;
+}
+
+/*
+ * Find the final position pointer
+ */
+SECUREC_INLINE char *SecUpdateToken(char *strToken, const char *strDelimit, char **context)
+{
+    /* Point to updated position. Record string position for next search in the context */
+    *context = SecFindRest(strToken, strDelimit);
+    /* Determine if a token has been found. */
+    if (*context == strToken) {
+        return NULL;
+    }
+    return strToken;
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The strtok_s function parses a string into a sequence of strToken,
+ *    replace all characters in strToken string that match to strDelimit set with 0.
+ *    On the first call to strtok_s the string to be parsed should be specified in strToken.
+ *    In each subsequent call that should parse the same string, strToken should be NULL
+ * <INPUT PARAMETERS>
+ *    strToken            String containing token or tokens.
+ *    strDelimit          Set of delimiter characters.
+ *    context             Used to store position information between calls
+ *                             to strtok_s
+ * <OUTPUT PARAMETERS>
+ *   context               is updated
+ * <RETURN VALUE>
+ *   On the first call returns the address of the first non \0 character, otherwise NULL is returned.
+ *   In subsequent calls, the strtoken is set to NULL, and the context set is the same as the previous call,
+ *   return NULL if the *context string length is equal 0, otherwise return *context.
+ */
+char *strtok_s(char *strToken, const char *strDelimit, char **context)
+{
+    char *orgToken = strToken;
+    /* Validate delimiter and string context */
+    if (context == NULL || strDelimit == NULL) {
+        return NULL;
+    }
+    /* Valid input string and string pointer from where to search */
+    if (orgToken == NULL && *context == NULL) {
+        return NULL;
+    }
+    /* If string is null, continue searching from previous string position stored in context */
+    if (orgToken == NULL) {
+        orgToken = *context;
+    }
+    orgToken = SecFindBegin(orgToken, strDelimit);
+    return SecUpdateToken(orgToken, strDelimit, context);
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(strtok_s);
+#endif
+
diff --git a/lib/libsecurec/src/sub.mk b/lib/libsecurec/src/sub.mk
new file mode 100644
index 0000000..25c7992
--- /dev/null
+++ b/lib/libsecurec/src/sub.mk
@@ -0,0 +1,31 @@
+srcs-y += fscanf_s.c
+srcs-y += fwscanf_s.c
+srcs-y += memcpy_s.c
+srcs-y += memmove_s.c
+srcs-y += memset_s.c
+srcs-y += scanf_s.c
+srcs-y += securecutil.c
+srcs-y += snprintf_s.c
+srcs-y += sprintf_s.c
+srcs-y += sscanf_s.c
+srcs-y += strcat_s.c
+srcs-y += strcpy_s.c
+srcs-y += strncat_s.c
+srcs-y += strncpy_s.c
+srcs-y += strtok_s.c
+srcs-y += swprintf_s.c
+srcs-y += swscanf_s.c
+srcs-y += vsnprintf_s.c
+srcs-y += vsprintf_s.c
+srcs-y += vsscanf_s.c
+srcs-y += vswprintf_s.c
+srcs-y += vswscanf_s.c
+srcs-y += wcscat_s.c
+srcs-y += wcscpy_s.c
+srcs-y += wcsncat_s.c
+srcs-y += wcsncpy_s.c
+srcs-y += wcstok_s.c
+srcs-y += wmemcpy_s.c
+srcs-y += wmemmove_s.c
+srcs-y += wscanf_s.c
+srcs-y += secureprintoutput_a.c
diff --git a/lib/libsecurec/src/swprintf_s.c b/lib/libsecurec/src/swprintf_s.c
new file mode 100644
index 0000000..09d77a2
--- /dev/null
+++ b/lib/libsecurec/src/swprintf_s.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: swprintf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *   The  swprintf_s  function  is  the  wide-character  equivalent  of the sprintf_s function
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                   Storage location for the output.
+ *    destMax                   Maximum number of characters to store.
+ *    format                    Format-control string.
+ *    ...                        Optional arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                    is updated
+ *
+ * <RETURN VALUE>
+ *    return  the number of wide characters stored in strDest, not  counting the terminating null wide character.
+ *    return -1  if an error occurred.
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+int swprintf_s(wchar_t *strDest, size_t destMax, const wchar_t *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vswprintf_s(strDest, destMax, format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+
diff --git a/lib/libsecurec/src/swscanf_s.c b/lib/libsecurec/src/swscanf_s.c
new file mode 100644
index 0000000..e5b8bbf
--- /dev/null
+++ b/lib/libsecurec/src/swscanf_s.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: swscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The  swscanf_s  function  is  the  wide-character  equivalent  of the sscanf_s function
+ *    The swscanf_s function reads data from buffer into the location given by
+ *    each argument. Every argument must be a pointer to a variable with a type
+ *    that corresponds to a type specifier in format. The format argument controls
+ *    the interpretation of the input fields and has the same form and function
+ *    as the format argument for the scanf function. If copying takes place between
+ *    strings that overlap, the behavior is undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    buffer                 Stored data.
+ *    format                 Format control string, see Format Specifications.
+ *    ...                    Optional arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    ...                    the converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Each of these functions returns the number of fields successfully converted
+ *    and assigned; The return value does not include fields that were read but not
+ *    assigned.
+ *    A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int swscanf_s(const wchar_t *buffer, const wchar_t *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vswscanf_s(buffer, format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+
diff --git a/lib/libsecurec/src/vfscanf_s.c b/lib/libsecurec/src/vfscanf_s.c
new file mode 100644
index 0000000..214ee6a
--- /dev/null
+++ b/lib/libsecurec/src/vfscanf_s.c
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vfscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "secinput.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The vfscanf_s function is equivalent to fscanf_s, with the variable argument list replaced by argList
+ *    The vfscanf_s function reads data from the current position of stream into
+ *    the locations given by argument (if any). Each argument must be a pointer
+ *    to a variable of a type that corresponds to a type specifier in format.
+ *    format controls the interpretation of the input fields and has the same
+ *    form and function as the format argument for scanf.
+ *
+ * <INPUT PARAMETERS>
+ *    stream               Pointer to FILE structure.
+ *    format               Format control string, see Format Specifications.
+ *    argList              pointer to list of arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    argList              the converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Each of these functions returns the number of fields successfully converted
+ *    and assigned; the return value does not include fields that were read but
+ *    not assigned. A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int vfscanf_s(FILE *stream, const char *format, va_list argList)
+{
+    int retVal;                 /* If initialization causes  e838 */
+    SecFileStream fStr;
+
+    if (stream == NULL || format == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("vfscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    if (stream == SECUREC_STREAM_STDIN) {
+        return vscanf_s(format, argList);
+    }
+
+    SECUREC_LOCK_FILE(stream);
+    SECUREC_FILE_STREAM_FROM_FILE(&fStr, stream);
+    retVal = SecInputS(&fStr, format, argList);
+    SECUREC_UNLOCK_FILE(stream);
+    if (retVal < 0) {
+        SECUREC_ERROR_INVALID_PARAMTER("vfscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+
+    return retVal;
+}
+
diff --git a/lib/libsecurec/src/vfwscanf_s.c b/lib/libsecurec/src/vfwscanf_s.c
new file mode 100644
index 0000000..1ab9c3c
--- /dev/null
+++ b/lib/libsecurec/src/vfwscanf_s.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vfwscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#ifndef SECUREC_FOR_WCHAR
+#define SECUREC_FOR_WCHAR
+#endif
+
+#include "secinput.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The  vfwscanf_s  function  is  the  wide-character  equivalent  of the vfscanf_s function
+ *    The vfwscanf_s function reads data from the current position of stream into
+ *    the locations given by argument (if any). Each argument must be a pointer
+ *    to a variable of a type that corresponds to a type specifier in format.
+ *    format controls the interpretation of the input fields and has the same form
+ *    and function as the format argument for scanf.
+ *
+ * <INPUT PARAMETERS>
+ *    stream               Pointer to FILE structure.
+ *    format               Format control string, see Format Specifications.
+ *    argList              pointer to list of arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    argList              the converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Each of these functions returns the number of fields successfully converted
+ *    and assigned; the return value does not include fields that were read but
+ *    not assigned. A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int vfwscanf_s(FILE *stream, const wchar_t *format, va_list argList)
+{
+    int retVal; /* If initialization causes  e838 */
+    SecFileStream fStr;
+
+    if (stream == NULL || format == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("vfwscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    if (stream == SECUREC_STREAM_STDIN) {
+        return vwscanf_s(format, argList);
+    }
+
+    SECUREC_LOCK_FILE(stream);
+    SECUREC_FILE_STREAM_FROM_FILE(&fStr, stream);
+    retVal = SecInputSW(&fStr, format, argList);
+    SECUREC_UNLOCK_FILE(stream);
+    if (retVal < 0) {
+        SECUREC_ERROR_INVALID_PARAMTER("vfwscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    return retVal;
+}
+
diff --git a/lib/libsecurec/src/vscanf_s.c b/lib/libsecurec/src/vscanf_s.c
new file mode 100644
index 0000000..61480a6
--- /dev/null
+++ b/lib/libsecurec/src/vscanf_s.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "secinput.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *     The vscanf_s function is equivalent to scanf_s, with the variable argument list replaced by argList,
+ *     The vscanf_s function reads data from the standard input stream stdin and
+ *    writes the data into the location that's given by argument. Each argument
+ *    must be a pointer to a variable of a type that corresponds to a type specifier
+ *    in format. If copying occurs between strings that overlap, the behavior is
+ *    undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    format                Format control string.
+ *    argList               pointer to list of arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    argList               the converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Returns the number of fields successfully converted and assigned;
+ *    the return value does not include fields that were read but not assigned.
+ *    A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int vscanf_s(const char *format, va_list argList)
+{
+    int retVal;                 /* If initialization causes  e838 */
+    SecFileStream fStr;
+    SECUREC_FILE_STREAM_FROM_STDIN(&fStr);
+    /*
+     * The "va_list" has different definition on different platform, so we can't use argList == NULL
+     * To determine it's invalid. If you has fixed platform, you can check some fields to validate it,
+     * such as "argList == NULL" or argList.xxx != NULL or *(size_t *)&argList != 0.
+     */
+    if (format == NULL || fStr.pf == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("vscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+
+    SECUREC_LOCK_STDIN(0, fStr.pf);
+    retVal = SecInputS(&fStr, format, argList);
+    SECUREC_UNLOCK_STDIN(0, fStr.pf);
+    if (retVal < 0) {
+        SECUREC_ERROR_INVALID_PARAMTER("vscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    return retVal;
+}
+
diff --git a/lib/libsecurec/src/vsnprintf_s.c b/lib/libsecurec/src/vsnprintf_s.c
new file mode 100644
index 0000000..35caaa2
--- /dev/null
+++ b/lib/libsecurec/src/vsnprintf_s.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vsnprintf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "secureprintoutput.h"
+
+#if SECUREC_ENABLE_VSNPRINTF
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The vsnprintf_s function is equivalent to the vsnprintf function
+ *     except for the parameter destMax/count and the explicit runtime-constraints violation
+ *    The vsnprintf_s function takes a pointer to an argument list, then formats
+ *    and writes up to count characters of the given data to the memory pointed
+ *    to by strDest and appends a terminating null.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                  Storage location for the output.
+ *    destMax                The size of the strDest for output.
+ *    count                    Maximum number of character to write(not including
+ *                                the terminating NULL)
+ *    format                   Format-control string.
+ *    argList                     pointer to list of arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                is updated
+ *
+ * <RETURN VALUE>
+ *    return  the number of characters written, not including the terminating null
+ *    return -1 if an  error occurs.
+ *    return -1 if count < destMax and the output string  has been truncated
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+int vsnprintf_s(char *strDest, size_t destMax, size_t count, const char *format, va_list argList)
+{
+    int retVal;
+
+    if (SECUREC_VSNPRINTF_PARAM_ERROR(format, strDest, destMax, count, SECUREC_STRING_MAX_LEN)) {
+        SECUREC_VSPRINTF_CLEAR_DEST(strDest, destMax, SECUREC_STRING_MAX_LEN);
+        SECUREC_ERROR_INVALID_PARAMTER("vsnprintf_s");
+        return -1;
+    }
+
+    if (destMax > count) {
+        retVal = SecVsnprintfImpl(strDest, count + 1, format, argList);
+        if (retVal == SECUREC_PRINTF_TRUNCATE) {  /* To keep dest buffer not destroyed 2014.2.18 */
+            /* The string has been truncated, return  -1 */
+            return -1;          /* To skip error handler,  return strlen(strDest) or -1 */
+        }
+    } else {
+        retVal = SecVsnprintfImpl(strDest, destMax, format, argList);
+#ifdef SECUREC_COMPATIBLE_WIN_FORMAT
+        if (retVal == SECUREC_PRINTF_TRUNCATE && count == (size_t)(-1)) {
+            return -1;
+        }
+#endif
+    }
+
+    if (retVal < 0) {
+        strDest[0] = '\0';      /* Empty the dest strDest */
+        if (retVal == SECUREC_PRINTF_TRUNCATE) {
+            /* Buffer too small */
+            SECUREC_ERROR_INVALID_RANGE("vsnprintf_s");
+        }
+        SECUREC_ERROR_INVALID_PARAMTER("vsnprintf_s");
+        return -1;
+    }
+
+    return retVal;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(vsnprintf_s);
+#endif
+#endif
+
+#if SECUREC_SNPRINTF_TRUNCATED
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The vsnprintf_truncated_s function is equivalent to the vsnprintf function
+ *     except for the parameter destMax/count and the explicit runtime-constraints violation
+ *    The vsnprintf_truncated_s function takes a pointer to an argument list, then formats
+ *    and writes up to count characters of the given data to the memory pointed
+ *    to by strDest and appends a terminating null.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                  Storage location for the output.
+ *    destMax                The size of the strDest for output.
+ *                                the terminating NULL)
+ *    format                   Format-control string.
+ *    argList                     pointer to list of arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                is updated
+ *
+ * <RETURN VALUE>
+ *    return  the number of characters written, not including the terminating null
+ *    return -1 if an  error occurs.
+ *    return destMax-1 if output string  has been truncated
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+int vsnprintf_truncated_s(char *strDest, size_t destMax, const char *format, va_list argList)
+{
+    int retVal;
+
+    if (SECUREC_VSPRINTF_PARAM_ERROR(format, strDest, destMax, SECUREC_STRING_MAX_LEN)) {
+        SECUREC_VSPRINTF_CLEAR_DEST(strDest, destMax, SECUREC_STRING_MAX_LEN);
+        SECUREC_ERROR_INVALID_PARAMTER("vsnprintf_truncated_s");
+        return -1;
+    }
+
+    retVal = SecVsnprintfImpl(strDest, destMax, format, argList);
+    if (retVal < 0) {
+        if (retVal == SECUREC_PRINTF_TRUNCATE) {
+            return (int)(destMax - 1);  /* To skip error handler,  return strlen(strDest) */
+        }
+        strDest[0] = '\0';      /* Empty the dest strDest */
+        SECUREC_ERROR_INVALID_PARAMTER("vsnprintf_truncated_s");
+        return -1;
+    }
+
+    return retVal;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(vsnprintf_truncated_s);
+#endif
+#endif
+
diff --git a/lib/libsecurec/src/vsprintf_s.c b/lib/libsecurec/src/vsprintf_s.c
new file mode 100644
index 0000000..f50fa4a
--- /dev/null
+++ b/lib/libsecurec/src/vsprintf_s.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vsprintf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "secureprintoutput.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The vsprintf_s function is equivalent to the vsprintf function
+ *    except for the parameter destMax and the explicit runtime-constraints violation
+ *    The vsprintf_s function takes a pointer to an argument list, and then formats
+ *    and writes the given data to the memory pointed to by strDest.
+ *    The function differ from the non-secure versions only in that the secure
+ *    versions support positional parameters.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                Storage location for the output.
+ *    destMax                Size of strDest
+ *    format                 Format specification.
+ *    argList                pointer to list of arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                is updated
+ *
+ * <RETURN VALUE>
+ *    return  the number of characters written, not including the terminating null character,
+ *    return -1  if an  error occurs.
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+int vsprintf_s(char *strDest, size_t destMax, const char *format, va_list argList)
+{
+    int retVal;               /* If initialization causes  e838 */
+
+    if (SECUREC_VSPRINTF_PARAM_ERROR(format, strDest, destMax, SECUREC_STRING_MAX_LEN)) {
+        SECUREC_VSPRINTF_CLEAR_DEST(strDest, destMax, SECUREC_STRING_MAX_LEN);
+        SECUREC_ERROR_INVALID_PARAMTER("vsprintf_s");
+        return -1;
+    }
+
+    retVal = SecVsnprintfImpl(strDest, destMax, format, argList);
+    if (retVal < 0) {
+        strDest[0] = '\0';
+        if (retVal == SECUREC_PRINTF_TRUNCATE) {
+            /* Buffer is too small */
+            SECUREC_ERROR_INVALID_RANGE("vsprintf_s");
+        }
+        SECUREC_ERROR_INVALID_PARAMTER("vsprintf_s");
+        return -1;
+    }
+
+    return retVal;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(vsprintf_s);
+#endif
+
diff --git a/lib/libsecurec/src/vsscanf_s.c b/lib/libsecurec/src/vsscanf_s.c
new file mode 100644
index 0000000..a19abe2
--- /dev/null
+++ b/lib/libsecurec/src/vsscanf_s.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vsscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "secinput.h"
+#if defined(SECUREC_VXWORKS_PLATFORM) && !SECUREC_IN_KERNEL && \
+    (!defined(SECUREC_SYSAPI4VXWORKS) && !defined(SECUREC_CTYPE_MACRO_ADAPT))
+#include <ctype.h>
+#endif
+
+/*
+ * <NAME>
+ *    vsscanf_s
+ *
+ *
+ * <FUNCTION DESCRIPTION>
+ *    The vsscanf_s function is equivalent to sscanf_s, with the variable argument list replaced by argList
+ *    The vsscanf_s function reads data from buffer into the location given by
+ *    each argument. Every argument must be a pointer to a variable with a type
+ *    that corresponds to a type specifier in format. The format argument controls
+ *    the interpretation of the input fields and has the same form and function
+ *    as the format argument for the scanf function.
+ *    If copying takes place between strings that overlap, the behavior is undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    buffer                Stored data
+ *    format                Format control string, see Format Specifications.
+ *    argList               pointer to list of arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    argList               the converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Each of these functions returns the number of fields successfully converted
+ *    and assigned; the return value does not include fields that were read but
+ *    not assigned. A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int vsscanf_s(const char *buffer, const char *format, va_list argList)
+{
+    size_t count;               /* If initialization causes  e838 */
+    int retVal;
+    SecFileStream fStr;
+
+    /* Validation section */
+    if (buffer == NULL || format == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("vsscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    count = strlen(buffer);
+    if (count == 0 || count > SECUREC_STRING_MAX_LEN) {
+        SecClearDestBuf(buffer, format, argList);
+        SECUREC_ERROR_INVALID_PARAMTER("vsscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+#if defined(SECUREC_VXWORKS_PLATFORM) && !SECUREC_IN_KERNEL
+    /*
+     * On vxworks platform when buffer is white string, will set first %s argument to zero.Like following usage:
+     * "   \v\f\t\r\n", "%s", str, strSize
+     * Do not check all character, just first and last character then consider it is white string
+     */
+    if (isspace((int)(unsigned char)buffer[0]) != 0 && isspace((int)(unsigned char)buffer[count - 1]) != 0) {
+        SecClearDestBuf(buffer, format, argList);
+    }
+#endif
+    SECUREC_FILE_STREAM_FROM_STRING(&fStr, buffer, count);
+    retVal = SecInputS(&fStr, format, argList);
+    if (retVal < 0) {
+        SECUREC_ERROR_INVALID_PARAMTER("vsscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    return retVal;
+}
+#if SECUREC_EXPORT_KERNEL_SYMBOL
+EXPORT_SYMBOL(vsscanf_s);
+#endif
+
diff --git a/lib/libsecurec/src/vswprintf_s.c b/lib/libsecurec/src/vswprintf_s.c
new file mode 100644
index 0000000..29715fc
--- /dev/null
+++ b/lib/libsecurec/src/vswprintf_s.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vswprintf_s  function
+ * Create: 2014-02-25
+ */
+
+#ifndef SECUREC_FOR_WCHAR
+#define SECUREC_FOR_WCHAR
+#endif
+
+#include "secureprintoutput.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The  vswprintf_s  function  is  the  wide-character  equivalent  of the vsprintf_s function
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                  Storage location for the output.
+ *    destMax                  Maximum number of characters to store
+ *    format                   Format specification.
+ *    argList                  pointer to list of arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                 is updated
+ *
+ * <RETURN VALUE>
+ *    return  the number of wide characters stored in strDest, not  counting the terminating null wide character.
+ *    return -1  if an error occurred.
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+int vswprintf_s(wchar_t *strDest, size_t destMax, const wchar_t *format, va_list argList)
+{
+    int retVal;               /* If initialization causes  e838 */
+    if (SECUREC_VSPRINTF_PARAM_ERROR(format, strDest, destMax, SECUREC_WCHAR_STRING_MAX_LEN)) {
+        SECUREC_VSPRINTF_CLEAR_DEST(strDest, destMax, SECUREC_WCHAR_STRING_MAX_LEN);
+        SECUREC_ERROR_INVALID_PARAMTER("vswprintf_s");
+        return -1;
+    }
+
+    retVal = SecVswprintfImpl(strDest, destMax, format, argList);
+    if (retVal < 0) {
+        strDest[0] = L'\0';
+        if (retVal == SECUREC_PRINTF_TRUNCATE) {
+            /* Buffer too small */
+            SECUREC_ERROR_INVALID_RANGE("vswprintf_s");
+        }
+        SECUREC_ERROR_INVALID_PARAMTER("vswprintf_s");
+        return -1;
+    }
+
+    return retVal;
+}
+
diff --git a/lib/libsecurec/src/vswscanf_s.c b/lib/libsecurec/src/vswscanf_s.c
new file mode 100644
index 0000000..bab53a3
--- /dev/null
+++ b/lib/libsecurec/src/vswscanf_s.c
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vswscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#ifndef SECUREC_FOR_WCHAR
+#define SECUREC_FOR_WCHAR
+#endif
+
+#include "secinput.h"
+
+SECUREC_INLINE size_t SecWcslen(const wchar_t *s)
+{
+    const wchar_t *end = s;
+    while (*end != L'\0') {
+        ++end;
+    }
+    return ((size_t)((end - s)));
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The  vswscanf_s  function  is  the  wide-character  equivalent  of the vsscanf_s function
+ *    The vsscanf_s function reads data from buffer into the location given by
+ *    each argument. Every argument must be a pointer to a variable with a type
+ *    that corresponds to a type specifier in format.
+ *    The format argument controls the interpretation of the input fields and
+ *    has the same form and function as the format argument for the scanf function.
+ *    If copying takes place between strings that overlap, the behavior is undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    buffer                Stored data
+ *    format                Format control string, see Format Specifications.
+ *    argList               pointer to list of arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    argList               the converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Each of these functions returns the number of fields successfully converted
+ *    and assigned; the return value does not include fields that were read but
+ *    not assigned. A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int vswscanf_s(const wchar_t *buffer, const wchar_t *format, va_list argList)
+{
+    size_t count; /* If initialization causes  e838 */
+    SecFileStream fStr;
+    int retVal;
+
+    /* Validation section */
+    if (buffer == NULL || format == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("vswscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    count = SecWcslen(buffer);
+    if (count == 0 || count > SECUREC_WCHAR_STRING_MAX_LEN) {
+        SecClearDestBufW(buffer, format, argList);
+        SECUREC_ERROR_INVALID_PARAMTER("vswscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    SECUREC_FILE_STREAM_FROM_STRING(&fStr, (const char *)buffer, count * sizeof(wchar_t));
+    retVal = SecInputSW(&fStr, format, argList);
+    if (retVal < 0) {
+        SECUREC_ERROR_INVALID_PARAMTER("vswscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+    return retVal;
+}
+
diff --git a/lib/libsecurec/src/vwscanf_s.c b/lib/libsecurec/src/vwscanf_s.c
new file mode 100644
index 0000000..b39f9bc
--- /dev/null
+++ b/lib/libsecurec/src/vwscanf_s.c
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: vwscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#ifndef SECUREC_FOR_WCHAR
+#define SECUREC_FOR_WCHAR
+#endif
+
+#include "secinput.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The  vwscanf_s  function  is  the  wide-character  equivalent  of the vscanf_s function
+ *    The vwscanf_s function is the wide-character version of vscanf_s. The
+ *    function reads data from the standard input stream stdin and writes the
+ *    data into the location that's given by argument. Each argument  must be a
+ *    pointer to a variable of a type that corresponds to a type specifier in
+ *    format. If copying occurs between strings that overlap, the behavior is
+ *    undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    format                 Format control string.
+ *    argList                pointer to list of arguments
+ *
+ * <OUTPUT PARAMETERS>
+ *    argList                the converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Returns the number of fields successfully converted and assigned;
+ *    the return value does not include fields that were read but not assigned.
+ *    A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int vwscanf_s(const wchar_t *format, va_list argList)
+{
+    int retVal;                 /* If initialization causes  e838 */
+    SecFileStream fStr;
+    SECUREC_FILE_STREAM_FROM_STDIN(&fStr);
+    if (format == NULL || fStr.pf == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("vwscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+
+    SECUREC_LOCK_STDIN(0, fStr.pf);
+    retVal = SecInputSW(&fStr, format, argList);
+    SECUREC_UNLOCK_STDIN(0, fStr.pf);
+    if (retVal < 0) {
+        SECUREC_ERROR_INVALID_PARAMTER("vwscanf_s");
+        return SECUREC_SCANF_EINVAL;
+    }
+
+    return retVal;
+}
+
diff --git a/lib/libsecurec/src/wcscat_s.c b/lib/libsecurec/src/wcscat_s.c
new file mode 100644
index 0000000..fa7d847
--- /dev/null
+++ b/lib/libsecurec/src/wcscat_s.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: wcscat_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+/*
+ * Befor this function, the basic parameter checking has been done
+ */
+SECUREC_INLINE errno_t SecDoCatW(wchar_t *strDest, size_t destMax, const wchar_t *strSrc)
+{
+    size_t destLen;
+    size_t srcLen;
+    size_t maxCount; /* Store the maximum available count */
+
+    /* To calculate the length of a wide character, the parameter must be a wide character */
+    SECUREC_CALC_WSTR_LEN(strDest, destMax, &destLen);
+    maxCount = destMax - destLen;
+    SECUREC_CALC_WSTR_LEN(strSrc, maxCount, &srcLen);
+
+    if (SECUREC_CAT_STRING_IS_OVERLAP(strDest, destLen, strSrc, srcLen)) {
+        strDest[0] = L'\0';
+        if (strDest + destLen <= strSrc && destLen == destMax) {
+            SECUREC_ERROR_INVALID_PARAMTER("wcscat_s");
+            return EINVAL_AND_RESET;
+        }
+        SECUREC_ERROR_BUFFER_OVERLAP("wcscat_s");
+        return EOVERLAP_AND_RESET;
+    }
+    if (srcLen + destLen >= destMax || strDest == strSrc) {
+        strDest[0] = L'\0';
+        if (destLen == destMax) {
+            SECUREC_ERROR_INVALID_PARAMTER("wcscat_s");
+            return EINVAL_AND_RESET;
+        }
+        SECUREC_ERROR_INVALID_RANGE("wcscat_s");
+        return ERANGE_AND_RESET;
+    }
+    /* Copy single character length  include \0 */
+    SECUREC_MEMCPY_WARP_OPT(strDest + destLen, strSrc, (srcLen + 1) * sizeof(wchar_t));
+    return EOK;
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The wcscat_s function appends a copy of the wide string pointed to by strSrc
+*      (including the terminating null wide character)
+ *     to the end of the wide string pointed to by strDest.
+ *    The arguments and return value of wcscat_s are wide-character strings.
+ *
+ *    The wcscat_s function appends strSrc to strDest and terminates the resulting
+ *    string with a null character. The initial character of strSrc overwrites the
+ *    terminating null character of strDest. wcscat_s will return EOVERLAP_AND_RESET if the
+ *    source and destination strings overlap.
+ *
+ *    Note that the second parameter is the total size of the buffer, not the
+ *    remaining size.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest              Null-terminated destination string buffer.
+ *    destMax              Size of the destination string buffer.
+ *    strSrc               Null-terminated source string buffer.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest               is updated
+ *
+ * <RETURN VALUE>
+ *    EOK                   Success
+ *    EINVAL                strDest is  NULL and destMax != 0 and destMax <= SECUREC_WCHAR_STRING_MAX_LEN
+ *    EINVAL_AND_RESET      (strDest unterminated and all other parameters are valid) or
+ *                          (strDest != NULL and strSrc is NULL and destMax != 0
+ *                           and destMax <= SECUREC_WCHAR_STRING_MAX_LEN)
+ *    ERANGE                destMax > SECUREC_WCHAR_STRING_MAX_LEN or destMax is 0
+ *    ERANGE_AND_RESET      strDest have not enough space  and all other parameters are valid  and not overlap
+ *    EOVERLAP_AND_RESET     dest buffer and source buffer are overlapped and all  parameters are valid
+ *
+ *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+errno_t wcscat_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc)
+{
+    if (destMax == 0 || destMax > SECUREC_WCHAR_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("wcscat_s");
+        return ERANGE;
+    }
+
+    if (strDest == NULL || strSrc == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("wcscat_s");
+        if (strDest != NULL) {
+            strDest[0] = L'\0';
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+
+    return SecDoCatW(strDest, destMax, strSrc);
+}
+
diff --git a/lib/libsecurec/src/wcscpy_s.c b/lib/libsecurec/src/wcscpy_s.c
new file mode 100644
index 0000000..8c4a4af
--- /dev/null
+++ b/lib/libsecurec/src/wcscpy_s.c
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: wcscpy_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+SECUREC_INLINE errno_t SecDoCpyW(wchar_t *strDest, size_t destMax, const wchar_t *strSrc)
+{
+    size_t srcStrLen;
+    SECUREC_CALC_WSTR_LEN(strSrc, destMax, &srcStrLen);
+
+    if (srcStrLen == destMax) {
+        strDest[0] = L'\0';
+        SECUREC_ERROR_INVALID_RANGE("wcscpy_s");
+        return ERANGE_AND_RESET;
+    }
+    if (strDest == strSrc) {
+        return EOK;
+    }
+
+    if (SECUREC_STRING_NO_OVERLAP(strDest, strSrc, srcStrLen)) {
+        /* Performance optimization, srcStrLen is single character length  include '\0' */
+        SECUREC_MEMCPY_WARP_OPT(strDest, strSrc, (srcStrLen + 1) * sizeof(wchar_t));
+        return EOK;
+    } else {
+        strDest[0] = L'\0';
+        SECUREC_ERROR_BUFFER_OVERLAP("wcscpy_s");
+        return EOVERLAP_AND_RESET;
+    }
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *   The wcscpy_s function copies the wide string pointed to by strSrc
+ *   (including the terminating null wide character) into the array pointed to by strDest
+
+ * <INPUT PARAMETERS>
+ *    strDest               Destination string buffer
+ *    destMax               Size of the destination string buffer.
+ *    strSrc                Null-terminated source string buffer.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest               is updated.
+ *
+ * <RETURN VALUE>
+ *    EOK                   Success
+ *    EINVAL                strDest is  NULL and destMax != 0 and destMax <= SECUREC_WCHAR_STRING_MAX_LEN
+ *    EINVAL_AND_RESET      strDest != NULL and strSrc is NULL and destMax != 0
+ *                          and destMax <= SECUREC_WCHAR_STRING_MAX_LEN
+ *    ERANGE                destMax > SECUREC_WCHAR_STRING_MAX_LEN or destMax is 0
+ *    ERANGE_AND_RESET      destMax <= length of strSrc and strDest != strSrc
+ *                          and strDest != NULL and strSrc != NULL and destMax != 0
+ *                          and destMax <= SECUREC_WCHAR_STRING_MAX_LEN and not overlap
+ *    EOVERLAP_AND_RESET    dest buffer and source buffer are overlapped and destMax != 0
+ *                          and destMax <= SECUREC_WCHAR_STRING_MAX_LEN
+ *                          and strDest != NULL and strSrc !=NULL and strDest != strSrc
+ *
+ *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+errno_t wcscpy_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc)
+{
+    if (destMax == 0 || destMax > SECUREC_WCHAR_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("wcscpy_s");
+        return ERANGE;
+    }
+    if (strDest == NULL || strSrc == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("wcscpy_s");
+        if (strDest != NULL) {
+            strDest[0] = L'\0';
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    return SecDoCpyW(strDest, destMax, strSrc);
+}
+
diff --git a/lib/libsecurec/src/wcsncat_s.c b/lib/libsecurec/src/wcsncat_s.c
new file mode 100644
index 0000000..33e53a3
--- /dev/null
+++ b/lib/libsecurec/src/wcsncat_s.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: wcsncat_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+/*
+ * Befor this function, the basic parameter checking has been done
+ */
+SECUREC_INLINE errno_t SecDoCatLimitW(wchar_t *strDest, size_t destMax, const wchar_t *strSrc, size_t count)
+{
+    /* To calculate the length of a wide character, the parameter must be a wide character */
+    size_t destLen;
+    size_t srcLen;
+    SECUREC_CALC_WSTR_LEN(strDest, destMax, &destLen);
+    SECUREC_CALC_WSTR_LEN(strSrc, count, &srcLen);
+
+    if (SECUREC_CAT_STRING_IS_OVERLAP(strDest, destLen, strSrc, srcLen)) {
+        strDest[0] = L'\0';
+        if (strDest + destLen <= strSrc && destLen == destMax) {
+            SECUREC_ERROR_INVALID_PARAMTER("wcsncat_s");
+            return EINVAL_AND_RESET;
+        }
+        SECUREC_ERROR_BUFFER_OVERLAP("wcsncat_s");
+        return EOVERLAP_AND_RESET;
+    }
+    if (srcLen + destLen >= destMax || strDest == strSrc) {
+        strDest[0] = L'\0';
+        if (destLen == destMax) {
+            SECUREC_ERROR_INVALID_PARAMTER("wcsncat_s");
+            return EINVAL_AND_RESET;
+        }
+        SECUREC_ERROR_INVALID_RANGE("wcsncat_s");
+        return ERANGE_AND_RESET;
+    }
+    SECUREC_MEMCPY_WARP_OPT(strDest + destLen, strSrc, srcLen * sizeof(wchar_t)); /* no  terminator */
+    *(strDest + destLen + srcLen) = L'\0';
+    return EOK;
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The wcsncat_s function appends not more than n successive wide characters
+ *     (not including the terminating null wide character)
+ *     from the array pointed to by strSrc to the end of the wide string pointed to by strDest.
+ *
+ *    The wcsncat_s function try to append the first D characters of strSrc to
+ *    the end of strDest, where D is the lesser of count and the length of strSrc.
+ *    If appending those D characters will fit within strDest (whose size is
+ *    given as destMax) and still leave room for a null terminator, then those
+ *    characters are appended, starting at the original terminating null of
+ *    strDest, and a new terminating null is appended; otherwise, strDest[0] is
+ *    set to the null character.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest               Null-terminated destination string.
+ *    destMax               Size of the destination buffer.
+ *    strSrc                Null-terminated source string.
+ *    count                 Number of character to append, or truncate.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest               is updated
+ *
+ * <RETURN VALUE>
+ *    EOK                   Success
+ *    EINVAL                strDest is  NULL and destMax != 0 and destMax <= SECUREC_WCHAR_STRING_MAX_LEN
+ *    EINVAL_AND_RESET      (strDest unterminated and all other parameters are valid) or
+ *                          (strDest != NULL and strSrc is NULL and destMax != 0 and
+ *                           destMax <= SECUREC_WCHAR_STRING_MAX_LEN)
+ *    ERANGE                destMax > SECUREC_WCHAR_STRING_MAX_LEN or destMax is 0
+ *    ERANGE_AND_RESET      strDest have not enough space  and all other parameters are valid  and not overlap
+ *    EOVERLAP_AND_RESET     dest buffer and source buffer are overlapped and all  parameters are valid
+ *
+ *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+errno_t wcsncat_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc, size_t count)
+{
+    if (destMax == 0 || destMax > SECUREC_WCHAR_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("wcsncat_s");
+        return ERANGE;
+    }
+    if (strDest == NULL || strSrc == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("wcsncat_s");
+        if (strDest != NULL) {
+            strDest[0] = L'\0';
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    if (count > SECUREC_WCHAR_STRING_MAX_LEN) {
+#ifdef  SECUREC_COMPATIBLE_WIN_FORMAT
+        if (count == ((size_t)(-1))) {
+            /* Windows internal functions may pass in -1 when calling this function */
+            return SecDoCatLimitW(strDest, destMax, strSrc, destMax);
+        }
+#endif
+        strDest[0] = L'\0';
+        SECUREC_ERROR_INVALID_RANGE("wcsncat_s");
+        return ERANGE_AND_RESET;
+    }
+    return SecDoCatLimitW(strDest, destMax, strSrc, count);
+}
+
diff --git a/lib/libsecurec/src/wcsncpy_s.c b/lib/libsecurec/src/wcsncpy_s.c
new file mode 100644
index 0000000..463f90e
--- /dev/null
+++ b/lib/libsecurec/src/wcsncpy_s.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: wcsncpy_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+SECUREC_INLINE errno_t SecDoCpyLimitW(wchar_t *strDest, size_t destMax, const wchar_t *strSrc, size_t count)
+{
+    size_t srcStrLen;
+    if (count < destMax) {
+        SECUREC_CALC_WSTR_LEN(strSrc, count, &srcStrLen);
+    } else {
+        SECUREC_CALC_WSTR_LEN(strSrc, destMax, &srcStrLen);
+    }
+    if (srcStrLen == destMax) {
+        strDest[0] = L'\0';
+        SECUREC_ERROR_INVALID_RANGE("wcsncpy_s");
+        return ERANGE_AND_RESET;
+    }
+    if (strDest == strSrc) {
+        return EOK;
+    }
+    if (SECUREC_STRING_NO_OVERLAP(strDest, strSrc, srcStrLen)) {
+        /* Performance optimization srcStrLen not include '\0' */
+        SECUREC_MEMCPY_WARP_OPT(strDest, strSrc, srcStrLen * sizeof(wchar_t));
+        *(strDest + srcStrLen) = L'\0';
+        return EOK;
+    } else {
+        strDest[0] = L'\0';
+        SECUREC_ERROR_BUFFER_OVERLAP("wcsncpy_s");
+        return EOVERLAP_AND_RESET;
+    }
+}
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *    The wcsncpy_s function copies not more than n successive wide characters
+ *     (not including the terminating null wide character)
+ *     from the array pointed to by strSrc to the array pointed to by strDest
+ *
+ * <INPUT PARAMETERS>
+ *    strDest             Destination string.
+ *    destMax             The size of the destination string, in characters.
+ *    strSrc              Source string.
+ *    count                Number of characters to be copied.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest              is updated
+ *
+ * <RETURN VALUE>
+ *    EOK                  Success
+ *    EINVAL               strDest is  NULL and destMax != 0 and destMax <= SECUREC_WCHAR_STRING_MAX_LEN
+ *    EINVAL_AND_RESET     strDest != NULL and strSrc is NULL and destMax != 0
+ *                         and destMax <= SECUREC_WCHAR_STRING_MAX_LEN
+ *    ERANGE               destMax > SECUREC_WCHAR_STRING_MAX_LEN or destMax is 0
+ *    ERANGE_AND_RESET     count > SECUREC_WCHAR_STRING_MAX_LEN or
+ *                         (destMax <= length of strSrc and destMax <= count and strDest != strSrc
+ *                          and strDest != NULL and strSrc != NULL and destMax != 0 and
+ *                          destMax <= SECUREC_WCHAR_STRING_MAX_LEN and not overlap)
+ *    EOVERLAP_AND_RESET     dest buffer and source buffer are overlapped and  all  parameters are valid
+ *
+ *
+ *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ */
+errno_t wcsncpy_s(wchar_t *strDest, size_t destMax, const wchar_t *strSrc, size_t count)
+{
+    if (destMax == 0 || destMax > SECUREC_WCHAR_STRING_MAX_LEN) {
+        SECUREC_ERROR_INVALID_RANGE("wcsncpy_s");
+        return ERANGE;
+    }
+    if (strDest == NULL || strSrc == NULL) {
+        SECUREC_ERROR_INVALID_PARAMTER("wcsncpy_s");
+        if (strDest != NULL) {
+            strDest[0] = L'\0';
+            return EINVAL_AND_RESET;
+        }
+        return EINVAL;
+    }
+    if (count > SECUREC_WCHAR_STRING_MAX_LEN) {
+#ifdef SECUREC_COMPATIBLE_WIN_FORMAT
+        if (count == (size_t)(-1)) {
+            return SecDoCpyLimitW(strDest, destMax, strSrc, destMax - 1);
+        }
+#endif
+        strDest[0] = L'\0';      /* Clear dest string */
+        SECUREC_ERROR_INVALID_RANGE("wcsncpy_s");
+        return ERANGE_AND_RESET;
+    }
+
+    if (count == 0) {
+        strDest[0] = L'\0';
+        return EOK;
+    }
+
+    return SecDoCpyLimitW(strDest, destMax, strSrc, count);
+}
+
diff --git a/lib/libsecurec/src/wcstok_s.c b/lib/libsecurec/src/wcstok_s.c
new file mode 100644
index 0000000..063ca69
--- /dev/null
+++ b/lib/libsecurec/src/wcstok_s.c
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: wcstok_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securecutil.h"
+
+SECUREC_INLINE int SecIsInDelimitW(wchar_t ch, const wchar_t *strDelimit)
+{
+    const wchar_t *ctl = strDelimit;
+    while (*ctl != L'\0' && *ctl != ch) {
+        ++ctl;
+    }
+    return (int)(*ctl != L'\0');
+}
+
+/*
+ * Find beginning of token (skip over leading delimiters).
+ * Note that there is no token if this loop sets string to point to the terminal null.
+ */
+SECUREC_INLINE wchar_t *SecFindBeginW(wchar_t *strToken, const wchar_t *strDelimit)
+{
+    wchar_t *token = strToken;
+    while (*token != L'\0') {
+        if (SecIsInDelimitW(*token, strDelimit) != 0) {
+            ++token;
+            continue;
+        }
+        /* Don't find any delimiter in string header, break the loop */
+        break;
+    }
+    return token;
+}
+
+/*
+ * Find the end of the token. If it is not the end of the string, put a null there.
+ */
+SECUREC_INLINE wchar_t *SecFindRestW(wchar_t *strToken, const wchar_t *strDelimit)
+{
+    wchar_t *token = strToken;
+    while (*token != L'\0') {
+        if (SecIsInDelimitW(*token, strDelimit) != 0) {
+            /* Find a delimiter, set string terminator */
+            *token = L'\0';
+            ++token;
+            break;
+        }
+        ++token;
+    }
+    return token;
+}
+
+/*
+ * Update Token wide character  function
+ */
+SECUREC_INLINE wchar_t *SecUpdateTokenW(wchar_t *strToken, const wchar_t *strDelimit, wchar_t **context)
+{
+    /* Point to updated position.  Record string position for next search in the context */
+    *context = SecFindRestW(strToken, strDelimit);
+    /* Determine if a token has been found */
+    if (*context == strToken) {
+        return NULL;
+    }
+    return strToken;
+}
+
+/*
+ * <NAME>
+ *    wcstok_s
+ *
+ *
+ * <FUNCTION DESCRIPTION>
+ *   The  wcstok_s  function  is  the  wide-character  equivalent  of the strtok_s function
+ *
+ * <INPUT PARAMETERS>
+ *    strToken               String containing token or tokens.
+ *    strDelimit             Set of delimiter characters.
+ *    context                Used to store position information between calls to
+ *                               wcstok_s.
+ *
+ * <OUTPUT PARAMETERS>
+ *    context               is updated
+ * <RETURN VALUE>
+ *   The  wcstok_s  function  is  the  wide-character  equivalent  of the strtok_s function
+ */
+wchar_t *wcstok_s(wchar_t *strToken, const wchar_t *strDelimit, wchar_t **context)
+{
+    wchar_t *orgToken = strToken;
+    /* Validation section */
+    if (context == NULL || strDelimit == NULL) {
+        return NULL;
+    }
+    if (orgToken == NULL && *context == NULL) {
+        return NULL;
+    }
+    /* If string==NULL, continue with previous string */
+    if (orgToken == NULL) {
+        orgToken = *context;
+    }
+    orgToken = SecFindBeginW(orgToken, strDelimit);
+    return SecUpdateTokenW(orgToken, strDelimit, context);
+}
+
diff --git a/lib/libsecurec/src/wmemcpy_s.c b/lib/libsecurec/src/wmemcpy_s.c
new file mode 100644
index 0000000..2f2b4a3
--- /dev/null
+++ b/lib/libsecurec/src/wmemcpy_s.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: wmemcpy_s  function
+ * Create: 2014-02-25
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Portability
+ * [reason] Use unsafe function to implement security function to maintain platform compatibility.
+ *          And sufficient input validation is performed before calling
+ */
+
+#include "securecutil.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *   The wmemcpy_s function copies n successive wide characters
+ *    from the object pointed to by src into the object pointed to by dest.t.
+ *
+ * <INPUT PARAMETERS>
+ *    dest                   Destination buffer.
+ *    destMax                Size of the destination buffer.
+ *    src                     Buffer to copy from.
+ *    count                  Number of characters to copy.
+ *
+ * <OUTPUT PARAMETERS>
+ *    dest buffer            is updated.
+ *
+ * <RETURN VALUE>
+ *    EOK                    Success
+ *    EINVAL                 dest is  NULL  and destMax != 0 and count <= destMax
+ *                           and destMax <= SECUREC_WCHAR_MEM_MAX_LEN
+ *    EINVAL_AND_RESET       dest != NULL and src is NULL and destMax != 0
+ *                           and destMax <= SECUREC_WCHAR_MEM_MAX_LEN and count <= destMax
+ *    ERANGE                 destMax > SECUREC_WCHAR_MEM_MAX_LEN or destMax is 0 or
+ *                           (count > destMax and dest is  NULL and destMax != 0
+ *                            and destMax <= SECUREC_WCHAR_MEM_MAX_LEN)
+ *    ERANGE_AND_RESET       count > destMax and dest  !=  NULL and destMax != 0
+ *                           and destMax <= SECUREC_WCHAR_MEM_MAX_LEN
+ *    EOVERLAP_AND_RESET     dest buffer and source buffer are overlapped and
+ *                           count <= destMax destMax != 0 and destMax <= SECUREC_WCHAR_MEM_MAX_LEN
+ *                           and dest  !=  NULL  and src != NULL and dest != src
+ *
+ *    if an error occurred, dest will be filled with 0 when dest and destMax valid .
+ *    If the source and destination overlap, the behavior of wmemcpy_s is undefined.
+ *    Use wmemmove_s to handle overlapping regions.
+ */
+errno_t wmemcpy_s(wchar_t *dest, size_t destMax, const wchar_t *src, size_t count)
+{
+    if (destMax == 0 || destMax > SECUREC_WCHAR_MEM_MAX_LEN) {
+        SECUREC_ERROR_INVALID_PARAMTER("wmemcpy_s");
+        return ERANGE;
+    }
+    if (count > destMax) {
+        SECUREC_ERROR_INVALID_PARAMTER("wmemcpy_s");
+        if (dest != NULL) {
+            (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax * sizeof(wchar_t));
+            return ERANGE_AND_RESET;
+        }
+        return ERANGE;
+    }
+    return memcpy_s(dest, destMax * sizeof(wchar_t), src, count * sizeof(wchar_t));
+}
+
diff --git a/lib/libsecurec/src/wmemmove_s.c b/lib/libsecurec/src/wmemmove_s.c
new file mode 100644
index 0000000..88bb97b
--- /dev/null
+++ b/lib/libsecurec/src/wmemmove_s.c
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: wmemmove_s  function
+ * Create: 2014-02-25
+ */
+/*
+ * [Standardize-exceptions] Use unsafe function: Portability
+ * [reason] Use unsafe function to implement security function to maintain platform compatibility.
+ *          And sufficient input validation is performed before calling
+ */
+
+#include "securecutil.h"
+
+/*
+ * <FUNCTION DESCRIPTION>
+ *   The wmemmove_s function copies n successive wide characters from the object pointed
+ *   to by src into the object pointed to by dest.
+ *
+ * <INPUT PARAMETERS>
+ *    dest                     Destination buffer.
+ *    destMax                  Size of the destination buffer.
+ *    src                      Source object.
+ *    count                    Number of bytes or character to copy.
+ *
+ * <OUTPUT PARAMETERS>
+ *    dest                     is updated.
+ *
+ * <RETURN VALUE>
+ *    EOK                      Success
+ *    EINVAL                   dest is  NULL and destMax != 0 and count <= destMax
+ *                             and destMax <= SECUREC_WCHAR_MEM_MAX_LEN
+ *    EINVAL_AND_RESET         dest != NULL and src is NULL and destMax != 0
+ *                             and destMax <= SECUREC_WCHAR_MEM_MAX_LEN and count <= destMax
+ *    ERANGE                   destMax > SECUREC_WCHAR_MEM_MAX_LEN or destMax is 0 or
+ *                             (count > destMax and dest is  NULL and destMax != 0
+ *                             and destMax <= SECUREC_WCHAR_MEM_MAX_LEN)
+ *    ERANGE_AND_RESET        count > destMax and dest  !=  NULL and destMax != 0
+ *                             and destMax <= SECUREC_WCHAR_MEM_MAX_LEN
+ *
+ *
+ *     If an error occurred, dest will  be filled with 0 when dest and destMax valid.
+ *     If some regions of the source area and the destination overlap, wmemmove_s
+ *     ensures that the original source bytes in the overlapping region are copied
+ *     before being overwritten
+ */
+errno_t wmemmove_s(wchar_t *dest, size_t destMax, const wchar_t *src, size_t count)
+{
+    if (destMax == 0 || destMax > SECUREC_WCHAR_MEM_MAX_LEN) {
+        SECUREC_ERROR_INVALID_PARAMTER("wmemmove_s");
+        return ERANGE;
+    }
+    if (count > destMax) {
+        SECUREC_ERROR_INVALID_PARAMTER("wmemmove_s");
+        if (dest != NULL) {
+            (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax * sizeof(wchar_t));
+            return ERANGE_AND_RESET;
+        }
+        return ERANGE;
+    }
+    return memmove_s(dest, destMax * sizeof(wchar_t), src, count * sizeof(wchar_t));
+}
+
diff --git a/lib/libsecurec/src/wscanf_s.c b/lib/libsecurec/src/wscanf_s.c
new file mode 100644
index 0000000..badb04e
--- /dev/null
+++ b/lib/libsecurec/src/wscanf_s.c
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) Huawei Technologies Co., Ltd. 2014-2021. All rights reserved.
+ * Licensed under Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ *          http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Description: wscanf_s  function
+ * Create: 2014-02-25
+ */
+
+#include "securec.h"
+
+/*
+ * <NAME>
+ * <FUNCTION DESCRIPTION>
+ *    The  wscanf_s  function  is  the  wide-character  equivalent  of the scanf_s function
+ *    The wscanf_s function reads data from the standard input stream stdin and
+ *    writes the data into the location that's given by argument. Each argument
+ *    must be a pointer to a variable of a type that corresponds to a type specifier
+ *    in format. If copying occurs between strings that overlap, the behavior is
+ *    undefined.
+ *
+ * <INPUT PARAMETERS>
+ *    format                  Format control string.
+ *    ...                         Optional arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    ...                     the converted value stored in user assigned address
+ *
+ * <RETURN VALUE>
+ *    Returns the number of fields successfully converted and assigned;
+ *    the return value does not include fields that were read but not assigned.
+ *    A return value of 0 indicates that no fields were assigned.
+ *    return -1 if an error occurs.
+ */
+int wscanf_s(const wchar_t *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list argList;
+
+    va_start(argList, format);
+    ret = vwscanf_s(format, argList);
+    va_end(argList);
+    (void)argList;              /* To clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+
diff --git a/lib/libsecurec/sub.mk b/lib/libsecurec/sub.mk
new file mode 100644
index 0000000..18938cf
--- /dev/null
+++ b/lib/libsecurec/sub.mk
@@ -0,0 +1,3 @@
+global-incdirs-y += include
+
+subdirs-y += src
diff --git a/lib/libutee/include/tee_pick_function_types.h b/lib/libutee/include/tee_pick_function_types.h
new file mode 100644
index 0000000..211c925
--- /dev/null
+++ b/lib/libutee/include/tee_pick_function_types.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) CompanyNameMagicTag. 2019-2019. All rights reserved.
+ * Description: Declare the function and struct related syscall_pick_funciton
+ * or TEE_pick_function.
+ * Author: AuthorNameMagicTag
+ * Create: 2019-12-11
+*/
+#ifndef TEE_PICK_FUNCTION_TYPES_H
+#define TEE_PICK_FUNCTION_TYPES_H
+
+#ifdef CFG_UNIFIED_SYSCALL
+#include <compiler.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <tee_api_defines.h>
+
+typedef struct {
+    uint32_t cmd;
+    void *param;
+} TEE_MMZ_Data;
+
+typedef struct {
+    uint32_t cmd;
+    void *param;
+} TEE_SECURITY_SUBSYS_Data;
+#endif
+
+#endif /* TEE_PICK_FUNCTION_TYPES_H */
diff --git a/lib/libutee/include/tee_syscall_numbers.h b/lib/libutee/include/tee_syscall_numbers.h
index 82d429b..8430537 100644
--- a/lib/libutee/include/tee_syscall_numbers.h
+++ b/lib/libutee/include/tee_syscall_numbers.h
@@ -79,8 +79,12 @@
 #define TEE_SCN_SE_CHANNEL_CLOSE__DEPRECATED		69
 /* End of deprecated Secure Element API syscalls */
 #define TEE_SCN_CACHE_OPERATION			70
-
+#ifdef CFG_UNIFIED_SYSCALL
+#define TEE_SCN_PICK_FUNCTION               71
+#define TEE_SCN_MAX				71
+#else
 #define TEE_SCN_MAX				70
+#endif
 
 /* Maximum number of allowed arguments for a syscall */
 #define TEE_SVC_MAX_ARGS			8
diff --git a/lib/libutee/include/utee_syscalls.h b/lib/libutee/include/utee_syscalls.h
index e83f803..e6ee6ff 100644
--- a/lib/libutee/include/utee_syscalls.h
+++ b/lib/libutee/include/utee_syscalls.h
@@ -12,6 +12,7 @@
 
 #include <utee_types.h>
 #include <tee_api_types.h>
+#include <tee_pick_function_types.h>
 #include <trace.h>
 
 /*
@@ -225,4 +226,8 @@ TEE_Result _utee_cache_operation(void *va, size_t l, unsigned long op);
 
 TEE_Result _utee_gprof_send(void *buf, size_t size, uint32_t *id);
 
+#ifdef CFG_UNIFIED_SYSCALL
+// Pick syscall function
+TEE_Result _utee_pick_function(uint32_t cmd, char *func, void *param, size_t param_len);
+#endif
 #endif /* UTEE_SYSCALLS_H */
diff --git a/lib/libutee/include/utee_syscalls_asm.S b/lib/libutee/include/utee_syscalls_asm.S
index 44bc60d..75da6d3 100644
--- a/lib/libutee/include/utee_syscalls_asm.S
+++ b/lib/libutee/include/utee_syscalls_asm.S
@@ -122,3 +122,7 @@
                      TEE_SCN_CRYP_OBJ_GENERATE_KEY, 4
 
         UTEE_SYSCALL _utee_cache_operation, TEE_SCN_CACHE_OPERATION, 3
+
+#ifdef CFG_UNIFIED_SYSCALL
+        UTEE_SYSCALL _utee_pick_function, TEE_SCN_PICK_FUNCTION, 4
+#endif
diff --git a/lib/libutee/include/utee_types.h b/lib/libutee/include/utee_types.h
index 547c21a..3ffd885 100644
--- a/lib/libutee/include/utee_types.h
+++ b/lib/libutee/include/utee_types.h
@@ -67,4 +67,10 @@ struct utee_object_info {
 	uint32_t handle_flags;
 };
 
+#ifdef CFG_UNIFIED_SYSCALL
+enum pick_function_catagory {
+	UTEE_PICK_FUNCTION = 0,
+};
+#endif
+
 #endif /* UTEE_TYPES_H */
diff --git a/lib/libutils/ext/mempool.c b/lib/libutils/ext/mempool.c
index e551305..ddc4834 100644
--- a/lib/libutils/ext/mempool.c
+++ b/lib/libutils/ext/mempool.c
@@ -158,7 +158,6 @@ void *mempool_alloc(struct mempool *pool, size_t size)
 		return p;
 	}
 
-	EMSG("Failed to allocate %zu bytes, please tune the pool size", size);
 	put_pool(pool);
 	return NULL;
 }
diff --git a/mk/config.mk b/mk/config.mk
index b1ad874..b3e5cd1 100644
--- a/mk/config.mk
+++ b/mk/config.mk
@@ -19,7 +19,7 @@
 # Cross-compiler prefix and suffix
 CROSS_COMPILE ?= arm-linux-gnueabihf-
 CROSS_COMPILE32 ?= $(CROSS_COMPILE)
-CROSS_COMPILE64 ?= aarch64-linux-gnu-
+CROSS_COMPILE64 ?= $(CROSS_COMPILE)
 COMPILER ?= gcc
 
 # For convenience
@@ -328,14 +328,14 @@ CFG_CORE_STACK_PROTECTOR ?= n
 # - An array of any size and type.
 # - A call to alloca().
 # - A local variable that has its address taken.
-CFG_CORE_STACK_PROTECTOR_STRONG ?= y
+CFG_CORE_STACK_PROTECTOR_STRONG ?= n
 # This enable stack protector flag -fstack-protector-all. Stack protector canary
 # logic will be added to all functions regardless of their vulnerability.
-CFG_CORE_STACK_PROTECTOR_ALL ?= n
+CFG_CORE_STACK_PROTECTOR_ALL ?= y
 # Stack Protection for TA
 CFG_TA_STACK_PROTECTOR ?= n
-CFG_TA_STACK_PROTECTOR_STRONG ?= y
-CFG_TA_STACK_PROTECTOR_ALL ?= n
+CFG_TA_STACK_PROTECTOR_STRONG ?= n
+CFG_TA_STACK_PROTECTOR_ALL ?= y
 
 _CFG_CORE_STACK_PROTECTOR := $(call cfg-one-enabled, CFG_CORE_STACK_PROTECTOR \
 						     CFG_CORE_STACK_PROTECTOR_STRONG \
@@ -1022,3 +1022,6 @@ CFG_FAULT_MITIGATION ?= y
 
 # Enable TEE Internal Core API v1.1 compatibility for in-tree TAs
 CFG_TA_OPTEE_CORE_API_COMPAT_1_1 ?= y
+
+# CFG_OPTEE_DEBUG deup tee info,such as smmz1
+CFG_OPTEE_DEBUG ?= y
diff --git a/ta/arch/arm/link.mk b/ta/arch/arm/link.mk
index 40bdc9f..8dafb33 100644
--- a/ta/arch/arm/link.mk
+++ b/ta/arch/arm/link.mk
@@ -13,7 +13,7 @@ ifeq ($(CFG_ENCRYPT_TA),y)
 # Note that a user of this TA encryption feature needs to provide
 # encryption key and its handling corresponding to their security
 # requirements.
-TA_ENC_KEY ?= 'b64d239b1f3c7d3b06506229cd8ff7c8af2bb4db2168621ac62c84948468c4f4'
+TA_ENC_KEY ?= ''
 endif
 
 all: $(link-out-dir$(sm))/$(user-ta-uuid).dmp \
@@ -26,7 +26,7 @@ cleanfiles += $(link-out-dir$(sm))/$(user-ta-uuid).stripped.elf
 cleanfiles += $(link-out-dir$(sm))/$(user-ta-uuid).ta
 cleanfiles += $(link-script-pp$(sm)) $(link-script-dep$(sm))
 
-link-ldflags  = -e__ta_entry -pie
+link-ldflags  = -e__ta_entry -pie -s
 link-ldflags += -T $(link-script-pp$(sm))
 link-ldflags += -Map=$(link-out-dir$(sm))/$(user-ta-uuid).map
 link-ldflags += --sort-section=alignment
diff --git a/ta/mk/ta_dev_kit.mk b/ta/mk/ta_dev_kit.mk
index cdcb230..5c9e724 100644
--- a/ta/mk/ta_dev_kit.mk
+++ b/ta/mk/ta_dev_kit.mk
@@ -82,6 +82,8 @@ libnames += utils
 libdeps += $(ta-dev-kit-dir$(sm))/lib/libutils.a
 libnames += utee
 libdeps += $(ta-dev-kit-dir$(sm))/lib/libutee.a
+libnames += bsptee
+libdeps += $(ta-dev-kit-dir$(sm))/lib/libbsptee.a
 ifeq ($(CFG_TA_MBEDTLS),y)
 libnames += mbedtls
 libdeps += $(ta-dev-kit-dir$(sm))/lib/libmbedtls.a
@@ -99,6 +101,10 @@ libdeps += $(ta-dev-kit-dir$(sm))/lib/libdl.a
 libnames-after-libgcc += utils
 libdeps-after-libgcc += $(ta-dev-kit-dir$(sm))/lib/libutils.a
 
+ifeq ($(CFG_SECUREC_LIB),y)
+libnames += securec
+libdeps += $(ta-dev-kit-dir$(sm))/lib/libsecurec.a
+endif
 # Pass config variable (CFG_) from conf.mk on the command line
 cppflags$(sm) += $(strip \
 	$(foreach var, $(filter CFG_%,$(.VARIABLES)), \
diff --git a/ta/ta.mk b/ta/ta.mk
index 87fc3ad..ed35731 100644
--- a/ta/ta.mk
+++ b/ta/ta.mk
@@ -110,6 +110,19 @@ libuuid = be807bbd-81e1-4dc4-bd99-3d363f240ece
 libl = utee utils
 include mk/lib.mk
 
+libname = bsptee
+libdir = lib/libbsptee
+libuuid = b9b43b74-798d-4721-8c7b-01ed92964635
+include mk/lib.mk
+
+ifeq ($(CFG_SECUREC_LIB),y)
+libname = securec
+libdir = lib/libsecurec
+libuuid = e314f8d7-1e38-492a-b5b2-a7ce76f65274
+include mk/lib.mk
+ta-mk-file-export-vars-$(sm) += CFG_SECUREC_LIB
+endif
+
 base-prefix :=
 
 incdirs-host := $(filter-out lib/libutils%, $(incdirs$(sm)))
