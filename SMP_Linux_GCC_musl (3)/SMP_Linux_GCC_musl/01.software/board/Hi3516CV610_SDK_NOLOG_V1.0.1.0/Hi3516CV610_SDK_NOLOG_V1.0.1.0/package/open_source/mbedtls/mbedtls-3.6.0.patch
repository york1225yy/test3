diff --git a/configs/huawei/Makefile b/configs/huawei/Makefile
new file mode 100644
index 0000000..9be105b
--- /dev/null
+++ b/configs/huawei/Makefile
@@ -0,0 +1,343 @@
+
+# Also see "include/mbedtls/mbedtls_config.h"
+
+CFLAGS	?= -O2
+WARNING_CFLAGS ?=  -Wall -Wextra -Wformat=2 -Wno-format-nonliteral
+LDFLAGS ?=
+
+# Include ../include for public headers and . for private headers.
+# Note that . needs to be included explicitly for the sake of library
+# files that are not in the /library directory (which currently means
+# under /3rdparty).
+LOCAL_CFLAGS = $(WARNING_CFLAGS) -I. -I../include -D_FILE_OFFSET_BITS=64
+LOCAL_LDFLAGS =
+
+ifdef DEBUG
+LOCAL_CFLAGS += -g3
+endif
+
+# MicroBlaze specific options:
+# CFLAGS += -mno-xl-soft-mul -mxl-barrel-shift
+
+# To compile on Plan9:
+# CFLAGS += -D_BSD_EXTENSION
+
+PERL ?= perl
+
+ifdef WINDOWS
+PYTHON ?= python
+else
+PYTHON ?= $(shell if type python3 >/dev/null 2>/dev/null; then echo python3; else echo python; fi)
+endif
+
+# if were running on Windows build for Windows
+ifdef WINDOWS
+WINDOWS_BUILD=1
+else ifeq ($(shell uname -s),Darwin)
+ifeq ($(AR),ar)
+APPLE_BUILD ?= 1
+endif
+endif
+
+# To compile as a shared library:
+ifdef SHARED
+# all code is position-indep with mingw, avoid warning about useless flag
+ifndef WINDOWS_BUILD
+LOCAL_CFLAGS += -fPIC -fpic
+endif
+endif
+
+SOEXT_TLS=so.17
+SOEXT_X509=so.4
+SOEXT_CRYPTO=so.11
+
+# Set AR_DASH= (empty string) to use an ar implementation that does not accept
+# the - prefix for command line options (e.g. llvm-ar)
+AR_DASH ?= -
+
+ARFLAGS = $(AR_DASH)src
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+ARFLAGS = $(AR_DASH)Src
+RLFLAGS = -no_warning_for_no_symbols -c
+RL ?= ranlib
+endif
+endif
+
+DLEXT ?= so
+ifdef WINDOWS_BUILD
+# Windows shared library extension:
+DLEXT = dll
+else ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+# Mac OS X shared library extension:
+DLEXT = dylib
+endif
+endif
+
+OBJS_CRYPTO= \
+	     aes.o \
+	     aesni.o \
+	     aria.o \
+	     asn1parse.o \
+	     asn1write.o \
+	     base64.o \
+	     bignum.o \
+		 blowfish.o	\
+	     camellia.o \
+	     ccm.o \
+	     chacha20.o \
+	     chachapoly.o \
+	     cipher.o \
+	     cipher_wrap.o \
+	     cmac.o \
+	     constant_time.o \
+	     ctr_drbg.o \
+	     des.o \
+	     dhm.o \
+	     ecdh.o \
+	     ecdsa.o \
+	     ecjpake.o \
+	     ecp.o \
+	     ecp_curves.o \
+	     entropy.o \
+	     entropy_poll.o \
+	     error.o \
+	     gcm.o \
+	     hkdf.o \
+	     hmac_drbg.o \
+	     md.o \
+		 md2.o	\
+		 md4.o	\
+	     md5.o \
+	     memory_buffer_alloc.o \
+	     mps_reader.o \
+	     mps_trace.o \
+	     nist_kw.o \
+	     oid.o \
+	     padlock.o \
+	     pem.o \
+	     pk.o \
+	     pk_wrap.o \
+	     pkcs12.o \
+	     pkcs5.o \
+	     pkparse.o \
+	     pkwrite.o \
+	     platform.o \
+	     platform_util.o \
+	     poly1305.o \
+	     psa_crypto.o \
+	     psa_crypto_aead.o \
+	     psa_crypto_cipher.o \
+	     psa_crypto_client.o \
+	     psa_crypto_driver_wrappers.o \
+	     psa_crypto_ecp.o \
+	     psa_crypto_hash.o \
+	     psa_crypto_mac.o \
+	     psa_crypto_rsa.o \
+	     psa_crypto_se.o \
+	     psa_crypto_slot_management.o \
+	     psa_crypto_storage.o \
+	     psa_its_file.o \
+	     ripemd160.o \
+	     rsa.o \
+	     rsa_alt_helpers.o \
+	     sha1.o \
+	     sha256.o \
+	     sha512.o \
+	     ssl_debug_helpers_generated.o \
+	     threading.o \
+	     timing.o \
+	     version.o \
+	     version_features.o \
+		 hw_aescrypt2.o		\
+		 hw_mbedtls_config.o	\
+	     # This line is intentionally left blank
+
+include ../3rdparty/Makefile.inc
+LOCAL_CFLAGS+=$(THIRDPARTY_INCLUDES)
+OBJS_CRYPTO+=$(THIRDPARTY_CRYPTO_OBJECTS)
+
+OBJS_X509= \
+	   x509.o \
+	   x509_create.o \
+	   x509_crl.o \
+	   x509_crt.o \
+	   x509_csr.o \
+	   x509write_crt.o \
+	   x509write_csr.o \
+	   # This line is intentionally left blank
+
+OBJS_TLS= \
+	  debug.o \
+	  net_sockets.o \
+	  ssl_cache.o \
+	  ssl_ciphersuites.o \
+	  ssl_cli.o \
+	  ssl_cookie.o \
+	  ssl_msg.o \
+	  ssl_srv.o \
+	  ssl_ticket.o \
+	  ssl_tls.o \
+	  ssl_tls13_keys.o \
+	  ssl_tls13_client.o \
+	  ssl_tls13_server.o \
+	  ssl_tls13_generic.o \
+	  hw_polarssl_api.o	\
+	  # This line is intentionally left blank
+
+.SILENT:
+
+.PHONY: all static shared clean
+
+ifndef SHARED
+all: static
+else
+all: shared static
+endif
+
+static: libmbedcrypto.a libmbedx509.a libmbedtls.a
+
+shared: libmbedcrypto.$(DLEXT) libmbedx509.$(DLEXT) libmbedtls.$(DLEXT)
+
+# Windows builds under Mingw can fail if make tries to create archives in the same
+# directory at the same time - see https://bugs.launchpad.net/gcc-arm-embedded/+bug/1848002.
+# This forces builds of the .a files to be serialised.
+ifdef WINDOWS
+libmbedtls.a: | libmbedx509.a
+libmbedx509.a: | libmbedcrypto.a
+endif
+
+# tls
+libmbedtls.a: $(OBJS_TLS)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_TLS)
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+	echo "  RL    $@"
+	$(RL) $(RLFLAGS) $@
+endif
+endif
+
+libmbedtls.$(SOEXT_TLS): $(OBJS_TLS) libmbedx509.so
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_TLS) -L. -lmbedx509 -lmbedcrypto $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedtls.so: libmbedtls.$(SOEXT_TLS)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+
+libmbedtls.dylib: $(OBJS_TLS) libmbedx509.dylib
+	echo "  LD    $@"
+	$(CC) -dynamiclib -o $@ $(OBJS_TLS) -L. -lmbedx509 -lmbedcrypto $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedtls.dll: $(OBJS_TLS) libmbedx509.dll
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_TLS) -lws2_32 -lwinmm -lgdi32 -L. -lmbedx509 -lmbedcrypto -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+# x509
+libmbedx509.a: $(OBJS_X509)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_X509)
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+	echo "  RL    $@"
+	$(RL) $(RLFLAGS) $@
+endif
+endif
+
+libmbedx509.$(SOEXT_X509): $(OBJS_X509) libmbedcrypto.so
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_X509) -L. -lmbedcrypto $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedx509.so: libmbedx509.$(SOEXT_X509)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+
+libmbedx509.dylib: $(OBJS_X509) libmbedcrypto.dylib
+	echo "  LD    $@"
+	$(CC) -dynamiclib -o $@ $(OBJS_X509) -L. -lmbedcrypto  $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedx509.dll: $(OBJS_X509) libmbedcrypto.dll
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_X509) -lws2_32 -lwinmm -lgdi32 -L. -lmbedcrypto -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+# crypto
+libmbedcrypto.a: $(OBJS_CRYPTO)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_CRYPTO)
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+	echo "  RL    $@"
+	$(RL) $(RLFLAGS) $@
+endif
+endif
+
+libmbedcrypto.$(SOEXT_CRYPTO): $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_CRYPTO) $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedcrypto.so: libmbedcrypto.$(SOEXT_CRYPTO)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+
+libmbedcrypto.dylib: $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -dynamiclib -o $@ $(OBJS_CRYPTO) $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedcrypto.dll: $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_CRYPTO) -lws2_32 -lwinmm -lgdi32 -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+.c.o:
+	echo "  CC    $<"
+	$(CC) $(LOCAL_CFLAGS) $(CFLAGS) -o $@ -c $<
+
+.PHONY: generated_files
+GENERATED_FILES = \
+	error.c version_features.c \
+	ssl_debug_helpers_generated.c ssl_debug_helpers_generated.h
+generated_files: $(GENERATED_FILES)
+
+error.c: ../scripts/generate_errors.pl
+error.c: ../scripts/data_files/error.fmt
+error.c: $(filter-out %config%,$(wildcard ../include/mbedtls/*.h))
+error.c:
+	echo "  Gen   $@"
+	$(PERL) ../scripts/generate_errors.pl
+
+ssl_debug_helpers_generated.c: | ssl_debug_helpers_generated.h
+ssl_debug_helpers_generated.h: ../scripts/generate_ssl_debug_helpers.py
+ssl_debug_helpers_generated.h: $(filter-out %config%,$(wildcard ../include/mbedtls/*.h))
+ssl_debug_helpers_generated.h:
+	echo "  Gen   $@"
+	$(PYTHON) ../scripts/generate_ssl_debug_helpers.py --mbedtls-root .. .
+
+version_features.c: ../scripts/generate_features.pl
+version_features.c: ../scripts/data_files/version_features.fmt
+## The generated file only depends on the options that are present in mbedtls_config.h,
+## not on which options are set. To avoid regenerating this file all the time
+## when switching between configurations, don't declare mbedtls_config.h as a
+## dependency. Remove this file from your working tree if you've just added or
+## removed an option in mbedtls_config.h.
+#version_features.c: ../include/mbedtls/mbedtls_config.h
+version_features.c:
+	echo "  Gen   $@"
+	$(PERL) ../scripts/generate_features.pl
+
+clean:
+ifndef WINDOWS
+	rm -f *.o libmbed*
+	rm -f $(THIRDPARTY_CRYPTO_OBJECTS)
+else
+	if exist *.o del /Q /F *.o
+	if exist libmbed* del /Q /F libmbed*
+	del /Q /F del_errors_out_if_the_file_list_is_empty_but_not_if_a_file_does_not_exist $(subst /,\,$(THIRDPARTY_CRYPTO_OBJECTS))
+endif
+
+neat: clean
+ifndef WINDOWS
+	rm -f $(GENERATED_FILES)
+else
+	for %f in ($(subst /,\,$(GENERATED_FILES))) if exist %f del /Q /F %f
+endif
diff --git a/configs/huawei/Makefile.ai b/configs/huawei/Makefile.ai
new file mode 100644
index 0000000..86a774d
--- /dev/null
+++ b/configs/huawei/Makefile.ai
@@ -0,0 +1,318 @@
+
+# Also see "include/mbedtls/mbedtls_config.h"
+
+CFLAGS	?= -O2
+WARNING_CFLAGS ?=  -Wall -Wextra -Wformat=2 -Wno-format-nonliteral
+LDFLAGS ?=
+
+# Include ../include for public headers and . for private headers.
+# Note that . needs to be included explicitly for the sake of library
+# files that are not in the /library directory (which currently means
+# under /3rdparty).
+LOCAL_CFLAGS = $(WARNING_CFLAGS) -I. -I../include -D_FILE_OFFSET_BITS=64
+LOCAL_LDFLAGS =
+
+ifdef DEBUG
+LOCAL_CFLAGS += -g3
+endif
+
+# MicroBlaze specific options:
+# CFLAGS += -mno-xl-soft-mul -mxl-barrel-shift
+
+# To compile on Plan9:
+# CFLAGS += -D_BSD_EXTENSION
+
+PERL ?= perl
+
+ifdef WINDOWS
+PYTHON ?= python
+else
+PYTHON ?= $(shell if type python3 >/dev/null 2>/dev/null; then echo python3; else echo python; fi)
+endif
+
+# if were running on Windows build for Windows
+ifdef WINDOWS
+WINDOWS_BUILD=1
+else ifeq ($(shell uname -s),Darwin)
+ifeq ($(AR),ar)
+APPLE_BUILD ?= 1
+endif
+endif
+
+# To compile as a shared library:
+ifdef SHARED
+# all code is position-indep with mingw, avoid warning about useless flag
+ifndef WINDOWS_BUILD
+LOCAL_CFLAGS += -fPIC -fpic
+endif
+endif
+
+SOEXT_TLS=so.17
+SOEXT_X509=so.4
+SOEXT_CRYPTO=so.11
+
+# Set AR_DASH= (empty string) to use an ar implementation that does not accept
+# the - prefix for command line options (e.g. llvm-ar)
+AR_DASH ?= -
+
+ARFLAGS = $(AR_DASH)src
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+ARFLAGS = $(AR_DASH)Src
+RLFLAGS = -no_warning_for_no_symbols -c
+RL ?= ranlib
+endif
+endif
+
+DLEXT ?= so
+ifdef WINDOWS_BUILD
+# Windows shared library extension:
+DLEXT = dll
+else ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+# Mac OS X shared library extension:
+DLEXT = dylib
+endif
+endif
+
+OBJS_CRYPTO= \
+	     aes.o \
+	     aesni.o \
+	     aria.o \
+	     asn1parse.o \
+	     asn1write.o \
+	     base64.o \
+	     bignum.o \
+	     camellia.o \
+	     ccm.o \
+	     chacha20.o \
+	     chachapoly.o \
+	     cipher.o \
+	     cipher_wrap.o \
+	     cmac.o \
+	     constant_time.o \
+	     ctr_drbg.o \
+	     des.o \
+	     dhm.o \
+	     ecdh.o \
+	     ecdsa.o \
+	     ecjpake.o \
+	     ecp.o \
+	     ecp_curves.o \
+	     entropy.o \
+	     entropy_poll.o \
+	     error.o \
+	     gcm.o \
+	     hkdf.o \
+	     hmac_drbg.o \
+	     md.o \
+	     md5.o \
+	     memory_buffer_alloc.o \
+	     mps_reader.o \
+	     mps_trace.o \
+	     nist_kw.o \
+	     oid.o \
+	     padlock.o \
+	     pem.o \
+	     pk.o \
+	     pk_wrap.o \
+	     pkcs12.o \
+	     pkcs5.o \
+	     pkparse.o \
+	     pkwrite.o \
+	     platform.o \
+	     platform_util.o \
+	     poly1305.o \
+	     psa_crypto.o \
+	     psa_crypto_aead.o \
+	     psa_crypto_cipher.o \
+	     psa_crypto_client.o \
+	     psa_crypto_driver_wrappers.o \
+	     psa_crypto_ecp.o \
+	     psa_crypto_hash.o \
+	     psa_crypto_mac.o \
+	     psa_crypto_rsa.o \
+	     psa_crypto_se.o \
+	     psa_crypto_slot_management.o \
+	     psa_crypto_storage.o \
+	     psa_its_file.o \
+	     ripemd160.o \
+	     rsa.o \
+	     rsa_alt_helpers.o \
+	     sha1.o \
+	     sha256.o \
+	     sha512.o \
+	     ssl_debug_helpers_generated.o \
+	     threading.o \
+	     timing.o \
+	     version.o \
+	     version_features.o \
+         crypto_api.o \
+	     # This line is intentionally left blank
+
+include ../3rdparty/Makefile.inc
+LOCAL_CFLAGS+=$(THIRDPARTY_INCLUDES)
+OBJS_CRYPTO+=$(THIRDPARTY_CRYPTO_OBJECTS)
+
+OBJS_CRYPTO += \
+	   x509.o \
+	   x509_create.o \
+	   x509_crl.o \
+	   x509_crt.o \
+	   x509_csr.o \
+	   x509write_crt.o \
+	   x509write_csr.o \
+	   # This line is intentionally left blank
+
+OBJS_CRYPTO += \
+	  debug.o \
+	  net_sockets.o \
+	  ssl_cache.o \
+	  ssl_ciphersuites.o \
+	  ssl_cli.o \
+	  ssl_cookie.o \
+	  ssl_msg.o \
+	  ssl_srv.o \
+	  ssl_ticket.o \
+	  ssl_tls.o \
+	  ssl_tls13_keys.o \
+	  ssl_tls13_client.o \
+	  ssl_tls13_server.o \
+	  ssl_tls13_generic.o \
+	  # This line is intentionally left blank
+
+.SILENT:
+
+.PHONY: all static shared clean
+
+ifndef SHARED
+all: static
+else
+all: shared static
+endif
+
+static: libmbedcrypto.a libmbedx509.a libmbedtls.a
+
+shared: libmbedcrypto.$(DLEXT) libmbedx509.$(DLEXT) libmbedtls.$(DLEXT)
+
+# Windows builds under Mingw can fail if make tries to create archives in the same
+# directory at the same time - see https://bugs.launchpad.net/gcc-arm-embedded/+bug/1848002.
+# This forces builds of the .a files to be serialised.
+ifdef WINDOWS
+libmbedtls.a: | libmbedx509.a
+libmbedx509.a: | libmbedcrypto.a
+endif
+
+# tls
+libmbedtls.a: $(OBJS_TLS)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_TLS)
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+	echo "  RL    $@"
+	$(RL) $(RLFLAGS) $@
+endif
+endif
+
+libmbedtls.$(SOEXT_TLS): $(OBJS_TLS) libmbedx509.so
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_TLS) -L. -lmbedx509 -lmbedcrypto $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedtls.so: libmbedtls.$(SOEXT_TLS)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+
+libmbedtls.dylib: $(OBJS_TLS) libmbedx509.dylib
+	echo "  LD    $@"
+	$(CC) -dynamiclib -o $@ $(OBJS_TLS) -L. -lmbedx509 -lmbedcrypto $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedtls.dll: $(OBJS_TLS) libmbedx509.dll
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_TLS) -lws2_32 -lwinmm -lgdi32 -L. -lmbedx509 -lmbedcrypto -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+# x509
+libmbedx509.a: $(OBJS_X509)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_X509)
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+	echo "  RL    $@"
+	$(RL) $(RLFLAGS) $@
+endif
+endif
+
+libmbedx509.$(SOEXT_X509): $(OBJS_X509) libmbedcrypto.so
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_X509) -L. -lmbedcrypto $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedx509.so: libmbedx509.$(SOEXT_X509)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+
+libmbedx509.dylib: $(OBJS_X509) libmbedcrypto.dylib
+	echo "  LD    $@"
+	$(CC) -dynamiclib -o $@ $(OBJS_X509) -L. -lmbedcrypto  $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedx509.dll: $(OBJS_X509) libmbedcrypto.dll
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_X509) -lws2_32 -lwinmm -lgdi32 -L. -lmbedcrypto -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+# crypto
+libmbedcrypto.a: $(OBJS_CRYPTO)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_CRYPTO)
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+	echo "  RL    $@"
+	$(RL) $(RLFLAGS) $@
+endif
+endif
+
+libmbedcrypto.$(SOEXT_CRYPTO): $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_CRYPTO) $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedcrypto.so: libmbedcrypto.$(SOEXT_CRYPTO)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+
+libmbedcrypto.dylib: $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -dynamiclib -o $@ $(OBJS_CRYPTO) $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+libmbedcrypto.dll: $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_CRYPTO) -lws2_32 -lwinmm -lgdi32 -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+.c.o:
+	echo "  CC    $<"
+	$(CC) $(LOCAL_CFLAGS) $(CFLAGS) -o $@ -c $<
+
+.PHONY: generated_files
+GENERATED_FILES = \
+	ssl_debug_helpers_generated.c ssl_debug_helpers_generated.h
+generated_files: $(GENERATED_FILES)
+
+ssl_debug_helpers_generated.c: | ssl_debug_helpers_generated.h
+ssl_debug_helpers_generated.h: ../scripts/generate_ssl_debug_helpers.py
+ssl_debug_helpers_generated.h: $(filter-out %config%,$(wildcard ../include/mbedtls/*.h))
+ssl_debug_helpers_generated.h:
+	echo "  Gen   $@"
+	$(PYTHON) ../scripts/generate_ssl_debug_helpers.py --mbedtls-root .. .
+
+clean:
+ifndef WINDOWS
+	rm -f *.o libmbed*
+	rm -f $(THIRDPARTY_CRYPTO_OBJECTS)
+else
+	if exist *.o del /Q /F *.o
+	if exist libmbed* del /Q /F libmbed*
+	del /Q /F del_errors_out_if_the_file_list_is_empty_but_not_if_a_file_does_not_exist $(subst /,\,$(THIRDPARTY_CRYPTO_OBJECTS))
+endif
+
+neat: clean
+ifndef WINDOWS
+	rm -f $(GENERATED_FILES)
+else
+	for %f in ($(subst /,\,$(GENERATED_FILES))) if exist %f del /Q /F %f
+endif
diff --git a/configs/huawei/Makefile.ont b/configs/huawei/Makefile.ont
new file mode 100644
index 0000000..4ece38c
--- /dev/null
+++ b/configs/huawei/Makefile.ont
@@ -0,0 +1,76 @@
+SHARED=1
+CFLAGS	?= -O2
+WARNING_CFLAGS ?=  -Wall -Wextra -Wformat=2 -Wno-format-nonliteral
+LDFLAGS ?=
+
+LOCAL_CFLAGS = $(WARNING_CFLAGS) -I. -I../include -D_FILE_OFFSET_BITS=64
+LOCAL_CFLAGS += -I../include -I$(HW_ONT_INFECTED_ROOT)/basic/inc
+LOCAL_LDFLAGS =
+
+ifdef DEBUG
+LOCAL_CFLAGS += -g3
+endif
+
+ifdef SHARED
+LOCAL_CFLAGS += -fPIC -fpic
+endif
+
+SOEXT_TLS=so.17
+SOEXT_X509=so.4
+SOEXT_CRYPTO=so.11
+
+# crypto
+OBJS_CRYPTO = aes.o	aesni.o	aria.o	asn1parse.o	asn1write.o	\
+		base64.o	bignum.o	blowfish.o	camellia.o	ccm.o	chacha20.o	\
+		chachapoly.o	cipher.o	cipher_wrap.o	cmac.o	\
+		constant_time.o	ctr_drbg.o	des.o	dhm.o	ecdh.o	ecdsa.o	\
+		ecjpake.o	ecp.o	ecp_curves.o	entropy.o	entropy_poll.o	\
+		error.o	gcm.o	hkdf.o	hmac_drbg.o	md.o	md2.o	md4.o	md5.o	\
+		memory_buffer_alloc.o	mps_reader.o	mps_trace.o	nist_kw.o	\
+		oid.o	padlock.o	pem.o	pk.o	pk_wrap.o	pkcs12.o	\
+		pkcs5.o	pkparse.o	pkwrite.o	platform.o	platform_util.o	poly1305.o	\
+		ripemd160.o	rsa_alt_helpers.o	rsa.o	sha1.o	sha256.o	sha512.o	\
+		ssl_debug_helpers_generated.o	threading.o	timing.o	version.o	\
+		version_features.o hw_polarssl_api.o hw_mbedtls_config.o
+
+# 3rdparty
+include ../3rdparty/Makefile.inc
+LOCAL_CFLAGS += $(THIRDPARTY_INCLUDES)
+OBJS_CRYPTO += $(THIRDPARTY_CRYPTO_OBJECTS)
+
+# x509 certs
+OBJS_CRYPTO += x509.o	x509_create.o	x509_crl.o	x509_crt.o	\
+		x509_csr.o	x509write_crt.o	x509write_csr.o x509write.o
+
+# tls api
+OBJS_CRYPTO += debug.o	net_sockets.o	ssl_cache.o	ssl_ciphersuites.o	\
+		ssl_cookie.o	ssl_msg.o	ssl_ticket.o	\
+		ssl_tls.o	ssl_tls13_keys.o	ssl_tls13_client.o	\
+		ssl_tls13_server.o	ssl_tls13_generic.o	\
+		psa_crypto.o psa_crypto_ecp.o psa_util.o psa_crypto_cipher.o psa_crypto_rsa.o\
+		ssl_client.o ssl_tls12_client.o ssl_tls12_server.o psa_crypto_hash.o\
+		bignum_core.o psa_crypto_aead.o psa_crypto_slot_management.o pk_ecc.o\
+		psa_crypto_ffdh.o psa_crypto_mac.o psa_crypto_driver_wrappers_no_static.o\
+		psa_crypto_client.o
+
+# aes file
+ifdef MBED_AESCRYPT
+OBJS_CRYPTO += hw_aescrypt2.o
+endif
+
+.SILENT:
+
+.PHONY: all clean
+
+all: libpolarssl.so
+
+libpolarssl.so:  $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@  $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_CRYPTO)
+
+.c.o:
+	echo "  CC    $<"
+	$(CC) $(LOCAL_CFLAGS) $(CFLAGS) -o $@ -c $<
+
+clean:
+	rm -f *.o libmbed* libpolarssl.so
diff --git a/configs/huawei/Makefile.tools b/configs/huawei/Makefile.tools
new file mode 100644
index 0000000..36ebe3e
--- /dev/null
+++ b/configs/huawei/Makefile.tools
@@ -0,0 +1,115 @@
+CFLAGS_	?= -O2 -m32 $(CFLAGS)
+WARNING_CFLAGS ?=  -Wall -Wextra -Wformat=2 -Wno-format-nonliteral
+LDFLAGS ?=
+
+LOCAL_CFLAGS = $(WARNING_CFLAGS) -I../include -D_FILE_OFFSET_BITS=64
+LOCAL_LDFLAGS =
+
+ifdef DEBUG
+LOCAL_CFLAGS += -g3
+endif
+
+# if were running on Windows build for Windows
+ifdef WINDOWS
+WINDOWS_BUILD=1
+else ifeq ($(shell uname -s),Darwin)
+ifeq ($(AR),ar)
+APPLE_BUILD ?= 1
+endif
+endif
+
+# To compile as a shared library:
+ifdef SHARED
+# all code is position-indep with mingw, avoid warning about useless flag
+ifndef WINDOWS_BUILD
+LOCAL_CFLAGS += -fPIC -fpic
+endif
+endif
+
+SOEXT_TLS=so.12
+SOEXT_X509=so.0
+SOEXT_CRYPTO=so.3
+
+# Set AR_DASH= (empty string) to use an ar implementation that does not accept
+# the - prefix for command line options (e.g. llvm-ar)
+AR_DASH ?= -
+
+ARFLAGS = $(AR_DASH)src
+ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+ARFLAGS = $(AR_DASH)Src
+RLFLAGS = -no_warning_for_no_symbols -c
+RL ?= ranlib
+endif
+endif
+
+DLEXT ?= so
+ifdef WINDOWS_BUILD
+# Windows shared library extension:
+DLEXT = dll
+else ifdef APPLE_BUILD
+ifneq ($(APPLE_BUILD),0)
+# Mac OS X shared library extension:
+DLEXT = dylib
+endif
+endif
+
+OBJS_CRYPTO= aes.o  aria.o  nist_kw.o	aesni.o	asn1parse.o	asn1write.o	\
+		base64.o	bignum.o	camellia.o	ccm.o	\
+		cipher.o	cipher_wrap.o	cmac.o	ctr_drbg.o	\
+		des.o	dhm.o	ecdh.o	ecdsa.o	constant_time.o	\
+		ecjpake.o	ecp.o	ecp_curves.o	entropy.o	entropy_poll.o	\
+		error.o	gcm.o	hkdf.o	hmac_drbg.o	\
+		md.o		md2.o	md4.o	md5.o	memory_buffer_alloc.o	\
+		oid.o		padlock.o	pem.o		\
+		pk.o		pk_wrap.o	pkcs12.o	\
+		pkcs5.o		pkparse.o	pkwrite.o	\
+		platform.o	platform_util.o	poly1305.o	\
+		gcm.o	chacha20.o	chachapoly.o	\
+		ripemd160.o		rsa.o	rsa_alt_helpers.o	\
+		sha1.o		sha256.o	sha512.o	ssl_debug_helpers_generated.o	\
+		threading.o	timing.o	version.o	version_features.o
+
+.SILENT:
+
+.PHONY: all static shared clean
+
+ifndef SHARED
+all: static
+else
+all: shared static
+endif
+
+static: libmbedcrypto.a
+
+shared: libmbedcrypto.$(DLEXT)
+
+# crypto
+libmbedcrypto.a: $(OBJS_CRYPTO)
+	echo "  AR    $@"
+	$(AR) -rc $@ $(OBJS_CRYPTO)
+	echo "  RL    $@"
+	$(AR) -s $@
+
+libmbedcrypto.$(SOEXT_CRYPTO): $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_CRYPTO)
+
+libmbedcrypto.so: libmbedcrypto.$(SOEXT_CRYPTO)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+
+libmbedcrypto.dylib: $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -dynamiclib $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_CRYPTO)
+
+libmbedcrypto.dll: $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_CRYPTO) -lws2_32 -lwinmm -lgdi32 -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
+
+.c.o:
+	echo "  CC    $<"
+	$(CC) $(LOCAL_CFLAGS) $(CFLAGS_) -c $<
+
+clean:
+	rm -f *.o libmbed*
diff --git a/configs/huawei/Makefile.x86 b/configs/huawei/Makefile.x86
new file mode 100644
index 0000000..ff3492e
--- /dev/null
+++ b/configs/huawei/Makefile.x86
@@ -0,0 +1,29 @@
+WARNING_CFLAGS ?=  -Wall -Wextra -Wformat=2 -Wno-format-nonliteral
+LDFLAGS ?=
+
+LOCAL_CFLAGS = $(WARNING_CFLAGS) -I../include -D_FILE_OFFSET_BITS=64
+LOCAL_LDFLAGS =
+
+ifdef DEBUG
+LOCAL_CFLAGS += -g3
+endif
+
+OBJS_CRYPTO = asn1parse.o bignum.o md.o oid.o pkcs5.o platform.o constant_time.o rsa_alt_helpers.o rsa.o sha1.o sha256.o sha512.o
+
+.PHONY: all static  clean
+
+all: static
+
+static: libmini_mbedcrypto.a
+
+# crypto
+libmini_mbedcrypto.a: $(OBJS_CRYPTO)
+	echo "  AR    $@"
+	$(AR) crv $@ $(OBJS_CRYPTO)
+
+%.o:%.c
+	echo "  CC  $<"
+	$(CC) $(LOCAL_CFLAGS) $(CFLAGS) -c $<
+
+clean:
+	rm -f *.o libmini*
diff --git a/configs/huawei/config-ont.h b/configs/huawei/config-ont.h
new file mode 100644
index 0000000..53a6a09
--- /dev/null
+++ b/configs/huawei/config-ont.h
@@ -0,0 +1,318 @@
+/**
+ * \file config-ont.h
+ *
+ * \brief 华为家庭网络产品，mbedtls库的配置文件，基于3.1.0版本的默认配置文件。
+ *
+ *  产品在使用时，在编译前，将此文件强制覆盖默认的配置文件即可，使用方式如下：
+ *  cp -f ./configs/huawei/config-ont.h ./include/mbedtls/mbedtls_config.h
+ *  
+ */
+/***********************************家庭网络产品定义的宏************************************/
+
+/**
+ * \file mbedtls_config.h
+ *
+ * \brief Configuration options (set of defines)
+ *
+ *  This set of compile-time options may be used to enable
+ *  or disable features selectively, and reduce the global
+ *  memory footprint.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+/**
+ * This is an optional version symbol that enables comatibility handling of
+ * config files.
+ *
+ * It is equal to the #MBEDTLS_VERSION_NUMBER of the Mbed TLS version that
+ * introduced the config format we want to be compatible with.
+ */
+//#define MBEDTLS_CONFIG_VERSION 0x03000000
+
+#define MBEDTLS_HAVE_ASM
+
+#define MBEDTLS_HAVE_TIME
+
+#define MBEDTLS_HAVE_TIME_DATE
+
+#define MBEDTLS_CIPHER_MODE_CBC
+
+#define MBEDTLS_CIPHER_MODE_CFB
+
+#define MBEDTLS_CIPHER_MODE_CTR
+
+#define MBEDTLS_CIPHER_PADDING_PKCS7
+#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
+#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
+#define MBEDTLS_CIPHER_PADDING_ZEROS
+
+#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
+
+#define MBEDTLS_ECP_NIST_OPTIM
+
+#define MBEDTLS_ECDSA_DETERMINISTIC
+
+#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
+
+#define MBEDTLS_SSL_KEEP_PEER_CERTIFICATE
+
+#define MBEDTLS_PK_PARSE_EC_EXTENDED
+
+#define MBEDTLS_ERROR_STRERROR_DUMMY
+
+#define MBEDTLS_GENPRIME
+
+#define MBEDTLS_FS_IO
+
+#define MBEDTLS_PKCS1_V15
+
+#define MBEDTLS_PKCS1_V21
+
+#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
+
+#define MBEDTLS_SSL_RENEGOTIATION
+
+#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
+
+#define MBEDTLS_SSL_PROTO_TLS1_2
+
+#define MBEDTLS_SSL_PROTO_TLS1_3
+
+#define MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE
+
+#define MBEDTLS_PSA_CRYPTO_C
+
+#define MBEDTLS_SSL_SESSION_TICKETS
+
+#define MBEDTLS_SSL_SERVER_NAME_INDICATION
+
+#define MBEDTLS_VERSION_FEATURES
+
+#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
+
+#define MBEDTLS_AESNI_C
+
+#define MBEDTLS_AES_C
+
+#define MBEDTLS_ASN1_PARSE_C
+
+#define MBEDTLS_ASN1_WRITE_C
+
+#define MBEDTLS_BASE64_C
+
+#define MBEDTLS_BIGNUM_C
+
+#define MBEDTLS_BLOWFISH_C
+
+#define MBEDTLS_CAMELLIA_C
+
+#define MBEDTLS_CCM_C
+
+#define MBEDTLS_CIPHER_C
+
+#define MBEDTLS_CMAC_C
+
+#define MBEDTLS_CTR_DRBG_C
+
+#define MBEDTLS_DEBUG_C
+
+#define MBEDTLS_DES_C
+
+#define MBEDTLS_DHM_C
+
+#define MBEDTLS_ECDH_C
+
+#define MBEDTLS_ECDSA_C
+
+#define MBEDTLS_ECP_C
+
+#define MBEDTLS_ENTROPY_C
+
+#define MBEDTLS_ERROR_C
+
+#define MBEDTLS_GCM_C
+
+#define MBEDTLS_HMAC_DRBG_C
+
+#define MBEDTLS_HKDF_C
+
+#define MBEDTLS_MD_C
+
+#define MBEDTLS_MD2_C
+
+#define MBEDTLS_MD4_C
+
+#define MBEDTLS_MD5_C
+
+#define MBEDTLS_NET_C
+
+#define MBEDTLS_OID_C
+
+#define MBEDTLS_PADLOCK_C
+
+#define MBEDTLS_PEM_PARSE_C
+
+#define MBEDTLS_PEM_WRITE_C
+
+#define MBEDTLS_PK_C
+
+#define MBEDTLS_PK_PARSE_C
+
+#define MBEDTLS_PK_WRITE_C
+
+#define MBEDTLS_PKCS5_C
+
+#define MBEDTLS_PKCS12_C
+
+#define MBEDTLS_PLATFORM_C
+
+#define MBEDTLS_RIPEMD160_C
+
+#define MBEDTLS_RSA_C
+
+#define MBEDTLS_SHA1_C
+#define MBEDTLS_SHA224_C
+#define MBEDTLS_SHA256_C
+#define MBEDTLS_SHA384_C
+#define MBEDTLS_SHA512_C
+
+#define MBEDTLS_SSL_CACHE_C
+
+#define MBEDTLS_SSL_COOKIE_C
+
+#define MBEDTLS_SSL_TICKET_C
+
+#define MBEDTLS_SSL_CLI_C
+
+#define MBEDTLS_SSL_SRV_C
+
+#define MBEDTLS_SSL_TLS_C
+
+#define MBEDTLS_TIMING_C
+
+#define MBEDTLS_VERSION_C
+
+#define MBEDTLS_X509_USE_C
+
+#define MBEDTLS_X509_CRT_PARSE_C
+
+#define MBEDTLS_X509_CRL_PARSE_C
+
+#define MBEDTLS_X509_CSR_PARSE_C
+
+#define MBEDTLS_X509_CREATE_C
+
+#define MBEDTLS_X509_CRT_WRITE_C
+
+#define MBEDTLS_X509_CSR_WRITE_C
+
+/**
+ * 华为家庭网络产品，对POLARSSL API的适配，所有的代码放在hw_polarssl_api.c文件中，
+ * 对应的为polarssl_api.h文件中。 使用此编译宏进行隔离。
+ * 其它产品不需要使用此API的，不打开此宏即可。
+ */
+#define HUAWEI_POLARSSL_API_C
+
+#define HUAWEI_POLARSSL_API_DEBUG_C
+
+#define HUAWEI_POLARSSL_API_FT_C
+
+#define HW_MBEDTLS_CONFIG_C
+
+#define MBEDTLS_SSL_PROTO_DTLS
+
+#define MBEDTLS_SSL_DTLS_HELLO_VERIFY
+
+#define MBEDTLS_PK_RSA_ALT_SUPPORT
+
+/* 自测试宏，开发时打开验证 */
+//#define MBEDTLS_SELF_TEST
+
+/*****************************************************************************
+ * \brief 华为家庭网络产品，对AESCRYPT2 API的适配，所有的代码放在hw_aescrypt2.c文件中，
+ * 对应的为hw_aescrypt2.c文件中。 使用此编译宏进行隔离。
+ * 其它产品不需要使用此API的，不打开此宏即可。
+******************************************************************************/
+#define HUAWEI_ONT_AESCRYPT2_API_C
+
+/*****************************************************************************
+ * \brief 华为定制特性，是否开启可以动态配置特性的能力。
+ * 如果打开此特性，则支持一些特性的动态配置，如MD2、MD4算法，在编译到库里以后，还可以通过API来限制是否使能。
+ * 
+******************************************************************************/
+#define HUAWEI_CUSTOMIZE_CONFIGS_C
+
+/*****************************************************************************
+ * \brief 华为定制特性，是否校验证书有效期。
+ * 如果打开此特性，则会在TLS协议栈中回调证书有效性的校验函数。
+ * 如果产品没有挂回调校验函数，则按默认规则处理。
+ * 如果不开此宏，则回调机制也不生效。
+ * 
+******************************************************************************/
+#define HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C
+
+/*****************************************************************************
+ * \brief 华为家庭网络产品定制特性，重载x509_crt_verify_name函数，用于校验设备证书名。 
+ * 
+******************************************************************************/
+#define HUAWEI_ONT_CHECK_CERT_CN_NAME_C
+
+/*****************************************************************************
+ * \brief 华为家庭网络产品定制特性，重载mbedtls_ssl_write_hostname_ext函数，用于SSL协议栈中返回主机名。
+ * 
+******************************************************************************/
+#define HUAWEI_ONT_SSL_WRITE_HOSTNAME_C
+
+/*****************************************************************************
+ * \brief 华为家庭网络产品定制特性，重载ssl_write_client_hello函数，用于SSL协议栈中返回主机名。
+ * 
+******************************************************************************/
+#define HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C
+
+/*****************************************************************************
+ * \brief 华为家庭网络产品，修改ssl_ciphersuite_match函数逻辑，在算法不匹配时继续处理
+ * 
+******************************************************************************/
+#define HUAWEI_ONT_CUSTOMIZE_SSL_CIPHERSUIE_MATCH_C
+
+/*****************************************************************************
+ * \brief 华为家庭网络产品，修改ssl_parse_server_dh_params函数逻辑，协商ECC算法参数定制处理
+ * 
+******************************************************************************/
+#define HUAWEI_ONT_CUSTOMIZE_ECP_SIZE_C
+
+/*****************************************************************************
+ * \brief 华为家庭网络产品，修改ssl_write_renegotiation_ext函数逻辑，重新协商
+ * 
+******************************************************************************/
+#define HUAWEI_ONT_CUSTOMIZE_SSL_RENEGOTIATION_C
+
+/*****************************************************************************
+ * \brief 华为家庭网络产品，修改SSL协议栈，证书失败时通过文件方式与业务通信。
+ * 
+******************************************************************************/
+#define HUAWEI_ONT_TLS_CERT_FAILED_NOTICE_C
diff --git a/configs/huawei/config-ontmini.h b/configs/huawei/config-ontmini.h
new file mode 100644
index 0000000..87d075d
--- /dev/null
+++ b/configs/huawei/config-ontmini.h
@@ -0,0 +1,221 @@
+/**
+ * \file mbedtls_config.h
+ *
+ * \brief Configuration options (set of defines)
+ *
+ *  This set of compile-time options may be used to enable
+ *  or disable features selectively, and reduce the global
+ *  memory footprint.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+/**
+ * This is an optional version symbol that enables comatibility handling of
+ * config files.
+ *
+ * It is equal to the #MBEDTLS_VERSION_NUMBER of the Mbed TLS version that
+ * introduced the config format we want to be compatible with.
+ */
+//#define MBEDTLS_CONFIG_VERSION 0x03000000
+
+#define MBEDTLS_HAVE_ASM
+
+#define MBEDTLS_PLATFORM_MEMORY
+
+#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
+
+#define MBEDTLS_CIPHER_MODE_CBC
+
+#define MBEDTLS_CIPHER_MODE_CFB
+
+#define MBEDTLS_CIPHER_MODE_CTR
+
+#define MBEDTLS_CIPHER_MODE_OFB
+
+#define MBEDTLS_CIPHER_MODE_XTS
+
+#define MBEDTLS_CIPHER_PADDING_PKCS7
+#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
+#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
+#define MBEDTLS_CIPHER_PADDING_ZEROS
+
+#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
+#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
+#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
+#define MBEDTLS_ECP_DP_BP256R1_ENABLED
+#define MBEDTLS_ECP_DP_BP384R1_ENABLED
+#define MBEDTLS_ECP_DP_BP512R1_ENABLED
+#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
+#define MBEDTLS_ECP_DP_CURVE448_ENABLED
+
+#define MBEDTLS_ECP_NIST_OPTIM
+
+#define MBEDTLS_ECDSA_DETERMINISTIC
+
+#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
+
+#define MBEDTLS_PK_PARSE_EC_EXTENDED
+
+#define MBEDTLS_ERROR_STRERROR_DUMMY
+
+#define MBEDTLS_GENPRIME
+
+#define MBEDTLS_PK_RSA_ALT_SUPPORT
+
+#define MBEDTLS_PKCS1_V15
+
+#define MBEDTLS_PKCS1_V21
+
+#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
+
+#define MBEDTLS_SSL_RENEGOTIATION
+
+#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
+
+#define MBEDTLS_SSL_ALPN
+
+#define MBEDTLS_SSL_SESSION_TICKETS
+
+#define MBEDTLS_SSL_EXPORT_KEYS
+
+#define MBEDTLS_SSL_SERVER_NAME_INDICATION
+
+#define MBEDTLS_VERSION_FEATURES
+
+#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
+
+#define MBEDTLS_AESNI_C
+
+#define MBEDTLS_AES_C
+
+#define MBEDTLS_ASN1_PARSE_C
+
+#define MBEDTLS_ASN1_WRITE_C
+
+#define MBEDTLS_BASE64_C
+
+#define MBEDTLS_BIGNUM_C
+
+#define MBEDTLS_CAMELLIA_C
+
+#define MBEDTLS_CCM_C
+
+#define MBEDTLS_CHACHA20_C
+
+#define MBEDTLS_CHACHAPOLY_C
+
+#define MBEDTLS_CIPHER_C
+
+#define MBEDTLS_CTR_DRBG_C
+
+#define MBEDTLS_DEBUG_C
+
+#define MBEDTLS_DES_C
+
+#define MBEDTLS_DHM_C
+
+#define MBEDTLS_ECDH_C
+
+#define MBEDTLS_ECP_C
+
+#define MBEDTLS_ENTROPY_C
+
+#define MBEDTLS_ERROR_C
+
+#define MBEDTLS_GCM_C
+
+#define MBEDTLS_HKDF_C
+
+#define MBEDTLS_HMAC_DRBG_C
+
+#define MBEDTLS_MD_C
+
+#define MBEDTLS_NET_C
+
+#define MBEDTLS_OID_C
+
+#define MBEDTLS_PADLOCK_C
+
+#define MBEDTLS_PEM_PARSE_C
+
+#define MBEDTLS_PEM_WRITE_C
+
+#define MBEDTLS_PK_C
+
+#define MBEDTLS_PK_PARSE_C
+
+#define MBEDTLS_PK_WRITE_C
+
+#define MBEDTLS_PKCS5_C
+
+#define MBEDTLS_PKCS12_C
+
+#define MBEDTLS_PLATFORM_C
+
+#define MBEDTLS_POLY1305_C
+
+#define MBEDTLS_RSA_C
+
+#define MBEDTLS_SHA224_C
+#define MBEDTLS_SHA256_C
+#define MBEDTLS_SHA384_C
+#define MBEDTLS_SHA512_C
+
+#define MBEDTLS_TIMING_C
+
+#define MBEDTLS_VERSION_C
+
+#define MBEDTLS_X509_USE_C
+
+#define MBEDTLS_X509_CRT_PARSE_C
+
+#define MBEDTLS_X509_CRL_PARSE_C
+
+#define MBEDTLS_X509_CSR_PARSE_C
+
+#define MBEDTLS_X509_CREATE_C
+
+#define MBEDTLS_X509_CRT_WRITE_C
+
+#define MBEDTLS_X509_CSR_WRITE_C
+
+/* To Use Function Macros MBEDTLS_PLATFORM_C must be enabled */
+/* MBEDTLS_PLATFORM_XXX_MACRO and MBEDTLS_PLATFORM_XXX_ALT cannot both be defined */
+void *mbedtls_adpt_calloc(unsigned int nmemb, unsigned int size);
+void mbedtls_adpt_free(void *ptr);
+#define MBEDTLS_PLATFORM_CALLOC_MACRO        mbedtls_adpt_calloc /**< Default allocator macro to use, can be undefined */
+#define MBEDTLS_PLATFORM_FREE_MACRO          mbedtls_adpt_free /**< Default free macro to use, can be undefined */
diff --git a/configs/huawei/config-onttool.h b/configs/huawei/config-onttool.h
new file mode 100644
index 0000000..eb189a6
--- /dev/null
+++ b/configs/huawei/config-onttool.h
@@ -0,0 +1,263 @@
+/**
+ * \file mbedtls_config.h
+ *
+ * \brief Configuration options (set of defines)
+ *
+ *  This set of compile-time options may be used to enable
+ *  or disable features selectively, and reduce the global
+ *  memory footprint.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+/**
+ * This is an optional version symbol that enables comatibility handling of
+ * config files.
+ *
+ * It is equal to the #MBEDTLS_VERSION_NUMBER of the Mbed TLS version that
+ * introduced the config format we want to be compatible with.
+ */
+//#define MBEDTLS_CONFIG_VERSION 0x03000000
+
+#define MBEDTLS_HAVE_ASM
+
+#define MBEDTLS_HAVE_TIME
+
+#define MBEDTLS_HAVE_TIME_DATE
+
+#define MBEDTLS_CIPHER_MODE_CBC
+
+#define MBEDTLS_CIPHER_MODE_CFB
+
+#define MBEDTLS_CIPHER_MODE_CTR
+
+#define MBEDTLS_CIPHER_MODE_OFB
+
+#define MBEDTLS_CIPHER_MODE_XTS
+
+#define MBEDTLS_CIPHER_PADDING_PKCS7
+#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
+#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
+#define MBEDTLS_CIPHER_PADDING_ZEROS
+
+#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
+#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
+#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
+#define MBEDTLS_ECP_DP_BP256R1_ENABLED
+#define MBEDTLS_ECP_DP_BP384R1_ENABLED
+#define MBEDTLS_ECP_DP_BP512R1_ENABLED
+#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
+#define MBEDTLS_ECP_DP_CURVE448_ENABLED
+
+#define MBEDTLS_ECP_NIST_OPTIM
+
+#define MBEDTLS_ECDSA_DETERMINISTIC
+
+#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
+
+#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
+
+#define MBEDTLS_PK_PARSE_EC_EXTENDED
+
+#define MBEDTLS_ERROR_STRERROR_DUMMY
+
+#define MBEDTLS_GENPRIME
+
+#define MBEDTLS_FS_IO
+
+#define MBEDTLS_PK_RSA_ALT_SUPPORT
+
+#define MBEDTLS_PKCS1_V15
+
+#define MBEDTLS_PKCS1_V21
+
+#define MBEDTLS_SELF_TEST
+
+#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
+
+#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
+
+#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
+
+#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
+
+#define MBEDTLS_SSL_RENEGOTIATION
+
+#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
+
+#define MBEDTLS_SSL_PROTO_TLS1
+
+#define MBEDTLS_SSL_PROTO_TLS1_1
+
+#define MBEDTLS_SSL_PROTO_TLS1_2
+
+#define MBEDTLS_SSL_PROTO_DTLS
+
+#define MBEDTLS_SSL_ALPN
+
+#define MBEDTLS_SSL_DTLS_ANTI_REPLAY
+
+#define MBEDTLS_SSL_DTLS_HELLO_VERIFY
+
+#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
+
+#define MBEDTLS_SSL_DTLS_BADMAC_LIMIT
+
+#define MBEDTLS_SSL_SESSION_TICKETS
+
+#define MBEDTLS_SSL_EXPORT_KEYS
+
+#define MBEDTLS_SSL_SERVER_NAME_INDICATION
+
+#define MBEDTLS_VERSION_FEATURES
+
+#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
+
+#define MBEDTLS_AESNI_C
+
+#define MBEDTLS_AES_C
+
+#define MBEDTLS_ASN1_PARSE_C
+
+#define MBEDTLS_ASN1_WRITE_C
+
+#define MBEDTLS_BASE64_C
+
+#define MBEDTLS_BIGNUM_C
+
+#define MBEDTLS_CAMELLIA_C
+
+#define MBEDTLS_CCM_C
+
+#define MBEDTLS_CHACHA20_C
+
+#define MBEDTLS_CHACHAPOLY_C
+
+#define MBEDTLS_CIPHER_C
+
+#define MBEDTLS_CTR_DRBG_C
+
+#define MBEDTLS_DEBUG_C
+
+#define MBEDTLS_DES_C
+
+#define MBEDTLS_DHM_C
+
+#define MBEDTLS_ECDH_C
+
+#define MBEDTLS_ECDSA_C
+
+#define MBEDTLS_ECP_C
+
+#define MBEDTLS_ENTROPY_C
+
+#define MBEDTLS_ERROR_C
+
+#define MBEDTLS_GCM_C
+
+#define MBEDTLS_HKDF_C
+
+#define MBEDTLS_HMAC_DRBG_C
+
+#define MBEDTLS_MD_C
+
+#define MBEDTLS_MD5_C
+
+#define MBEDTLS_NET_C
+
+#define MBEDTLS_OID_C
+
+#define MBEDTLS_PADLOCK_C
+
+#define MBEDTLS_PEM_PARSE_C
+
+#define MBEDTLS_PEM_WRITE_C
+
+#define MBEDTLS_PK_C
+
+#define MBEDTLS_PK_PARSE_C
+
+#define MBEDTLS_PK_WRITE_C
+
+#define MBEDTLS_PKCS5_C
+
+#define MBEDTLS_PKCS12_C
+
+#define MBEDTLS_PLATFORM_C
+
+#define MBEDTLS_POLY1305_C
+
+#define MBEDTLS_RIPEMD160_C
+
+#define MBEDTLS_RSA_C
+
+#define MBEDTLS_SHA1_C
+#define MBEDTLS_SHA224_C
+#define MBEDTLS_SHA256_C
+#define MBEDTLS_SHA384_C
+#define MBEDTLS_SHA512_C
+
+#define MBEDTLS_SSL_CACHE_C
+
+#define MBEDTLS_SSL_COOKIE_C
+
+#define MBEDTLS_SSL_TICKET_C
+
+#define MBEDTLS_SSL_CLI_C
+
+#define MBEDTLS_SSL_SRV_C
+
+#define MBEDTLS_SSL_TLS_C
+
+#define MBEDTLS_TIMING_C
+
+#define MBEDTLS_VERSION_C
+
+#define MBEDTLS_X509_USE_C
+
+#define MBEDTLS_X509_CRT_PARSE_C
+
+#define MBEDTLS_X509_CRL_PARSE_C
+
+#define MBEDTLS_X509_CSR_PARSE_C
+
+#define MBEDTLS_X509_CREATE_C
+
+#define MBEDTLS_X509_CRT_WRITE_C
+
+#define MBEDTLS_X509_CSR_WRITE_C
diff --git a/configs/huawei/config-suite-b-ai.h b/configs/huawei/config-suite-b-ai.h
new file mode 100644
index 0000000..d6ec809
--- /dev/null
+++ b/configs/huawei/config-suite-b-ai.h
@@ -0,0 +1,124 @@
+/**
+ * \file config-suite-b.h
+ *
+ * \brief Minimal configuration for TLS NSA Suite B Profile (RFC 6460)
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+/*
+ * Minimal configuration for TLS NSA Suite B Profile (RFC 6460)
+ *
+ * Distinguishing features:
+ * - no RSA or classic DH, fully based on ECC
+ * - optimized for low RAM usage
+ *
+ * Possible improvements:
+ * - if 128-bit security is enough, disable secp384r1 and SHA-512
+ * - use embedded certs in DER format and disable PEM_PARSE_C and BASE64_C
+ *
+ * See README.txt for usage instructions.
+ */
+
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
+#define MBEDTLS_RSA_C
+#define MBEDTLS_THREADING_C
+#define MBEDTLS_THREADING_PTHREAD
+#define MBEDTLS_FS_IO
+#define MBEDTLS_SSL_TICKET_C
+#define MBEDTLS_MD5_C
+#define MBEDTLS_DEBUG_C
+#define MBEDTLS_CIPHER_MODE_CBC
+#define MBEDTLS_SSL_RENEGOTIATION
+#define MBEDTLS_ARC4_C
+#define MBEDTLS_ERROR_C
+#define MBEDTLS_X509_CRL_PARSE_C
+#define MBEDTLS_VERSION_C
+#define MBEDTLS_PK_WRITE_C
+#define MBEDTLS_SSL_SRV_C
+#define MBEDTLS_SSL_SESSION_TICKETS
+#define MBEDTLS_PKCS5_C
+#define MBEDTLS_DES_C
+#define MBEDTLS_HUAWEI_ARM_ALG
+#define MBEDTLS_SSL_CLI_C
+#define MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED
+#define MBEDTLS_X509_CRT_PARSE_C
+#define MBEDTLS_X509_CRT_WRITE_C
+#define MBEDTLS_X509_CREATE_C
+#define MBEDTLS_PLATFORM_C
+#define MBEDTLS_DHM_C
+#define MBEDTLS_SSL_CACHE_C
+#define MBEDTLS_SHA1_C
+#define MBEDTLS_PKCS1_V15
+#define MBEDTLS_X509_CSR_WRITE_C
+#define MBEDTLS_PEM_WRITE_C
+#define MBEDTLS_GENPRIME
+
+#define MBEDTLS_HAVE_ASM
+#define MBEDTLS_HAVE_TIME
+
+#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
+#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
+#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
+#define MBEDTLS_SSL_PROTO_TLS1_2
+
+#define MBEDTLS_AES_C
+#define MBEDTLS_ASN1_PARSE_C
+#define MBEDTLS_ASN1_WRITE_C
+#define MBEDTLS_BIGNUM_C
+#define MBEDTLS_CIPHER_C
+#define MBEDTLS_CTR_DRBG_C
+#define MBEDTLS_ECDH_C
+#define MBEDTLS_ECDSA_C
+#define MBEDTLS_ECP_C
+#define MBEDTLS_ENTROPY_C
+#define MBEDTLS_GCM_C
+#define MBEDTLS_MD_C
+#define MBEDTLS_NET_C
+#define MBEDTLS_OID_C
+#define MBEDTLS_PK_C
+#define MBEDTLS_PK_PARSE_C
+
+#define MBEDTLS_SHA224_C
+#define MBEDTLS_SHA256_C
+#define MBEDTLS_SHA384_C
+#define MBEDTLS_SHA512_C
+#define MBEDTLS_SSL_CLI_C
+#define MBEDTLS_SSL_SRV_C
+#define MBEDTLS_SSL_TLS_C
+#define MBEDTLS_X509_CRT_PARSE_C
+#define MBEDTLS_X509_USE_C
+
+#define MBEDTLS_BASE64_C
+#define MBEDTLS_PEM_PARSE_C
+
+#define MBEDTLS_AES_ROM_TABLES
+
+#define MBEDTLS_MPI_MAX_SIZE    1024 // 384-bit EC curve = 1024 bytes
+
+#define MBEDTLS_ECP_WINDOW_SIZE        2
+#define MBEDTLS_ECP_FIXED_POINT_OPTIM  0
+
+#define MBEDTLS_ECP_NIST_OPTIM
+
+#define MBEDTLS_ENTROPY_MAX_SOURCES 2
+
+#define MBEDTLS_SSL_CIPHERSUITES                        \
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,    \
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+
+#define MBEDTLS_SSL_IN_CONTENT_LEN             16384
+#define MBEDTLS_SSL_OUT_CONTENT_LEN             16384
diff --git a/harden/build/conncet/mbedtls.cmake b/harden/build/conncet/mbedtls.cmake
new file mode 100644
index 0000000..7f50429
--- /dev/null
+++ b/harden/build/conncet/mbedtls.cmake
@@ -0,0 +1,250 @@
+#===============================================================================
+# @brief    cmake file
+# Copyright (c) @CompanyNameMagicTag 2022-2022. All rights reserved.
+#===============================================================================
+set(COMPONENT_NAME "mbedtls")
+
+set(SOURCES
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/aes.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/aesni.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/aria.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/asn1parse.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/asn1write.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/base64.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/bignum.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/camellia.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ccm.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/chacha20.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/chachapoly.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/cipher.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/cipher_wrap.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/cmac.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/constant_time.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ctr_drbg.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/debug.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/des.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/dhm.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ecdh.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ecdsa.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ecjpake.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ecp.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ecp_curves.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/entropy.c
+	# ${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/entropy_poll.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/error.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/gcm.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/hmac_drbg.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/hkdf.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/md.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/md5.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/memory_buffer_alloc.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/mps_reader.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/mps_trace.c
+	# ${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/net_sockets.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/nist_kw.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/oid.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/padlock.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/pem.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/pk.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/pk_wrap.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/pkcs5.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/pkcs12.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/pkparse.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/pkwrite.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/platform.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/platform_util.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/poly1305.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_aead.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_cipher.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_client.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_driver_wrappers.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_ecp.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_hash.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_mac.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_rsa.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_se.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_slot_management.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_crypto_storage.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/psa_its_file.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ripemd160.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/rsa.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/rsa_alt_helpers.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/sha1.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/sha256.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/sha512.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_cache.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_ciphersuites.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_cli.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_cookie.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_debug_helpers_generated.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_msg.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_srv.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_ticket.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_tls.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_tls13_client.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_tls13_generic.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_tls13_server.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/ssl_tls13_keys.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/threading.c
+	# ${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/timing.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/version.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/version_features.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/x509.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/x509_create.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/x509_crl.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/x509_crt.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/x509_csr.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/x509write_crt.c
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library/x509write_csr.c
+)
+
+set(PUBLIC_HEADER
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/include
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/include/psa
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/include/mbedtls
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/3rdparty/everest/include/everest
+)
+
+set(PRIVATE_HEADER
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/include
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/library
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/include/psa
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/include/mbedtls
+	${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/3rdparty/everest/include/everest
+)
+
+set(PRIVATE_DEFINES
+	SYSCALLS_H
+)
+
+if ("${CHIP}" STREQUAL "brandy")
+	list(INSERT PRIVATE_DEFINES 0
+		MBEDTLS_USER_CONFIG_FILE="mbedtls_platform_hardware_config.h"
+	)
+
+	list(APPEND SOURCES
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/entropy_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/cipher_adapt.c
+	)
+
+	list(APPEND PRIVATE_HEADER
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/internal_include
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/platform/wearable
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/cipher_adapt_include
+	)
+endif()
+
+if("MBEDTLS_HARDEN_OPEN" IN_LIST DEFINES)
+	list(APPEND PRIVATE_DEFINES
+		MBEDTLS_USER_CONFIG_FILE="mbedtls_platform_hardware_config.h"
+	)
+	list(APPEND SOURCES
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/aes_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/cipher_adapt.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/cipher_common.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/cmac_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/ecc_harden_common.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/ecc_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/hash_harden_common.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/hash_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/hkdf_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/pbkdf2_hmac_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/bignum_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/entropy_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/dfx.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/gcm_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/ccm_harden.c
+	)
+	list(APPEND PRIVATE_HEADER
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/internal_include
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/platform/connect
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/cipher_adapt_include
+	)
+elseif("FUZZ_TEST" IN_LIST DEFINES)
+	list(APPEND PRIVATE_DEFINES
+		MBEDTLS_USER_CONFIG_FILE="mbedtls_platform_hardware_config.h"
+		MBEDTLS_CONFIG_FILE="mbedtls_platform_fuzz_config.h"
+	)
+	list(APPEND SOURCES
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/aes_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/cipher_adapt.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/cipher_common.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/cmac_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/ecc_harden_common.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/ecc_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/hash_harden_common.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/hash_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/hkdf_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/pbkdf2_hmac_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/bignum_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/entropy_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/dfx.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/gcm_harden.c
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/ccm_harden.c
+	)
+	list(APPEND PRIVATE_HEADER
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/internal_include
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/platform/connect
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/cipher_adapt_include
+	)
+	list(APPEND PUBLIC_HEADER
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/src/internal_include
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/platform/connect
+		${ROOT_DIR}/open_source/mbedtls/mbedtls_v3.1.0/harden/cipher_adapt_include
+	)
+else()
+	if(${OS} STREQUAL "liteos")
+		list (APPEND PRIVATE_DEFINES
+			MBEDTLS_ECP_RESTARTABLE
+		)
+	endif()
+endif()
+
+set(PUBLIC_DEFINES
+)
+
+# use this when you want to add ccflags like -include xxx
+set(COMPONENT_PUBLIC_CCFLAGS
+)
+
+set(COMPONENT_CCFLAGS
+	-Wno-error=switch-default
+	-Wno-error=unused-parameter
+    -Wno-error=unused-variable
+    -Wno-error=strict-prototypes
+    -Wno-error=sign-compare
+    -Wno-error=return-type
+    -Wno-error=unused-value
+    -Wno-error=comment
+    -Wno-error=pointer-sign
+    -Wno-error=attributes
+    -Wno-error=uninitialized
+    -Wno-error=unused-function
+	-Wno-error=format
+	-Wno-error=incompatible-pointer-types
+)
+
+if("${ARCH}" STREQUAL "riscv31")
+list (APPEND COMPONENT_CCFLAGS
+	-Wno-error=jump-misses-init
+)
+endif()
+
+if("${ARCH}" STREQUAL "cortex_m7")
+	list (APPEND COMPONENT_CCFLAGS
+			-Wno-error=jump-misses-init
+	)
+endif()
+
+
+set(WHOLE_LINK
+    true
+)
+
+set(MAIN_COMPONENT
+    false
+)
+
+build_component()
diff --git a/harden/build/vision/Makefile b/harden/build/vision/Makefile
new file mode 100644
index 0000000..69d52d6
--- /dev/null
+++ b/harden/build/vision/Makefile
@@ -0,0 +1,346 @@
+
+PARAM_FILE_SDK:=../../../../../../smp/a7_linux/source/Makefile.param
+PARAM_FILE_SRCS:=../../../../../../source/Makefile.param
+ifneq ($(wildcard $(PARAM_FILE_SDK)),)
+    PARAM_FILE:=$(PARAM_FILE_SDK)
+    include $(PARAM_FILE)
+else
+    PARAM_FILE:=$(PARAM_FILE_SRCS)
+    include $(PARAM_FILE)
+endif
+
+ifeq ($(CONFIG_LLVM), y)
+	CLANG_CROSS += LLVM=1 LLVM_IAS=1
+	CC:=clang
+	AR:=llvm-ar
+	STRIP:=llvm-strip
+	OBJCOPY:=llvm-objcopy
+else
+	CC:=$(CROSS)gcc
+	AR:=$(CROSS)ar
+	STRIP:=$(CROSS)strip
+	OBJCOPY:=$(CROSS)objcopy
+endif
+
+MBED_ROOT_PATH = ../../..
+MBED_LIB_PATH = $(MBED_ROOT_PATH)/library
+
+SHARED = y
+
+GENERATED_FILES := \
+	error.c version_features.c \
+	ssl_debug_helpers_generated.c \
+	psa_crypto_driver_wrappers.h \
+	psa_crypto_driver_wrappers_no_static.c
+
+CFLAGS	?= -O2
+WARNING_CFLAGS ?= -Wall -Wextra -Wformat=2 -Wno-format-nonliteral
+LDFLAGS ?=
+
+CFLAGS += -DCRYPTO_SOFT_HMAC_SUPPORT
+CFLAGS += -DMBEDTLS_USER_CONFIG_FILE='"mbedtls_platform_hardware_config.h"'
+
+# if you want to view the log, open this macro
+# CFLAGS += -DMBED_HARDEN_DEBUG
+
+LOCAL_CFLAGS = $(WARNING_CFLAGS) -I$(MBED_LIB_PATH) -I$(MBED_ROOT_PATH)/include -D_FILE_OFFSET_BITS=64
+
+CFLAGS  += -I$(MBED_ROOT_PATH)/harden/src/internal_include
+CFLAGS  += -I$(MBED_ROOT_PATH)/harden/platform/vision
+CFLAGS  += -I$(MBED_ROOT_PATH)/harden/cipher_adapt_include
+
+ifdef DEBUG
+LOCAL_CFLAGS += -g3
+endif
+
+PERL ?= perl
+
+PYTHON ?= $(shell if type python3 >/dev/null 2>/dev/null; then echo python3; else echo python; fi)
+
+LOCAL_CFLAGS += -fPIC -fpic
+
+SOEXT_TLS?=so.21
+SOEXT_X509?=so.7
+SOEXT_CRYPTO?=so.16
+
+# Set AR_DASH= (empty string) to use an ar implementation that does not accept
+# the - prefix for command line options (e.g. llvm-ar)
+AR_DASH ?= -
+
+ARFLAGS = $(AR_DASH)src
+
+OBJS_CRYPTO= \
+		 $(MBED_LIB_PATH)/aes.o \
+	     $(MBED_LIB_PATH)/aesni.o \
+		 $(MBED_LIB_PATH)/aesce.o \
+	     $(MBED_LIB_PATH)/aria.o \
+	     $(MBED_LIB_PATH)/asn1parse.o \
+	     $(MBED_LIB_PATH)/asn1write.o \
+	     $(MBED_LIB_PATH)/base64.o \
+	     $(MBED_LIB_PATH)/bignum_core.o \
+	     $(MBED_LIB_PATH)/bignum_mod.o \
+	     $(MBED_LIB_PATH)/bignum_mod_raw.o \
+	     $(MBED_LIB_PATH)/block_cipher.o \
+		 $(MBED_LIB_PATH)/bignum.o \
+	     $(MBED_LIB_PATH)/camellia.o \
+	     $(MBED_LIB_PATH)/ccm.o \
+	     $(MBED_LIB_PATH)/chacha20.o \
+	     $(MBED_LIB_PATH)/chachapoly.o \
+	     $(MBED_LIB_PATH)/cipher.o \
+	     $(MBED_LIB_PATH)/cipher_wrap.o \
+	     $(MBED_LIB_PATH)/cmac.o \
+	     $(MBED_LIB_PATH)/constant_time.o \
+	     $(MBED_LIB_PATH)/ctr_drbg.o \
+	     $(MBED_LIB_PATH)/des.o \
+	     $(MBED_LIB_PATH)/dhm.o \
+	     $(MBED_LIB_PATH)/ecdh.o \
+	     $(MBED_LIB_PATH)/ecdsa.o \
+	     $(MBED_LIB_PATH)/ecjpake.o \
+		 $(MBED_LIB_PATH)/ecp.o \
+	     $(MBED_LIB_PATH)/ecp_curves.o \
+	     $(MBED_LIB_PATH)/ecp_curves_new.o \
+	     $(MBED_LIB_PATH)/entropy.o \
+	     $(MBED_LIB_PATH)/entropy_poll.o \
+	     $(MBED_LIB_PATH)/error.o \
+	     $(MBED_LIB_PATH)/gcm.o \
+	     $(MBED_LIB_PATH)/hkdf.o \
+	     $(MBED_LIB_PATH)/hmac_drbg.o \
+	     $(MBED_LIB_PATH)/lmots.o \
+	     $(MBED_LIB_PATH)/lms.o \
+		 $(MBED_LIB_PATH)/md.o \
+	     $(MBED_LIB_PATH)/md5.o \
+	     $(MBED_LIB_PATH)/memory_buffer_alloc.o \
+	     $(MBED_LIB_PATH)/nist_kw.o \
+	     $(MBED_LIB_PATH)/oid.o \
+	     $(MBED_LIB_PATH)/padlock.o \
+	     $(MBED_LIB_PATH)/pem.o \
+	     $(MBED_LIB_PATH)/pk.o \
+	     $(MBED_LIB_PATH)/pk_ecc.o \
+	     $(MBED_LIB_PATH)/pk_wrap.o \
+		 $(MBED_LIB_PATH)/pkcs5.o \
+	     $(MBED_LIB_PATH)/pkcs12.o \
+	     $(MBED_LIB_PATH)/pkparse.o \
+	     $(MBED_LIB_PATH)/pkwrite.o \
+	     $(MBED_LIB_PATH)/platform.o \
+	     $(MBED_LIB_PATH)/platform_util.o \
+	     $(MBED_LIB_PATH)/poly1305.o \
+	     $(MBED_LIB_PATH)/psa_crypto.o \
+	     $(MBED_LIB_PATH)/psa_crypto_aead.o \
+	     $(MBED_LIB_PATH)/psa_crypto_cipher.o \
+	     $(MBED_LIB_PATH)/psa_crypto_client.o \
+	     $(MBED_LIB_PATH)/psa_crypto_driver_wrappers_no_static.o \
+	     $(MBED_LIB_PATH)/psa_crypto_ecp.o \
+	     $(MBED_LIB_PATH)/psa_crypto_ffdh.o \
+	     $(MBED_LIB_PATH)/psa_crypto_hash.o \
+	     $(MBED_LIB_PATH)/psa_crypto_mac.o \
+	     $(MBED_LIB_PATH)/psa_crypto_pake.o \
+	     $(MBED_LIB_PATH)/psa_crypto_rsa.o \
+	     $(MBED_LIB_PATH)/psa_crypto_se.o \
+	     $(MBED_LIB_PATH)/psa_crypto_slot_management.o \
+	     $(MBED_LIB_PATH)/psa_crypto_storage.o \
+	     $(MBED_LIB_PATH)/psa_its_file.o \
+	     $(MBED_LIB_PATH)/psa_util.o \
+	     $(MBED_LIB_PATH)/ripemd160.o \
+	     $(MBED_LIB_PATH)/rsa.o \
+	     $(MBED_LIB_PATH)/rsa_alt_helpers.o \
+	     $(MBED_LIB_PATH)/sha1.o \
+	     $(MBED_LIB_PATH)/sha256.o \
+	     $(MBED_LIB_PATH)/sha512.o \
+	     $(MBED_LIB_PATH)/sha3.o \
+	     $(MBED_LIB_PATH)/threading.o \
+	     $(MBED_LIB_PATH)/timing.o \
+	     $(MBED_LIB_PATH)/version.o \
+	     $(MBED_LIB_PATH)/version_features.o \
+	     # This line is intentionally left blank
+
+THIRDPARTY_INCLUDES+=-I$(MBED_ROOT_PATH)/3rdparty/everest/include \
+	-I$(MBED_ROOT_PATH)/3rdparty/everest/include/everest \
+	-I$(MBED_ROOT_PATH)/3rdparty/everest/include/everest/kremlib
+
+THIRDPARTY_CRYPTO_OBJECTS+= \
+	$(MBED_ROOT_PATH)/3rdparty/everest/library/everest.o \
+	$(MBED_ROOT_PATH)/3rdparty/everest/library/x25519.o \
+	$(MBED_ROOT_PATH)/3rdparty/everest/library/Hacl_Curve25519_joined.o
+
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/gcm_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/cmac_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/dfx.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/bignum_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/entropy_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/pbkdf2_hmac_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/ecc_harden_common.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/ecc_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/hash_harden_common.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/cipher_common.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/cipher_adapt.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/sha1_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/sha256_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/sha512_harden.o
+HARDEN_OBJECTS += $(MBED_ROOT_PATH)/harden/src/aes_alt.o
+
+CFLAGS += $(THIRDPARTY_INCLUDES)
+OBJS_CRYPTO  += $(THIRDPARTY_CRYPTO_OBJECTS)
+OBJS_CRYPTO  += $(HARDEN_OBJECTS)
+
+OBJS_X509= \
+	   $(MBED_LIB_PATH)/x509.o \
+	   $(MBED_LIB_PATH)/x509_create.o \
+	   $(MBED_LIB_PATH)/x509_crl.o \
+	   $(MBED_LIB_PATH)/x509_crt.o \
+	   $(MBED_LIB_PATH)/x509_csr.o \
+	   $(MBED_LIB_PATH)/x509write.o \
+	   $(MBED_LIB_PATH)/x509write_crt.o \
+	   $(MBED_LIB_PATH)/x509write_csr.o \
+	   $(MBED_LIB_PATH)/pkcs7.o
+	   # This line is intentionally left blank
+
+OBJS_TLS= \
+	  $(MBED_LIB_PATH)/debug.o \
+	  $(MBED_LIB_PATH)/mps_reader.o \
+	  $(MBED_LIB_PATH)/mps_trace.o \
+	  $(MBED_LIB_PATH)/net_sockets.o \
+	  $(MBED_LIB_PATH)/ssl_cache.o \
+	  $(MBED_LIB_PATH)/ssl_ciphersuites.o \
+	  $(MBED_LIB_PATH)/ssl_client.o \
+	  $(MBED_LIB_PATH)/ssl_cookie.o \
+	  $(MBED_LIB_PATH)/ssl_debug_helpers_generated.o \
+	  $(MBED_LIB_PATH)/ssl_msg.o \
+	  $(MBED_LIB_PATH)/ssl_ticket.o \
+	  $(MBED_LIB_PATH)/ssl_tls.o \
+	  $(MBED_LIB_PATH)/ssl_tls12_client.o \
+	  $(MBED_LIB_PATH)/ssl_tls12_server.o \
+	  $(MBED_LIB_PATH)/ssl_tls13_keys.o \
+	  $(MBED_LIB_PATH)/ssl_tls13_client.o \
+	  $(MBED_LIB_PATH)/ssl_tls13_server.o \
+	  $(MBED_LIB_PATH)/ssl_tls13_generic.o \
+	  # This line is intentionally left blank
+
+.SILENT:
+
+.PHONY: all static shared clean
+
+ifndef SHARED
+all: static
+else
+all: shared static
+	if [ ! -d "out" ]; then mkdir out; fi
+	mv libmbedtls.*    out
+	mv libmbedx509.*   out
+	mv libmbedcrypto.* out
+endif
+
+static: libmbedcrypto.a libmbedx509.a libmbedtls.a
+	cd $(MBED_LIB_PATH)/../tests && echo "This is a seedfile that contains 64 bytes (65 on Windows)......" > seedfile
+
+shared: libmbedcrypto.so libmbedx509.so libmbedtls.so
+
+# tls
+libmbedtls.a: $(OBJS_TLS)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_TLS)
+
+libmbedtls.$(SOEXT_TLS): $(OBJS_TLS) libmbedx509.so
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_TLS) -L. -lmbedx509 -lmbedcrypto $(LDFLAGS)
+
+ifneq ($(SOEXT_TLS),so)
+libmbedtls.so: libmbedtls.$(SOEXT_TLS)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+endif
+
+# x509
+libmbedx509.a: $(OBJS_X509)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_X509)
+
+libmbedx509.$(SOEXT_X509): $(OBJS_X509) libmbedcrypto.so
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_X509) -L. -lmbedcrypto $(LDFLAGS)
+
+ifneq ($(SOEXT_X509),so)
+libmbedx509.so: libmbedx509.$(SOEXT_X509)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+endif
+
+# crypto
+libmbedcrypto.a: $(OBJS_CRYPTO)
+	echo "  AR    $@"
+	$(AR) $(ARFLAGS) $@ $(OBJS_CRYPTO)
+
+libmbedcrypto.$(SOEXT_CRYPTO): $(OBJS_CRYPTO)
+	echo "  LD    $@"
+	$(CC) -shared -Wl,-soname,$@ -o $@ $(OBJS_CRYPTO) $(LDFLAGS)
+
+ifneq ($(SOEXT_CRYPTO),so)
+libmbedcrypto.so: libmbedcrypto.$(SOEXT_CRYPTO)
+	echo "  LN    $@ -> $<"
+	ln -sf $< $@
+endif
+
+.c.o:
+	echo "  CC    $<"
+	$(CC) $(LOCAL_CFLAGS) $(CFLAGS) -o $@ -c $<
+
+.PHONY: generated_files
+
+generated_files: $(GENERATED_FILES)
+
+# See root Makefile
+GEN_FILES ?=
+ifdef GEN_FILES
+gen_file_dep =
+else
+gen_file_dep = |
+endif
+
+error.c:  $(gen_file_dep) $(MBED_ROOT_PATH)/scripts/generate_errors.pl
+error.c:  $(gen_file_dep) $(MBED_ROOT_PATH)/scripts/data_files/error.fmt
+error.c:  $(gen_file_dep) $(filter-out %config%,$(wildcard $(MBED_ROOT_PATH)/include/mbedtls/*.h))
+error.c:
+	echo "  Gen   $@"
+	$(PERL) $(MBED_ROOT_PATH)/scripts/generate_errors.pl
+
+ssl_debug_helpers_generated.c: $(gen_file_dep) $(MBED_ROOT_PATH)/scripts/generate_ssl_debug_helpers.py
+ssl_debug_helpers_generated.c: $(gen_file_dep) $(filter-out %config%,$(wildcard $(MBED_ROOT_PATH)/include/mbedtls/*.h))
+ssl_debug_helpers_generated.c:
+	echo "  Gen   $@"
+	$(PYTHON) $(MBED_ROOT_PATH)/scripts/generate_ssl_debug_helpers.py --mbedtls-root $(MBED_ROOT_PATH) $(MBED_LIB_PATH)
+
+version_features.c: $(gen_file_dep) $(MBED_ROOT_PATH)/scripts/generate_features.pl
+version_features.c: $(gen_file_dep) $(MBED_ROOT_PATH)/scripts/data_files/version_features.fmt
+## The generated file only depends on the options that are present in mbedtls_config.h,
+## not on which options are set. To avoid regenerating this file all the time
+## when switching between configurations, don't declare mbedtls_config.h as a
+## dependency. Remove this file from your working tree if you've just added or
+## removed an option in mbedtls_config.h.
+#version_features.c: $(MBED_ROOT_PATH)/include/mbedtls/mbedtls_config.h
+version_features.c:
+	echo "  Gen   $@"
+	$(PERL) $(MBED_ROOT_PATH)/scripts/generate_features.pl
+
+GENERATED_WRAPPER_FILES = \
+                    $(MBED_LIB_PATH)/psa_crypto_driver_wrappers.h \
+                    $(MBED_LIB_PATH)/psa_crypto_driver_wrappers_no_static.c
+$(GENERATED_WRAPPER_FILES): $(MBED_ROOT_PATH)/scripts/generate_driver_wrappers.py
+$(GENERATED_WRAPPER_FILES): $(MBED_ROOT_PATH)/scripts/data_files/driver_templates/psa_crypto_driver_wrappers.h.jinja
+$(GENERATED_WRAPPER_FILES): $(MBED_ROOT_PATH)/scripts/data_files/driver_templates/psa_crypto_driver_wrappers_no_static.c.jinja
+$(GENERATED_WRAPPER_FILES):
+	echo "  Gen   $(GENERATED_WRAPPER_FILES)"
+	$(PYTHON) $(MBED_ROOT_PATH)/scripts/generate_driver_wrappers.py
+
+psa_crypto.o:$(MBED_LIB_PATH)/psa_crypto_driver_wrappers.h
+
+clean:
+	rm -f *.o libmbed*
+	rm -f $(THIRDPARTY_CRYPTO_OBJECTS)
+	rm -f $(OBJS_CRYPTO)
+	rm -f $(OBJS_X509)
+	rm -f $(OBJS_TLS)
+	rm -f out/*
+	rm -rf $(MBED_ROOT_PATH)/harden/src/*.o
+	rm -rf $(HARDEN_OBJECTS)
+
+neat: clean
+	rm -f $(GENERATED_FILES)
\ No newline at end of file
diff --git a/harden/cipher_adapt_include/crypto_cipher_common_struct.h b/harden/cipher_adapt_include/crypto_cipher_common_struct.h
new file mode 100644
index 0000000..293ebf9
--- /dev/null
+++ b/harden/cipher_adapt_include/crypto_cipher_common_struct.h
@@ -0,0 +1,343 @@
+/**
+ * Copyright ( c ) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef CRYPTO_CIPHER_COMMON_STRUCT_H
+#define CRYPTO_CIPHER_COMMON_STRUCT_H
+
+#include "mbedtls_crypto_type.h"
+#include "mbedtls_platform_hardware_config.h"
+
+#define CRYPTO_IV_LEN_IN_BYTES      16
+#define CRYPTO_HASH_RESULT_SIZE_MAX_IN_WORD 16      // for SHA-512
+#define CRYPTO_HASH_BLOCK_SIZE_MAX 128              // for SHA-512
+
+typedef enum {
+    CRYPTO_BUF_SECURE,
+    CRYPTO_BUF_NONSECURE,
+} crypto_buffer_secure;
+
+typedef enum {
+    CRYPTO_HASH_TYPE_SHA1 = 0xf690a0,
+    CRYPTO_HASH_TYPE_SHA224 = 0x10690e0,
+    CRYPTO_HASH_TYPE_SHA256 = 0x1169100,
+    CRYPTO_HASH_TYPE_SHA384 = 0x127a180,
+    CRYPTO_HASH_TYPE_SHA512 = 0x137a200,
+    CRYPTO_HASH_TYPE_SM3 = 0x2169100,
+
+    CRYPTO_HASH_TYPE_HMAC_SHA1 = 0x10f690a0,
+    CRYPTO_HASH_TYPE_HMAC_SHA224 = 0x110690e0,
+    CRYPTO_HASH_TYPE_HMAC_SHA256 = 0x11169100,
+    CRYPTO_HASH_TYPE_HMAC_SHA384 = 0x1127a180,
+    CRYPTO_HASH_TYPE_HMAC_SHA512 = 0x1137a200,
+    CRYPTO_HASH_TYPE_HMAC_SM3 = 0x12169100,
+
+    CRYPTO_HASH_TYPE_INVALID = 0xffffffff,
+} crypto_hash_type;
+
+typedef enum {
+    CRYPTO_SYMC_ALG_TDES = 0x0,
+    CRYPTO_SYMC_ALG_AES = 0x1,
+    CRYPTO_SYMC_ALG_SM4 = 0x2,
+    CRYPTO_SYMC_ALG_LEA = 0x3,
+    CRYPTO_SYMC_ALG_DMA = 0x4,
+    CRYPTO_SYMC_ALG_MAX,
+    CRYPTO_SYMC_ALG_INVALID = 0xffffffff,
+} crypto_symc_alg;
+
+typedef enum {
+    CRYPTO_SYMC_TYPE_NORMAL = 0x0,
+    CRYPTO_SYMC_TYPE_REG,
+    CRYPTO_SYMC_TYPE_MAX,
+    CRYPTO_SYMC_TYPE_INVALID = 0xffffffff,
+} crypto_symc_type;
+
+typedef enum {
+    CRYPTO_SYMC_WORK_MODE_ECB = 0x0,
+    CRYPTO_SYMC_WORK_MODE_CBC,
+    CRYPTO_SYMC_WORK_MODE_CTR,
+    CRYPTO_SYMC_WORK_MODE_OFB,
+    CRYPTO_SYMC_WORK_MODE_CFB,
+    CRYPTO_SYMC_WORK_MODE_CCM,
+    CRYPTO_SYMC_WORK_MODE_GCM,
+    CRYPTO_SYMC_WORK_MODE_CBC_MAC,
+    CRYPTO_SYMC_WORK_MODE_CMAC,
+    CRYPTO_SYMC_WORK_MODE_MAX,
+    CRYPTO_SYMC_WORK_MODE_INVALID = 0xffffffff,
+} crypto_symc_work_mode;
+
+typedef enum {
+    CRYPTO_SYMC_KEY_64BIT =  0x0,
+    CRYPTO_SYMC_KEY_128BIT = 0x1,
+    CRYPTO_SYMC_KEY_192BIT = 0x2,
+    CRYPTO_SYMC_KEY_256BIT = 0x3,
+    CRYPTO_SYMC_KEY_LENGTH_MAX,
+    CRYPTO_SYMC_KEY_LENGTH_INVALID = 0xffffffff,
+} crypto_symc_key_length;
+
+typedef enum {
+    CRYPTO_SYMC_KEY_EVEN =  0x0,
+    CRYPTO_SYMC_KEY_ODD  =  0x1,
+    CRYPTO_SYMC_KEY_PARITY_MAX,
+    CRYPTO_SYMC_KEY_PARITY_INVALID = 0xffffffff,
+} crypto_symc_key_parity;
+
+typedef enum {
+    CRYPTO_SYMC_BIT_WIDTH_1BIT = 0x0,
+    CRYPTO_SYMC_BIT_WIDTH_8BIT = 0x1,
+    CRYPTO_SYMC_BIT_WIDTH_64BIT = 0x2,
+    CRYPTO_SYMC_BIT_WIDTH_128BIT = 0x3,
+    CRYPTO_SYMC_BIT_WIDTH_MAX,
+    CRYPTO_SYMC_BIT_WIDTH_INVALID = 0xffffffff,
+} crypto_symc_bit_width;
+
+typedef enum {
+    CRYPTO_SYMC_IV_DO_NOT_CHANGE = 0,
+    CRYPTO_SYMC_IV_CHANGE_ONE_PKG,
+    CRYPTO_SYMC_IV_CHANGE_ALL_PKG,
+    /* GCM. */
+    CRYPTO_SYMC_GCM_IV_DO_NOT_CHANGE,
+    CRYPTO_SYMC_GCM_IV_CHANGE_START,
+    CRYPTO_SYMC_GCM_IV_CHANGE_UPDATE,
+    CRYPTO_SYMC_GCM_IV_CHANGE_FINISH,
+    /* CCM. */
+    CRYPTO_SYMC_CCM_IV_DO_NOT_CHANGE,
+    CRYPTO_SYMC_CCM_IV_CHANGE_START,
+    CRYPTO_SYMC_CCM_IV_CHANGE_UPDATE,
+    CRYPTO_SYMC_CCM_IV_CHANGE_FINISH,
+    CRYPTO_SYMC_IV_CHANGE_MAX,
+    CRYPTO_SYMC_IV_CHANGE_INVALID = 0xffffffff,
+} crypto_symc_iv_change_type;
+
+typedef enum {
+    DRV_PKE_RSA_SCHEME_PKCS1_V15 = 0x00,  /* PKCS#1 V15 */
+    DRV_PKE_RSA_SCHEME_PKCS1_V21,         /* PKCS#1 V21, PSS for signning, OAEP for encryption */
+    DRV_PKE_RSA_SCHEME_MAX,
+    DRV_PKE_RSA_SCHEME_INVALID = 0xffffffff,
+} drv_pke_rsa_scheme;
+
+typedef enum {
+    DRV_PKE_HASH_TYPE_SHA1 = 0x00,   /* Suggest Not to use */
+    DRV_PKE_HASH_TYPE_SHA224,
+    DRV_PKE_HASH_TYPE_SHA256,
+    DRV_PKE_HASH_TYPE_SHA384,
+    DRV_PKE_HASH_TYPE_SHA512,
+    DRV_PKE_HASH_TYPE_SM3,
+    DRV_PKE_HASH_TYPE_MAX,
+    DRV_PKE_HASH_TYPE_INVALID = 0xffffffff,
+} drv_pke_hash_type;
+
+typedef enum {
+    DRV_PKE_BUF_NONSECURE = 0x00,
+    DRV_PKE_BUF_SECURE,
+    DRV_PKE_BUF_INVALID = 0xffffffff,
+} drv_pke_buffer_secure;
+
+typedef enum {
+    DRV_PKE_LEN_192 = 24,
+    DRV_PKE_LEN_224 = 32,
+    DRV_PKE_LEN_256 = 32,
+    DRV_PKE_LEN_384 = 48,
+    DRV_PKE_LEN_448 = 56,
+    DRV_PKE_LEN_512 = 64,
+    DRV_PKE_LEN_521 = 68,
+    DRV_PKE_LEN_576 = 72,
+    DRV_PKE_LEN_1024 = 128,
+    DRV_PKE_LEN_2048 = 256,
+    DRV_PKE_LEN_3072 = 384,
+    DRV_PKE_LEN_4096 = 512,
+    DRV_PKE_LEN_MAX,
+    DRV_PKE_LEN_INVALID = 0xffffffff,
+} drv_pke_len;
+
+typedef enum {
+    DRV_PKE_ECC_TYPE_RFC5639_P256 = 0,      /* RFC 5639 - Brainpool P256/384/512 */
+    DRV_PKE_ECC_TYPE_RFC5639_P384,          /* RFC 5639 - Brainpool P256/384/512 */
+    DRV_PKE_ECC_TYPE_RFC5639_P512,          /* RFC 5639 - Brainpool P256/384/512 */
+    DRV_PKE_ECC_TYPE_FIPS_P256K,            /* NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+#if defined(MBEDTLS_SECP192R1_USE_HARDWARE)
+    DRV_PKE_ECC_TYPE_FIPS_P192R,            /* NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+#endif
+#if defined(MBEDTLS_SECP224R1_USE_HARDWARE)
+    DRV_PKE_ECC_TYPE_FIPS_P224R,            /* NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+#endif
+    DRV_PKE_ECC_TYPE_FIPS_P256R,            /* NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+    DRV_PKE_ECC_TYPE_FIPS_P384R,            /* NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+    DRV_PKE_ECC_TYPE_FIPS_P521R,            /* NIST FIPS 186-4 P192/224/256/384/521, suggest not to use */
+    DRV_PKE_ECC_TYPE_RFC7748,               /* RFC 7748 - Curve25519 */
+#if defined(MBEDTLS_CURVE448_USE_HARDWARE)
+    DRV_PKE_ECC_TYPE_RFC7748_448,           /* RFC 7748 - Curve448 */
+#endif
+    DRV_PKE_ECC_TYPE_RFC8032,               /* RFC 8032 - ED25519 */
+    DRV_PKE_ECC_TYPE_SM2,                   /* GMT 0003.2-2012 */
+    DRV_PKE_ECC_TYPE_MAX,
+    DRV_PKE_ECC_TYPE_INVALID = 0xffffffff,
+} drv_pke_ecc_curve_type;
+
+typedef struct {
+    unsigned long long uapi_mem_handle;     /* Handle to buffer header address */
+    unsigned long long addr_offset;         /* buffer offset, unused. */
+    td_void *kapi_mem_handle;
+
+    unsigned long long phys_addr;
+    void *virt_addr;
+    crypto_buffer_secure buf_sec;           /* NONSECURE or SECURE */
+} crypto_buf_attr;
+
+typedef struct {
+    td_u8 *key;
+    td_u32 key_len;
+    td_handle drv_keyslot_handle;
+    crypto_hash_type hash_type;
+    td_bool is_keyslot;
+    td_bool is_long_term;
+} crypto_hash_attr;
+
+typedef struct {
+    td_u32 length[2];
+    td_u32 state[CRYPTO_HASH_RESULT_SIZE_MAX_IN_WORD];
+    td_u32 tail_len;
+    crypto_hash_type hash_type;
+#if defined(CRYPTO_SOFT_HMAC_SUPPORT)
+    td_u8 o_key_pad[CRYPTO_HASH_BLOCK_SIZE_MAX];
+    td_u8 i_key_pad[CRYPTO_HASH_BLOCK_SIZE_MAX];
+#endif
+    td_u8 tail[CRYPTO_HASH_BLOCK_SIZE_MAX];
+} crypto_hash_clone_ctx;
+
+typedef struct {
+    crypto_hash_type hmac_type;
+    td_u8 *salt;
+    td_u32 salt_length;
+    td_u8 *ikm;
+    td_u32 ikm_length;
+} crypto_hkdf_extract_t;
+
+typedef struct {
+    crypto_hash_type hmac_type;
+    td_u8 *prk;
+    td_u32 prk_length;
+    td_u8 *info;
+    td_u32 info_length;
+} crypto_hkdf_expand_t;
+
+typedef struct {
+    crypto_hash_type hmac_type;
+    td_u8 *salt;
+    td_u32 salt_length;
+    td_u8 *ikm;
+    td_u32 ikm_length;
+    td_u8 *info;
+    td_u32 info_length;
+} crypto_hkdf_t;
+
+typedef struct {
+    crypto_hash_type hash_type;
+    td_u8 *password;
+    td_u32 plen;
+    td_u8 *salt;
+    td_u32 slen;
+    td_u16 count;
+} crypto_kdf_pbkdf2_param;
+
+typedef struct {
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_type symc_type;
+    td_bool is_long_term;
+} crypto_symc_attr;
+
+typedef struct {
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    crypto_symc_key_parity key_parity;
+    crypto_symc_bit_width symc_bit_width;
+    crypto_symc_iv_change_type iv_change_flag;
+    td_u8 iv[CRYPTO_IV_LEN_IN_BYTES];
+    td_u32 iv_length;
+    td_void *param;
+} crypto_symc_ctrl_t;
+
+typedef struct {
+    crypto_buf_attr aad_buf;
+    td_u32 aad_len;         /* Addition Data Length In Bytes. */
+    td_u32 data_len;        /* Crypto Data Length In Bytes. */
+    td_u32 tag_len;         /* Tag Length In Bytes. */
+} crypto_symc_config_aes_ccm_gcm;
+
+typedef struct {
+    td_bool is_long_term;
+    crypto_symc_alg symc_alg;
+    crypto_symc_work_mode work_mode;
+    crypto_symc_key_length symc_key_length;
+    td_u32 keyslot_chn;
+} crypto_symc_mac_attr;
+
+typedef struct {
+    td_u32  length;
+    td_u8  *data;
+} drv_pke_data;
+
+typedef struct {
+    td_u8 *x;   /* X coordinates of the generated public key, the caller ensures it is padded with leading
+                   zeros if the effective size of this key is smaller than ecc key size. */
+    td_u8 *y;   /* Y coordinates of the generated public key, the caller ensures it is padded with leading
+                   zeros if the effective size of this key is smaller than ecc key size. */
+    td_u32 length;
+} drv_pke_ecc_point;
+
+typedef struct {
+    td_u8 *r;   /* r component of the signature. */
+    td_u8 *s;   /* s component of the signature. */
+    td_u32 length;
+} drv_pke_ecc_sig;
+
+typedef struct {
+    td_u8 *n;          /* *< public modulus */
+    td_u8 *e;          /* *< public exponent */
+    td_u8 *d;          /* *< private exponent */
+    td_u8 *p;          /* *< 1st prime factor */
+    td_u8 *q;          /* *< 2nd prime factor */
+    td_u8 *dp;         /* *< D % (P - 1) */
+    td_u8 *dq;         /* *< D % (Q - 1) */
+    td_u8 *qp;         /* *< 1 / (Q % P) */
+    td_u16 n_len;      /* *< length of public modulus */
+    td_u16 e_len;      /* *< length of public exponent */
+    td_u16 d_len;      /* *< length of private exponent */
+    td_u16 p_len;      /* *< length of 1st prime factor,should be half of u16NLen */
+    td_u16 q_len;      /* *< length of 2nd prime factor,should be half of u16NLen */
+    td_u16 dp_len;     /* *< length of D % (P - 1),should be half of u16NLen */
+    td_u16 dq_len;     /* *< length of D % (Q - 1),should be half of u16NLen */
+    td_u16 qp_len;     /* *< length of 1 / (Q % P),should be half of u16NLen */
+} drv_pke_rsa_priv_key;
+
+/* * struct of RSA public key */
+typedef struct {
+    td_u8  *n;            /* point to public modulus */
+    td_u8  *e;            /* point to public exponent */
+    td_u16 len;           /* length of public modulus, max value is 512Byte */
+} drv_pke_rsa_pub_key;
+
+typedef struct {
+    td_u32  length;
+    td_u8  *data;
+    drv_pke_buffer_secure buf_sec;
+} drv_pke_msg;
+
+typedef struct {
+    unsigned int data_len;        /* For CCM/GCM. */
+    unsigned int processed_aad_len;
+    unsigned int total_aad_len;
+    unsigned int tag_len;
+    unsigned char ccm_cmac[16];
+    unsigned char ctr0[16];
+    /* CCM CMAC. */
+    unsigned char cmac_tail_len;
+    td_u8 cmac_tail[16];
+} crypto_symc_ccm_ctx;
+
+#endif /* CRYPTO_CIPHER_COMMON_STRUCT_H */
\ No newline at end of file
diff --git a/harden/cipher_adapt_include/mbedtls_harden_struct.h b/harden/cipher_adapt_include/mbedtls_harden_struct.h
new file mode 100644
index 0000000..6494957
--- /dev/null
+++ b/harden/cipher_adapt_include/mbedtls_harden_struct.h
@@ -0,0 +1,35 @@
+#ifndef MBEDTLS_HARDEN_STRUCT_H
+#define MBEDTLS_HARDEN_STRUCT_H
+
+#define MBEDTLS_ALT_HASH_RESULT_SIZE_MAX_IN_WORD 16      // for SHA-512
+#define MBEDTLS_ALT_HASH_BLOCK_SIZE_MAX 128              // for SHA-512
+
+typedef enum {
+    MBEDTLS_ALT_HASH_TYPE_SHA1 = 0xf690a0,
+    MBEDTLS_ALT_HASH_TYPE_SHA224 = 0x10690e0,
+    MBEDTLS_ALT_HASH_TYPE_SHA256 = 0x1169100,
+    MBEDTLS_ALT_HASH_TYPE_SHA384 = 0x127a180,
+    MBEDTLS_ALT_HASH_TYPE_SHA512 = 0x137a200,
+    MBEDTLS_ALT_HASH_TYPE_SM3 = 0x2169100,
+
+    MBEDTLS_ALT_HASH_TYPE_HMAC_SHA1 = 0x10f690a0,
+    MBEDTLS_ALT_HASH_TYPE_HMAC_SHA224 = 0x110690e0,
+    MBEDTLS_ALT_HASH_TYPE_HMAC_SHA256 = 0x11169100,
+    MBEDTLS_ALT_HASH_TYPE_HMAC_SHA384 = 0x1127a180,
+    MBEDTLS_ALT_HASH_TYPE_HMAC_SHA512 = 0x1137a200,
+    MBEDTLS_ALT_HASH_TYPE_HMAC_SM3 = 0x12169100,
+
+    MBEDTLS_ALT_HASH_TYPE_INVALID = 0xffffffff,
+} mbedtls_alt_hash_type;
+
+typedef struct {
+    unsigned int length[2];
+    unsigned int state[MBEDTLS_ALT_HASH_RESULT_SIZE_MAX_IN_WORD];
+    unsigned int tail_len;
+    mbedtls_alt_hash_type hash_type;
+    unsigned char o_key_pad[MBEDTLS_ALT_HASH_BLOCK_SIZE_MAX];
+    unsigned char i_key_pad[MBEDTLS_ALT_HASH_BLOCK_SIZE_MAX];
+    unsigned char tail[MBEDTLS_ALT_HASH_BLOCK_SIZE_MAX];
+} mbedtls_alt_hash_clone_ctx;
+
+#endif
\ No newline at end of file
diff --git a/harden/platform/connect/mbedtls_crypto_type.h b/harden/platform/connect/mbedtls_crypto_type.h
new file mode 100644
index 0000000..5b8a061
--- /dev/null
+++ b/harden/platform/connect/mbedtls_crypto_type.h
@@ -0,0 +1,90 @@
+/**
+ * Copyright ( c ) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_CRYPTO_TYPE_H
+#define MBEDTLS_CRYPTO_TYPE_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#elif (defined(__LITEOS__) || defined(TD_SUPPORT_STDLIB) || defined(CONFIG_CGRA_CORE))
+#include <stdint.h>
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+#endif
+
+/* defines */
+#define TD_NULL             NULL
+#define TD_NULL_PTR         TD_NULL
+#define TD_FALSE 0
+#define TD_TRUE  1
+#define TD_SUCCESS              0
+#define TD_FAILURE              (-1)
+
+typedef unsigned char           td_uchar;
+typedef unsigned char           td_u8;
+typedef unsigned short          td_u16;
+typedef unsigned int            td_u32;
+typedef unsigned long long      td_u64;
+typedef unsigned long           td_ulong;
+typedef char                    td_char;
+typedef signed char             td_s8;
+typedef short                   td_s16;
+typedef int                     td_s32;
+typedef long long               td_s64;
+typedef long                    td_slong;
+typedef float                   td_float;
+typedef double                  td_double;
+typedef void                    td_void;
+typedef td_u8                   td_bool;
+typedef td_u32                  td_handle;
+typedef td_u8                   td_byte;
+typedef td_byte*                td_pbyte;
+typedef void*                   td_pvoid;
+typedef volatile td_u32         td_u32_reg;
+typedef unsigned long           td_size_t;
+typedef signed   long           td_ssize_t;
+typedef unsigned long           td_length_t;
+typedef unsigned long long      td_mem_size_t;
+typedef long long               td_mem_handle_t;
+typedef unsigned int            td_fr32; // 分数，分子高16bit，分母低16bit
+
+#if ((!defined(_LINUX_TYPES_H)) && (!defined(_STDINT_H)) && (!defined(CONFIG_CGRA_CORE)) && \
+    (!defined(__DEFINED_uintptr_t)))
+typedef unsigned int            uintptr_t;
+#define __DEFINED_uintptr_t
+#endif
+typedef uintptr_t            td_uintptr_t;
+
+#ifdef __LP64__
+typedef unsigned long long      td_phys_addr_t;
+typedef unsigned long long      td_virt_addr_t;
+#else
+typedef unsigned int            td_phys_addr_t;
+typedef unsigned int            td_virt_addr_t;
+#endif
+typedef unsigned int            td_phys_addr_bit32;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* MBEDTLS_CRYPTO_TYPE_H */
+
diff --git a/harden/platform/connect/mbedtls_platform_hardware_config.h b/harden/platform/connect/mbedtls_platform_hardware_config.h
new file mode 100644
index 0000000..32cb4a9
--- /dev/null
+++ b/harden/platform/connect/mbedtls_platform_hardware_config.h
@@ -0,0 +1,97 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_PLATFORM_HARDWARE_CONFIG_H
+#define MBEDTLS_PLATFORM_HARDWARE_CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MBEDTLS_HARDEN_SUCCESS           TD_SUCCESS
+#define MBEDTLS_HARDEN_TRUE              TD_TRUE
+#define MBEDTLS_HARDEN_FALSE             TD_FALSE
+
+#define MAX_AES_HARD_CTX_NUM  4
+
+#define MAX_AES_XTS_TWEAK_SIZE   256
+
+#define MAX_GCM_HARD_CTX_NUM   2
+
+#define MBEDTLS_CIPHER_MAX_ADD_LEN   128
+
+#define MAX_CCM_HARD_CTX_NUM   2
+
+#define MAX_CMAC_HARD_CTX_NUM   4
+
+#define MBEDTLS_AES_192_HARD_KEY_SUPPORT
+
+#define DRV_PKE_LEN_1024_SUPPORT
+
+#define HARDWARE_521_ALIGN_576_LEN
+
+#define MAX_HASH_HARD_CTX_NUM   4
+
+/*******************************************alternative macro*********************************************/
+
+#define MBEDTLS_ENTROPY_HARDWARE_ALT
+
+#define MBEDTLS_AES_ALT
+
+#define MBEDTLS_CMAC_ALT
+
+#define MBEDTLS_ECDH_COMPUTE_SHARED_ALT
+
+#define MBEDTLS_ECDSA_VERIFY_ALT
+
+#define MBEDTLS_ECDSA_SIGN_ALT
+
+#define MBEDTLS_ECC_GEN_KEY_ALT
+
+#define MBEDTLS_SHA1_ALT
+
+#define MBEDTLS_SHA256_ALT
+
+#define MBEDTLS_SHA512_ALT
+
+#define MBEDTLS_HKDF_ALT
+
+#define MBEDTLS_PBKDF2_HMAC_ALT
+
+#define MBEDTLS_ECDSA_GENKEY_ALT
+/*******************************************alternative macro*********************************************/
+
+/*******************************************algorithm cfg macro*******************************************/
+
+#define MBEDTLS_SECP192R1_USE_HARDWARE
+#define MBEDTLS_SECP224R1_USE_HARDWARE
+#define MBEDTLS_SECP256R1_USE_HARDWARE
+#define MBEDTLS_SECP384R1_USE_HARDWARE
+#define MBEDTLS_SECP521R1_USE_HARDWARE
+#define MBEDTLS_BP256R1_USE_HARDWARE
+#define MBEDTLS_BP384R1_USE_HARDWARE
+#define MBEDTLS_BP512R1_USE_HARDWARE
+#define MBEDTLS_CURVE25519_USE_HARDWARE
+#define MBEDTLS_CURVE448_USE_HARDWARE
+
+#define MBEDTLS_SHA1_USE_HARDWARE
+#define MBEDTLS_SHA224_USE_HARDWARE
+#define MBEDTLS_SHA256_USE_HARDWARE
+#define MBEDTLS_SHA384_USE_HARDWARE
+#define MBEDTLS_SHA512_USE_HARDWARE
+
+#define MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE
+#define MBEDTLS_BIGNUM_MOD_USE_HARDWARE
+
+#define MBEDTLS_NO_PLATFORM_ENTROPY
+/*******************************************algorithm cfg macro*******************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MBEDTLS_PLATFORM_USER_CONFIG_H */
\ No newline at end of file
diff --git a/harden/platform/vision/mbedtls_crypto_type.h b/harden/platform/vision/mbedtls_crypto_type.h
new file mode 100644
index 0000000..43601ac
--- /dev/null
+++ b/harden/platform/vision/mbedtls_crypto_type.h
@@ -0,0 +1,75 @@
+/**
+ * Copyright ( c ) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_CRYPTO_TYPE_H
+#define MBEDTLS_CRYPTO_TYPE_H
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#else
+
+#include <stdint.h>
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#ifndef NULL
+    #define NULL                0L
+#endif
+
+#define TD_NULL                 0L
+#define TD_SUCCESS              0
+#define TD_FAILURE              (-1)
+
+typedef unsigned char           td_uchar;
+typedef unsigned char           td_u8;
+typedef unsigned short          td_u16;
+typedef unsigned int            td_u32;
+typedef unsigned long           td_ulong;
+
+typedef char                    td_char;
+typedef signed char             td_s8;
+typedef short                   td_s16;
+typedef int                     td_s32;
+typedef long                    td_slong;
+
+typedef float                   td_float;
+typedef double                  td_double;
+
+typedef void                    td_void;
+
+typedef unsigned long long  td_u64;
+typedef long long           td_s64;
+
+#ifdef CONFIG_PHYS_ADDR_BIT_WIDTH_64
+    typedef unsigned long long  td_phys_addr_t;
+#else
+    typedef unsigned int        td_phys_addr_t;
+#endif
+
+typedef td_u32                  td_handle;
+typedef uintptr_t               td_uintptr_t;
+typedef unsigned int            td_fr32;
+
+typedef enum {
+    TD_FALSE = 0,
+    TD_TRUE  = 1,
+} td_bool;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* MBEDTLS_CRYPTO_TYPE_H */
+
diff --git a/harden/platform/vision/mbedtls_platform_hardware_config.h b/harden/platform/vision/mbedtls_platform_hardware_config.h
new file mode 100644
index 0000000..d6c633e
--- /dev/null
+++ b/harden/platform/vision/mbedtls_platform_hardware_config.h
@@ -0,0 +1,84 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_PLATFORM_HARDWARE_CONFIG_H
+#define MBEDTLS_PLATFORM_HARDWARE_CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MBEDTLS_HARDEN_SUCCESS           TD_SUCCESS
+#define MBEDTLS_HARDEN_TRUE              TD_TRUE
+#define MBEDTLS_HARDEN_FALSE             TD_FALSE
+
+#define MAX_AES_HARD_CTX_NUM  3
+
+#define MAX_AES_XTS_TWEAK_SIZE   256
+
+#define MAX_GCM_HARD_CTX_NUM   2
+
+#define MBEDTLS_CIPHER_MAX_ADD_LEN   128
+
+#define MAX_CCM_HARD_CTX_NUM   2
+
+#define MAX_CMAC_HARD_CTX_NUM   4
+
+#define HARDWARE_521_ALIGN_576_LEN
+
+#define MAX_HASH_HARD_CTX_NUM   3
+
+/*******************************************alternative macro*********************************************/
+
+#define MBEDTLS_ENTROPY_HARDWARE_ALT
+
+// #define MBEDTLS_AES_ALT
+
+#define MBEDTLS_ECDH_COMPUTE_SHARED_ALT
+
+#define MBEDTLS_ECDSA_VERIFY_ALT
+
+#define MBEDTLS_ECDSA_SIGN_ALT
+
+#define MBEDTLS_ECC_GEN_KEY_ALT
+
+#define MBEDTLS_ECDSA_GENKEY_ALT
+
+#define MBEDTLS_SHA256_ALT
+
+#define MBEDTLS_RSA_NO_CRT
+
+// #define MBEDTLS_SHA512_ALT
+
+#define MBEDTLS_PBKDF2_HMAC_ALT
+
+
+/*******************************************alternative macro*********************************************/
+
+/*******************************************algorithm cfg macro*******************************************/
+
+#define MBEDTLS_BP256R1_USE_HARDWARE
+#define MBEDTLS_BP384R1_USE_HARDWARE
+#define MBEDTLS_BP512R1_USE_HARDWARE
+// #define MBEDTLS_CURVE25519_USE_HARDWARE
+
+#define MBEDTLS_SHA224_USE_HARDWARE
+#define MBEDTLS_SHA256_USE_HARDWARE
+// #define MBEDTLS_SHA384_USE_HARDWARE
+// #define MBEDTLS_SHA512_USE_HARDWARE
+
+#define DRV_PKE_LEN_1024_SUPPORT
+#define MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE
+#define MBEDTLS_BIGNUM_MOD_USE_HARDWARE
+#define MBEDTLS_NO_PLATFORM_ENTROPY
+/*******************************************algorithm cfg macro*******************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MBEDTLS_PLATFORM_USER_CONFIG_H */
\ No newline at end of file
diff --git a/harden/platform/wearable/mbedtls_crypto_type.h b/harden/platform/wearable/mbedtls_crypto_type.h
new file mode 100644
index 0000000..5b8a061
--- /dev/null
+++ b/harden/platform/wearable/mbedtls_crypto_type.h
@@ -0,0 +1,90 @@
+/**
+ * Copyright ( c ) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_CRYPTO_TYPE_H
+#define MBEDTLS_CRYPTO_TYPE_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#elif (defined(__LITEOS__) || defined(TD_SUPPORT_STDLIB) || defined(CONFIG_CGRA_CORE))
+#include <stdint.h>
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0L
+#else
+#define NULL ((void*)0)
+#endif
+#endif
+
+/* defines */
+#define TD_NULL             NULL
+#define TD_NULL_PTR         TD_NULL
+#define TD_FALSE 0
+#define TD_TRUE  1
+#define TD_SUCCESS              0
+#define TD_FAILURE              (-1)
+
+typedef unsigned char           td_uchar;
+typedef unsigned char           td_u8;
+typedef unsigned short          td_u16;
+typedef unsigned int            td_u32;
+typedef unsigned long long      td_u64;
+typedef unsigned long           td_ulong;
+typedef char                    td_char;
+typedef signed char             td_s8;
+typedef short                   td_s16;
+typedef int                     td_s32;
+typedef long long               td_s64;
+typedef long                    td_slong;
+typedef float                   td_float;
+typedef double                  td_double;
+typedef void                    td_void;
+typedef td_u8                   td_bool;
+typedef td_u32                  td_handle;
+typedef td_u8                   td_byte;
+typedef td_byte*                td_pbyte;
+typedef void*                   td_pvoid;
+typedef volatile td_u32         td_u32_reg;
+typedef unsigned long           td_size_t;
+typedef signed   long           td_ssize_t;
+typedef unsigned long           td_length_t;
+typedef unsigned long long      td_mem_size_t;
+typedef long long               td_mem_handle_t;
+typedef unsigned int            td_fr32; // 分数，分子高16bit，分母低16bit
+
+#if ((!defined(_LINUX_TYPES_H)) && (!defined(_STDINT_H)) && (!defined(CONFIG_CGRA_CORE)) && \
+    (!defined(__DEFINED_uintptr_t)))
+typedef unsigned int            uintptr_t;
+#define __DEFINED_uintptr_t
+#endif
+typedef uintptr_t            td_uintptr_t;
+
+#ifdef __LP64__
+typedef unsigned long long      td_phys_addr_t;
+typedef unsigned long long      td_virt_addr_t;
+#else
+typedef unsigned int            td_phys_addr_t;
+typedef unsigned int            td_virt_addr_t;
+#endif
+typedef unsigned int            td_phys_addr_bit32;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* MBEDTLS_CRYPTO_TYPE_H */
+
diff --git a/harden/platform/wearable/mbedtls_platform_hardware_config.h b/harden/platform/wearable/mbedtls_platform_hardware_config.h
new file mode 100644
index 0000000..61f324f
--- /dev/null
+++ b/harden/platform/wearable/mbedtls_platform_hardware_config.h
@@ -0,0 +1,26 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_PLATFORM_HARDWARE_CONFIG_H
+#define MBEDTLS_PLATFORM_HARDWARE_CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MBEDTLS_HARDEN_SUCCESS           TD_SUCCESS
+#define MBEDTLS_HARDEN_TRUE              TD_TRUE
+#define MBEDTLS_HARDEN_FALSE             TD_FALSE
+
+#define MBEDTLS_NO_PLATFORM_ENTROPY
+#define MBEDTLS_ENTROPY_HARDWARE_ALT
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MBEDTLS_PLATFORM_HARDWARE_CONFIG_H */
\ No newline at end of file
diff --git a/harden/src/aes_alt.c b/harden/src/aes_alt.c
new file mode 100644
index 0000000..b64de61
--- /dev/null
+++ b/harden/src/aes_alt.c
@@ -0,0 +1,573 @@
+/*
+ *  FIPS-197 compliant AES implementation
+ *
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+/*
+ *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
+ *
+ *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
+ *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
+ */
+
+#include "common.h"
+
+#if defined(MBEDTLS_AES_C)
+
+#include "mbedtls/aes.h"
+#include "mbedtls/platform.h"
+#include "mbedtls/platform_util.h"
+#include "mbedtls/error.h"
+#include "cipher_adapt.h"
+#include "securec.h"
+
+#define BITS_IN_BYTE        8
+#define INVLID_KSLOT_HANDLE 0xffffffff
+
+#if defined(MBEDTLS_AES_ALT)
+
+/* Parameter validation macros based on platform_util.h */
+#define AES_VALIDATE_RET(cond)    \
+    MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_AES_BAD_INPUT_DATA)
+#define AES_VALIDATE(cond)        \
+    MBEDTLS_INTERNAL_VALIDATE(cond)
+
+void mbedtls_aes_init(mbedtls_aes_context *ctx)
+{
+    AES_VALIDATE(ctx != NULL);
+
+    (void)memset_s(ctx, sizeof(mbedtls_aes_context), 0, sizeof(mbedtls_aes_context));
+    if (mbedtls_alt_aes_create_key(&ctx->kslot_handle) != 0) {
+        ctx->kslot_handle = INVLID_KSLOT_HANDLE;
+    }
+}
+
+void mbedtls_aes_free(mbedtls_aes_context *ctx)
+{
+    if(ctx == NULL)
+        return;
+
+    if (ctx->kslot_handle != INVLID_KSLOT_HANDLE) {
+        mbedtls_alt_aes_destroy_key(ctx->kslot_handle);
+    }
+    (void)memset_s(ctx, sizeof(mbedtls_aes_context), 0, sizeof(mbedtls_aes_context));
+    ctx->kslot_handle = INVLID_KSLOT_HANDLE;
+}
+
+#if defined(MBEDTLS_CIPHER_MODE_XTS)
+void mbedtls_aes_xts_init(mbedtls_aes_xts_context *ctx)
+{
+    AES_VALIDATE(ctx != NULL);
+
+    mbedtls_aes_init(&ctx->crypt);
+    mbedtls_aes_init(&ctx->tweak);
+}
+
+void mbedtls_aes_xts_free(mbedtls_aes_xts_context *ctx)
+{
+    if(ctx == NULL)
+        return;
+
+    mbedtls_aes_free(&ctx->crypt);
+    mbedtls_aes_free(&ctx->tweak);
+}
+#endif /* MBEDTLS_CIPHER_MODE_XTS */
+
+/*
+ * AES key schedule (encryption)
+ */
+int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *key,
+                    unsigned int keybits)
+{
+    int ret;
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(key != NULL);
+#ifdef MBEDTLS_AES192_KEYLEN_UNSUPPORT
+    if (keybits == 192) {
+        return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    }
+#endif
+    ret = mbedtls_alt_aes_set_key(ctx->kslot_handle, key, keybits / BITS_IN_BYTE);
+    ctx->key_len = keybits / BITS_IN_BYTE;
+    if (ret != 0) {
+        return -1;
+    }
+    ret = memcpy_s(ctx->key, sizeof(ctx->key), key, ctx->key_len);
+    if (ret != EOK) {
+        return -1;
+    }
+    return 0;
+}
+
+/*
+ * AES key schedule (decryption)
+ */
+int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *key,
+                    unsigned int keybits)
+{
+    int ret;
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(key != NULL);
+#ifdef MBEDTLS_AES192_KEYLEN_UNSUPPORT
+    if (keybits == 192) {
+        return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    }
+#endif
+    ret = mbedtls_alt_aes_set_key(ctx->kslot_handle, key, keybits / BITS_IN_BYTE);
+    ctx->key_len = keybits / BITS_IN_BYTE;
+    if (ret != 0) {
+        return -1;
+    }
+    ret = memcpy_s(ctx->key, sizeof(ctx->key), key, ctx->key_len);
+    if (ret != EOK) {
+        return -1;
+    }
+    return 0;
+}
+
+#if defined(MBEDTLS_CIPHER_MODE_XTS)
+static int mbedtls_aes_xts_decode_keys(const unsigned char *key,
+                                        unsigned int keybits,
+                                        const unsigned char **key1,
+                                        unsigned int *key1bits,
+                                        const unsigned char **key2,
+                                        unsigned int *key2bits)
+{
+    const unsigned int half_keybits = keybits / 2;
+    const unsigned int half_keybytes = half_keybits / 8;
+
+    switch(keybits)
+    {
+        case 256: break;
+        case 512: break;
+        default : return(MBEDTLS_ERR_AES_INVALID_KEY_LENGTH);
+    }
+
+    *key1bits = half_keybits;
+    *key2bits = half_keybits;
+    *key1 = &key[0];
+    *key2 = &key[half_keybytes];
+
+    return 0;
+}
+
+int mbedtls_aes_xts_setkey_enc(mbedtls_aes_xts_context *ctx,
+                                const unsigned char *key,
+                                unsigned int keybits)
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    const unsigned char *key1, *key2;
+    unsigned int key1bits, key2bits;
+
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(key != NULL);
+
+    ret = mbedtls_aes_xts_decode_keys(key, keybits, &key1, &key1bits,
+                                       &key2, &key2bits);
+    if(ret != 0)
+        return(ret);
+
+    /* Set the tweak key. Always set tweak key for the encryption mode. */
+    ret = mbedtls_aes_setkey_enc(&ctx->tweak, key2, key2bits);
+    if(ret != 0)
+        return(ret);
+
+    /* Set crypt key for encryption. */
+    return mbedtls_aes_setkey_enc(&ctx->crypt, key1, key1bits);
+}
+
+int mbedtls_aes_xts_setkey_dec(mbedtls_aes_xts_context *ctx,
+                                const unsigned char *key,
+                                unsigned int keybits)
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    const unsigned char *key1, *key2;
+    unsigned int key1bits, key2bits;
+
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(key != NULL);
+
+    ret = mbedtls_aes_xts_decode_keys(key, keybits, &key1, &key1bits,
+                                       &key2, &key2bits);
+    if(ret != 0)
+        return(ret);
+
+    /* Set the tweak key. Always set tweak key for encryption. */
+    ret = mbedtls_aes_setkey_enc(&ctx->tweak, key2, key2bits);
+    if(ret != 0)
+        return(ret);
+
+    /* Set crypt key for decryption. */
+    return mbedtls_aes_setkey_dec(&ctx->crypt, key1, key1bits);
+}
+#endif /* MBEDTLS_CIPHER_MODE_XTS */
+
+/*
+ * AES-ECB block encryption
+ */
+int mbedtls_internal_aes_encrypt(mbedtls_aes_context *ctx,
+                                  const unsigned char input[16],
+                                  unsigned char output[16])
+{
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+
+    return mbedtls_alt_aes_encrypt(ctx->kslot_handle, ctx->key, ctx->key_len, input, output);
+}
+
+/*
+ * AES-ECB block decryption
+ */
+int mbedtls_internal_aes_decrypt(mbedtls_aes_context *ctx,
+                                  const unsigned char input[16],
+                                  unsigned char output[16])
+{
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+    
+    return mbedtls_alt_aes_decrypt(ctx->kslot_handle, ctx->key, ctx->key_len, input, output);
+}
+
+/*
+ * AES-ECB block encryption/decryption
+ */
+int mbedtls_aes_crypt_ecb(mbedtls_aes_context *ctx,
+                           int mode,
+                           const unsigned char input[16],
+                           unsigned char output[16])
+{
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+    AES_VALIDATE_RET(mode == MBEDTLS_AES_ENCRYPT || mode == MBEDTLS_AES_DECRYPT);
+    
+    if (mode == MBEDTLS_AES_ENCRYPT) {
+        return mbedtls_internal_aes_encrypt(ctx, input, output);
+    } else {
+        return mbedtls_internal_aes_decrypt(ctx, input, output);
+    }
+}
+
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+/*
+ * AES-CBC buffer encryption/decryption
+ */
+int mbedtls_aes_crypt_cbc(mbedtls_aes_context *ctx,
+                    int mode,
+                    size_t length,
+                    unsigned char iv[16],
+                    const unsigned char *input,
+                    unsigned char *output)
+{
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(mode == MBEDTLS_AES_ENCRYPT || mode == MBEDTLS_AES_DECRYPT);
+    AES_VALIDATE_RET(iv != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+
+    if (mode == MBEDTLS_AES_ENCRYPT) {
+        return mbedtls_alt_aes_cbc_encrypt(ctx->kslot_handle, ctx->key, ctx->key_len, iv, input, output, length);
+    } else {
+        return mbedtls_alt_aes_cbc_decrypt(ctx->kslot_handle, ctx->key, ctx->key_len, iv, input, output, length);
+    }
+}
+#endif /* MBEDTLS_CIPHER_MODE_CBC */
+
+#if defined(MBEDTLS_CIPHER_MODE_XTS)
+
+typedef unsigned char mbedtls_be128[16];
+
+/*
+ * GF(2^128) multiplication function
+ *
+ * This function multiplies a field element by x in the polynomial field
+ * representation. It uses 64-bit word operations to gain speed but compensates
+ * for machine endianess and hence works correctly on both big and little
+ * endian machines.
+ */
+static void mbedtls_gf128mul_x_ble(unsigned char r[16],
+                                    const unsigned char x[16])
+{
+    uint64_t a, b, ra, rb;
+
+    a = MBEDTLS_GET_UINT64_LE(x, 0);
+    b = MBEDTLS_GET_UINT64_LE(x, 8);
+
+    ra = (a << 1)  ^ 0x0087 >> (8 - ((b >> 63) << 3));
+    rb = (a >> 63) | (b << 1);
+
+    MBEDTLS_PUT_UINT64_LE(ra, r, 0);
+    MBEDTLS_PUT_UINT64_LE(rb, r, 8);
+}
+
+/*
+ * AES-XTS buffer encryption/decryption
+ */
+int mbedtls_aes_crypt_xts(mbedtls_aes_xts_context *ctx,
+                           int mode,
+                           size_t length,
+                           const unsigned char data_unit[16],
+                           const unsigned char *input,
+                           unsigned char *output)
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t blocks = length / 16;
+    size_t leftover = length % 16;
+    unsigned char tweak[16];
+    unsigned char prev_tweak[16];
+    unsigned char tmp[16];
+
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(mode == MBEDTLS_AES_ENCRYPT ||
+                      mode == MBEDTLS_AES_DECRYPT);
+    AES_VALIDATE_RET(data_unit != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+
+    /* Data units must be at least 16 bytes long. */
+    if(length < 16)
+        return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
+
+    /* NIST SP 800-38E disallows data units larger than 2**20 blocks. */
+    if(length > (1 << 20) * 16)
+        return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
+
+    /* Compute the tweak. */
+    ret = mbedtls_aes_crypt_ecb(&ctx->tweak, MBEDTLS_AES_ENCRYPT,
+                                 data_unit, tweak);
+    if(ret != 0)
+        return(ret);
+
+    while(blocks--)
+    {
+        size_t i;
+
+        if(leftover && (mode == MBEDTLS_AES_DECRYPT) && blocks == 0)
+        {
+            /* We are on the last block in a decrypt operation that has
+             * leftover bytes, so we need to use the next tweak for this block,
+             * and this tweak for the lefover bytes. Save the current tweak for
+             * the leftovers and then update the current tweak for use on this,
+             * the last full block. */
+            memcpy(prev_tweak, tweak, sizeof(tweak));
+            mbedtls_gf128mul_x_ble(tweak, tweak);
+        }
+
+        for(i = 0; i < 16; i++)
+            tmp[i] = input[i] ^ tweak[i];
+
+        ret = mbedtls_aes_crypt_ecb(&ctx->crypt, mode, tmp, tmp);
+        if(ret != 0)
+            return(ret);
+
+        for(i = 0; i < 16; i++)
+            output[i] = tmp[i] ^ tweak[i];
+
+        /* Update the tweak for the next block. */
+        mbedtls_gf128mul_x_ble(tweak, tweak);
+
+        output += 16;
+        input += 16;
+    }
+
+    if(leftover)
+    {
+        /* If we are on the leftover bytes in a decrypt operation, we need to
+         * use the previous tweak for these bytes (as saved in prev_tweak). */
+        unsigned char *t = mode == MBEDTLS_AES_DECRYPT ? prev_tweak : tweak;
+
+        /* We are now on the final part of the data unit, which doesn't divide
+         * evenly by 16. It's time for ciphertext stealing. */
+        size_t i;
+        unsigned char *prev_output = output - 16;
+
+        /* Copy ciphertext bytes from the previous block to our output for each
+         * byte of cyphertext we won't steal. At the same time, copy the
+         * remainder of the input for this final round (since the loop bounds
+         * are the same). */
+        for(i = 0; i < leftover; i++)
+        {
+            output[i] = prev_output[i];
+            tmp[i] = input[i] ^ t[i];
+        }
+
+        /* Copy ciphertext bytes from the previous block for input in this
+         * round. */
+        for(; i < 16; i++)
+            tmp[i] = prev_output[i] ^ t[i];
+
+        ret = mbedtls_aes_crypt_ecb(&ctx->crypt, mode, tmp, tmp);
+        if(ret != 0)
+            return ret;
+
+        /* Write the result back to the previous block, overriding the previous
+         * output we copied. */
+        for(i = 0; i < 16; i++)
+            prev_output[i] = tmp[i] ^ t[i];
+    }
+
+    return(0);
+}
+#endif /* MBEDTLS_CIPHER_MODE_XTS */
+
+#if defined(MBEDTLS_CIPHER_MODE_CFB)
+/*
+ * AES-CFB128 buffer encryption/decryption
+ */
+int mbedtls_aes_crypt_cfb128(mbedtls_aes_context *ctx,
+                       int mode,
+                       size_t length,
+                       size_t *iv_off,
+                       unsigned char iv[16],
+                       const unsigned char *input,
+                       unsigned char *output)
+{
+    int c;
+    unsigned int i = 0, buf_off = 0;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t n;
+
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(mode == MBEDTLS_AES_ENCRYPT ||
+                      mode == MBEDTLS_AES_DECRYPT);
+    AES_VALIDATE_RET(iv_off != NULL);
+    AES_VALIDATE_RET(iv != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+
+    n = *iv_off;
+
+    if(n > 15)
+        return(MBEDTLS_ERR_AES_BAD_INPUT_DATA);
+
+    if(mode == MBEDTLS_AES_DECRYPT)
+    {
+        buf_off = (16 - n) % 16;
+
+        for (; i < buf_off; i++) {
+            c = *input++;
+            *output++ = (unsigned char)(c ^ iv[n + i]);
+            iv[n + i] = (unsigned char) c;
+        }
+
+        ret = mbedtls_alt_aes_cfb128_decrypt(ctx->kslot_handle, ctx->key, ctx->key_len, iv,
+            input, output, length - buf_off);
+        if (ret != 0) {
+            goto exit;
+        }
+        n = (n + length) % 16;
+    }
+    else
+    {
+        buf_off = (16 - n) % 16;
+
+        for (; i < buf_off; i++) {
+            c = *input++;
+            iv[n + i] = *output++ = (unsigned char)(c ^ iv[n + i]);
+        }
+
+        ret = mbedtls_alt_aes_cfb128_encrypt(ctx->kslot_handle, ctx->key, ctx->key_len, iv,
+            input, output, length - buf_off);
+        if (ret != 0) {
+            goto exit;
+        }
+        n = (n + length) % 16;
+    }
+
+    *iv_off = n;
+    ret = 0;
+
+exit:
+    return(ret);
+}
+
+/*
+ * AES-CFB8 buffer encryption/decryption
+ */
+int mbedtls_aes_crypt_cfb8(mbedtls_aes_context *ctx,
+                            int mode,
+                            size_t length,
+                            unsigned char iv[16],
+                            const unsigned char *input,
+                            unsigned char *output)
+{
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(mode == MBEDTLS_AES_ENCRYPT || mode == MBEDTLS_AES_DECRYPT);
+    AES_VALIDATE_RET(iv != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+
+    if (mode == MBEDTLS_AES_ENCRYPT) {
+        return mbedtls_alt_aes_cfb8_encrypt(ctx->kslot_handle, ctx->key, ctx->key_len, iv, input, output, length);
+    } else {
+        return mbedtls_alt_aes_cfb8_decrypt(ctx->kslot_handle, ctx->key, ctx->key_len, iv, input, output, length);
+    }
+}
+#endif /* MBEDTLS_CIPHER_MODE_CFB */
+
+#if defined(MBEDTLS_CIPHER_MODE_OFB)
+/*
+ * AES-OFB (Output Feedback Mode) buffer encryption/decryption
+ */
+int mbedtls_aes_crypt_ofb(mbedtls_aes_context *ctx,
+                           size_t length,
+                           size_t *iv_off,
+                           unsigned char iv[16],
+                           const unsigned char *input,
+                           unsigned char *output)
+{
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(iv_off != NULL);
+    AES_VALIDATE_RET(iv != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+
+    if (*iv_off > 15) {
+        return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
+    }
+    return mbedtls_alt_aes_ofb_crypt(ctx->kslot_handle, ctx->key, ctx->key_len,
+        (uint8_t *)iv_off, iv, input, output, length);
+}
+#endif /* MBEDTLS_CIPHER_MODE_OFB */
+
+#if defined(MBEDTLS_CIPHER_MODE_CTR)
+/*
+ * AES-CTR buffer encryption/decryption
+ */
+int mbedtls_aes_crypt_ctr(mbedtls_aes_context *ctx,
+                       size_t length,
+                       size_t *nc_off,
+                       unsigned char nonce_counter[16],
+                       unsigned char stream_block[16],
+                       const unsigned char *input,
+                       unsigned char *output)
+{
+    AES_VALIDATE_RET(ctx != NULL);
+    AES_VALIDATE_RET(nc_off != NULL);
+    AES_VALIDATE_RET(nonce_counter != NULL);
+    AES_VALIDATE_RET(stream_block != NULL);
+    AES_VALIDATE_RET(input != NULL);
+    AES_VALIDATE_RET(output != NULL);
+
+    return mbedtls_alt_aes_ctr_crypt(ctx->kslot_handle, ctx->key, ctx->key_len,
+        (uint8_t *)nc_off, nonce_counter, stream_block, input, output, length);
+}
+#endif /* MBEDTLS_CIPHER_MODE_CTR */
+
+#endif /* !MBEDTLS_AES_ALT */
+#endif /* MBEDTLS_AES_C */
diff --git a/harden/src/bignum_harden.c b/harden/src/bignum_harden.c
new file mode 100644
index 0000000..96a1c3c
--- /dev/null
+++ b/harden/src/bignum_harden.c
@@ -0,0 +1,205 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "bignum_harden.h"
+#include "cipher_adapt.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform_util.h"
+#include "mbedtls/platform.h"
+#include "dfx.h"
+
+#define max(a, b)                   (a) > (b) ? (a) : (b)
+#define min(a, b)                   (a) < (b) ? (a) : (b)
+#define max_three(a, b, c)          max( max( a, b ), c )
+#define min_three(a, b, c)          min( min( a, b ), c )
+
+#if defined(MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE) || defined(MBEDTLS_BIGNUM_MOD_USE_HARDWARE)
+static void get_size_align( size_t size_a, size_t size_b, size_t size_c, size_t *size_align )
+{
+    size_t sizes[] = {
+#if defined(DRV_PKE_LEN_1024_SUPPORT)
+        DRV_PKE_LEN_1024,
+#endif
+        DRV_PKE_LEN_2048, DRV_PKE_LEN_3072, DRV_PKE_LEN_4096 };
+    int sizes_count = sizeof( sizes ) / sizeof( sizes[0] );
+    *size_align = max_three( size_a, size_b, size_c );
+
+    for( int i = 0; i < sizes_count - 1; i++ )
+    {
+        if ( *size_align <= sizes[i] )
+        {
+            *size_align = sizes[i];
+            return;
+        }
+    }
+    *size_align = sizes[sizes_count - 1];
+}
+#endif /* MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE || MBEDTLS_BIGNUM_MOD_USE_HARDWARE */
+
+#if defined(MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE)
+int check_exp_mod_harden_can_do( const mbedtls_mpi *A,
+        const mbedtls_mpi *E, const mbedtls_mpi *N )
+{
+    size_t size_a, size_e, size_n, size_max;
+    size_a = mbedtls_mpi_size( A );
+    size_e = mbedtls_mpi_size( E );
+    size_n = mbedtls_mpi_size( N );
+    size_max = max_three( size_a, size_e, size_n );
+
+    if( IS_PKE_EXP_MOD_FUNC_REGISTERED() != TD_TRUE )
+        return ( 0 );
+    if (size_max > DRV_PKE_LEN_4096 || size_max < DRV_PKE_LEN_2048)
+        return( 0 );
+
+#if defined(DRV_PKE_LEN_1024_SUPPORT)
+    get_size_align( size_a, size_e, size_n, &size_max );
+    return( ( size_max - size_n ) <= 2 );
+#else
+    return( 1 );
+#endif
+}
+
+int exp_mod_harden( mbedtls_mpi *X, const mbedtls_mpi *A,
+                    const mbedtls_mpi *E, const mbedtls_mpi *N )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    drv_pke_data hw_data[3];
+    size_t size_align = 0;
+    const mbedtls_mpi *inputs[] = { A, E, N };
+    unsigned char *buffer = NULL;
+
+    mbedtls_harden_log_func_enter();
+
+    get_size_align( mbedtls_mpi_size( A ), mbedtls_mpi_size( E ), mbedtls_mpi_size( N ), &size_align );
+
+    buffer = mbedtls_calloc( 3, size_align );
+    if ( buffer == NULL )
+    {
+        mbedtls_harden_log_err("mbedtls_calloc failed!\n");
+        return MBEDTLS_ERR_MPI_ALLOC_FAILED;
+    }
+
+    for (int i = 0; i < 3; i++)
+    {
+        hw_data[i].data = buffer + (i * size_align);
+        hw_data[i].length = size_align;
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( inputs[i], hw_data[i].data, hw_data[i].length ) );
+    }
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    ret = CIPHER_PKE_EXP_MOD( &hw_data[2], &hw_data[1], &hw_data[0], &hw_data[0] );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( X, hw_data[0].data, hw_data[0].length ) );
+    ret = 0;
+
+cleanup:
+    CIPHER_PKE_DEINIT();
+    if( buffer != NULL )
+    {
+        mbedtls_platform_zeroize( buffer, 3 * size_align );
+        mbedtls_free( buffer );
+    }
+
+    mbedtls_harden_log_func_exit();
+
+    return( ret );
+}
+#endif /* MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE */
+
+#if defined(MBEDTLS_BIGNUM_MOD_USE_HARDWARE)
+int check_mod_harden_can_do( const mbedtls_mpi *A, const mbedtls_mpi *B )
+{
+    size_t size_a, size_b, size_max;
+    size_a = mbedtls_mpi_size( A );
+    size_b = mbedtls_mpi_size( B );
+    size_max = max( size_a, size_b );
+
+    if( IS_PKE_MOD_FUNC_REGISTERED() != TD_TRUE )
+        return ( 0 );
+    if ( A->MBEDTLS_PRIVATE(s) < 0 || mbedtls_mpi_cmp_int( B, 0 ) == 0 )
+        return ( 0 );
+    if (size_max > DRV_PKE_LEN_4096 || size_max < DRV_PKE_LEN_2048)
+        return( 0 );
+
+#if defined(DRV_PKE_LEN_1024_SUPPORT)
+    if ( size_a > 2 * size_b || mbedtls_mpi_get_bit( B, 0 ) == 0 )
+        return( 0 );
+    return( 1 );
+#else
+    return( 1 );
+#endif
+}
+
+int mod_harden( mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B )
+{
+    int ret;
+    size_t size_align = 0;
+    drv_pke_data hw_data[3];
+    unsigned char *buffer = NULL;
+
+    mbedtls_harden_log_func_enter();
+
+    get_size_align( mbedtls_mpi_size( A ), mbedtls_mpi_size( B ), 0, &size_align );
+
+    buffer = mbedtls_calloc( 3, size_align );
+    if ( buffer == NULL )
+    {
+        mbedtls_harden_log_err("mbedtls_calloc failed!\n");
+        return MBEDTLS_ERR_MPI_ALLOC_FAILED;
+    }
+
+    for (int i = 0; i < 3; i++)
+    {
+        hw_data[i].data = buffer + (i * size_align);
+        hw_data[i].length = size_align;
+    }
+    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( A, hw_data[0].data, hw_data[0].length ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( B, hw_data[1].data, hw_data[1].length ) );
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    ret = CIPHER_PKE_MOD( &hw_data[0], &hw_data[1], &hw_data[2] );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_MOD failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( R, hw_data[2].data, hw_data[2].length ) );
+
+cleanup:
+    CIPHER_PKE_DEINIT();
+    if( buffer != NULL )
+    {
+        mbedtls_platform_zeroize( buffer, 3 * size_align );
+        mbedtls_free( buffer );
+    }
+
+    mbedtls_harden_log_func_exit();
+
+    return( ret );
+}
+#endif /* MBEDTLS_BIGNUM_MOD_USE_HARDWARE */
\ No newline at end of file
diff --git a/harden/src/ccm_alt.c b/harden/src/ccm_alt.c
new file mode 100644
index 0000000..151147b
--- /dev/null
+++ b/harden/src/ccm_alt.c
@@ -0,0 +1,181 @@
+#include "mbedtls/ccm.h"
+#include "mbedtls/error.h"
+#include "securec.h"
+#include "cipher_adapt.h"
+
+#if defined(MBEDTLS_CCM_ALT)
+#define unused(x) (void)(x)
+#define BITS_IN_BYTE        8
+#define INVLID_KSLOT_HANDLE 0xffffffff
+
+void mbedtls_ccm_init( mbedtls_ccm_context *ctx )
+{
+    if ( ctx == NULL) {
+        return;
+    }
+
+    (void)memset_s(ctx, sizeof(mbedtls_ccm_context), 0, sizeof(mbedtls_ccm_context));
+    if (mbedtls_alt_aes_create_key(&ctx->kslot_handle) != 0) {
+        ctx->kslot_handle = INVLID_KSLOT_HANDLE;
+    }
+}
+
+int mbedtls_ccm_setkey( mbedtls_ccm_context *ctx,
+                        mbedtls_cipher_id_t cipher,
+                        const unsigned char *key,
+                        unsigned int keybits )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    unused(cipher);
+    if (ctx == NULL) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+    if (key == NULL) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+#ifdef MBEDTLS_AES192_KEYLEN_UNSUPPORT
+    if (keybits == 192) {
+        return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
+    }
+#endif
+    ret = mbedtls_alt_aes_set_key(ctx->kslot_handle, key, keybits / BITS_IN_BYTE);
+    ctx->key_len = keybits / BITS_IN_BYTE;
+    if (ret != 0) {
+        return -1;
+    }
+    ret = memcpy_s(ctx->key, sizeof(ctx->key), key, ctx->key_len);
+    if (ret != EOK) {
+        return -1;
+    }
+
+    return( 0 );
+}
+
+void mbedtls_ccm_free( mbedtls_ccm_context *ctx )
+{
+    if (ctx == NULL) {
+        return;
+    }
+
+    if (ctx->kslot_handle != INVLID_KSLOT_HANDLE) {
+        mbedtls_alt_aes_destroy_key(ctx->kslot_handle);
+    }
+    (void)memset_s(ctx, sizeof(mbedtls_ccm_context), 0, sizeof(mbedtls_ccm_context));
+    ctx->kslot_handle = INVLID_KSLOT_HANDLE;
+}
+
+int mbedtls_ccm_starts( mbedtls_ccm_context *ctx,
+                        int mode,
+                        const unsigned char *iv,
+                        size_t iv_len )
+{
+    int ret = 0;
+    if( iv_len < 7 || iv_len > 13 ) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+    if ( ctx == NULL || iv == NULL ) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+    if (mode > 1 || mode < 0) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+
+    ret = memcpy_s(ctx->iv, sizeof(ctx->iv), iv, iv_len);
+    if (ret != EOK) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+
+    ctx->is_decrypt = mode ^ 0x1;
+    ctx->processed_aad_len = 0;
+    ctx->iv_length = iv_len;
+
+    ret = mbedtls_alt_aes_ccm_start(&ctx->phys_addr, &ctx->virt_addr);
+    if (ret != EOK) {
+        return( MBEDTLS_ERR_CCM_AUTH_FAILED );
+    }
+
+    (void )memset_s(&ctx->store_ctx, sizeof(crypto_symc_ccm_ctx), 0, sizeof(crypto_symc_ccm_ctx));
+    return 0;
+}
+
+int mbedtls_ccm_set_lengths( mbedtls_ccm_context *ctx,
+                             size_t total_ad_len,
+                             size_t plaintext_len,
+                             size_t tag_len )
+{
+    if ( ctx == NULL) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+
+    ctx->total_aad_len = total_ad_len;
+    ctx->data_len = plaintext_len;
+    ctx->tag_len = tag_len;
+
+    return 0;
+}
+
+int mbedtls_ccm_update_ad( mbedtls_ccm_context *ctx,
+                           const unsigned char *add,
+                           size_t add_len )
+{
+    int ret = 0;
+    if ( ctx == NULL || add == NULL ) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+
+    ret = mbedtls_alt_aes_ccm_update_ad(ctx, add, add_len);
+    if (ret != 0) {
+        return( MBEDTLS_ERR_CCM_AUTH_FAILED );
+    }
+
+    ctx->processed_aad_len += add_len;
+
+    return 0;
+}
+
+int mbedtls_ccm_update( mbedtls_ccm_context *ctx, const unsigned char *input, size_t input_len,
+                        unsigned char *output, size_t output_size, size_t *output_len )
+{
+    int ret = 0;
+
+    if ( ctx == NULL || input == NULL || output == NULL || output_len == NULL) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+
+    if(ctx->tag_len != 0 && ctx->processed_data_len + input_len > ctx->data_len)
+    {
+        return MBEDTLS_ERR_CCM_BAD_INPUT;
+    }
+
+    if( output_size < input_len )
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    *output_len = input_len;
+
+    ret = mbedtls_alt_aes_ccm_update(ctx, input, input_len, output, *output_len);
+    if (ret != 0) {
+        return MBEDTLS_ERR_CCM_AUTH_FAILED;
+    }
+
+    ctx->processed_data_len += input_len;
+    return 0;
+}
+
+int mbedtls_ccm_finish( mbedtls_ccm_context *ctx,
+                        unsigned char *tag, size_t tag_len )
+{
+    int ret = 0;
+    if ( ctx == NULL || tag == NULL || ctx->iv == NULL) {
+        return( MBEDTLS_ERR_CCM_BAD_INPUT );
+    }
+
+    ctx->processed_data_len = 0;
+
+    ret = mbedtls_alt_aes_ccm_finish(ctx, tag, tag_len);
+    if (ret != 0) {
+        return MBEDTLS_ERR_CCM_AUTH_FAILED;
+    }
+
+    return 0;
+}
+#endif
\ No newline at end of file
diff --git a/harden/src/cipher_adapt.c b/harden/src/cipher_adapt.c
new file mode 100644
index 0000000..c419612
--- /dev/null
+++ b/harden/src/cipher_adapt.c
@@ -0,0 +1,1090 @@
+#include "cipher_adapt.h"
+#include "dfx.h"
+
+mbedtls_harden_cipher_func g_harden_cipher_func = { 0 };
+
+mbedtls_harden_km_func g_harden_km_func = { 0 };
+
+mbedtls_harden_mem_func g_harden_mem_func = { 0 };
+
+td_void mbedtls_cipher_adapt_register_func( mbedtls_harden_cipher_func *harden_cipher_func )
+{
+    g_harden_cipher_func.alt_hash_start = harden_cipher_func->alt_hash_start;
+    g_harden_cipher_func.alt_hash_update = harden_cipher_func->alt_hash_update;
+    g_harden_cipher_func.alt_hash_finish = harden_cipher_func->alt_hash_finish;
+    g_harden_cipher_func.aes_create_key = harden_cipher_func->aes_create_key;
+    g_harden_cipher_func.aes_set_key = harden_cipher_func->aes_set_key;
+    g_harden_cipher_func.aes_destroy_key = harden_cipher_func->aes_destroy_key;
+    g_harden_cipher_func.encrypt = harden_cipher_func->encrypt;
+    g_harden_cipher_func.decrypt = harden_cipher_func->decrypt;
+    g_harden_cipher_func.cbc_encrypt = harden_cipher_func->cbc_encrypt;
+    g_harden_cipher_func.cbc_decrypt = harden_cipher_func->cbc_decrypt;
+    g_harden_cipher_func.cfb128_encrypt = harden_cipher_func->cfb128_encrypt;
+    g_harden_cipher_func.cfb128_decrypt = harden_cipher_func->cfb128_decrypt;
+    g_harden_cipher_func.cfb8_encrypt = harden_cipher_func->cfb8_encrypt;
+    g_harden_cipher_func.cfb8_decrypt = harden_cipher_func->cfb8_decrypt;
+    g_harden_cipher_func.ofb_crypt = harden_cipher_func->ofb_crypt;
+    g_harden_cipher_func.ctr_crypt = harden_cipher_func->ctr_crypt;
+    g_harden_cipher_func.ccm_start = harden_cipher_func->ccm_start;
+    g_harden_cipher_func.ccm_ad_update = harden_cipher_func->ccm_ad_update;
+    g_harden_cipher_func.ccm_update = harden_cipher_func->ccm_update;
+    g_harden_cipher_func.ccm_finish = harden_cipher_func->ccm_finish;
+    g_harden_cipher_func.harden_hash_init = harden_cipher_func->harden_hash_init;
+    g_harden_cipher_func.harden_hash_deinit = harden_cipher_func->harden_hash_deinit;
+    g_harden_cipher_func.harden_hash_start = harden_cipher_func->harden_hash_start;
+    g_harden_cipher_func.harden_hash_update = harden_cipher_func->harden_hash_update;
+    g_harden_cipher_func.harden_hash_get = harden_cipher_func->harden_hash_get;
+    g_harden_cipher_func.harden_hash_set = harden_cipher_func->harden_hash_set;
+    g_harden_cipher_func.harden_hash_destroy = harden_cipher_func->harden_hash_destroy;
+    g_harden_cipher_func.harden_hash_finish = harden_cipher_func->harden_hash_finish;
+    g_harden_cipher_func.harden_hkdf = harden_cipher_func->harden_hkdf;
+    g_harden_cipher_func.harden_hkdf_extract = harden_cipher_func->harden_hkdf_extract;
+    g_harden_cipher_func.harden_hkdf_expand = harden_cipher_func->harden_hkdf_expand;
+    g_harden_cipher_func.harden_trng_get_random = harden_cipher_func->harden_trng_get_random;
+    g_harden_cipher_func.harden_trng_get_multi_random = harden_cipher_func->harden_trng_get_multi_random;
+    g_harden_cipher_func.harden_pbkdf2 = harden_cipher_func->harden_pbkdf2;
+    g_harden_cipher_func.harden_symc_init = harden_cipher_func->harden_symc_init;
+    g_harden_cipher_func.harden_symc_deinit = harden_cipher_func->harden_symc_deinit;
+    g_harden_cipher_func.harden_symc_create = harden_cipher_func->harden_symc_create;
+    g_harden_cipher_func.harden_symc_destroy = harden_cipher_func->harden_symc_destroy;
+    g_harden_cipher_func.harden_symc_set_config = harden_cipher_func->harden_symc_set_config;
+    g_harden_cipher_func.harden_symc_get_config = harden_cipher_func->harden_symc_get_config;
+    g_harden_cipher_func.harden_symc_attach = harden_cipher_func->harden_symc_attach;
+    g_harden_cipher_func.harden_symc_encrypt = harden_cipher_func->harden_symc_encrypt;
+    g_harden_cipher_func.harden_symc_decrypt = harden_cipher_func->harden_symc_decrypt;
+    g_harden_cipher_func.harden_symc_get_tag= harden_cipher_func->harden_symc_get_tag;
+    g_harden_cipher_func.harden_symc_mac_start = harden_cipher_func->harden_symc_mac_start;
+    g_harden_cipher_func.harden_symc_mac_update = harden_cipher_func->harden_symc_mac_update;
+    g_harden_cipher_func.harden_symc_mac_finish = harden_cipher_func->harden_symc_mac_finish;
+    g_harden_cipher_func.harden_pke_init = harden_cipher_func->harden_pke_init;
+    g_harden_cipher_func.harden_pke_deinit = harden_cipher_func->harden_pke_deinit;
+    g_harden_cipher_func.harden_pke_mod = harden_cipher_func->harden_pke_mod;
+    g_harden_cipher_func.harden_pke_exp_mod = harden_cipher_func->harden_pke_exp_mod;
+    g_harden_cipher_func.harden_pke_ecc_gen_key = harden_cipher_func->harden_pke_ecc_gen_key;
+    g_harden_cipher_func.harden_pke_ecdsa_sign = harden_cipher_func->harden_pke_ecdsa_sign;
+    g_harden_cipher_func.harden_pke_ecdsa_verify = harden_cipher_func->harden_pke_ecdsa_verify;
+    g_harden_cipher_func.harden_pke_eddsa_sign = harden_cipher_func->harden_pke_eddsa_sign;
+    g_harden_cipher_func.harden_pke_eddsa_verify = harden_cipher_func->harden_pke_eddsa_verify;
+    g_harden_cipher_func.harden_pke_gen_ecdh_key = harden_cipher_func->harden_pke_gen_ecdh_key;
+    g_harden_cipher_func.harden_pke_check_dot_on_curve = harden_cipher_func->harden_pke_check_dot_on_curve;
+    g_harden_cipher_func.harden_pke_rsa_sign = harden_cipher_func->harden_pke_rsa_sign;
+    g_harden_cipher_func.harden_pke_rsa_verify = harden_cipher_func->harden_pke_rsa_verify;
+    g_harden_cipher_func.harden_pke_rsa_public_encrypt = harden_cipher_func->harden_pke_rsa_public_encrypt;
+    g_harden_cipher_func.harden_pke_rsa_private_decrypt = harden_cipher_func->harden_pke_rsa_private_decrypt;
+}
+
+td_void mbedtls_km_adapt_register_func( mbedtls_harden_km_func *harden_km_func )
+{
+    g_harden_km_func.harden_km_init = harden_km_func->harden_km_init;
+    g_harden_km_func.harden_km_deinit = harden_km_func->harden_km_deinit;
+    g_harden_km_func.harden_km_create_keyslot = harden_km_func->harden_km_create_keyslot;
+    g_harden_km_func.harden_km_destroy_keyslot = harden_km_func->harden_km_destroy_keyslot;
+    g_harden_km_func.harden_km_set_clear_key = harden_km_func->harden_km_set_clear_key;
+}
+
+td_void mbedtls_mem_adapt_register_func( mbedtls_harden_mem_func *harden_mem_func )
+{
+    g_harden_mem_func.harden_alloc_phys_buf = harden_mem_func->harden_alloc_phys_buf;
+    g_harden_mem_func.harden_free_phys_buf = harden_mem_func->harden_free_phys_buf;
+    g_harden_mem_func.harden_get_phys_addr = harden_mem_func->harden_get_phys_addr;
+}
+
+/* HASH */
+int mbedtls_alt_hash_start(mbedtls_alt_hash_clone_ctx *clone_ctx, mbedtls_alt_hash_type hash_type)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.alt_hash_start == NULL) {
+        mbedtls_printf("Error: hash start unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.alt_hash_start(clone_ctx, hash_type);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_hash_update(mbedtls_alt_hash_clone_ctx *clone_ctx, const unsigned char *data, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.alt_hash_update == NULL) {
+        mbedtls_printf("Error: hash update unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.alt_hash_update(clone_ctx, data, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_hash_finish(mbedtls_alt_hash_clone_ctx *clone_ctx, unsigned char *out, unsigned int out_len)
+{
+    int ret = -1;
+    unsigned int hash_out_len = out_len;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.alt_hash_finish == NULL) {
+        mbedtls_printf("Error: hash finish unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.alt_hash_finish(clone_ctx, out, &hash_out_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_create_key(td_handle *kslot_handle)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.aes_create_key == NULL) {
+        mbedtls_printf("Error: aes create key unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.aes_create_key(kslot_handle);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_set_key(td_handle kslot_handle, const unsigned char *key, unsigned int key_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.aes_set_key == NULL) {
+        mbedtls_printf("Error: aes set key unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.aes_set_key(kslot_handle, key, key_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_destroy_key(td_handle kslot_handle)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.aes_destroy_key == NULL) {
+        mbedtls_printf("Error: aes destroy key unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.aes_destroy_key(kslot_handle);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_encrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, const unsigned char src[16], unsigned char dst[16])
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.encrypt == NULL) {
+        mbedtls_printf("Error: encrypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.encrypt(kslot_handle, key, key_len, src, dst);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_decrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, const unsigned char src[16], unsigned char dst[16])
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.decrypt == NULL) {
+        mbedtls_printf("Error: decrypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.decrypt(kslot_handle, key, key_len, src, dst);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+
+int mbedtls_alt_aes_cbc_encrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.cbc_encrypt == NULL) {
+        mbedtls_printf("Error: cbc encrypt unregister!\n");
+        return -1;
+    }
+
+    ret = g_harden_cipher_func.cbc_encrypt(kslot_handle, key, key_len, iv, src, dst, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_cbc_decrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.cbc_decrypt == NULL) {
+        mbedtls_printf("Error: cbc decrypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.cbc_decrypt(kslot_handle, key, key_len, iv, src, dst, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_cfb128_encrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.cfb128_encrypt == NULL) {
+        mbedtls_printf("Error: cfb8 encrypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.cfb128_encrypt(kslot_handle, key, key_len, iv, src, dst, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_cfb128_decrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.cfb128_decrypt == NULL) {
+        mbedtls_printf("Error: cfb8 encrypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.cfb128_decrypt(kslot_handle, key, key_len, iv, src, dst, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_cfb8_encrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.cfb8_encrypt == NULL) {
+        mbedtls_printf("Error: cfb8 encrypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.cfb8_encrypt(kslot_handle, key, key_len, iv, src, dst, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_cfb8_decrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.cfb8_decrypt == NULL) {
+        mbedtls_printf("Error: cfb8 decrypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.cfb8_decrypt(kslot_handle, key, key_len, iv, src, dst, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_ofb_crypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, unsigned char *iv_off, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.ofb_crypt == NULL) {
+        mbedtls_printf("Error: ofb crypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.ofb_crypt(kslot_handle, key, key_len, iv_off, iv, src, dst, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_ctr_crypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len, unsigned char *nc_off, unsigned char nonce_counter[16], unsigned char stream_block[16], const unsigned char *src, unsigned char *dst, unsigned int data_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.ctr_crypt == NULL) {
+        mbedtls_printf("Error: ctr crypt unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.ctr_crypt(kslot_handle, key, key_len, nc_off, nonce_counter, stream_block, src, dst, data_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+/* CCM GCM */
+
+int mbedtls_alt_aes_ccm_start(unsigned long long *phys_addr, void **vir_addr)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.ccm_start == NULL) {
+        mbedtls_printf("Error: ccm update ad unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.ccm_start(phys_addr, vir_addr);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_ccm_update_ad(mbedtls_ccm_context *ctx, const unsigned char *add, unsigned int add_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.ccm_ad_update == NULL) {
+        mbedtls_printf("Error: ccm update ad unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.ccm_ad_update(ctx, add, add_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_ccm_update(mbedtls_ccm_context *ctx, const unsigned char *input, unsigned int input_len,
+    unsigned char *output, unsigned int output_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.ccm_update == NULL) {
+        mbedtls_printf("Error: ccm update unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.ccm_update(ctx, input, input_len, output, output_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_alt_aes_ccm_finish(mbedtls_ccm_context *ctx, unsigned char *tag, unsigned int tag_buf_len)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    if (g_harden_cipher_func.ccm_finish == NULL) {
+        mbedtls_printf("Error: ccm finish unregister!\n");
+        return -1;
+    }
+    ret = g_harden_cipher_func.ccm_finish(ctx, tag, tag_buf_len);
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+/* HASH */
+td_s32 CIPHER_HASH_INIT( td_void )
+{
+    if( g_harden_cipher_func.harden_hash_init == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hash_init func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hash_init();
+}
+
+td_s32 CIPHER_HASH_DEINIT( td_void )
+{
+    if( g_harden_cipher_func.harden_hash_deinit == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hash_deinit func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hash_deinit();
+}
+
+td_s32 CIPHER_HASH_START( td_handle *uapi_hash_handle, const crypto_hash_attr *hash_attr )
+{
+    if( g_harden_cipher_func.harden_hash_start == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hash_start func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hash_start( uapi_hash_handle, hash_attr );
+}
+
+td_s32 CIPHER_HASH_UPDATE( td_handle uapi_hash_handle, const crypto_buf_attr *src_buf, const td_u32 len )
+{
+    if( g_harden_cipher_func.harden_hash_update == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hash_update func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hash_update( uapi_hash_handle, src_buf, len );
+}
+
+td_s32 CIPHER_HASH_GET( td_handle uapi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx )
+{
+    if( g_harden_cipher_func.harden_hash_get == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hash_get func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hash_get( uapi_hash_handle, hash_clone_ctx );
+}
+
+td_s32 CIPHER_HASH_SET( td_handle uapi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx )
+{
+    if( g_harden_cipher_func.harden_hash_set == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hash_set func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hash_set( uapi_hash_handle, hash_clone_ctx );
+}
+
+td_s32 CIPHER_HASH_DESTROY( td_handle uapi_hash_handle )
+{
+    if( g_harden_cipher_func.harden_hash_destroy == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hash_destroy func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hash_destroy( uapi_hash_handle );
+}
+
+td_s32 CIPHER_HASH_FINISH( td_handle uapi_hash_handle, td_u8 *out, td_u32 *out_len )
+{
+    if( g_harden_cipher_func.harden_hash_finish == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hash_finish func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hash_finish( uapi_hash_handle, out, out_len );
+}
+
+/* HKDF */
+td_s32 CIPHER_HKDF( crypto_hkdf_t *hkdf_param, td_u8 *okm, td_u32 okm_length )
+{
+    if( g_harden_cipher_func.harden_hkdf == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hkdf func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hkdf( hkdf_param, okm, okm_length );
+}
+
+td_s32 CIPHER_HKDF_EXTRACT( crypto_hkdf_extract_t *extract_param, td_u8 *prk, td_u32 *prk_length )
+{
+    if( g_harden_cipher_func.harden_hkdf_extract == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hkdf_extract func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hkdf_extract( extract_param, prk, prk_length );
+}
+
+td_s32 CIPHER_HKDF_EXPAND( const crypto_hkdf_expand_t *expand_param, td_u8 *okm, td_u32 okm_length )
+{
+    if( g_harden_cipher_func.harden_hkdf_expand == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_hkdf_expand func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_hkdf_expand( expand_param, okm, okm_length );
+}
+
+/* TRNG */
+td_s32 CIPHER_TRNG_GET_RANDOM( td_u32 *randnum )
+{
+    if( g_harden_cipher_func.harden_trng_get_random == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_trng_get_random func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_trng_get_random( randnum );
+}
+
+td_s32 CIPHER_TRNG_GET_MULTI_RANDOM( td_u32 size, td_u8 *randnum )
+{
+    if( g_harden_cipher_func.harden_trng_get_multi_random == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_trng_get_multi_random func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_trng_get_multi_random(size, randnum);
+}
+
+/* PBKDF2 */
+td_s32 CIPHER_PBKDF2( const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len )
+{
+    if( g_harden_cipher_func.harden_pbkdf2 == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pbkdf2 func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pbkdf2( param, out, out_len );
+}
+
+/* SYMC */
+td_s32 CIPHER_SYMC_INIT( td_void )
+{
+    if( g_harden_cipher_func.harden_symc_init == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_init func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_init();
+}
+
+td_s32 CIPHER_SYMC_DEINIT( td_void )
+{
+    if( g_harden_cipher_func.harden_symc_deinit == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_deinit func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_deinit();
+}
+
+td_s32 CIPHER_SYMC_CREATE( td_handle *symc_handle, const crypto_symc_attr *symc_attr )
+{
+    if( g_harden_cipher_func.harden_symc_create == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_create func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_create( symc_handle, symc_attr );
+}
+
+td_s32 CIPHER_SYMC_DESTROY( td_handle symc_handle )
+{
+    if( g_harden_cipher_func.harden_symc_destroy == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_destroy func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_destroy( symc_handle );
+}
+
+td_s32 CIPHER_SYMC_SET_CONFIG( td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl )
+{
+    if( g_harden_cipher_func.harden_symc_set_config == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_set_config func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_set_config( symc_handle, symc_ctrl );
+}
+
+td_s32 CIPHER_SYMC_GET_CONFIG( td_handle symc_handle, crypto_symc_ctrl_t *symc_ctrl )
+{
+    if( g_harden_cipher_func.harden_symc_get_config == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_get_config func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_get_config( symc_handle, symc_ctrl );
+}
+
+td_s32 CIPHER_SYMC_ATTACH( td_handle symc_handle, td_handle keyslot_handle )
+{
+    if( g_harden_cipher_func.harden_symc_attach == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_attach func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_attach( symc_handle, keyslot_handle );
+}
+
+td_s32 CIPHER_SYMC_ENCRYPT( td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length )
+{
+    if( g_harden_cipher_func.harden_symc_encrypt == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_encrypt func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_encrypt( symc_handle, src_buf, dst_buf, length );
+}
+
+td_s32 CIPHER_SYMC_DECRYPT( td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length )
+{
+    if( g_harden_cipher_func.harden_symc_decrypt == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_decrypt func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_decrypt( symc_handle, src_buf, dst_buf, length );
+}
+
+td_s32 CIPHER_SYMC_GET_TAG( td_handle symc_handle, td_u8 *tag, td_u32 tag_length )
+{
+    if( g_harden_cipher_func.harden_symc_get_tag == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_get_tag func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_get_tag( symc_handle, tag, tag_length );
+}
+
+td_s32 CIPHER_SYMC_MAC_START( td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr )
+{
+    if( g_harden_cipher_func.harden_symc_mac_start == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_mac_start func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_mac_start( symc_handle, mac_attr );
+}
+
+td_s32 CIPHER_SYMC_MAC_UPDATE( td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length )
+{
+    if( g_harden_cipher_func.harden_symc_mac_update == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_mac_update func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_mac_update( symc_handle, src_buf, length );
+}
+
+td_s32 CIPHER_SYMC_MAC_FINISH( td_handle symc_handle, td_u8 *mac, td_u32 *mac_length )
+{
+    if( g_harden_cipher_func.harden_symc_mac_finish == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_symc_mac_finish func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_symc_mac_finish( symc_handle, mac, mac_length );
+}
+
+/* PKE */
+td_s32 CIPHER_PKE_INIT( td_void )
+{
+    if( g_harden_cipher_func.harden_pke_init == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_init func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_init();
+}
+
+td_s32 CIPHER_PKE_DEINIT( td_void )
+{
+    if( g_harden_cipher_func.harden_pke_deinit == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_deinit func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_deinit();
+}
+
+td_s32 CIPHER_PKE_MOD( const drv_pke_data *a, const drv_pke_data *p, drv_pke_data *c )
+{
+    if( g_harden_cipher_func.harden_pke_mod == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_mod func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_mod( a, p, c );
+}
+
+td_s32 CIPHER_PKE_EXP_MOD( const drv_pke_data *n, const drv_pke_data *k,
+    const drv_pke_data *in, const drv_pke_data *out )
+{
+    if( g_harden_cipher_func.harden_pke_exp_mod == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_exp_mod func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_exp_mod( n, k, in, out );
+}
+
+td_s32 CIPHER_PKE_ECC_GEN_KEY( drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key )
+{
+    if( g_harden_cipher_func.harden_pke_ecc_gen_key == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_ecc_gen_key func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_ecc_gen_key( curve_type, input_priv_key, output_priv_key, output_pub_key );
+}
+
+td_s32 CIPHER_PKE_ECDSA_SIGN( drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig )
+{
+    if( g_harden_cipher_func.harden_pke_ecdsa_sign == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_ecdsa_sign func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_ecdsa_sign( curve_type, priv_key, hash, sig );
+}
+td_s32 CIPHER_PKE_ECDSA_VERIFY( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig )
+{
+    if( g_harden_cipher_func.harden_pke_ecdsa_verify == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_ecdsa_verify func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_ecdsa_verify( curve_type, pub_key, hash, sig );
+}
+
+td_s32 CIPHER_PKE_EDDSA_SIGN( drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig )
+{
+    if( g_harden_cipher_func.harden_pke_eddsa_sign == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_eddsa_sign func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_eddsa_sign( curve_type, priv_key, msg, sig );
+}
+td_s32 CIPHER_PKE_EDDSA_VERIFY( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig )
+{
+    if( g_harden_cipher_func.harden_pke_eddsa_verify == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_eddsa_verify func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_eddsa_verify( curve_type, pub_key, msg, sig );
+}
+
+td_s32 CIPHER_PKE_ECC_GEN_ECDH_KEY( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key )
+{
+    if( g_harden_cipher_func.harden_pke_gen_ecdh_key == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_gen_ecdh_key func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_gen_ecdh_key( curve_type, input_pub_key, input_priv_key, output_shared_key );
+}
+
+td_s32 CIPHER_PKE_CHECK_DOT_ON_CURVE( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve )
+{
+    if( g_harden_cipher_func.harden_pke_check_dot_on_curve == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_check_dot_on_curve func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_check_dot_on_curve( curve_type, pub_key, is_on_curve );
+}
+
+td_s32 CIPHER_PKE_RSA_SIGN( const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign )
+{
+    if( g_harden_cipher_func.harden_pke_rsa_sign == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_rsa_sign func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_rsa_sign( priv_key, scheme, hash_type, input_hash, sign );
+}
+
+td_s32 CIPHER_PKE_RSA_VERIFY( const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, drv_pke_data *input_hash, const drv_pke_data *sig )
+{
+    if( g_harden_cipher_func.harden_pke_rsa_verify == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_rsa_verify func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_rsa_verify( pub_key, scheme, hash_type, input_hash, sig );
+}
+
+td_s32 CIPHER_PKE_RSA_PUBLIC_ENCRYPT( drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output )
+{
+    if( g_harden_cipher_func.harden_pke_rsa_public_encrypt == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_rsa_public_encrypt func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_rsa_public_encrypt( scheme, hash_type, pub_key, input, label, output );
+}
+
+td_s32 CIPHER_PKE_RSA_PRIVATE_DECRYPT( drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output )
+{
+    if( g_harden_cipher_func.harden_pke_rsa_private_decrypt == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_pke_rsa_private_decrypt func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_cipher_func.harden_pke_rsa_private_decrypt( scheme, hash_type, priv_key, input, label, output );
+}
+
+/* KM */
+td_s32 KM_INIT( td_void )
+{
+    if( g_harden_km_func.harden_km_init == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_km_init func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_km_func.harden_km_init();
+}
+
+td_s32 KM_DEINIT( td_void )
+{
+    if( g_harden_km_func.harden_km_deinit == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_km_deinit func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_km_func.harden_km_deinit();
+}
+
+td_s32 CIPHER_CREATE_KEYSLOT( td_handle *keyslot_handle, km_keyslot_engine key_engine )
+{
+    if( g_harden_km_func.harden_km_create_keyslot == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_km_create_keyslot func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_km_func.harden_km_create_keyslot( keyslot_handle, key_engine );
+}
+
+td_void CIPHER_DESTROY_KEYSLOT( td_handle keyslot_handle )
+{
+    if( g_harden_km_func.harden_km_destroy_keyslot == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_km_destroy_keyslot func\n");
+        return;
+    }
+    g_harden_km_func.harden_km_destroy_keyslot( keyslot_handle );
+}
+
+td_s32 CIPHER_SET_CLEAR_KEY( td_handle keyslot_handle, td_u8 *key, td_u32 keylen,
+    km_keyslot_engine key_engine )
+{
+    if( g_harden_km_func.harden_km_set_clear_key == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_km_set_clear_key func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_km_func.harden_km_set_clear_key( keyslot_handle, key, keylen, key_engine );
+}
+
+/* MEM */
+td_s32 CIPHER_ALLOC_BUF_ATTR( crypto_buf_attr *buf_attr, void **virt_addr, unsigned int size )
+{
+    if( g_harden_mem_func.harden_alloc_phys_buf == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_alloc_phys_buf func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_mem_func.harden_alloc_phys_buf( buf_attr, virt_addr, size );
+}
+
+td_void CIPHER_FREE_BUF_ATTR( crypto_buf_attr *buf_attr, void *virt_addr, unsigned int size )
+{
+    if( g_harden_mem_func.harden_free_phys_buf == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_free_phys_buf func\n");
+        return;
+    }
+    g_harden_mem_func.harden_free_phys_buf( buf_attr, virt_addr, size );
+}
+
+td_s32 CIPHER_GET_PHYS_MEM( void *virt_addr, unsigned long *phys_addr )
+{
+    if( g_harden_mem_func.harden_get_phys_addr == TD_NULL )
+    {
+        mbedtls_harden_log_err("Unexpected error, please register the harden_get_phys_addr func\n");
+        return TD_FAILURE;
+    }
+    return g_harden_mem_func.harden_get_phys_addr( virt_addr, phys_addr );
+}
+
+td_bool IS_KM_FUNC_REGISTERED()
+{
+    if ( g_harden_km_func.harden_km_init != TD_NULL &&
+            g_harden_km_func.harden_km_deinit != TD_NULL &&
+            g_harden_km_func.harden_km_create_keyslot != TD_NULL &&
+            g_harden_km_func.harden_km_destroy_keyslot != TD_NULL &&
+            g_harden_km_func.harden_km_set_clear_key != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_MEM_FUNC_REGISTERED()
+{
+    if ( g_harden_mem_func.harden_alloc_phys_buf != TD_NULL &&
+            g_harden_mem_func.harden_free_phys_buf != TD_NULL &&
+            g_harden_mem_func.harden_get_phys_addr != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_SYMC_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_symc_init != TD_NULL &&
+            g_harden_cipher_func.harden_symc_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_symc_create != TD_NULL &&
+            g_harden_cipher_func.harden_symc_destroy != TD_NULL &&
+            g_harden_cipher_func.harden_symc_set_config != TD_NULL &&
+            g_harden_cipher_func.harden_symc_get_config != TD_NULL &&
+            g_harden_cipher_func.harden_symc_attach != TD_NULL &&
+            g_harden_cipher_func.harden_symc_encrypt != TD_NULL &&
+            g_harden_cipher_func.harden_symc_decrypt != TD_NULL &&
+            g_harden_cipher_func.harden_symc_get_tag != TD_NULL &&
+            g_harden_cipher_func.harden_symc_mac_start != TD_NULL &&
+            g_harden_cipher_func.harden_symc_mac_update != TD_NULL &&
+            g_harden_cipher_func.harden_symc_mac_finish != TD_NULL &&
+            IS_KM_FUNC_REGISTERED() &&
+            IS_MEM_FUNC_REGISTERED() )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_HASH_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_hash_init  != TD_NULL &&
+            g_harden_cipher_func.harden_hash_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_hash_start != TD_NULL &&
+            g_harden_cipher_func.harden_hash_update != TD_NULL &&
+            g_harden_cipher_func.harden_hash_get != TD_NULL &&
+            g_harden_cipher_func.harden_hash_set != TD_NULL &&
+            g_harden_cipher_func.harden_hash_destroy != TD_NULL &&
+            g_harden_cipher_func.harden_hash_finish != TD_NULL &&
+            IS_KM_FUNC_REGISTERED() &&
+            IS_MEM_FUNC_REGISTERED() )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_HKDF_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_hash_init  != TD_NULL &&
+            g_harden_cipher_func.harden_hash_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_hkdf != TD_NULL &&
+            g_harden_cipher_func.harden_hkdf_extract != TD_NULL &&
+            g_harden_cipher_func.harden_hkdf_expand != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PBKDF2_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pbkdf2 != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_TRNG_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_trng_get_random != TD_NULL &&
+            g_harden_cipher_func.harden_trng_get_multi_random != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_MOD_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_mod != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_EXP_MOD_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_exp_mod != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_EDDSA_SIGN_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_eddsa_sign != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_EDDSA_VERIFY_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_eddsa_verify != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_ECC_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_gen_ecdh_key != TD_NULL &&
+            g_harden_cipher_func.harden_pke_ecc_gen_key != TD_NULL &&
+            g_harden_cipher_func.harden_pke_ecdsa_sign != TD_NULL &&
+            g_harden_cipher_func.harden_pke_ecdsa_verify != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_CHECK_DOT_ON_CURVE_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_check_dot_on_curve != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_RSA_SIGN_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_rsa_sign != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_RSA_VERIFY_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_rsa_verify != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_RSA_PUBLIC_ENCRYPT_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_rsa_public_encrypt != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
+
+td_bool IS_PKE_RSA_PRIVATE_DECRYPT_FUNC_REGISTERED()
+{
+    if ( g_harden_cipher_func.harden_pke_init != TD_NULL &&
+            g_harden_cipher_func.harden_pke_deinit != TD_NULL &&
+            g_harden_cipher_func.harden_pke_rsa_private_decrypt != TD_NULL )
+    {
+        return TD_TRUE;
+    }
+    return TD_FALSE;
+}
\ No newline at end of file
diff --git a/harden/src/cipher_common.c b/harden/src/cipher_common.c
new file mode 100644
index 0000000..800500d
--- /dev/null
+++ b/harden/src/cipher_common.c
@@ -0,0 +1,58 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "cipher_common.h"
+#include "aes_alt.h"
+#include "securec.h"
+
+#if defined(MBEDTLS_AES_ALT)
+/*
+ * Set symc_ctrl
+ */
+typedef struct key_len_pair {
+    unsigned int key_len;
+    crypto_symc_key_length key_len_input;
+} key_len_pair;
+
+#define KEY_LEN_MAP_SIZE    3
+
+key_len_pair key_len_map[] = {
+    {.key_len = 16, .key_len_input = CRYPTO_SYMC_KEY_128BIT},
+    {.key_len = 24, .key_len_input = CRYPTO_SYMC_KEY_192BIT},
+    {.key_len = 32, .key_len_input = CRYPTO_SYMC_KEY_256BIT},
+};
+
+int mbedtls_cipher_set_ctrl(crypto_symc_ctrl_t *symc_ctrl, const crypto_symc_alg symc_alg,
+    const crypto_symc_work_mode work_mode, const unsigned int key_len, const crypto_symc_bit_width bit_width,
+    const crypto_symc_iv_change_type iv_change_flag, const unsigned char *iv, const unsigned int iv_len)
+{
+    int i = 0;
+    symc_ctrl->symc_alg = symc_alg;
+    symc_ctrl->work_mode = work_mode;
+    symc_ctrl->symc_bit_width = bit_width;
+    symc_ctrl->iv_change_flag = iv_change_flag;
+    for (i = 0; i < KEY_LEN_MAP_SIZE; ++i) {
+        if (key_len_map[i].key_len == key_len) {
+            symc_ctrl->symc_key_length = key_len_map[i].key_len_input;
+        }
+    }
+    (void)memcpy_s(symc_ctrl->iv, sizeof(symc_ctrl->iv), iv, iv_len);
+    symc_ctrl->iv_length = iv_len;
+    return 0;
+}
+
+int mbedtls_cipher_set_gcm_ccm_config(crypto_symc_config_aes_ccm_gcm *gcm_config, const unsigned char *aad,
+    const unsigned int aad_len, const unsigned int data_len, const unsigned int tag_len)
+{
+    gcm_config->aad_buf.virt_addr = (void *)aad;
+    gcm_config->aad_len = aad_len;
+    gcm_config->data_len = data_len;
+    gcm_config->tag_len = tag_len;
+    return 0;
+}
+
+#endif
\ No newline at end of file
diff --git a/harden/src/cmac_harden.c b/harden/src/cmac_harden.c
new file mode 100644
index 0000000..911d5b8
--- /dev/null
+++ b/harden/src/cmac_harden.c
@@ -0,0 +1,355 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+#include "common.h"
+#include "mbedtls/error.h"
+#include "cmac_harden.h"
+#include "cipher_common.h"
+#include "dfx.h"
+
+#if defined(MBEDTLS_CMAC_ALT)
+
+static cmac_harden_context g_cmac_harden_context[MAX_CMAC_HARD_CTX_NUM] = {0};
+
+static cmac_harden_context * get_cmac_harden_ctx( mbedtls_cipher_context_t *ctx )
+{
+    unsigned int i = 0;
+    for( i = 0; i < MAX_CMAC_HARD_CTX_NUM; ++i )
+    {
+        if( g_cmac_harden_context[i].ctx == ctx )
+        {
+            return &g_cmac_harden_context[i];
+        }
+    }
+    return NULL;
+}
+
+static int internal_cmac_starts_harden( cmac_harden_context *harden_ctx )
+{
+    int ret = 0;
+    crypto_symc_mac_attr mac_attr = {
+        .symc_alg = CRYPTO_SYMC_ALG_AES,
+        .work_mode = CRYPTO_SYMC_WORK_MODE_CMAC,
+        .is_long_term = 1
+    };
+
+    ret = CIPHER_SYMC_INIT();
+    if(ret != 0)
+        return ret;
+    ret = KM_INIT();
+    if(ret != 0)
+        goto cipher_deinit;
+    ret = CIPHER_CREATE_KEYSLOT(&harden_ctx->keyslot_handle, KM_KEYSLOT_ENGINE_AES);
+    if(ret != 0)
+        goto km_deinit;
+    
+    ret = CIPHER_SET_CLEAR_KEY(harden_ctx->keyslot_handle, harden_ctx->key, harden_ctx->key_length,
+        KM_KEYSLOT_ENGINE_AES);
+    if( ret != 0 )
+        goto keyslot_destroy;
+    mac_attr.keyslot_chn = harden_ctx->keyslot_handle;
+    switch( harden_ctx->key_length )
+    {
+        case 16:
+            mac_attr.symc_key_length = CRYPTO_SYMC_KEY_128BIT;
+            break;
+        case 24:
+            mac_attr.symc_key_length = CRYPTO_SYMC_KEY_192BIT;
+            break;
+        case 32:
+            mac_attr.symc_key_length = CRYPTO_SYMC_KEY_256BIT;
+            break;
+    }
+    ret = CIPHER_SYMC_MAC_START(&harden_ctx->symc_handle, &mac_attr);
+    if(ret != 0)
+        goto keyslot_destroy;
+    return ret;
+
+keyslot_destroy:
+    CIPHER_DESTROY_KEYSLOT(harden_ctx->keyslot_handle);
+km_deinit:
+    (void)KM_DEINIT();
+cipher_deinit:
+    (void)CIPHER_SYMC_DEINIT();
+    return ret;
+}
+
+static void internal_check_and_free_harden_ctx( mbedtls_cipher_context_t *ctx )
+{
+    int i = 0;
+    for( i = 0; i < MAX_CMAC_HARD_CTX_NUM; ++i )
+    {
+        if( g_cmac_harden_context[i].ctx == ctx ) {
+            if( g_cmac_harden_context[i].symc_handle != 0 )
+            {
+                ( void )CIPHER_SYMC_DESTROY( g_cmac_harden_context[i].symc_handle );
+                ( void )CIPHER_SYMC_DEINIT();
+            }
+            if( g_cmac_harden_context[i].keyslot_handle != 0 )
+            {
+                ( void )CIPHER_DESTROY_KEYSLOT( g_cmac_harden_context[i].keyslot_handle );
+                ( void )KM_DEINIT();
+            }
+            memset( &g_cmac_harden_context[i], 0, sizeof( cmac_harden_context ) );
+        }
+    }
+}
+
+int mbedtls_cipher_cmac_starts_harden( mbedtls_cipher_context_t *ctx,
+                                const unsigned char *key, size_t keybits,
+                                mbedtls_cipher_type_t type )
+{
+    int i = 0;
+    int ret = 0;
+    internal_check_and_free_harden_ctx( ctx );
+    if( IS_SYMC_FUNC_REGISTERED() != TD_TRUE )
+        return ( -1 );
+    if( type == MBEDTLS_CIPHER_DES_EDE3_ECB )
+        return ( -1 );
+#if !defined( MBEDTLS_AES_192_HARD_KEY_SUPPORT )
+    if( type == MBEDTLS_CIPHER_AES_192_ECB )
+        return ( -1 );
+#endif
+    for(i = 0; i < MAX_CMAC_HARD_CTX_NUM; ++i)
+    {
+        if( g_cmac_harden_context[i].is_used == 0 ) {
+            g_cmac_harden_context[i].ctx = ctx;
+            g_cmac_harden_context[i].is_used = 1;
+            g_cmac_harden_context[i].key_length = keybits / 8;
+            g_cmac_harden_context[i].is_update = 0;
+            g_cmac_harden_context[i].is_finish = 0;
+            memcpy( g_cmac_harden_context[i].key, key, g_cmac_harden_context[i].key_length );
+            ret = internal_cmac_starts_harden( &g_cmac_harden_context[i] );
+            if( ret != 0 )
+                g_cmac_harden_context[i].use_software = 1;
+            break;
+        }
+    }
+    return ret;
+}
+
+int mbedtls_cipher_cmac_update_harden( mbedtls_cipher_context_t *ctx,
+                                        const unsigned char *input, size_t ilen )
+{
+    int ret = 0;
+    cmac_harden_context *harden_ctx;
+    crypto_buf_attr src_buf = {0};
+
+    harden_ctx = get_cmac_harden_ctx( ctx );
+    if( harden_ctx == NULL || harden_ctx->use_software == 1 )
+        return ( -1 );
+#if !defined( MBEDTLS_AES_192_HARD_KEY_SUPPORT )
+    if( harden_ctx->key_length == 24 )
+        return ( -1 );
+#endif
+    if( harden_ctx->is_finish == 1 )
+    {
+        ret = internal_cmac_starts_harden( harden_ctx );
+        if( ret != 0 )
+        {
+            harden_ctx->is_finish = 0;
+            harden_ctx->use_software = 1;
+            return ( -1 );
+        }
+    }
+    if( ilen == 0 )
+        return ( 0 );
+    harden_ctx->is_update = 1;
+    src_buf.virt_addr = ( void * )input;
+    ret = CIPHER_SYMC_MAC_UPDATE( harden_ctx->symc_handle, &src_buf, ilen );
+    return ret;
+}
+
+static void reset_harden_ctx( cmac_harden_context *harden_ctx )
+{
+    harden_ctx->is_finish = 1;
+    harden_ctx->is_update = 0;
+    harden_ctx->use_software = 0;
+    harden_ctx->symc_handle = 0;
+    harden_ctx->keyslot_handle = 0;
+}
+
+static void release_hard_resource( cmac_harden_context *harden_ctx )
+{
+    ( void )CIPHER_DESTROY_KEYSLOT( harden_ctx->keyslot_handle );
+    ( void )KM_DEINIT();
+    ( void )CIPHER_SYMC_DEINIT();
+}
+
+int mbedtls_cipher_cmac_finish_harden( mbedtls_cipher_context_t *ctx,
+                                        unsigned char *output )
+{
+    int ret = 0;
+    cmac_harden_context *harden_ctx;
+    unsigned int mac_len = MBEDTLS_CIPHER_BLKSIZE_MAX;
+    harden_ctx = get_cmac_harden_ctx( ctx );
+    if( harden_ctx == NULL )
+        return ( -1 );
+#if !defined( MBEDTLS_AES_192_HARD_KEY_SUPPORT )
+    if( harden_ctx->key_length == 24 )
+        return ( -1 );
+#endif
+    if( harden_ctx->is_update == 0 )
+    {
+        ( void )CIPHER_SYMC_DESTROY( harden_ctx->symc_handle );
+        release_hard_resource( harden_ctx );
+        reset_harden_ctx( harden_ctx );
+        return ( -1 );
+    }
+    ret = CIPHER_SYMC_MAC_FINISH( harden_ctx->symc_handle, output, &mac_len );
+    release_hard_resource( harden_ctx );
+    reset_harden_ctx( harden_ctx );
+    return ret;
+}
+
+int mbedtls_cipher_cmac_reset_harden( mbedtls_cipher_context_t *ctx )
+{
+    cmac_harden_context *harden_ctx;
+    harden_ctx = get_cmac_harden_ctx( ctx );
+    if( harden_ctx == NULL )
+        return ( -1 );
+
+    if(harden_ctx->symc_handle != 0)
+    {
+        (void)CIPHER_SYMC_DESTROY(harden_ctx->symc_handle);
+        (void)CIPHER_SYMC_DEINIT();
+    }
+    if(harden_ctx->keyslot_handle != 0)
+    {
+        (void)CIPHER_DESTROY_KEYSLOT(harden_ctx->keyslot_handle);
+        (void)KM_DEINIT();
+    }
+    reset_harden_ctx( harden_ctx );
+    return 0;
+}
+
+int mbedtls_cipher_cmac_starts( mbedtls_cipher_context_t *ctx,
+                                const unsigned char *key, size_t keybits )
+{
+    mbedtls_cipher_type_t type;
+
+    if( ctx == NULL || ctx->cipher_info == NULL || key == NULL )
+        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
+
+    type = ctx->cipher_info->type;
+
+    switch( type )
+    {
+        case MBEDTLS_CIPHER_AES_128_ECB:
+        case MBEDTLS_CIPHER_AES_192_ECB:
+        case MBEDTLS_CIPHER_AES_256_ECB:
+            break;
+        default:
+            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
+    }
+
+    return mbedtls_cipher_cmac_starts_harden( ctx, key, keybits, type );
+}
+
+int mbedtls_cipher_cmac_update( mbedtls_cipher_context_t *ctx,
+                                const unsigned char *input, size_t ilen )
+{
+    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL)
+        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
+
+    return mbedtls_cipher_cmac_update_harden( ctx, input, ilen );
+}
+
+int mbedtls_cipher_cmac_finish( mbedtls_cipher_context_t *ctx,
+                                unsigned char *output )
+{
+    if( ctx == NULL || ctx->cipher_info == NULL || output == NULL )
+        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
+
+    return mbedtls_cipher_cmac_finish_harden( ctx, output );
+}
+
+int mbedtls_cipher_cmac_reset( mbedtls_cipher_context_t *ctx )
+{
+
+    if( ctx == NULL || ctx->cipher_info == NULL )
+        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
+
+    return mbedtls_cipher_cmac_reset_harden( ctx );
+}
+
+int mbedtls_cipher_cmac( const mbedtls_cipher_info_t *cipher_info,
+                         const unsigned char *key, size_t keylen,
+                         const unsigned char *input, size_t ilen,
+                         unsigned char *output )
+{
+    mbedtls_cipher_context_t ctx;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( cipher_info == NULL || key == NULL || input == NULL || output == NULL )
+        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
+
+    mbedtls_cipher_init( &ctx );
+
+    if( ( ret = mbedtls_cipher_setup( &ctx, cipher_info ) ) != 0 )
+        goto exit;
+
+    ret = mbedtls_cipher_cmac_starts( &ctx, key, keylen );
+    if( ret != 0 )
+       goto exit;
+
+    ret = mbedtls_cipher_cmac_update( &ctx, input, ilen );
+    if( ret != 0 )
+        goto exit;
+
+exit:
+    ret = mbedtls_cipher_cmac_finish( &ctx, output );
+
+    mbedtls_cipher_free( &ctx );
+
+    return( ret );
+}
+
+int mbedtls_aes_cmac_prf_128( const unsigned char *key, size_t key_length,
+                              const unsigned char *input, size_t in_len,
+                              unsigned char output[16] )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    const mbedtls_cipher_info_t *cipher_info;
+    unsigned char zero_key[MBEDTLS_AES_BLOCK_SIZE];
+    unsigned char int_key[MBEDTLS_AES_BLOCK_SIZE];
+
+    if( key == NULL || input == NULL || output == NULL )
+        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
+
+    cipher_info = mbedtls_cipher_info_from_type( MBEDTLS_CIPHER_AES_128_ECB );
+    if( cipher_info == NULL )
+    {
+        /* Failing at this point must be due to a build issue */
+        ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
+        goto exit;
+    }
+
+    if( key_length == MBEDTLS_AES_BLOCK_SIZE )
+    {
+        /* Use key as is */
+        memcpy( int_key, key, MBEDTLS_AES_BLOCK_SIZE );
+    }
+    else
+    {
+        memset( zero_key, 0, MBEDTLS_AES_BLOCK_SIZE );
+
+        ret = mbedtls_cipher_cmac( cipher_info, zero_key, 128, key,
+                                   key_length, int_key );
+        if( ret != 0 )
+            goto exit;
+    }
+
+    ret = mbedtls_cipher_cmac( cipher_info, int_key, 128, input, in_len,
+                               output );
+
+exit:
+    mbedtls_platform_zeroize( int_key, sizeof( int_key ) );
+
+    return( ret );
+}
+
+#endif /* !MBEDTLS_CMAC_ALT */
\ No newline at end of file
diff --git a/harden/src/dfx.c b/harden/src/dfx.c
new file mode 100644
index 0000000..8ed4f75
--- /dev/null
+++ b/harden/src/dfx.c
@@ -0,0 +1,172 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "dfx.h"
+#include <string.h>
+#include "common.h"
+#include "mbedtls_platform_hardware_config.h"
+
+#if defined(MBED_HARDEN_DEBUG)
+
+typedef struct {
+    mbedtls_ecp_group_id group_id;
+    const char *name;
+} mbedtls_ecp_group_id_name_mapping;
+
+static const mbedtls_ecp_group_id_name_mapping group_id_name_table[] =
+{
+    { MBEDTLS_ECP_DP_NONE,       "MBEDTLS_ECP_DP_NONE"       },
+    { MBEDTLS_ECP_DP_SECP192R1,  "MBEDTLS_ECP_DP_SECP192R1"  },
+    { MBEDTLS_ECP_DP_SECP224R1,  "MBEDTLS_ECP_DP_SECP224R1"  },
+    { MBEDTLS_ECP_DP_SECP256R1,  "MBEDTLS_ECP_DP_SECP256R1"  },
+    { MBEDTLS_ECP_DP_SECP384R1,  "MBEDTLS_ECP_DP_SECP384R1"  },
+    { MBEDTLS_ECP_DP_SECP521R1,  "MBEDTLS_ECP_DP_SECP521R1"  },
+    { MBEDTLS_ECP_DP_BP256R1,    "MBEDTLS_ECP_DP_BP256R1"    },
+    { MBEDTLS_ECP_DP_BP384R1,    "MBEDTLS_ECP_DP_BP384R1"    },
+    { MBEDTLS_ECP_DP_BP512R1,    "MBEDTLS_ECP_DP_BP512R1"    },
+    { MBEDTLS_ECP_DP_CURVE25519, "MBEDTLS_ECP_DP_CURVE25519" },
+    { MBEDTLS_ECP_DP_SECP192K1,  "MBEDTLS_ECP_DP_SECP192K1"  },
+    { MBEDTLS_ECP_DP_SECP224K1,  "MBEDTLS_ECP_DP_SECP224K1"  },
+    { MBEDTLS_ECP_DP_SECP256K1,  "MBEDTLS_ECP_DP_SECP256K1"  },
+    { MBEDTLS_ECP_DP_CURVE448,   "MBEDTLS_ECP_DP_CURVE448"   },
+};
+
+static const char* mbedtls_ecp_group_id_to_str(mbedtls_ecp_group_id group_id)
+{
+    for (int i = 0; group_id_name_table[i].name != NULL; i++) {
+        if (group_id_name_table[i].group_id == group_id) {
+            return group_id_name_table[i].name;
+        }
+    }
+    return "Unknown";
+}
+
+void mbedtls_dump_grp_id(mbedtls_ecp_group_id group_id)
+{
+    const char* group_id_name = mbedtls_ecp_group_id_to_str(group_id);
+    mbedtls_printf("group id = %s!\n", group_id_name);
+}
+
+void mbedtls_dump_hex(const char* name, const unsigned char* buf, unsigned int buf_len)
+{
+    unsigned int i;
+    if (name == NULL) {
+        mbedtls_printf("you should give a name!\n");
+        return;
+    }
+    if (buf == NULL) {
+        mbedtls_printf("%s == NULL!\n", name);
+        return;
+    }
+    mbedtls_printf("\n---------------%s--------------\n", name);
+    for (i = 0; i < buf_len; i++) {
+        mbedtls_printf("%02x ", *(buf + i));
+        if ((i + 1) % PRINT_LINE_LEN == 0) {
+            mbedtls_printf("\n");
+        }
+    }
+    mbedtls_printf("\n");
+}
+
+void mbedtls_dump_mpi(const char* name, const mbedtls_mpi *mpi)
+{
+    size_t buf_len;
+    unsigned char* buf;
+    if (name == NULL) {
+        mbedtls_printf("you should give a name!\n");
+        return;
+    }
+    if (mpi == NULL) {
+        mbedtls_printf("%s == NULL!\n", name);
+        return;
+    }
+    buf_len = mbedtls_mpi_size(mpi);
+    buf = (unsigned char*)mbedtls_calloc(1, buf_len);
+    if (buf == NULL) {
+        mbedtls_printf("ERROR! mbedtls_calloc failed! LINE = %d\n", __LINE__);
+    }
+    if (mbedtls_mpi_write_binary(mpi, buf, buf_len) != 0) {
+        mbedtls_printf("ERROR! mbedtls_mpi_write_binary failed!\n");
+        mbedtls_free(buf);
+        return;
+    }
+    mbedtls_dump_hex(name, buf, buf_len);
+    mbedtls_free(buf);
+}
+
+void mbedtls_dump_point(const char* name, const mbedtls_ecp_point *point)
+{
+    size_t name_len;
+    size_t xyz_name_len;
+    char *xname = NULL;
+    char *yname = NULL;
+    char *zname = NULL;
+    if (name == NULL) {
+        mbedtls_printf("you should give a name!\n");
+        return;
+    }
+    if (point == NULL) {
+        mbedtls_printf("%s == NULL!\n", name);
+    }
+    name_len = strlen((char *)name);
+    xyz_name_len = name_len + strlen(".x") + 1;
+    xname = (char *)mbedtls_calloc(1, xyz_name_len);
+    yname = (char *)mbedtls_calloc(1, xyz_name_len);
+    zname = (char *)mbedtls_calloc(1, xyz_name_len);
+    if (xname == NULL || yname == NULL || zname == NULL) {
+        mbedtls_printf("ERROR! mbedtls_calloc failed! LINE = %d\n", __LINE__);
+        goto cleanup;
+        return;
+    }
+    (void)snprintf(xname, xyz_name_len, "%s%s", name, ".x");
+    (void)snprintf(yname, xyz_name_len, "%s%s", name, ".y");
+    (void)snprintf(zname, xyz_name_len, "%s%s", name, ".z");
+    mbedtls_dump_mpi(xname, &point->MBEDTLS_PRIVATE(X));
+    mbedtls_dump_mpi(yname, &point->MBEDTLS_PRIVATE(Y));
+    mbedtls_dump_mpi(zname, &point->MBEDTLS_PRIVATE(Z));
+cleanup:
+    if (xname != NULL) {
+        mbedtls_free(xname);
+    }
+    if (yname != NULL) {
+        mbedtls_free(yname);
+    }
+    if (zname != NULL) {
+        mbedtls_free(zname);
+    }
+}
+
+#else
+
+void mbedtls_dump_grp_id(mbedtls_ecp_group_id group_id){
+    unused(group_id);
+    return;
+}
+
+void mbedtls_dump_hex(const char* name, const unsigned char* buf, unsigned int buf_len)
+{
+    unused(name);
+    unused(buf);
+    unused(buf_len);
+    return;
+}
+
+void mbedtls_dump_mpi(const char* name, const mbedtls_mpi *mpi)
+{
+    unused(name);
+    unused(mpi);
+    return;
+}
+
+void mbedtls_dump_point(const char* name, const mbedtls_ecp_point *point)
+{
+    unused(name);
+    unused(point);
+    return;
+}
+
+#endif
\ No newline at end of file
diff --git a/harden/src/ecc_genkey_harden.c b/harden/src/ecc_genkey_harden.c
new file mode 100644
index 0000000..1c3946a
--- /dev/null
+++ b/harden/src/ecc_genkey_harden.c
@@ -0,0 +1,80 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "ecc_genkey_harden.h"
+#include "cipher_adapt.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform_util.h"
+#include "ecc_harden_common.h"
+#include "dfx.h"
+
+#if defined(MBEDTLS_ECC_GENKEY_USE_HARDWARE)
+int ecc_genkey_harden( mbedtls_ecp_group *grp,
+        const mbedtls_ecp_point *G,
+        mbedtls_mpi *d, mbedtls_ecp_point *Q,
+        int (*f_rng)(void *, unsigned char *, size_t),
+        void *p_rng )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    drv_pke_ecc_point pub_key;
+    drv_pke_data priv_key;
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+
+    mbedtls_harden_log_func_enter();
+
+    (void)G;
+    (void)f_rng;
+    (void)p_rng;
+    get_curve_type( grp->id, &curve_type, &klen );
+
+    ret = ecp_pub_key_alloc( klen, &pub_key );
+    if( ret != 0)
+    {
+        mbedtls_harden_log_err("ecp_pub_key_alloc failed! ret = 0x%x!\n", ret);
+        return( ret );
+    }
+
+    ret = ecp_priv_key_alloc( klen, &priv_key );
+    if( ret != 0)
+    {
+        mbedtls_harden_log_err("ecp_priv_key_alloc failed! ret = 0x%x!\n", ret);
+        goto cleanup_pub_key;
+    }
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x!\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup_priv_key;
+    }
+
+    ret = CIPHER_PKE_ECC_GEN_KEY( curve_type, NULL, &priv_key, &pub_key );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_ECC_GEN_KEY failed! ret = 0x%x!\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( d, priv_key.data, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &Q->MBEDTLS_PRIVATE(X), pub_key.x, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &Q->MBEDTLS_PRIVATE(Y), pub_key.y, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Q->MBEDTLS_PRIVATE(Z), 1 ) );
+cleanup:
+    CIPHER_PKE_DEINIT();
+cleanup_priv_key:
+    ecp_priv_key_free( &priv_key );
+cleanup_pub_key:
+    ecp_pub_key_free( &pub_key );
+
+    mbedtls_harden_log_func_exit();
+
+    return( ret );
+}
+#endif /* MBEDTLS_ECC_GENKEY_USE_HARDWARE */
\ No newline at end of file
diff --git a/harden/src/ecc_harden.c b/harden/src/ecc_harden.c
new file mode 100644
index 0000000..7588da9
--- /dev/null
+++ b/harden/src/ecc_harden.c
@@ -0,0 +1,524 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+#include "common.h"
+#include "ecc_genkey_harden.h"
+#include "ecdh_harden.h"
+#include "ecdsa_harden.h"
+#include "cipher_adapt.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform_util.h"
+#include "ecc_harden_common.h"
+#include "dfx.h"
+
+#define ECP_VALIDATE_RET( cond )    \
+    MBEDTLS_INTERNAL_VALIDATE_RET( cond, MBEDTLS_ERR_ECP_BAD_INPUT_DATA )
+#define ECP_VALIDATE( cond )        \
+    MBEDTLS_INTERNAL_VALIDATE( cond )
+#define ECDH_VALIDATE_RET( cond )    \
+    MBEDTLS_INTERNAL_VALIDATE_RET( cond, MBEDTLS_ERR_ECP_BAD_INPUT_DATA )
+#define ECDH_VALIDATE( cond )        \
+    MBEDTLS_INTERNAL_VALIDATE( cond )
+
+#define ECDSA_VALIDATE_RET( cond )    \
+    MBEDTLS_INTERNAL_VALIDATE_RET( cond, MBEDTLS_ERR_ECP_BAD_INPUT_DATA )
+#define ECDSA_VALIDATE( cond )        \
+    MBEDTLS_INTERNAL_VALIDATE( cond )
+
+
+static int ecdsa_sig_alloc( const unsigned int klen, drv_pke_ecc_sig *sig );
+static void ecdsa_sig_free( drv_pke_ecc_sig *sig );
+
+static int ecdsa_sig_alloc( const unsigned int klen, drv_pke_ecc_sig *sig )
+{
+    int ret;
+
+    if( sig == NULL )
+        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
+
+    sig->length = klen;
+    sig->r = mbedtls_calloc( 1, klen );
+    sig->s = mbedtls_calloc( 1, klen );
+    if( sig->r == NULL || sig->s == NULL )
+    {
+        ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
+        goto cleanup;
+    }
+
+    return( 0 );
+
+cleanup:
+    ecdsa_sig_free(sig);
+    return( ret );
+}
+
+static void ecdsa_sig_free( drv_pke_ecc_sig *sig )
+{
+    if( sig == NULL)
+        return;
+
+    if( sig->r != NULL )
+    {
+        mbedtls_platform_zeroize( sig->r, sig->length );
+        mbedtls_free( sig->r );
+        sig->r = NULL;
+    }
+    if( sig->s != NULL )
+    {
+        mbedtls_platform_zeroize( sig->s, sig->length );
+        mbedtls_free( sig->s );
+        sig->s = NULL;
+    }
+    sig->length = 0;
+}
+
+#if defined(MBEDTLS_ECC_GEN_KEY_ALT)
+int ecc_genkey_harden( mbedtls_ecp_group *grp,
+        const mbedtls_ecp_point *G,
+        mbedtls_mpi *d, mbedtls_ecp_point *Q,
+        int (*f_rng)(void *, unsigned char *, size_t),
+        void *p_rng )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    drv_pke_ecc_point pub_key;
+    drv_pke_data priv_key;
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+
+    mbedtls_harden_log_func_enter();
+
+    (void)G;
+    (void)f_rng;
+    (void)p_rng;
+    get_curve_type( grp->id, &curve_type, &klen );
+
+    ret = ecp_pub_key_alloc( klen, &pub_key );
+    if( ret != 0)
+    {
+        mbedtls_harden_log_err("ecp_pub_key_alloc failed! ret = 0x%x!\n", ret);
+        return( ret );
+    }
+
+    ret = ecp_priv_key_alloc( klen, &priv_key );
+    if( ret != 0)
+    {
+        mbedtls_harden_log_err("ecp_priv_key_alloc failed! ret = 0x%x!\n", ret);
+        goto cleanup_pub_key;
+    }
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x!\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup_priv_key;
+    }
+
+    ret = CIPHER_PKE_ECC_GEN_KEY( curve_type, NULL, &priv_key, &pub_key );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_ECC_GEN_KEY failed! ret = 0x%x!\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( d, priv_key.data, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &Q->MBEDTLS_PRIVATE(X), pub_key.x, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &Q->MBEDTLS_PRIVATE(Y), pub_key.y, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Q->MBEDTLS_PRIVATE(Z), 1 ) );
+cleanup:
+    CIPHER_PKE_DEINIT();
+cleanup_priv_key:
+    ecp_priv_key_free( &priv_key );
+cleanup_pub_key:
+    ecp_pub_key_free( &pub_key );
+
+    mbedtls_harden_log_func_exit();
+
+    return( ret );
+}
+
+int mbedtls_ecp_gen_keypair_base( mbedtls_ecp_group *grp,
+                     const mbedtls_ecp_point *G,
+                     mbedtls_mpi *d, mbedtls_ecp_point *Q,
+                     int (*f_rng)(void *, unsigned char *, size_t),
+                     void *p_rng )
+{
+    ECP_VALIDATE_RET( grp   != NULL );
+    ECP_VALIDATE_RET( d     != NULL );
+    ECP_VALIDATE_RET( G     != NULL );
+    ECP_VALIDATE_RET( Q     != NULL );
+
+    if( check_ecc_harden_can_do( grp, f_rng ) == 1 )
+    {
+        return ecc_genkey_harden( grp, G, d, Q, f_rng, p_rng );
+    }
+
+    return -1;
+}
+
+int mbedtls_ecp_gen_keypair( mbedtls_ecp_group *grp,
+                             mbedtls_mpi *d, mbedtls_ecp_point *Q,
+                             int (*f_rng)(void *, unsigned char *, size_t),
+                             void *p_rng )
+{
+    ECP_VALIDATE_RET( grp   != NULL );
+    ECP_VALIDATE_RET( d     != NULL );
+    ECP_VALIDATE_RET( Q     != NULL );
+
+    return( mbedtls_ecp_gen_keypair_base( grp, &grp->G, d, Q, f_rng, p_rng ) );
+}
+
+#if defined(MBEDTLS_ECDSA_GENKEY_ALT)
+int mbedtls_ecdsa_genkey( mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_id gid,
+                  int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
+{
+    int ret = 0;
+    ECDSA_VALIDATE_RET( ctx   != NULL );
+
+    ret = mbedtls_ecp_group_load( &ctx->grp, gid );
+    if( ret != 0 )
+        return( ret );
+
+   return( mbedtls_ecp_gen_keypair( &ctx->grp, &ctx->d,
+                                    &ctx->Q, f_rng, p_rng ) );
+}
+#endif /* MBEDTLS_ECDSA_GENKEY_ALT */
+#endif /* MBEDTLS_ECC_GEN_KEY_ALT */
+
+#if defined(MBEDTLS_ECDH_COMPUTE_SHARED_ALT)
+int ecdh_harden( mbedtls_ecp_group *grp, mbedtls_mpi *z,
+                 const mbedtls_ecp_point *Q, const mbedtls_mpi *d,
+                 int (*f_rng)(void *, unsigned char *, size_t),
+                 void *p_rng )
+{
+    int ret;
+    drv_pke_data priv_key;
+    drv_pke_ecc_point pub_key;
+    drv_pke_data shared_key;
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+    size_t byte_length;
+
+    mbedtls_harden_log_func_enter();
+
+    (void)f_rng;
+    (void)p_rng;
+
+    get_curve_type( grp->id, &curve_type, &klen);
+
+    ret = ecp_pub_key_create( curve_type, klen, Q, &pub_key );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecp_pub_key_create failed!\n");
+        return( ret );
+    }
+
+    ret = ecp_priv_key_create( curve_type, klen, d, &priv_key );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecp_priv_key_create failed!\n");
+        goto cleanup_pub_key;
+    }
+
+    shared_key.length = klen;
+    shared_key.data = mbedtls_calloc( 1, klen );
+    if( shared_key.data == NULL )
+    {
+        mbedtls_harden_log_err("mbedtls_calloc failed!\n");
+        ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
+        goto cleanup_priv_key;
+    }
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup_shared_key;
+    }
+
+    ret = CIPHER_PKE_ECC_GEN_ECDH_KEY( curve_type, &pub_key, &priv_key, &shared_key);
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_ECC_GEN_ECDH_KEY failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    byte_length = grp->pbits / 8 + ( ( grp->pbits % 8 ) != 0 );
+    if ( grp->id == MBEDTLS_ECP_DP_CURVE25519 )
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( z, shared_key.data, byte_length ) );
+    /* 
+        The alignment length of 521 bits is 68 bytes in the chip and 66 bytes in the mbedtls.
+        Therefore, 0s of the first 2 bytes need to be removed.
+    */
+    else if (grp->id == MBEDTLS_ECP_DP_SECP521R1 )
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( z, shared_key.data + 2, byte_length ) );
+    else
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( z, shared_key.data, byte_length ) );
+
+cleanup:
+    CIPHER_PKE_DEINIT();
+cleanup_shared_key:
+    if( shared_key.data != NULL )
+    {
+        mbedtls_platform_zeroize( shared_key.data, shared_key.length);
+        mbedtls_free( shared_key.data );
+    }
+cleanup_priv_key:
+    ecp_priv_key_free( &priv_key );
+cleanup_pub_key:
+    ecp_pub_key_free( &pub_key );
+    mbedtls_harden_log_func_exit();
+
+    return( ret );
+}
+
+int mbedtls_ecdh_compute_shared( mbedtls_ecp_group *grp, mbedtls_mpi *z,
+                         const mbedtls_ecp_point *Q, const mbedtls_mpi *d,
+                         int (*f_rng)(void *, unsigned char *, size_t),
+                         void *p_rng )
+{
+    ECDH_VALIDATE_RET( grp != NULL );
+    ECDH_VALIDATE_RET( Q != NULL );
+    ECDH_VALIDATE_RET( d != NULL );
+    ECDH_VALIDATE_RET( z != NULL );
+
+    if( check_ecc_harden_can_do( grp, NULL ) == 1 )
+    {
+        return ecdh_harden( grp, z, Q, d, f_rng, p_rng );
+    }
+    return -1;
+}
+#endif /* MBEDTLS_ECDH_COMPUTE_SHARED_ALT */
+
+#if defined(MBEDTLS_ECDSA_SIGN_ALT)
+int check_ecdsa_sign_harden_can_do( mbedtls_ecp_group *grp,
+    int (*f_rng)(void *, unsigned char *, size_t), size_t blen )
+{
+    if( check_ecc_harden_can_do( grp, f_rng ) != 1 || blen < 20 || blen > 64 )
+        return( 0 );
+
+    switch( grp->id )
+    {
+#ifdef MBEDTLS_ECP_DP_CURVE25519_ENABLED
+        case MBEDTLS_ECP_DP_CURVE25519:
+            return 0;
+#endif
+#ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
+        case MBEDTLS_ECP_DP_CURVE448:
+            return 0;
+#endif
+        default:
+            return 1;
+    }
+}
+
+int ecdsa_sign_harden( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
+                const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
+                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
+{
+    int ret;
+    drv_pke_ecc_sig sig;
+    drv_pke_data priv_key;
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+    drv_pke_data input = {0};
+
+    mbedtls_harden_log_func_enter();
+
+    (void)f_rng;
+    (void)p_rng;
+
+    get_curve_type( grp->id, &curve_type, &klen);
+
+    ret = ecp_priv_key_create( curve_type, klen, d, &priv_key );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecp_priv_key_create failed!\n");
+        return( ret );
+    }
+
+    ret = ecdsa_sig_alloc( klen, &sig );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecdsa_sig_alloc failed!\n");
+        goto cleanup_priv_key;
+    }
+
+    input.data = (unsigned char *) buf;
+    input.length = blen;
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup_sig;
+    }
+    ret = CIPHER_PKE_ECDSA_SIGN( curve_type, &priv_key, &input, &sig );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_ECDSA_SIGN failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( r, sig.r, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( s, sig.s, klen ) );
+
+cleanup:
+    CIPHER_PKE_DEINIT();
+cleanup_sig:
+    ecdsa_sig_free( &sig );
+cleanup_priv_key:
+    ecp_priv_key_free( &priv_key );
+
+    mbedtls_harden_log_func_exit();
+    return( ret );
+}
+
+int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
+                const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
+                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
+{
+    ECDSA_VALIDATE_RET( grp   != NULL );
+    ECDSA_VALIDATE_RET( r     != NULL );
+    ECDSA_VALIDATE_RET( s     != NULL );
+    ECDSA_VALIDATE_RET( d     != NULL );
+    ECDSA_VALIDATE_RET( buf   != NULL || blen == 0 );
+
+    if( check_ecdsa_sign_harden_can_do( grp, f_rng, blen ) == 1 )
+    {
+        return ecdsa_sign_harden( grp, r, s, d, buf, blen, f_rng, p_rng );
+    }
+    return( -1 );
+}
+#endif /* MBEDTLS_ECDSA_SIGN_ALT */
+
+#if defined(MBEDTLS_ECDSA_VERIFY_ALT)
+static int check_hash_zero( const unsigned char *buf, size_t blen )
+{
+    int ret = 1;
+    size_t i = 0;
+    for( i = 0; i < blen; i++ )
+    {
+        if( buf[i] != 0 )
+        {
+            ret = 0;
+            break;
+        }
+    }
+    return ret;
+}
+
+int check_ecdsa_verify_harden_can_do( mbedtls_ecp_group *grp, const unsigned char *buf, size_t blen )
+{
+    if( check_ecc_harden_can_do( grp, NULL ) != 1 || blen < 20 || blen > 64 ||
+        check_hash_zero( buf, blen ) == 1 )
+        return( 0 );
+
+    switch( grp->id )
+    {
+#ifdef MBEDTLS_ECP_DP_CURVE25519_ENABLED
+        case MBEDTLS_ECP_DP_CURVE25519:
+            return 0;
+#endif
+#ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
+        case MBEDTLS_ECP_DP_CURVE448:
+            return 0;
+#endif
+        default:
+            return 1;
+    }
+}
+
+int ecdsa_verify_harden( mbedtls_ecp_group *grp,
+        const unsigned char *buf, size_t blen,
+        const mbedtls_ecp_point *Q,
+        const mbedtls_mpi *r,
+        const mbedtls_mpi *s)
+{
+    int ret;
+    drv_pke_ecc_sig sig;
+    drv_pke_ecc_point pub_key;
+    drv_pke_data input;
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+
+    mbedtls_harden_log_func_enter();
+
+    get_curve_type( grp->id, &curve_type, &klen);
+
+    ret = ecp_pub_key_create( curve_type, klen, Q, &pub_key );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecp_pub_key_create failed!\n");
+        return( ret );
+    }
+
+    ret = ecdsa_sig_alloc( klen, &sig );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecdsa_sig_alloc failed!\n");
+        goto cleanup_pub_key;
+    }
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup_sig;
+    }
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( r, sig.r, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( s, sig.s, klen ) );
+
+    input.data = (unsigned char *) buf;
+    input.length = blen;
+
+    ret = CIPHER_PKE_ECDSA_VERIFY( curve_type, &pub_key, &input, &sig );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_ECDSA_VERIFY failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
+        goto cleanup;
+    }
+
+    ret = 0;
+
+cleanup:
+    CIPHER_PKE_DEINIT();
+cleanup_sig:
+    ecdsa_sig_free( &sig );
+cleanup_pub_key:
+    ecp_pub_key_free( &pub_key );
+
+    mbedtls_harden_log_func_exit();
+    return( ret );
+}
+
+int mbedtls_ecdsa_verify( mbedtls_ecp_group *grp,
+                          const unsigned char *buf, size_t blen,
+                          const mbedtls_ecp_point *Q,
+                          const mbedtls_mpi *r,
+                          const mbedtls_mpi *s)
+{
+    ECDSA_VALIDATE_RET( grp != NULL );
+    ECDSA_VALIDATE_RET( Q   != NULL );
+    ECDSA_VALIDATE_RET( r   != NULL );
+    ECDSA_VALIDATE_RET( s   != NULL );
+    ECDSA_VALIDATE_RET( buf != NULL || blen == 0 );
+
+    if( check_ecdsa_verify_harden_can_do( grp, buf, blen ) == 1 )
+    {
+        return ecdsa_verify_harden( grp, buf, blen, Q, r, s );
+    }
+    return( -1 );
+}
+#endif /* MBEDTLS_ECDSA_VERIFY_ALT */
\ No newline at end of file
diff --git a/harden/src/ecc_harden_common.c b/harden/src/ecc_harden_common.c
new file mode 100644
index 0000000..8f2e0c4
--- /dev/null
+++ b/harden/src/ecc_harden_common.c
@@ -0,0 +1,224 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "ecc_harden_common.h"
+#include "mbedtls/platform.h"
+#include "mbedtls/platform_util.h"
+#include "common.h"
+#include "mbedtls_platform_hardware_config.h"
+
+typedef struct {
+    mbedtls_ecp_group_id group_id;
+    drv_pke_ecc_curve_type curve_type;
+    unsigned int klen;
+} curve_info;
+
+static const curve_info g_curve_info_table[] = {
+    { MBEDTLS_ECP_DP_NONE,       DRV_PKE_ECC_TYPE_INVALID,      0               },
+#if defined(MBEDTLS_SECP192R1_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_SECP192R1,  DRV_PKE_ECC_TYPE_FIPS_P192R,   DRV_PKE_LEN_192 },
+#endif
+#if defined(MBEDTLS_SECP224R1_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_SECP224R1,  DRV_PKE_ECC_TYPE_FIPS_P224R,   DRV_PKE_LEN_224 },
+#endif
+#if defined(MBEDTLS_SECP256R1_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_SECP256R1,  DRV_PKE_ECC_TYPE_FIPS_P256R,   DRV_PKE_LEN_256 },
+#endif
+#if defined(MBEDTLS_SECP384R1_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_SECP384R1,  DRV_PKE_ECC_TYPE_FIPS_P384R,   DRV_PKE_LEN_384 },
+#endif
+#if defined(MBEDTLS_SECP521R1_USE_HARDWARE)
+#if defined(HARDWARE_521_ALIGN_576_LEN)
+    { MBEDTLS_ECP_DP_SECP521R1,  DRV_PKE_ECC_TYPE_FIPS_P521R,   DRV_PKE_LEN_576 },
+#else
+    { MBEDTLS_ECP_DP_SECP521R1,  DRV_PKE_ECC_TYPE_FIPS_P521R,   DRV_PKE_LEN_521 },
+#endif
+#endif
+#if defined(MBEDTLS_BP256R1_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_BP256R1,    DRV_PKE_ECC_TYPE_RFC5639_P256, DRV_PKE_LEN_256 },
+#endif
+#if defined(MBEDTLS_BP384R1_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_BP384R1,    DRV_PKE_ECC_TYPE_RFC5639_P384, DRV_PKE_LEN_384 },
+#endif
+#if defined(MBEDTLS_BP512R1_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_BP512R1,    DRV_PKE_ECC_TYPE_RFC5639_P512, DRV_PKE_LEN_512 },
+#endif
+#if defined(MBEDTLS_CURVE25519_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_CURVE25519, DRV_PKE_ECC_TYPE_RFC7748,      DRV_PKE_LEN_256 },
+#endif
+#if defined(MBEDTLS_SECP256K1_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_SECP256K1,  DRV_PKE_ECC_TYPE_FIPS_P256K,   DRV_PKE_LEN_256 },
+#endif
+#if defined(MBEDTLS_CURVE448_USE_HARDWARE)
+    { MBEDTLS_ECP_DP_CURVE448,   DRV_PKE_ECC_TYPE_RFC7748_448,  DRV_PKE_LEN_448 },
+#endif
+};
+
+void get_curve_type( mbedtls_ecp_group_id grp_id, drv_pke_ecc_curve_type *curve_type, unsigned int *klen )
+{
+    unsigned int i = 0;
+    for (i = 0; i < sizeof(g_curve_info_table) / sizeof(g_curve_info_table[0]); i++) {
+        if (g_curve_info_table[i].group_id == grp_id) {
+            *curve_type = g_curve_info_table[i].curve_type;
+            *klen = g_curve_info_table[i].klen;
+            return;
+        }
+    }
+    *curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    *klen = 0;
+}
+
+int check_ecc_harden_can_do( mbedtls_ecp_group *grp, int (*f_rng)(void *, unsigned char *, size_t) )
+{
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+
+    if( IS_PKE_ECC_FUNC_REGISTERED() != TD_TRUE || IS_HASH_FUNC_REGISTERED() != TD_TRUE )
+        return ( 0 );
+
+    (void)f_rng;
+
+    get_curve_type( grp->id, &curve_type, &klen );
+    return curve_type != DRV_PKE_ECC_TYPE_INVALID;
+}
+
+int ecp_priv_key_alloc( const unsigned int klen, drv_pke_data *priv_key )
+{
+    int ret;
+
+    if( priv_key == NULL )
+        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
+
+    priv_key->length = klen;
+    priv_key->data = mbedtls_calloc( 1, klen );
+    if( priv_key->data == NULL )
+    {
+        ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
+        goto cleanup;
+    }
+
+    return( 0 );
+
+cleanup:
+    ecp_priv_key_free(priv_key);
+    return( ret );
+}
+
+void ecp_priv_key_free( drv_pke_data *priv_key )
+{
+    if( priv_key == NULL)
+        return;
+
+    if( priv_key->data != NULL )
+    {
+        mbedtls_platform_zeroize( priv_key->data, priv_key->length );
+        mbedtls_free( priv_key->data );
+        priv_key->data = NULL;
+    }
+    priv_key->length = 0;
+}
+
+int ecp_pub_key_alloc( const unsigned int klen, drv_pke_ecc_point *pub_key )
+{
+    int ret;
+
+    if( pub_key == NULL )
+        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
+
+    pub_key->length = klen;
+    pub_key->x = mbedtls_calloc( 1, klen );
+    pub_key->y = mbedtls_calloc( 1, klen );
+    if( pub_key->x == NULL || pub_key->y == NULL )
+    {
+        ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
+        goto cleanup;
+    }
+
+    return( 0 );
+
+cleanup:
+    ecp_pub_key_free(pub_key);
+    return( ret );
+}
+
+void ecp_pub_key_free( drv_pke_ecc_point *pub_key )
+{
+    if( pub_key == NULL)
+        return;
+
+    if( pub_key->x != NULL )
+    {
+        mbedtls_platform_zeroize( pub_key->x, pub_key->length );
+        mbedtls_free( pub_key->x );
+        pub_key->x = NULL;
+    }
+    if( pub_key->y != NULL )
+    {
+        mbedtls_platform_zeroize( pub_key->y, pub_key->length );
+        mbedtls_free( pub_key->y );
+        pub_key->y = NULL;
+    }
+    pub_key->length = 0;
+}
+
+int ecp_priv_key_create( drv_pke_ecc_curve_type ecc_type, unsigned int klen, const mbedtls_mpi *d,
+                                  drv_pke_data *priv_key )
+{
+    int ret;
+
+    if( d == NULL )
+        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA);
+
+    ret = ecp_priv_key_alloc( klen, priv_key );
+    if( ret != 0 )
+        return( ret );
+
+    if( ecc_type == DRV_PKE_ECC_TYPE_RFC7748 )
+    {
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( d, priv_key->data, klen ) );
+    }
+    else
+    {
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( d, priv_key->data, klen ) );
+    }
+
+    return( 0 );
+
+cleanup:
+    ecp_priv_key_free(priv_key);
+    return( ret );
+}
+
+int ecp_pub_key_create( drv_pke_ecc_curve_type ecc_type, unsigned int klen, const mbedtls_ecp_point *pub,
+                        drv_pke_ecc_point *pub_key )
+{
+    int ret;
+
+    if( pub == NULL )
+        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
+
+    ret = ecp_pub_key_alloc( klen, pub_key );
+    if( ret != 0 )
+        return( ret );
+
+    if( ecc_type == DRV_PKE_ECC_TYPE_RFC7748 )
+    {
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( &pub->MBEDTLS_PRIVATE(X), pub_key->x, klen ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( &pub->MBEDTLS_PRIVATE(Y), pub_key->y, klen ) );
+    }
+    else
+    {
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &pub->MBEDTLS_PRIVATE(X), pub_key->x, klen ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &pub->MBEDTLS_PRIVATE(Y), pub_key->y, klen ) );
+    }
+
+    return( 0 );
+
+cleanup:
+    ecp_pub_key_free( pub_key );
+    return( ret );
+}
\ No newline at end of file
diff --git a/harden/src/ecdh_harden.c b/harden/src/ecdh_harden.c
new file mode 100644
index 0000000..92eff87
--- /dev/null
+++ b/harden/src/ecdh_harden.c
@@ -0,0 +1,105 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "ecdh_harden.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform_util.h"
+#include "cipher_adapt.h"
+#include "dfx.h"
+#include "ecc_harden_common.h"
+
+#if defined(MBEDTLS_ECDH_USE_HARDWARE)
+
+int ecdh_harden( mbedtls_ecp_group *grp, mbedtls_mpi *z,
+                 const mbedtls_ecp_point *Q, const mbedtls_mpi *d,
+                 int (*f_rng)(void *, unsigned char *, size_t),
+                 void *p_rng )
+{
+    int ret;
+    drv_pke_data priv_key;
+    drv_pke_ecc_point pub_key;
+    drv_pke_data shared_key;
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+    size_t byte_length;
+
+    mbedtls_harden_log_func_enter();
+
+    (void)f_rng;
+    (void)p_rng;
+
+    get_curve_type( grp->id, &curve_type, &klen);
+
+    ret = ecp_pub_key_create( curve_type, klen, Q, &pub_key );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecp_pub_key_create failed!\n");
+        return( ret );
+    }
+
+    ret = ecp_priv_key_create( curve_type, klen, d, &priv_key );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecp_priv_key_create failed!\n");
+        goto cleanup_pub_key;
+    }
+
+    shared_key.length = klen;
+    shared_key.data = mbedtls_calloc( 1, klen );
+    if( shared_key.data == NULL )
+    {
+        mbedtls_harden_log_err("mbedtls_calloc failed!\n");
+        ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
+        goto cleanup_priv_key;
+    }
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup_shared_key;
+    }
+
+    ret = CIPHER_PKE_ECC_GEN_ECDH_KEY( curve_type, &pub_key, &priv_key, &shared_key);
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_ECC_GEN_ECDH_KEY failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    byte_length = grp->pbits / 8 + ( ( grp->pbits % 8 ) != 0 );
+    if ( grp->id == MBEDTLS_ECP_DP_CURVE25519 )
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( z, shared_key.data, byte_length ) );
+    /* 
+        The alignment length of 521 bits is 68 bytes in the chip and 66 bytes in the mbedtls.
+        Therefore, 0s of the first 2 bytes need to be removed.
+    */
+    else if (grp->id == MBEDTLS_ECP_DP_SECP521R1 )
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( z, shared_key.data + 2, byte_length ) );
+    else
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( z, shared_key.data, byte_length ) );
+
+cleanup:
+    CIPHER_PKE_DEINIT();
+cleanup_shared_key:
+    if( shared_key.data != NULL )
+    {
+        mbedtls_platform_zeroize( shared_key.data, shared_key.length);
+        mbedtls_free( shared_key.data );
+    }
+cleanup_priv_key:
+    ecp_priv_key_free( &priv_key );
+cleanup_pub_key:
+    ecp_pub_key_free( &pub_key );
+    mbedtls_harden_log_func_exit();
+
+    return( ret );
+}
+
+#endif /* MBEDTLS_ECDH_USE_HARDWARE */
\ No newline at end of file
diff --git a/harden/src/ecdsa_harden.c b/harden/src/ecdsa_harden.c
new file mode 100644
index 0000000..b70d367
--- /dev/null
+++ b/harden/src/ecdsa_harden.c
@@ -0,0 +1,252 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "ecdsa_harden.h"
+#include "cipher_adapt.h"
+#include "mbedtls/error.h"
+#include "dfx.h"
+#include "ecc_harden_common.h"
+#include "mbedtls/platform_util.h"
+
+static int ecdsa_sig_alloc( const unsigned int klen, drv_pke_ecc_sig *sig );
+static void ecdsa_sig_free( drv_pke_ecc_sig *sig );
+
+static int ecdsa_sig_alloc( const unsigned int klen, drv_pke_ecc_sig *sig )
+{
+    int ret;
+
+    if( sig == NULL )
+        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
+
+    sig->length = klen;
+    sig->r = mbedtls_calloc( 1, klen );
+    sig->s = mbedtls_calloc( 1, klen );
+    if( sig->r == NULL || sig->s == NULL )
+    {
+        ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
+        goto cleanup;
+    }
+
+    return( 0 );
+
+cleanup:
+    ecdsa_sig_free(sig);
+    return( ret );
+}
+
+static void ecdsa_sig_free( drv_pke_ecc_sig *sig )
+{
+    if( sig == NULL)
+        return;
+
+    if( sig->r != NULL )
+    {
+        mbedtls_platform_zeroize( sig->r, sig->length );
+        mbedtls_free( sig->r );
+        sig->r = NULL;
+    }
+    if( sig->s != NULL )
+    {
+        mbedtls_platform_zeroize( sig->s, sig->length );
+        mbedtls_free( sig->s );
+        sig->s = NULL;
+    }
+    sig->length = 0;
+}
+
+#if defined(MBEDTLS_ECDSA_SIGN_USE_HARDWARE)
+
+int check_ecdsa_sign_harden_can_do( mbedtls_ecp_group *grp,
+    int (*f_rng)(void *, unsigned char *, size_t), size_t blen )
+{
+    if( check_ecc_harden_can_do( grp, f_rng ) != 1 || blen < 20 || blen > 64 )
+        return( 0 );
+
+    switch( grp->id )
+    {
+#ifdef MBEDTLS_ECP_DP_CURVE25519_ENABLED
+        case MBEDTLS_ECP_DP_CURVE25519:
+            return 0;
+#endif
+#ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
+        case MBEDTLS_ECP_DP_CURVE448:
+            return 0;
+#endif
+        default:
+            return 1;
+    }
+}
+
+int ecdsa_sign_harden( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
+                const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
+                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
+{
+    int ret;
+    drv_pke_ecc_sig sig;
+    drv_pke_data priv_key;
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+    drv_pke_data input = {0};
+
+    mbedtls_harden_log_func_enter();
+
+    (void)f_rng;
+    (void)p_rng;
+
+    get_curve_type( grp->id, &curve_type, &klen);
+
+    ret = ecp_priv_key_create( curve_type, klen, d, &priv_key );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecp_priv_key_create failed!\n");
+        return( ret );
+    }
+
+    ret = ecdsa_sig_alloc( klen, &sig );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecdsa_sig_alloc failed!\n");
+        goto cleanup_priv_key;
+    }
+
+    input.data = (unsigned char *) buf;
+    input.length = blen;
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup_sig;
+    }
+    ret = CIPHER_PKE_ECDSA_SIGN( curve_type, &priv_key, &input, &sig );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_ECDSA_SIGN failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup;
+    }
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( r, sig.r, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( s, sig.s, klen ) );
+
+cleanup:
+    CIPHER_PKE_DEINIT();
+cleanup_sig:
+    ecdsa_sig_free( &sig );
+cleanup_priv_key:
+    ecp_priv_key_free( &priv_key );
+
+    mbedtls_harden_log_func_exit();
+    return( ret );
+}
+
+#endif /* MBEDTLS_ECDSA_SIGN_USE_HARDWARE */
+
+#if defined(MBEDTLS_ECDSA_VERIFY_USE_HARDWARE)
+static int check_hash_zero( const unsigned char *buf, size_t blen )
+{
+    int ret = 1;
+    size_t i = 0;
+    for( i = 0; i < blen; i++ )
+    {
+        if( buf[i] != 0 )
+        {
+            ret = 0;
+            break;
+        }
+    }
+    return ret;
+}
+
+int check_ecdsa_verify_harden_can_do( mbedtls_ecp_group *grp, const unsigned char *buf, size_t blen )
+{
+    if( check_ecc_harden_can_do( grp, NULL ) != 1 || blen < 20 || blen > 64 ||
+        check_hash_zero( buf, blen ) == 1 )
+        return( 0 );
+
+    switch( grp->id )
+    {
+#ifdef MBEDTLS_ECP_DP_CURVE25519_ENABLED
+        case MBEDTLS_ECP_DP_CURVE25519:
+            return 0;
+#endif
+#ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
+        case MBEDTLS_ECP_DP_CURVE448:
+            return 0;
+#endif
+        default:
+            return 1;
+    }
+}
+
+int ecdsa_verify_harden( mbedtls_ecp_group *grp,
+        const unsigned char *buf, size_t blen,
+        const mbedtls_ecp_point *Q,
+        const mbedtls_mpi *r,
+        const mbedtls_mpi *s)
+{
+    int ret;
+    drv_pke_ecc_sig sig;
+    drv_pke_ecc_point pub_key;
+    drv_pke_data input;
+    drv_pke_ecc_curve_type curve_type = DRV_PKE_ECC_TYPE_INVALID;
+    unsigned int klen = 0;
+
+    mbedtls_harden_log_func_enter();
+
+    get_curve_type( grp->id, &curve_type, &klen);
+
+    ret = ecp_pub_key_create( curve_type, klen, Q, &pub_key );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecp_pub_key_create failed!\n");
+        return( ret );
+    }
+
+    ret = ecdsa_sig_alloc( klen, &sig );
+    if( ret != 0 )
+    {
+        mbedtls_harden_log_err("ecdsa_sig_alloc failed!\n");
+        goto cleanup_pub_key;
+    }
+
+    ret = CIPHER_PKE_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_INIT failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
+        goto cleanup_sig;
+    }
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( r, sig.r, klen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( s, sig.s, klen ) );
+
+    input.data = (unsigned char *) buf;
+    input.length = blen;
+
+    ret = CIPHER_PKE_ECDSA_VERIFY( curve_type, &pub_key, &input, &sig );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PKE_ECDSA_VERIFY failed! ret = 0x%x\n", ret);
+        ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
+        goto cleanup;
+    }
+
+    ret = 0;
+
+cleanup:
+    CIPHER_PKE_DEINIT();
+cleanup_sig:
+    ecdsa_sig_free( &sig );
+cleanup_pub_key:
+    ecp_pub_key_free( &pub_key );
+
+    mbedtls_harden_log_func_exit();
+    return( ret );
+}
+#endif /* MBEDTLS_ECDSA_VERIFY_USE_HARDWARE */
\ No newline at end of file
diff --git a/harden/src/entropy_harden.c b/harden/src/entropy_harden.c
new file mode 100644
index 0000000..75dc725
--- /dev/null
+++ b/harden/src/entropy_harden.c
@@ -0,0 +1,48 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "common.h"
+
+#if defined(MBEDTLS_ENTROPY_C) && defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
+#include "mbedtls/error.h"
+#include "mbedtls/entropy.h"
+#include "entropy_poll.h"
+#include "cipher_adapt.h"
+#include "dfx.h"
+
+int mbedtls_hardware_poll( void *data, unsigned char *output, size_t len, size_t *olen )
+{
+    int ret;
+
+    mbedtls_harden_log_func_enter();
+
+    if( IS_TRNG_FUNC_REGISTERED() != TD_TRUE )
+#if !defined(MBEDTLS_NO_PLATFORM_ENTROPY)
+        return mbedtls_platform_entropy_poll( data, output, len, olen );
+#else
+        return ( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+#endif
+
+    if( len == 0 || olen == NULL || output == NULL )
+        return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );
+
+    (void) data;
+
+    ret = CIPHER_TRNG_GET_MULTI_RANDOM( len, output );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_TRNG_GET_MULTI_RANDOM failed, ret = 0x%x!\n", ret );
+        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+    }
+    *olen = len;
+
+    mbedtls_harden_log_func_exit();
+
+    return( 0 );
+}
+
+#endif /* MBEDTLS_ENTROPY_C && MBEDTLS_ENTROPY_HARDWARE_ALT */
\ No newline at end of file
diff --git a/harden/src/gcm_harden.c b/harden/src/gcm_harden.c
new file mode 100644
index 0000000..c78444e
--- /dev/null
+++ b/harden/src/gcm_harden.c
@@ -0,0 +1,469 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+#include "common.h"
+#include "mbedtls/gcm.h"
+#include "mbedtls/error.h"
+#include "gcm_harden.h"
+#include "cipher_common.h"
+#include "dfx.h"
+
+#if defined(MBEDTLS_GCM_ALT)
+
+#define GCM_VALIDATE_RET( cond ) \
+    MBEDTLS_INTERNAL_VALIDATE_RET( cond, MBEDTLS_ERR_GCM_BAD_INPUT )
+#define GCM_VALIDATE( cond ) \
+    MBEDTLS_INTERNAL_VALIDATE( cond )
+
+static gcm_harden_context g_gcm_harden_context[MAX_GCM_HARD_CTX_NUM] = {0};
+
+static gcm_harden_context * get_gcm_harden_ctx( mbedtls_gcm_context *ctx )
+{
+    unsigned int i = 0;
+    for( i = 0; i < MAX_GCM_HARD_CTX_NUM; ++i )
+    {
+        if( g_gcm_harden_context[i].ctx == ctx )
+        {
+            return &g_gcm_harden_context[i];
+        }
+    }
+    return NULL;
+}
+
+static void internal_release_hard_resource( gcm_harden_context *harden_ctx )
+{
+    if( harden_ctx->symc_handle != 0 )
+    {
+        ( void )CIPHER_SYMC_DESTROY( harden_ctx->symc_handle );
+        harden_ctx->symc_handle = 0;
+    }
+    if( harden_ctx->keyslot_handle != 0 )
+    {
+        ( void )CIPHER_DESTROY_KEYSLOT( harden_ctx->keyslot_handle );
+        harden_ctx->keyslot_handle = 0;
+    }
+}
+
+void mbedtls_gcm_init_harden( mbedtls_gcm_context *ctx )
+{
+    int i = 0;
+    int ret = 0;
+
+    if( IS_SYMC_FUNC_REGISTERED() != TD_TRUE )
+        return;
+
+    ret = CIPHER_SYMC_INIT();
+    if( ret != 0 ) {
+        mbedtls_harden_log_err( "CIPHER_SYMC_INIT faild!\n" );
+        return;
+    }
+
+    ret = KM_INIT();
+    if( ret != 0 ) {
+        CIPHER_SYMC_DEINIT();
+        mbedtls_harden_log_err( "KM_INIT faild!\n" );
+        return;
+    }
+
+    for( i = 0; i < MAX_GCM_HARD_CTX_NUM; ++i )
+    {
+        if( g_gcm_harden_context[i].is_used == 0 ) {
+            g_gcm_harden_context[i].ctx = ctx;
+            g_gcm_harden_context[i].is_used = 1;
+            g_gcm_harden_context[i].only_software_support = 0;
+            g_gcm_harden_context[i].is_set_config = 0;
+            g_gcm_harden_context[i].is_software_update_ad = 0;
+            break;
+        }
+    }
+}
+
+int mbedtls_gcm_setkey_harden( mbedtls_gcm_context *ctx,
+                                mbedtls_cipher_id_t cipher,
+                                const unsigned char *key,
+                                unsigned int keybits )
+{
+    gcm_harden_context *harden_ctx;
+    harden_ctx = get_gcm_harden_ctx( ctx );
+    if( harden_ctx == NULL )
+        return -1;
+    harden_ctx->key_length = keybits / 8;
+    memcpy( harden_ctx->key, key, keybits / 8 );
+    harden_ctx->only_software_support = 0;
+    if( cipher == MBEDTLS_CIPHER_ID_CAMELLIA )
+        harden_ctx->only_software_support = 1;
+#if !defined( MBEDTLS_AES_192_HARD_KEY_SUPPORT )
+        if( keybits == 192 )
+            harden_ctx->only_software_support = 1;
+#endif
+    return 0;
+}
+
+/*
+ * GCM hardware start
+ */
+int mbedtls_gcm_start_harden( mbedtls_gcm_context *ctx,
+                                int mode,
+                                const unsigned char *iv,
+                                size_t iv_len )
+{
+    int ret = 0;
+    gcm_harden_context *harden_ctx;
+    crypto_symc_attr symc_attr = { 
+        .symc_type = CRYPTO_SYMC_TYPE_NORMAL,
+        .is_long_term = 0
+    };
+
+    harden_ctx = get_gcm_harden_ctx( ctx );
+    if( harden_ctx == NULL || harden_ctx->only_software_support == 1 )
+        return ( -1 );
+    if( iv_len > 16 )
+    {
+        ret = -1;
+        goto exit_set_ctx;
+    }
+    harden_ctx->iv_len = iv_len;
+    harden_ctx->mode = mode;
+    memcpy( harden_ctx->iv, iv, iv_len );
+
+    internal_release_hard_resource( harden_ctx );
+
+    ret = CIPHER_SYMC_CREATE( &harden_ctx->symc_handle, &symc_attr );
+    if( ret != 0 ) {
+        mbedtls_harden_log_err( "CIPHER_SYMC_CREATE faild!\n" );
+        goto exit_set_ctx;
+    }
+    ret = CIPHER_CREATE_KEYSLOT( &harden_ctx->keyslot_handle, KM_KEYSLOT_ENGINE_AES);
+    if( ret != 0 ) {
+        mbedtls_harden_log_err( "CIPHRE_CREATE_KEYSLOT faild!\n" );
+        goto exit_cipher_destroy;
+    }
+    ret = CIPHER_SET_CLEAR_KEY( harden_ctx->keyslot_handle, harden_ctx->key, harden_ctx->key_length,
+        KM_KEYSLOT_ENGINE_AES );
+    if( ret != 0 ) {
+        mbedtls_harden_log_err( "CIPHER_SET_CLEAR_KEY faild!\n" );
+        goto exit_destroy_keyslot;
+    }
+    ret = CIPHER_SYMC_ATTACH( harden_ctx->symc_handle, harden_ctx->keyslot_handle );
+    if( ret != 0 ) {
+        mbedtls_harden_log_err( "CIPHER_SYMC_ATTACH faild!\n" );
+        goto exit_destroy_keyslot;
+    }
+    return ( 0 );
+
+exit_destroy_keyslot:
+    CIPHER_DESTROY_KEYSLOT( harden_ctx->keyslot_handle );
+exit_cipher_destroy:
+    CIPHER_SYMC_DESTROY( harden_ctx->symc_handle );
+exit_set_ctx:
+    harden_ctx->only_software_support = 1;
+    return ret;
+}
+
+/*
+ * GCM hardware cache add
+ */
+int mbedtls_gcm_update_ad_harden( mbedtls_gcm_context *ctx,
+                                const unsigned char *add,
+                                size_t add_len )
+{
+    gcm_harden_context *harden_ctx;
+    harden_ctx = get_gcm_harden_ctx( ctx );
+    if( harden_ctx == NULL || harden_ctx->only_software_support == 1 )
+        return ( -1 );
+    if( harden_ctx->add_len + add_len > MBEDTLS_CIPHER_MAX_ADD_LEN )
+    {
+        harden_ctx->only_software_support = 1;
+        return ( -1 );
+    }
+    memcpy( harden_ctx->add + harden_ctx->add_len, add, add_len );
+    harden_ctx->add_len += add_len;
+    return ( 0 );
+}
+
+/*
+ * GCM hardware update
+ */
+int mbedtls_gcm_update_harden( mbedtls_gcm_context *ctx,
+                                const unsigned char *input, size_t input_length,
+                                unsigned char *output )
+{
+    int ret = 0;
+    unsigned long in_phys_addr;
+    unsigned long out_phys_addr;
+    crypto_buf_attr in_buf;
+    crypto_buf_attr out_buf;
+    gcm_harden_context *harden_ctx;
+
+    harden_ctx = get_gcm_harden_ctx( ctx );
+    if( harden_ctx == NULL || harden_ctx->only_software_support == 1 )
+        return ( -1 );
+    if( CIPHER_GET_PHYS_MEM( ( void * )input, &in_phys_addr ) != 0 ||
+        CIPHER_GET_PHYS_MEM( output, &out_phys_addr ) != 0 )
+    {
+        harden_ctx->only_software_support = 1;
+        return ( -1 );
+    }
+    if( harden_ctx->is_set_config == 0 )
+    {
+        ret = mbedtls_cipher_set_ctrl( &harden_ctx->symc_ctrl, CRYPTO_SYMC_ALG_AES, CRYPTO_SYMC_WORK_MODE_GCM,
+            harden_ctx->key_length, CRYPTO_SYMC_BIT_WIDTH_128BIT, CRYPTO_SYMC_GCM_IV_CHANGE_START,
+            harden_ctx->iv, harden_ctx->iv_len );
+        if( ret != 0 )
+            return ret;
+        ret = mbedtls_cipher_set_gcm_ccm_config( &harden_ctx->gcm_config, harden_ctx->add, harden_ctx->add_len,
+            0, 16 );
+        if( ret != 0 )
+            return ret;
+        harden_ctx->symc_ctrl.param = ( void * )&harden_ctx->gcm_config;
+        ret = CIPHER_SYMC_SET_CONFIG( harden_ctx->symc_handle, &harden_ctx->symc_ctrl );
+        if( ret != 0 )
+        {
+            mbedtls_harden_log_err( "CIPHER_SYMC_SET_CONFIG faild!\n" );
+            return ret;
+        }
+        harden_ctx->is_set_config = 1;
+    }
+    in_buf.virt_addr = (void *)input;
+    in_buf.phys_addr = in_phys_addr;
+    out_buf.virt_addr = output;
+    out_buf.phys_addr = out_phys_addr;
+    if( harden_ctx->mode == MBEDTLS_GCM_ENCRYPT )
+    {
+        ret = CIPHER_SYMC_ENCRYPT( harden_ctx->symc_handle, &in_buf, &out_buf, input_length );
+    } else {
+        ret = CIPHER_SYMC_DECRYPT( harden_ctx->symc_handle, &in_buf, &out_buf, input_length );
+    }
+    if( ret != 0 )
+        mbedtls_harden_log_err( "CIPHER_SYMC_CRYPTO faild!\n" );
+    return ret;
+}
+
+/*
+ * GCM hardware finish
+ */
+int mbedtls_gcm_finish_harden( mbedtls_gcm_context *ctx,
+                                unsigned char *tag, size_t tag_len )
+{
+    int ret = 0;
+    gcm_harden_context *harden_ctx;
+    if( tag_len > 16 || tag_len < 4 )
+        return( MBEDTLS_ERR_GCM_BAD_INPUT );
+    harden_ctx = get_gcm_harden_ctx( ctx );
+    if ( harden_ctx == NULL || harden_ctx->only_software_support == 1 )
+        return ( -1 );
+    if ( harden_ctx->is_set_config == 0 )
+    {
+        mbedtls_harden_log_err( "set config first!\n" );
+        return ( -1 );
+    }
+    ret = CIPHER_SYMC_GET_TAG( harden_ctx->symc_handle, tag, tag_len );
+    if( ret != 0 )
+        mbedtls_harden_log_err( "CIPHER_SYMC_GET_TAG faild!\n" );
+    internal_release_hard_resource( harden_ctx );
+    harden_ctx->is_set_config = 0;
+    return ret;
+}
+
+void mbedtls_gcm_free_harden( mbedtls_gcm_context *ctx )
+{
+    gcm_harden_context * harden_ctx;
+    harden_ctx = get_gcm_harden_ctx( ctx );
+    if ( harden_ctx != NULL )
+    {
+        internal_release_hard_resource( harden_ctx );
+        KM_DEINIT();
+        CIPHER_SYMC_DEINIT();
+        ( void )memset( harden_ctx, 0, sizeof( gcm_harden_context ) );
+    }
+}
+
+void mbedtls_gcm_init( mbedtls_gcm_context *ctx )
+{
+    GCM_VALIDATE( ctx != NULL );
+
+    mbedtls_gcm_init_harden( ctx );
+}
+
+int mbedtls_gcm_setkey( mbedtls_gcm_context *ctx,
+                        mbedtls_cipher_id_t cipher,
+                        const unsigned char *key,
+                        unsigned int keybits )
+{
+    GCM_VALIDATE_RET( ctx != NULL );
+    GCM_VALIDATE_RET( key != NULL );
+    GCM_VALIDATE_RET( keybits == 128 || keybits == 192 || keybits == 256 );
+
+    return mbedtls_gcm_setkey_harden( ctx, cipher, key, keybits );
+}
+
+int mbedtls_gcm_starts( mbedtls_gcm_context *ctx,
+                        int mode,
+                        const unsigned char *iv, size_t iv_len )
+{
+    GCM_VALIDATE_RET( ctx != NULL );
+    GCM_VALIDATE_RET( iv != NULL );
+
+    return mbedtls_gcm_start_harden( ctx, mode, iv, iv_len );
+}
+
+int mbedtls_gcm_update_ad( mbedtls_gcm_context *ctx,
+                           const unsigned char *add, size_t add_len )
+{
+    GCM_VALIDATE_RET( add_len == 0 || add != NULL );
+
+    /* IV is limited to 2^64 bits, so 2^61 bytes */
+    if( (uint64_t) add_len >> 61 != 0 )
+        return( MBEDTLS_ERR_GCM_BAD_INPUT );
+
+    return mbedtls_gcm_update_ad_harden( ctx, add, add_len );
+}
+
+int mbedtls_gcm_update( mbedtls_gcm_context *ctx,
+                        const unsigned char *input, size_t input_length,
+                        unsigned char *output, size_t output_size,
+                        size_t *output_length )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( output_size < input_length )
+        return( MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL );
+    GCM_VALIDATE_RET( output_length != NULL );
+    *output_length = input_length;
+
+    /* Exit early if input_length==0 so that we don't do any pointer arithmetic
+     * on a potentially null pointer.
+     * Returning early also means that the last partial block of AD remains
+     * untouched for mbedtls_gcm_finish */
+    if( input_length == 0 )
+        return( 0 );
+
+    GCM_VALIDATE_RET( ctx != NULL );
+    GCM_VALIDATE_RET( input != NULL );
+    GCM_VALIDATE_RET( output != NULL );
+
+    if( output > input && (size_t) ( output - input ) < input_length )
+        return( MBEDTLS_ERR_GCM_BAD_INPUT );
+
+    /* Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes
+     * Also check for possible overflow */
+    if( ctx->len + input_length < ctx->len ||
+        (uint64_t) ctx->len + input_length > 0xFFFFFFFE0ull )
+    {
+        return( MBEDTLS_ERR_GCM_BAD_INPUT );
+    }
+
+    ret = mbedtls_gcm_update_harden( ctx, input, input_length, output );
+    if( ret == 0 )
+    {
+        ctx->len += input_length;
+    }
+
+    return ret;
+}
+
+int mbedtls_gcm_finish( mbedtls_gcm_context *ctx,
+                        unsigned char *output, size_t output_size,
+                        size_t *output_length,
+                        unsigned char *tag, size_t tag_len )
+{
+    GCM_VALIDATE_RET( ctx != NULL );
+    GCM_VALIDATE_RET( tag != NULL );
+
+    return mbedtls_gcm_finish_harden( ctx, tag, tag_len );
+}
+
+int mbedtls_gcm_crypt_and_tag( mbedtls_gcm_context *ctx,
+                       int mode,
+                       size_t length,
+                       const unsigned char *iv,
+                       size_t iv_len,
+                       const unsigned char *add,
+                       size_t add_len,
+                       const unsigned char *input,
+                       unsigned char *output,
+                       size_t tag_len,
+                       unsigned char *tag )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t olen;
+
+    GCM_VALIDATE_RET( ctx != NULL );
+    GCM_VALIDATE_RET( iv != NULL );
+    GCM_VALIDATE_RET( add_len == 0 || add != NULL );
+    GCM_VALIDATE_RET( length == 0 || input != NULL );
+    GCM_VALIDATE_RET( length == 0 || output != NULL );
+    GCM_VALIDATE_RET( tag != NULL );
+
+    if( ( ret = mbedtls_gcm_starts( ctx, mode, iv, iv_len ) ) != 0 )
+        return( ret );
+
+    if( ( ret = mbedtls_gcm_update_ad( ctx, add, add_len ) ) != 0 )
+        return( ret );
+
+    if( ( ret = mbedtls_gcm_update( ctx, input, length,
+                                    output, length, &olen ) ) != 0 )
+        return( ret );
+
+    if( ( ret = mbedtls_gcm_finish( ctx, NULL, 0, &olen, tag, tag_len ) ) != 0 )
+        return( ret );
+
+    return( 0 );
+}
+
+int mbedtls_gcm_auth_decrypt( mbedtls_gcm_context *ctx,
+                      size_t length,
+                      const unsigned char *iv,
+                      size_t iv_len,
+                      const unsigned char *add,
+                      size_t add_len,
+                      const unsigned char *tag,
+                      size_t tag_len,
+                      const unsigned char *input,
+                      unsigned char *output )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    unsigned char check_tag[16];
+    size_t i;
+    int diff;
+
+    GCM_VALIDATE_RET( ctx != NULL );
+    GCM_VALIDATE_RET( iv != NULL );
+    GCM_VALIDATE_RET( add_len == 0 || add != NULL );
+    GCM_VALIDATE_RET( tag != NULL );
+    GCM_VALIDATE_RET( length == 0 || input != NULL );
+    GCM_VALIDATE_RET( length == 0 || output != NULL );
+
+    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,
+                                   iv, iv_len, add, add_len,
+                                   input, output, tag_len, check_tag ) ) != 0 )
+    {
+        return( ret );
+    }
+
+    /* Check tag in "constant-time" */
+    for( diff = 0, i = 0; i < tag_len; i++ )
+        diff |= tag[i] ^ check_tag[i];
+
+    if( diff != 0 )
+    {
+        mbedtls_platform_zeroize( output, length );
+        return( MBEDTLS_ERR_GCM_AUTH_FAILED );
+    }
+
+    return( 0 );
+}
+
+void mbedtls_gcm_free( mbedtls_gcm_context *ctx )
+{
+    if( ctx == NULL )
+        return;
+
+    mbedtls_gcm_free_harden( ctx );
+
+    mbedtls_cipher_free( &ctx->cipher_ctx );
+}
+#endif
\ No newline at end of file
diff --git a/harden/src/hash_harden_common.c b/harden/src/hash_harden_common.c
new file mode 100644
index 0000000..6750dc0
--- /dev/null
+++ b/harden/src/hash_harden_common.c
@@ -0,0 +1,141 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "hash_harden_common.h"
+#include "dfx.h"
+#include "mbedtls/error.h"
+#include <string.h>
+
+static const md_type_info g_md_type_info_table[] = {
+#if defined(MBEDTLS_SHA1_USE_HARDWARE)
+    { MBEDTLS_MD_SHA1,   CRYPTO_HASH_TYPE_HMAC_SHA1,   20,  64 },
+#endif
+#if defined(MBEDTLS_SHA224_USE_HARDWARE)
+    { MBEDTLS_MD_SHA224, CRYPTO_HASH_TYPE_HMAC_SHA224, 28,  64 },
+#endif
+#if defined(MBEDTLS_SHA256_USE_HARDWARE)
+    { MBEDTLS_MD_SHA256, CRYPTO_HASH_TYPE_HMAC_SHA256, 32,  64 },
+#endif
+#if defined(MBEDTLS_SHA384_USE_HARDWARE)
+    { MBEDTLS_MD_SHA384, CRYPTO_HASH_TYPE_HMAC_SHA384, 48, 128 },
+#endif
+#if defined(MBEDTLS_SHA512_USE_HARDWARE)
+    { MBEDTLS_MD_SHA512, CRYPTO_HASH_TYPE_HMAC_SHA512, 64, 128 },
+#endif
+    { MBEDTLS_MD_NONE,   CRYPTO_HASH_TYPE_INVALID,     0,   0  },
+};
+
+static const kslot_hmac_engine_map g_kslot_hmac_engine_map_table[] = {
+#if defined(MBEDTLS_SHA1_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA1,     KM_KEYSLOT_ENGINE_HMAC_SHA1   },
+#endif
+#if defined(MBEDTLS_SHA224_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA224,   KM_KEYSLOT_ENGINE_HMAC_SHA224 },
+#endif
+#if defined(MBEDTLS_SHA256_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA256,   KM_KEYSLOT_ENGINE_HMAC_SHA256 },
+#endif
+#if defined(MBEDTLS_SHA384_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA384,   KM_KEYSLOT_ENGINE_HMAC_SHA384 },
+#endif
+#if defined(MBEDTLS_SHA512_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA512,   KM_KEYSLOT_ENGINE_HMAC_SHA512 },
+#endif
+    {  CRYPTO_HASH_TYPE_INVALID,      KM_KEYSLOT_ENGINE_AES,        },
+};
+
+static const hmac_hash_map g_hmac_hash_map_table[] = {
+#if defined(MBEDTLS_SHA1_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA1,     CRYPTO_HASH_TYPE_SHA1    },
+#endif
+#if defined(MBEDTLS_SHA224_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA224,   CRYPTO_HASH_TYPE_SHA224  },
+#endif
+#if defined(MBEDTLS_SHA256_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA256,   CRYPTO_HASH_TYPE_SHA256  },
+#endif
+#if defined(MBEDTLS_SHA384_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA384,   CRYPTO_HASH_TYPE_SHA384  },
+#endif
+#if defined(MBEDTLS_SHA512_USE_HARDWARE)
+    { CRYPTO_HASH_TYPE_HMAC_SHA512,   CRYPTO_HASH_TYPE_SHA512  },
+#endif
+    {  CRYPTO_HASH_TYPE_INVALID,      CRYPTO_HASH_TYPE_INVALID },
+};
+
+void get_km_keyslot_engine(crypto_hash_type hash_type, km_keyslot_engine *key_engine)
+{
+    unsigned int i = 0;
+    for (i = 0; i < sizeof(g_md_type_info_table) / sizeof(g_md_type_info_table[0]); i++) {
+        if (g_kslot_hmac_engine_map_table[i].hash_type == hash_type) {
+            if (key_engine != NULL)
+                *key_engine = g_kslot_hmac_engine_map_table[i].key_engine;
+            return;
+        }
+    }
+    return;
+}
+
+void get_hash_info(mbedtls_md_type_t md_type, crypto_hash_type *hash_type, unsigned int *olen, unsigned int *block_size)
+{
+    unsigned int i = 0;
+    for (i = 0; i < sizeof(g_md_type_info_table) / sizeof(g_md_type_info_table[0]); i++) {
+        if (g_md_type_info_table[i].md_type == md_type) {
+            if (hash_type != NULL)
+                *hash_type = g_md_type_info_table[i].hash_type;
+            if (olen != NULL)
+                *olen = g_md_type_info_table[i].olen;
+            if (block_size != NULL)
+                *block_size = g_md_type_info_table[i].block_size;
+            return;
+        }
+    }
+    return;
+}
+
+int get_hmac_hashed_key( crypto_hash_attr *hmac_attr, unsigned char *key, size_t keylen )
+{
+    unsigned int i = 0;
+    int ret = MBEDTLS_HARDEN_SUCCESS;
+    crypto_hash_attr hash_attr;
+    unsigned int hash_handle;
+    crypto_buf_attr src_buf = {0};
+    unsigned int out_len = hmac_attr->key_len;
+
+    hash_attr.is_long_term = 0;
+    src_buf.virt_addr = key;
+    for (i = 0; i < sizeof(g_hmac_hash_map_table) / sizeof(g_hmac_hash_map_table[0]); i++) {
+        if (g_hmac_hash_map_table[i].hmac_type == hmac_attr->hash_type) {
+            hash_attr.hash_type = g_hmac_hash_map_table[i].hash_type;
+        }
+    }
+
+    ret = CIPHER_HASH_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+        return ( -1 );
+
+    ret = CIPHER_HASH_START( &hash_handle, &hash_attr );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+        goto exit_deinit;
+
+    ret = CIPHER_HASH_UPDATE( hash_handle, &src_buf, keylen );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+        goto exit_destroy;
+
+    ret = CIPHER_HASH_FINISH( hash_handle, hmac_attr->key, &out_len );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+        goto exit_destroy;
+
+    CIPHER_HASH_DEINIT();
+
+    return ret;
+exit_destroy:
+    (void)CIPHER_HASH_DESTROY( hash_handle );
+exit_deinit:
+    CIPHER_HASH_DEINIT();
+    return ( -1 );
+}
\ No newline at end of file
diff --git a/harden/src/hkdf_harden.c b/harden/src/hkdf_harden.c
new file mode 100644
index 0000000..055dbe5
--- /dev/null
+++ b/harden/src/hkdf_harden.c
@@ -0,0 +1,220 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "hkdf_harden.h"
+#include "cipher_adapt.h"
+#include "mbedtls/error.h"
+#include "dfx.h"
+#include "hash_harden_common.h"
+#include "mbedtls/platform_util.h"
+
+#if defined(MBEDTLS_HKDF_ALT)
+int hkdf_harden_can_do( const mbedtls_md_info_t *md )
+{
+    crypto_hash_type hmac_type = CRYPTO_HASH_TYPE_INVALID;
+
+    if( IS_HKDF_FUNC_REGISTERED() != TD_TRUE || md == NULL )
+        return ( 0 );
+
+    get_hash_info( md->type, &hmac_type, NULL, NULL );
+
+    return( hmac_type != CRYPTO_HASH_TYPE_INVALID );
+}
+
+int hkdf_extract_harden( const mbedtls_md_info_t *md,
+        const unsigned char *salt, size_t salt_len,
+        const unsigned char *ikm, size_t ikm_len,
+        unsigned char *prk )
+{
+    int ret;
+    crypto_hkdf_extract_t extract_param;
+    unsigned int prk_len = 0;
+    crypto_hash_type hmac_type = CRYPTO_HASH_TYPE_INVALID;
+
+    mbedtls_harden_log_func_enter();
+
+    get_hash_info( md->type, &hmac_type, NULL, NULL );
+
+    extract_param.hmac_type = hmac_type;
+    extract_param.salt = (unsigned char *)salt;
+    extract_param.salt_length = salt_len;
+    extract_param.ikm = (unsigned char *)ikm;
+    extract_param.ikm_length = ikm_len;
+
+    ret = CIPHER_HASH_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_HASH_INIT failed, ret = 0x%x!\n", ret );
+        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+    }
+
+    ret = CIPHER_HKDF_EXTRACT( &extract_param, prk, &prk_len );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_HKDF_EXTRACT failed, ret = 0x%x!\n", ret );
+
+        CIPHER_HASH_DEINIT();
+
+        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+    }
+
+    CIPHER_HASH_DEINIT();
+
+    mbedtls_harden_log_func_exit();
+
+    return( 0 );
+}
+
+int hkdf_expand_harden( const mbedtls_md_info_t *md, const unsigned char *prk,
+                         size_t prk_len, const unsigned char *info,
+                         size_t info_len, unsigned char *okm, size_t okm_len )
+{
+    int ret;
+    crypto_hkdf_expand_t expand_param;
+    crypto_hash_type hmac_type = CRYPTO_HASH_TYPE_INVALID;
+
+    mbedtls_harden_log_func_enter();
+
+    get_hash_info( md->type, &hmac_type, NULL, NULL );
+
+    expand_param.hmac_type = hmac_type;
+    expand_param.prk = (unsigned char *)prk;
+    expand_param.prk_length = prk_len;
+    expand_param.info = (unsigned char *)info;
+    expand_param.info_length = info_len;
+
+    ret = CIPHER_HASH_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_HASH_INIT failed, ret = 0x%x!\n", ret );
+        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+    }
+
+    ret = CIPHER_HKDF_EXPAND( &expand_param, okm, okm_len );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_HKDF_EXPAND failed, ret = 0x%x!\n", ret );
+
+        CIPHER_HASH_DEINIT();
+
+        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+    }
+
+    CIPHER_HASH_DEINIT();
+
+    mbedtls_harden_log_func_exit();
+
+    return( 0 );
+}
+
+int hkdf_harden( const mbedtls_md_info_t *md, const unsigned char *salt,
+                  size_t salt_len, const unsigned char *ikm, size_t ikm_len,
+                  const unsigned char *info, size_t info_len,
+                  unsigned char *okm, size_t okm_len )
+{
+    int ret;
+    crypto_hkdf_t hkdf_param;
+    crypto_hash_type hmac_type = CRYPTO_HASH_TYPE_INVALID;
+
+    mbedtls_harden_log_func_enter();
+
+    get_hash_info( md->type, &hmac_type, NULL, NULL );
+
+    hkdf_param.hmac_type = hmac_type;
+    hkdf_param.salt = (unsigned char *)salt;
+    hkdf_param.salt_length = salt_len;
+    hkdf_param.ikm = (unsigned char *)ikm;
+    hkdf_param.ikm_length = ikm_len;
+    hkdf_param.info = (unsigned char *)info;
+    hkdf_param.info_length = info_len;
+
+    ret = CIPHER_HASH_INIT();
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_HASH_INIT failed, ret = 0x%x!\n", ret );
+        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+    }
+
+    ret = CIPHER_HKDF( &hkdf_param, okm, okm_len );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_HKDF failed, ret = 0x%x!\n", ret );
+
+        CIPHER_HASH_DEINIT();
+
+        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+    }
+
+    CIPHER_HASH_DEINIT();
+
+    mbedtls_harden_log_func_exit();
+
+    return( 0 );
+}
+
+int mbedtls_hkdf( const mbedtls_md_info_t *md, const unsigned char *salt,
+                  size_t salt_len, const unsigned char *ikm, size_t ikm_len,
+                  const unsigned char *info, size_t info_len,
+                  unsigned char *okm, size_t okm_len )
+{
+    if( md == NULL )
+        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
+
+    if( hkdf_harden_can_do( md ) == 1 )
+    {
+        return hkdf_harden( md, salt, salt_len, ikm, ikm_len, info, info_len, okm, okm_len );
+    }
+
+    return( -1 );
+}
+
+int mbedtls_hkdf_extract( const mbedtls_md_info_t *md,
+                          const unsigned char *salt, size_t salt_len,
+                          const unsigned char *ikm, size_t ikm_len,
+                          unsigned char *prk )
+{
+    size_t hash_len;
+    if( salt == NULL )
+    {
+        if( salt_len != 0 )
+        {
+            return MBEDTLS_ERR_HKDF_BAD_INPUT_DATA;
+        }
+
+        hash_len = mbedtls_md_get_size( md );
+
+        if( hash_len == 0 )
+        {
+            return MBEDTLS_ERR_HKDF_BAD_INPUT_DATA;
+        }
+    }
+
+    if( hkdf_harden_can_do( md ) == 1 )
+    {
+        return hkdf_extract_harden( md, salt, salt_len, ikm, ikm_len, prk );
+    }
+
+    return( -1 );
+}
+
+int mbedtls_hkdf_expand( const mbedtls_md_info_t *md, const unsigned char *prk,
+                         size_t prk_len, const unsigned char *info,
+                         size_t info_len, unsigned char *okm, size_t okm_len )
+{
+    if( okm == NULL )
+    {
+        return( MBEDTLS_ERR_HKDF_BAD_INPUT_DATA );
+    }
+
+    if( hkdf_harden_can_do( md ) == 1 )
+    {
+        return hkdf_expand_harden( md, prk, prk_len, info, info_len, okm, okm_len );
+    }
+
+    return( -1 );
+}
+#endif /* MBEDTLS_HKDF_ALT */
\ No newline at end of file
diff --git a/harden/src/internal_include/aes_alt.h b/harden/src/internal_include/aes_alt.h
new file mode 100644
index 0000000..9ee406b
--- /dev/null
+++ b/harden/src/internal_include/aes_alt.h
@@ -0,0 +1,50 @@
+/* aes_alt.h with dummy types for MBEDTLS_AES_ALT */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef AES_ALT_H
+#define AES_ALT_H
+#include "mbedtls/private_access.h"
+
+#include "mbedtls/build_info.h"
+#include "mbedtls/platform_util.h"
+
+#include <stddef.h>
+#include <stdint.h>
+#include "mbedtls_crypto_type.h"
+
+typedef struct mbedtls_aes_context
+{
+    td_handle kslot_handle;
+    unsigned char key[32];
+    unsigned int key_len;
+}
+mbedtls_aes_context;
+
+#if defined(MBEDTLS_CIPHER_MODE_XTS)
+
+typedef struct mbedtls_aes_xts_context
+{
+    mbedtls_aes_context MBEDTLS_PRIVATE(crypt); /*!< The AES context to use for AES block
+                                        encryption or decryption. */
+    mbedtls_aes_context MBEDTLS_PRIVATE(tweak); /*!< The AES context used for tweak
+                                        computation. */
+} mbedtls_aes_xts_context;
+#endif /* MBEDTLS_CIPHER_MODE_XTS */
+
+
+#endif /* aes_alt.h */
diff --git a/harden/src/internal_include/bignum_harden.h b/harden/src/internal_include/bignum_harden.h
new file mode 100644
index 0000000..ca2ca56
--- /dev/null
+++ b/harden/src/internal_include/bignum_harden.h
@@ -0,0 +1,23 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_BIGNUM_HARDEN_H
+#define MBEDTLS_BIGNUM_HARDEN_H
+
+#include "mbedtls/bignum.h"
+
+int check_exp_mod_harden_can_do( const mbedtls_mpi *A,
+        const mbedtls_mpi *E, const mbedtls_mpi *N );
+
+int exp_mod_harden( mbedtls_mpi *X, const mbedtls_mpi *A,
+        const mbedtls_mpi *E, const mbedtls_mpi *N);
+
+int check_mod_harden_can_do( const mbedtls_mpi *A, const mbedtls_mpi *B );
+
+int mod_harden( mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B );
+
+#endif /* MBEDTLS_BIGNUM_HARDEN_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/ccm_alt.h b/harden/src/internal_include/ccm_alt.h
new file mode 100644
index 0000000..880b0cf
--- /dev/null
+++ b/harden/src/internal_include/ccm_alt.h
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden alg alt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+#ifndef CCM_ALT_H
+#define CCM_ALT_H
+#include "crypto_cipher_common_struct.h"
+
+#if defined(MBEDTLS_CCM_ALT)
+
+/**
+ * \brief    The CCM context-type alt definition. The CCM context is passed
+ *           to the APIs called.
+ */
+
+typedef struct {
+    unsigned int kslot_handle;
+    crypto_symc_ccm_ctx store_ctx;
+    unsigned int data_len;        /* Crypto Data Length In Bytes. */
+    unsigned int tag_len;         /* Tag Length In Bytes. */
+    unsigned int total_aad_len;
+    unsigned int processed_aad_len;
+    unsigned int processed_data_len;
+    unsigned char iv[16];
+    unsigned int iv_length;
+    unsigned char key[32];
+    unsigned int key_len;
+    int is_decrypt; // flag of crypt
+    unsigned long long phys_addr;
+    void *virt_addr;
+} mbedtls_ccm_context;
+
+#endif
+
+#endif
\ No newline at end of file
diff --git a/harden/src/internal_include/cipher_adapt.h b/harden/src/internal_include/cipher_adapt.h
new file mode 100644
index 0000000..f84ba0d
--- /dev/null
+++ b/harden/src/internal_include/cipher_adapt.h
@@ -0,0 +1,389 @@
+/**
+ * Copyright ( c ) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef CIPHER_ADAPT_H
+#define CIPHER_ADAPT_H
+
+#include "crypto_cipher_common_struct.h"
+#include "mbedtls_harden_struct.h"
+#include "ccm_alt.h"
+#include "mbedtls/ccm.h"
+
+typedef enum {
+    KM_KEYSLOT_ENGINE_AES = 0,
+    KM_KEYSLOT_ENGINE_SM4,
+    KM_KEYSLOT_ENGINE_HMAC_SHA1,
+    KM_KEYSLOT_ENGINE_HMAC_SHA224,
+    KM_KEYSLOT_ENGINE_HMAC_SHA256,
+    KM_KEYSLOT_ENGINE_HMAC_SHA384,
+    KM_KEYSLOT_ENGINE_HMAC_SHA512,
+    KM_KEYSLOT_ENGINE_HMAC_SM3,
+} km_keyslot_engine;
+
+/* HASH */
+typedef td_s32 ( *func_hash_init )( td_void );
+typedef td_s32 ( *func_hash_deinit )( td_void );
+typedef td_s32 ( *func_hash_start )( td_handle *uapi_hash_handle, const crypto_hash_attr *hash_attr );
+typedef td_s32 ( *func_hash_update )( td_handle uapi_hash_handle, const crypto_buf_attr *src_buf, const td_u32 len );
+typedef td_s32 ( *func_hash_get )( td_handle uapi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx );
+typedef td_s32 ( *func_hash_set )( td_handle uapi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx );
+typedef td_s32 ( *func_hash_destroy )( td_handle uapi_hash_handle );
+typedef td_s32 ( *func_hash_finish )( td_handle uapi_hash_handle, td_u8 *out, td_u32 *out_len );
+typedef td_s32 (*func_hash_start_impl)
+    (mbedtls_alt_hash_clone_ctx *clone_ctx, mbedtls_alt_hash_type hash_type);
+typedef td_s32 (*func_hash_update_impl)
+    (mbedtls_alt_hash_clone_ctx *clone_ctx, const unsigned char *data, unsigned int data_len);
+typedef td_s32 (*func_hash_finish_impl)
+    (mbedtls_alt_hash_clone_ctx *clone_ctx, unsigned char *out, unsigned int *out_len);
+
+/* HKDF */
+typedef td_s32 ( *func_hkdf )( crypto_hkdf_t *hkdf_param, td_u8 *okm, td_u32 okm_length );
+typedef td_s32 ( *func_hkdf_extract )( crypto_hkdf_extract_t *extract_param, td_u8 *prk, td_u32 *prk_length );
+typedef td_s32 ( *func_hkdf_expand )( const crypto_hkdf_expand_t *expand_param, td_u8 *okm, td_u32 okm_length );
+
+/* TRNG */
+typedef td_s32 ( *func_trng_get_random )( td_u32 *randnum );
+typedef td_s32 ( *func_trng_get_multi_random )( td_u32 size, td_u8 *randnum );
+
+/* PBKDF2 */
+typedef td_s32 ( *func_pbkdf2 )( const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len );
+
+/* SYMC */
+typedef td_s32 ( *func_symc_init )( td_void );
+typedef td_s32 ( *func_symc_deinit )( td_void );
+typedef td_s32 ( *func_symc_create )( td_handle *symc_handle, const crypto_symc_attr *symc_attr );
+typedef td_s32 ( *func_symc_destroy )( td_handle symc_handle );
+typedef td_s32 ( *func_symc_set_config )( td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl );
+typedef td_s32 ( *func_symc_get_config )( td_handle symc_handle, crypto_symc_ctrl_t *symc_ctrl );
+typedef td_s32 ( *func_symc_attach )( td_handle symc_handle, td_handle keyslot_handle );
+typedef td_s32 ( *func_symc_encrypt )( td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length );
+typedef td_s32 ( *func_symc_decrypt )( td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length );
+typedef td_s32 ( *func_symc_get_tag )( td_handle symc_handle, td_u8 *tag, td_u32 tag_length );
+typedef td_s32 ( *func_symc_mac_start )( td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr );
+typedef td_s32 ( *func_symc_mac_update )( td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length );
+typedef td_s32 ( *func_symc_mac_finish )( td_handle symc_handle, td_u8 *mac, td_u32 *mac_length );
+/* AES */
+typedef int (*func_aes_create_key_impl)(td_handle *keyslot_handle);
+typedef int (*func_aes_set_key_impl)(td_handle keyslot_handle, const unsigned char *key, unsigned int key_len);
+typedef int (*func_aes_destroy_key_impl)(const td_handle keyslot_handle);
+typedef int (*func_aes_crypt_impl)(const td_handle keyslot_handle, const unsigned char *key, unsigned int key_len,
+    const unsigned char src[16], unsigned char dst[16]);
+typedef int (*func_aes_cbc_crypt_impl)(const td_handle keyslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+typedef int (*func_aes_cfb128_crypt_impl)(const td_handle keyslot_handle,
+    const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+typedef int (*func_aes_cfb8_crypt_impl)(const td_handle keyslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+typedef int (*func_aes_ofb_crypt_impl)(const td_handle keyslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char *iv_off, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+typedef int (*func_aes_ctr_crypt_impl)(const td_handle keyslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char *nc_off, unsigned char nonce_counter[16], unsigned char stream_block[16],
+    const unsigned char *src, unsigned char *dst, unsigned int data_len);
+/* AEAD */
+typedef int (*func_aes_ccm_start)(unsigned long long *phys_addr, void **vir_addr);
+typedef int (*func_aes_ccm_update_ad_impl)(mbedtls_ccm_context *ctx, const unsigned char *add, unsigned int add_len);
+typedef int (*func_aes_ccm_update_impl)(mbedtls_ccm_context *ctx, const unsigned char *input, unsigned int input_len,
+    unsigned char *output, unsigned int output_len);
+typedef int (*func_aes_ccm_finish_impl)(mbedtls_ccm_context *ctx, unsigned char *tag, unsigned int tag_buf_len);
+/* PKE */
+typedef td_s32 ( *func_pke_init )( td_void );
+typedef td_s32 ( *func_pke_deinit )( td_void );
+typedef td_s32 ( *func_pke_mod )( const drv_pke_data *a, const drv_pke_data *p, const drv_pke_data *c );
+typedef td_s32 ( *func_pke_exp_mod )( const drv_pke_data *n, const drv_pke_data *k,
+    const drv_pke_data *in, const drv_pke_data *out );
+typedef td_s32 ( *func_pke_ecc_gen_key )( drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key );
+typedef td_s32 ( *func_pke_ecdsa_sign )( drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig );
+typedef td_s32 ( *func_pke_ecdsa_verify )( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig );
+typedef td_s32 ( *func_pke_eddsa_sign )( drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig );
+typedef td_s32 ( *func_pke_eddsa_verify )( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig );
+typedef td_s32 ( *func_pke_gen_ecdh_key )( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key );
+typedef td_s32 ( *func_pke_check_dot_on_curve )( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve );
+typedef td_s32 ( *func_pke_rsa_sign )( const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign );
+typedef td_s32 ( *func_pke_rsa_verify )( const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, drv_pke_data *input_hash, const drv_pke_data *sig );
+typedef td_s32 ( *func_pke_rsa_public_encrypt )( drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output );
+typedef td_s32 ( *func_pke_rsa_private_decrypt )( drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output );
+
+/* KM */
+typedef td_s32 ( *func_km_init )( td_void );
+typedef td_s32 ( *func_km_deinit )( td_void );
+typedef td_s32 ( *func_km_create_keyslot )( td_handle *keyslot_handle, km_keyslot_engine key_engine );
+typedef td_void ( *func_km_destroy_keyslot )( td_handle keyslot_handle );
+typedef td_s32 ( *func_km_set_clear_key )( td_handle keyslot_handle, td_u8 *key, td_u32 keylen,
+    km_keyslot_engine key_engine );
+
+/* MEM */
+typedef td_s32 ( *func_alloc_phys_buf )( crypto_buf_attr *buf_attr, void **virt_addr, unsigned int size );
+typedef td_void ( *func_free_phys_buf )( crypto_buf_attr *buf_attr, void *virt_addr, unsigned int size );
+typedef td_s32 ( *func_get_phys_addr )( void *virt_addr, unsigned long *phys_addr );
+
+typedef struct {
+    func_hash_start_impl alt_hash_start;
+    func_hash_update_impl alt_hash_update;
+    func_hash_finish_impl alt_hash_finish;
+    func_aes_create_key_impl aes_create_key;
+    func_aes_set_key_impl aes_set_key;
+    func_aes_destroy_key_impl aes_destroy_key;
+    func_aes_crypt_impl encrypt;
+    func_aes_crypt_impl decrypt;
+    func_aes_cbc_crypt_impl cbc_encrypt;
+    func_aes_cbc_crypt_impl cbc_decrypt;
+    func_aes_cfb128_crypt_impl cfb128_encrypt;
+    func_aes_cfb128_crypt_impl cfb128_decrypt;
+    func_aes_cfb8_crypt_impl cfb8_encrypt;
+    func_aes_cfb8_crypt_impl cfb8_decrypt;
+    func_aes_ofb_crypt_impl ofb_crypt;
+    func_aes_ctr_crypt_impl ctr_crypt;
+    func_aes_ccm_start ccm_start;
+    func_aes_ccm_update_ad_impl ccm_ad_update;
+    func_aes_ccm_update_impl ccm_update;
+    func_aes_ccm_finish_impl ccm_finish;
+    func_hash_init harden_hash_init;
+    func_hash_deinit harden_hash_deinit;
+    func_hash_start harden_hash_start;
+    func_hash_update harden_hash_update;
+    func_hash_get harden_hash_get;
+    func_hash_set harden_hash_set;
+    func_hash_destroy harden_hash_destroy;
+    func_hash_finish harden_hash_finish;
+    func_hkdf harden_hkdf;
+    func_hkdf_extract harden_hkdf_extract;
+    func_hkdf_expand harden_hkdf_expand;
+    func_trng_get_random harden_trng_get_random;
+    func_trng_get_multi_random harden_trng_get_multi_random;
+    func_pbkdf2 harden_pbkdf2;
+    func_symc_init harden_symc_init;
+    func_symc_deinit harden_symc_deinit;
+    func_symc_create harden_symc_create;
+    func_symc_destroy harden_symc_destroy;
+    func_symc_set_config harden_symc_set_config;
+    func_symc_get_config harden_symc_get_config;
+    func_symc_attach harden_symc_attach;
+    func_symc_encrypt harden_symc_encrypt;
+    func_symc_decrypt harden_symc_decrypt;
+    func_symc_get_tag harden_symc_get_tag;
+    func_symc_mac_start harden_symc_mac_start;
+    func_symc_mac_update harden_symc_mac_update;
+    func_symc_mac_finish harden_symc_mac_finish;
+    func_pke_init harden_pke_init;
+    func_pke_deinit harden_pke_deinit;
+    func_pke_mod harden_pke_mod;
+    func_pke_exp_mod harden_pke_exp_mod;
+    func_pke_ecc_gen_key harden_pke_ecc_gen_key;
+    func_pke_ecdsa_sign harden_pke_ecdsa_sign;
+    func_pke_ecdsa_verify harden_pke_ecdsa_verify;
+    func_pke_eddsa_sign harden_pke_eddsa_sign;
+    func_pke_eddsa_verify harden_pke_eddsa_verify;
+    func_pke_gen_ecdh_key harden_pke_gen_ecdh_key;
+    func_pke_check_dot_on_curve harden_pke_check_dot_on_curve;
+    func_pke_rsa_sign harden_pke_rsa_sign;
+    func_pke_rsa_verify harden_pke_rsa_verify;
+    func_pke_rsa_public_encrypt harden_pke_rsa_public_encrypt;
+    func_pke_rsa_private_decrypt harden_pke_rsa_private_decrypt;
+} mbedtls_harden_cipher_func;
+
+typedef struct {
+    func_km_init harden_km_init;
+    func_km_deinit harden_km_deinit;
+    func_km_create_keyslot harden_km_create_keyslot;
+    func_km_destroy_keyslot harden_km_destroy_keyslot;
+    func_km_set_clear_key harden_km_set_clear_key;
+} mbedtls_harden_km_func;
+
+typedef struct {
+    func_alloc_phys_buf harden_alloc_phys_buf;
+    func_free_phys_buf harden_free_phys_buf;
+    func_get_phys_addr harden_get_phys_addr;
+} mbedtls_harden_mem_func;
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+td_void mbedtls_cipher_adapt_register_func( mbedtls_harden_cipher_func *harden_cipher_func );
+td_void mbedtls_km_adapt_register_func( mbedtls_harden_km_func *harden_km_func );
+td_void mbedtls_mem_adapt_register_func( mbedtls_harden_mem_func *harden_mem_func );
+
+/* HASH */
+td_s32 CIPHER_HASH_INIT( td_void );
+td_s32 CIPHER_HASH_DEINIT( td_void );
+td_s32 CIPHER_HASH_START( td_handle *uapi_hash_handle, const crypto_hash_attr *hash_attr );
+td_s32 CIPHER_HASH_UPDATE( td_handle uapi_hash_handle, const crypto_buf_attr *src_buf, const td_u32 len );
+td_s32 CIPHER_HASH_GET( td_handle uapi_hash_handle, crypto_hash_clone_ctx *hash_clone_ctx );
+td_s32 CIPHER_HASH_SET( td_handle uapi_hash_handle, const crypto_hash_clone_ctx *hash_clone_ctx );
+td_s32 CIPHER_HASH_DESTROY( td_handle uapi_hash_handle );
+td_s32 CIPHER_HASH_FINISH( td_handle uapi_hash_handle, td_u8 *out, td_u32 *out_len );
+
+/* HKDF */
+td_s32 CIPHER_HKDF( crypto_hkdf_t *hkdf_param, td_u8 *okm, td_u32 okm_length );
+td_s32 CIPHER_HKDF_EXTRACT( crypto_hkdf_extract_t *extract_param, td_u8 *prk, td_u32 *prk_length );
+td_s32 CIPHER_HKDF_EXPAND( const crypto_hkdf_expand_t *expand_param, td_u8 *okm, td_u32 okm_length );
+
+/* TRNG */
+td_s32 CIPHER_TRNG_GET_RANDOM( td_u32 *randnum );
+td_s32 CIPHER_TRNG_GET_MULTI_RANDOM( td_u32 size, td_u8 *randnum );
+
+/* PBKDF2 */
+td_s32 CIPHER_PBKDF2( const crypto_kdf_pbkdf2_param *param, td_u8 *out, const td_u32 out_len );
+
+/* SYMC */
+td_s32 CIPHER_SYMC_INIT( td_void );
+td_s32 CIPHER_SYMC_DEINIT( td_void );
+td_s32 CIPHER_SYMC_CREATE( td_handle *symc_handle, const crypto_symc_attr *symc_attr );
+td_s32 CIPHER_SYMC_DESTROY( td_handle symc_handle );
+td_s32 CIPHER_SYMC_SET_CONFIG( td_handle symc_handle, const crypto_symc_ctrl_t *symc_ctrl );
+td_s32 CIPHER_SYMC_GET_CONFIG( td_handle symc_handle, crypto_symc_ctrl_t *symc_ctrl );
+td_s32 CIPHER_SYMC_ATTACH( td_handle symc_handle, td_handle keyslot_handle );
+td_s32 CIPHER_SYMC_ENCRYPT( td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length );
+td_s32 CIPHER_SYMC_DECRYPT( td_handle symc_handle, const crypto_buf_attr *src_buf,
+    const crypto_buf_attr *dst_buf, td_u32 length );
+td_s32 CIPHER_SYMC_GET_TAG( td_handle symc_handle, td_u8 *tag, td_u32 tag_length );
+td_s32 CIPHER_SYMC_MAC_START( td_handle *symc_handle, const crypto_symc_mac_attr *mac_attr );
+td_s32 CIPHER_SYMC_MAC_UPDATE( td_handle symc_handle, const crypto_buf_attr *src_buf, td_u32 length );
+td_s32 CIPHER_SYMC_MAC_FINISH( td_handle symc_handle, td_u8 *mac, td_u32 *mac_length );
+
+/* PKE */
+td_s32 CIPHER_PKE_INIT( td_void );
+td_s32 CIPHER_PKE_DEINIT( td_void );
+td_s32 CIPHER_PKE_MOD( const drv_pke_data *a, const drv_pke_data *p, drv_pke_data *c );
+td_s32 CIPHER_PKE_EXP_MOD( const drv_pke_data *n, const drv_pke_data *k,
+    const drv_pke_data *in, const drv_pke_data *out );
+td_s32 CIPHER_PKE_ECC_GEN_KEY( drv_pke_ecc_curve_type curve_type, const drv_pke_data *input_priv_key,
+    const drv_pke_data *output_priv_key, const drv_pke_ecc_point *output_pub_key );
+td_s32 CIPHER_PKE_ECDSA_SIGN( drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig );
+td_s32 CIPHER_PKE_ECDSA_VERIFY( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_data *hash, const drv_pke_ecc_sig *sig );
+td_s32 CIPHER_PKE_EDDSA_SIGN( drv_pke_ecc_curve_type curve_type, const drv_pke_data *priv_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig );
+td_s32 CIPHER_PKE_EDDSA_VERIFY( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    const drv_pke_msg *msg, const drv_pke_ecc_sig *sig );
+td_s32 CIPHER_PKE_ECC_GEN_ECDH_KEY( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *input_pub_key,
+    const drv_pke_data *input_priv_key, const drv_pke_data *output_shared_key );
+td_s32 CIPHER_PKE_CHECK_DOT_ON_CURVE( drv_pke_ecc_curve_type curve_type, const drv_pke_ecc_point *pub_key,
+    td_bool *is_on_curve );
+td_s32 CIPHER_PKE_RSA_SIGN( const drv_pke_rsa_priv_key *priv_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, const drv_pke_data *input_hash,
+    drv_pke_data *sign );
+td_s32 CIPHER_PKE_RSA_VERIFY( const drv_pke_rsa_pub_key *pub_key, drv_pke_rsa_scheme scheme,
+    drv_pke_hash_type hash_type, drv_pke_data *input_hash, const drv_pke_data *sig );
+td_s32 CIPHER_PKE_RSA_PUBLIC_ENCRYPT( drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_pub_key *pub_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output );
+td_s32 CIPHER_PKE_RSA_PRIVATE_DECRYPT( drv_pke_rsa_scheme scheme, drv_pke_hash_type hash_type,
+    const drv_pke_rsa_priv_key *priv_key, const drv_pke_data *input, const drv_pke_data *label,
+    drv_pke_data *output );
+
+/* KM */
+td_s32 KM_INIT( td_void );
+td_s32 KM_DEINIT( td_void );
+td_s32 CIPHER_CREATE_KEYSLOT( td_handle *keyslot_handle, km_keyslot_engine key_engine );
+td_void CIPHER_DESTROY_KEYSLOT( td_handle keyslot_handle );
+td_s32 CIPHER_SET_CLEAR_KEY( td_handle keyslot_handle, td_u8 *key, td_u32 keylen,
+    km_keyslot_engine key_engine );
+
+/* MEM */
+td_s32 CIPHER_ALLOC_BUF_ATTR( crypto_buf_attr *buf_attr, void **virt_addr, unsigned int size );
+td_void CIPHER_FREE_BUF_ATTR( crypto_buf_attr *buf_attr, void *virt_addr, unsigned int size );
+td_s32 CIPHER_GET_PHYS_MEM( void *virt_addr, unsigned long *phys_addr );
+
+td_bool IS_KM_FUNC_REGISTERED(td_void);
+td_bool IS_MEM_FUNC_REGISTERED(td_void);
+td_bool IS_SYMC_FUNC_REGISTERED(td_void);
+td_bool IS_HASH_FUNC_REGISTERED(td_void);
+td_bool IS_HKDF_FUNC_REGISTERED(td_void);
+td_bool IS_PBKDF2_FUNC_REGISTERED(td_void);
+td_bool IS_TRNG_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_MOD_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_EXP_MOD_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_ECC_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_EDDSA_SIGN_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_EDDSA_VERIFY_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_CHECK_DOT_ON_CURVE_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_RSA_SIGN_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_RSA_VERIFY_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_RSA_PUBLIC_ENCRYPT_FUNC_REGISTERED(td_void);
+td_bool IS_PKE_RSA_PRIVATE_DECRYPT_FUNC_REGISTERED(td_void);
+
+int mbedtls_alt_hash_start(mbedtls_alt_hash_clone_ctx *clone_ctx, mbedtls_alt_hash_type hash_type);
+
+int mbedtls_alt_hash_update(mbedtls_alt_hash_clone_ctx *clone_ctx, const unsigned char *data, unsigned int data_len);
+
+int mbedtls_alt_hash_finish(mbedtls_alt_hash_clone_ctx *clone_ctx, unsigned char *out, unsigned int out_len);
+
+int mbedtls_alt_aes_create_key(td_handle *kslot_handle);
+
+int mbedtls_alt_aes_set_key(td_handle kslot_handle, const unsigned char *key, unsigned int key_len);
+
+int mbedtls_alt_aes_destroy_key(td_handle kslot_handle);
+
+int mbedtls_alt_aes_encrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    const unsigned char src[16], unsigned char dst[16]);
+
+int mbedtls_alt_aes_decrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    const unsigned char src[16], unsigned char dst[16]);
+
+int mbedtls_alt_aes_cbc_encrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+
+int mbedtls_alt_aes_cbc_decrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+
+int mbedtls_alt_aes_cfb128_encrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+
+int mbedtls_alt_aes_cfb128_decrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+
+int mbedtls_alt_aes_cfb8_encrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+
+int mbedtls_alt_aes_cfb8_decrypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+
+int mbedtls_alt_aes_ofb_crypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char *iv_off, unsigned char iv[16], const unsigned char *src, unsigned char *dst, unsigned int data_len);
+
+int mbedtls_alt_aes_ctr_crypt(td_handle kslot_handle, const unsigned char *key, unsigned int key_len,
+    unsigned char *nc_off, unsigned char nonce_counter[16], unsigned char stream_block[16],
+    const unsigned char *src, unsigned char *dst, unsigned int data_len);
+
+int mbedtls_alt_aes_ccm_start(unsigned long long *phys_addr, void **vir_addr);
+
+int mbedtls_alt_aes_ccm_update_ad(mbedtls_ccm_context *ctx, const unsigned char *add, unsigned int add_len);
+
+int mbedtls_alt_aes_ccm_update(mbedtls_ccm_context *ctx, const unsigned char *input, unsigned int input_len,
+    unsigned char *output, unsigned int output_len);
+
+int mbedtls_alt_aes_ccm_finish(mbedtls_ccm_context *ctx, unsigned char *tag, unsigned int tag_buf_len);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* CIPHER_ADAPT_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/cipher_common.h b/harden/src/internal_include/cipher_common.h
new file mode 100644
index 0000000..b68661b
--- /dev/null
+++ b/harden/src/internal_include/cipher_common.h
@@ -0,0 +1,42 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_CIPHER_COMMON_STRUCT_H
+#define MBEDTLS_CIPHER_COMMON_STRUCT_H
+
+#include "cipher_adapt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Set symc_ctrl
+ */
+int mbedtls_cipher_set_ctrl(crypto_symc_ctrl_t *symc_ctrl, const crypto_symc_alg symc_alg,
+    const crypto_symc_work_mode work_mode, const unsigned int key_len, const crypto_symc_bit_width bit_width,
+    const crypto_symc_iv_change_type iv_change_flag, const unsigned char *iv, const unsigned int iv_len);
+
+/*
+ * Set CCM & GCM configuration
+ */
+int mbedtls_cipher_set_gcm_ccm_config(crypto_symc_config_aes_ccm_gcm *gcm_config, const unsigned char *aad,
+    const unsigned int aad_len, const unsigned int data_len, const unsigned int tag_len);
+
+/*
+ * Direction of synchronize hard_ctx with soft_ctx
+ */
+typedef enum {
+    SOFT_TO_HARD = 0,
+    HARD_TO_SOFT,
+} sync_direction;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MBEDTLS_CIPHER_COMMON_STRUCT_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/cmac_alt.h b/harden/src/internal_include/cmac_alt.h
new file mode 100644
index 0000000..7f6ed34
--- /dev/null
+++ b/harden/src/internal_include/cmac_alt.h
@@ -0,0 +1,35 @@
+/* cmac_alt.h with dummy types for MBEDTLS_CMAC_ALT */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef CMAC_ALT_H
+#define CMAC_ALT_H
+
+struct mbedtls_cmac_context_t
+{
+    /** The internal state of the CMAC algorithm.  */
+    unsigned char       MBEDTLS_PRIVATE(state)[MBEDTLS_CIPHER_BLKSIZE_MAX];
+
+    /** Unprocessed data - either data that was not block aligned and is still
+     *  pending processing, or the final block. */
+    unsigned char       MBEDTLS_PRIVATE(unprocessed_block)[MBEDTLS_CIPHER_BLKSIZE_MAX];
+
+    /** The length of data pending processing. */
+    size_t              MBEDTLS_PRIVATE(unprocessed_len);
+};
+
+#endif /* cmac_alt.h */
diff --git a/harden/src/internal_include/cmac_harden.h b/harden/src/internal_include/cmac_harden.h
new file mode 100644
index 0000000..193379d
--- /dev/null
+++ b/harden/src/internal_include/cmac_harden.h
@@ -0,0 +1,43 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_CMAC_HARDEN_H
+#define MBEDTLS_CMAC_HARDEN_H
+
+#include "cipher_adapt.h"
+#include "mbedtls/cmac.h"
+#include "string.h"
+
+#ifdef MBEDTLS_CMAC_ALT
+
+typedef struct cmac_harden_context{
+    unsigned int symc_handle;
+    unsigned int keyslot_handle;
+    mbedtls_cipher_context_t *ctx;
+    unsigned char key[32];
+    unsigned int key_length;
+    unsigned char is_update;
+    unsigned char is_finish;
+    unsigned char use_software;
+    unsigned char is_used;
+} cmac_harden_context;
+
+int mbedtls_cipher_cmac_starts_harden( mbedtls_cipher_context_t *ctx,
+                                const unsigned char *key, size_t keybits,
+                                mbedtls_cipher_type_t type );
+
+int mbedtls_cipher_cmac_update_harden( mbedtls_cipher_context_t *ctx,
+                                        const unsigned char *input, size_t ilen );
+
+int mbedtls_cipher_cmac_finish_harden( mbedtls_cipher_context_t *ctx,
+                                        unsigned char *output );
+
+int mbedtls_cipher_cmac_reset_harden( mbedtls_cipher_context_t *ctx );
+
+#endif
+
+#endif
\ No newline at end of file
diff --git a/harden/src/internal_include/dfx.h b/harden/src/internal_include/dfx.h
new file mode 100644
index 0000000..9daed17
--- /dev/null
+++ b/harden/src/internal_include/dfx.h
@@ -0,0 +1,40 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "mbedtls/ecp.h"
+#include "mbedtls/platform.h"
+
+#define PRINT_LINE_LEN                     16
+
+#define mbedtls_harden_log_err(fmt, ...)   \
+    mbedtls_printf("[%s:%d]" "HARDEN MBED ERR! : " fmt, __func__, __LINE__, ##__VA_ARGS__)
+
+#define unused(x)                          (void)(x)
+
+#if defined(MBED_HARDEN_DEBUG)
+#define mbedtls_harden_log_dbg             mbedtls_printf
+#else
+#define mbedtls_harden_log_dbg(...)        (void)0
+#endif
+
+#define mbedtls_harden_log_func_enter()    mbedtls_harden_log_dbg("%s ===>Enter\n", __func__)
+#define mbedtls_harden_log_func_exit()     mbedtls_harden_log_dbg("%s <===Exit\n", __func__)
+
+#define MBED_HARDEN_DEBUG_BREAKPOINT       1
+
+#if defined(MBED_HARDEN_DEBUG_BREAKPOINT)
+#define mbedtls_harden_log_breakpoint()    \
+    mbedtls_harden_log_dbg("your code go here %s--> LINE = %d!\n", __func__,__LINE__)
+#endif
+
+void mbedtls_dump_grp_id(mbedtls_ecp_group_id group_id);
+
+void mbedtls_dump_hex(const char* name, const unsigned char* buf, unsigned int buf_len);
+
+void mbedtls_dump_mpi(const char* name, const mbedtls_mpi *mpi);
+
+void mbedtls_dump_point(const char* name, const mbedtls_ecp_point *point);
\ No newline at end of file
diff --git a/harden/src/internal_include/ecc_genkey_harden.h b/harden/src/internal_include/ecc_genkey_harden.h
new file mode 100644
index 0000000..9d7abf8
--- /dev/null
+++ b/harden/src/internal_include/ecc_genkey_harden.h
@@ -0,0 +1,17 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_ECC_GENKEY_HARDEN_H
+#define MBEDTLS_ECC_GENKEY_HARDEN_H
+
+#include "mbedtls/ecp.h"
+
+int ecc_genkey_harden( mbedtls_ecp_group *grp, const mbedtls_ecp_point *G,
+        mbedtls_mpi *d, mbedtls_ecp_point *Q, int (*f_rng)(void *, unsigned char *, size_t),
+        void *p_rng );
+
+#endif /* MBEDTLS_ECC_GENKEY_HARDEN_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/ecc_harden_common.h b/harden/src/internal_include/ecc_harden_common.h
new file mode 100644
index 0000000..53cbafb
--- /dev/null
+++ b/harden/src/internal_include/ecc_harden_common.h
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+#ifndef MBEDTLS_ECC_COMMON_H
+#define MBEDTLS_ECC_COMMON_H
+
+#include "cipher_adapt.h"
+#include "mbedtls/ecp.h"
+
+void get_curve_type( mbedtls_ecp_group_id grp_id, drv_pke_ecc_curve_type *curve_type, unsigned int *klen );
+
+int check_ecc_harden_can_do( mbedtls_ecp_group *grp, int (*f_rng)(void *, unsigned char *, size_t) );
+
+int ecp_priv_key_alloc( const unsigned int klen, drv_pke_data *priv_key );
+
+void ecp_priv_key_free( drv_pke_data *priv_key );
+
+int ecp_pub_key_alloc( const unsigned int klen, drv_pke_ecc_point *pub_key );
+
+void ecp_pub_key_free( drv_pke_ecc_point *pub_key );
+
+int ecp_priv_key_create( drv_pke_ecc_curve_type ecc_type, unsigned int klen, const mbedtls_mpi *d,
+                         drv_pke_data *priv_key );
+
+int ecp_pub_key_create( drv_pke_ecc_curve_type ecc_type, unsigned int klen, const mbedtls_ecp_point *pub,
+                        drv_pke_ecc_point *pub_key );
+
+#endif /* MBEDTLS_ECC_COMMON_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/ecdh_harden.h b/harden/src/internal_include/ecdh_harden.h
new file mode 100644
index 0000000..9caf423
--- /dev/null
+++ b/harden/src/internal_include/ecdh_harden.h
@@ -0,0 +1,18 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_ECDH_HARDEN_H
+#define MBEDTLS_ECDH_HARDEN_H
+
+#include "mbedtls/ecdh.h"
+
+int ecdh_harden( mbedtls_ecp_group *grp, mbedtls_mpi *z,
+                 const mbedtls_ecp_point *Q, const mbedtls_mpi *d,
+                 int (*f_rng)(void *, unsigned char *, size_t),
+                 void *p_rng );
+
+#endif /* MBEDTLS_ECDH_HARDEN_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/ecdsa_harden.h b/harden/src/internal_include/ecdsa_harden.h
new file mode 100644
index 0000000..80a434b
--- /dev/null
+++ b/harden/src/internal_include/ecdsa_harden.h
@@ -0,0 +1,28 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_ECDSA_HARDEN_H
+#define MBEDTLS_ECDSA_HARDEN_H
+
+#include "mbedtls/ecdsa.h"
+
+int check_ecdsa_sign_harden_can_do( mbedtls_ecp_group *grp,
+    int (*f_rng)(void *, unsigned char *, size_t), size_t blen );
+
+int ecdsa_sign_harden( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
+                const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
+                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
+
+int check_ecdsa_verify_harden_can_do( mbedtls_ecp_group *grp, const unsigned char *buf, size_t blen );
+
+int ecdsa_verify_harden( mbedtls_ecp_group *grp,
+        const unsigned char *buf, size_t blen,
+        const mbedtls_ecp_point *Q,
+        const mbedtls_mpi *r,
+        const mbedtls_mpi *s);
+
+#endif /* MBEDTLS_ECDSA_HARDEN_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/gcm_alt.h b/harden/src/internal_include/gcm_alt.h
new file mode 100644
index 0000000..6fdef8f
--- /dev/null
+++ b/harden/src/internal_include/gcm_alt.h
@@ -0,0 +1,33 @@
+/* gcm_alt.h with dummy types for MBEDTLS_GCM_ALT */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef GCM_ALT_H
+#define GCM_ALT_H
+
+/**
+ * \brief          The GCM context alt structure.
+ */
+typedef struct mbedtls_gcm_context
+{
+    mbedtls_cipher_context_t MBEDTLS_PRIVATE(cipher_ctx);  /*!< The cipher context used. */
+    uint64_t MBEDTLS_PRIVATE(len);                         /*!< The total length of the encrypted data. */
+}
+mbedtls_gcm_context;
+
+
+#endif /* gcm_alt.h */
diff --git a/harden/src/internal_include/gcm_harden.h b/harden/src/internal_include/gcm_harden.h
new file mode 100644
index 0000000..462f69a
--- /dev/null
+++ b/harden/src/internal_include/gcm_harden.h
@@ -0,0 +1,63 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_GCM_HARDEN_H
+#define MBEDTLS_GCM_HARDEN_H
+
+#include "cipher_adapt.h"
+#include "mbedtls/gcm.h"
+#include "string.h"
+
+#ifdef MBEDTLS_GCM_ALT
+
+typedef struct gcm_harden_context{
+    mbedtls_gcm_context *ctx;
+    crypto_symc_ctrl_t symc_ctrl;
+    crypto_symc_config_aes_ccm_gcm gcm_config;
+    int mode;
+    unsigned int symc_handle;
+    unsigned int keyslot_handle;
+    unsigned char key[32];
+    unsigned char add[MBEDTLS_CIPHER_MAX_ADD_LEN];
+    unsigned char iv[16];
+    size_t iv_len;
+    size_t add_len;
+    unsigned int key_length;
+    unsigned char is_used;
+    unsigned char is_set_config;
+    unsigned char is_software_update_ad;
+    unsigned char only_software_support;
+} gcm_harden_context;
+
+void mbedtls_gcm_init_harden( mbedtls_gcm_context *ctx );
+
+int mbedtls_gcm_setkey_harden( mbedtls_gcm_context *ctx,
+                                mbedtls_cipher_id_t cipher,
+                                const unsigned char *key,
+                                unsigned int keybits );
+
+int mbedtls_gcm_start_harden( mbedtls_gcm_context *ctx,
+                                int mode,
+                                const unsigned char *iv,
+                                size_t iv_len );
+
+int mbedtls_gcm_update_ad_harden( mbedtls_gcm_context *ctx,
+                                const unsigned char *add,
+                                size_t add_len );
+
+int mbedtls_gcm_update_harden( mbedtls_gcm_context *ctx,
+                                const unsigned char *input, size_t input_length,
+                                unsigned char *output );
+
+int mbedtls_gcm_finish_harden( mbedtls_gcm_context *ctx,
+                                unsigned char *tag, size_t tag_len );
+
+void mbedtls_gcm_free_harden( mbedtls_gcm_context *ctx );
+
+#endif
+
+#endif
\ No newline at end of file
diff --git a/harden/src/internal_include/hash_harden_common.h b/harden/src/internal_include/hash_harden_common.h
new file mode 100644
index 0000000..b67877b
--- /dev/null
+++ b/harden/src/internal_include/hash_harden_common.h
@@ -0,0 +1,39 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_HASH_HARDEN_COMMON_H
+#define MBEDTLS_HASH_HARDEN_COMMON_H
+
+#include "cipher_adapt.h"
+#include "mbedtls/platform.h"
+#include "md_wrap.h"
+
+typedef struct {
+    mbedtls_md_type_t md_type;
+    crypto_hash_type hash_type;
+    size_t olen;
+    size_t block_size;
+} md_type_info;
+
+typedef struct {
+    crypto_hash_type hash_type;
+    km_keyslot_engine key_engine;
+} kslot_hmac_engine_map;
+
+typedef struct {
+    crypto_hash_type hmac_type;
+    crypto_hash_type hash_type;
+} hmac_hash_map;
+
+void get_km_keyslot_engine(crypto_hash_type hash_type, km_keyslot_engine *key_engine);
+
+void get_hash_info( mbedtls_md_type_t md_type, crypto_hash_type *hash_type, unsigned int *olen,
+    unsigned int *block_size);
+
+int get_hmac_hashed_key( crypto_hash_attr *hmac_attr, unsigned char *key, size_t keylen );
+
+#endif /* MBEDTLS_HASH_HARDEN_COMMON_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/hkdf_harden.h b/harden/src/internal_include/hkdf_harden.h
new file mode 100644
index 0000000..a899263
--- /dev/null
+++ b/harden/src/internal_include/hkdf_harden.h
@@ -0,0 +1,29 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_HKDF_HARDEN_H
+#define MBEDTLS_HKDF_HARDEN_H
+
+#include "mbedtls/hkdf.h"
+
+int hkdf_harden_can_do( const mbedtls_md_info_t *md );
+
+int hkdf_extract_harden( const mbedtls_md_info_t *md,
+        const unsigned char *salt, size_t salt_len,
+        const unsigned char *ikm, size_t ikm_len,
+        unsigned char *prk );
+
+int hkdf_expand_harden( const mbedtls_md_info_t *md, const unsigned char *prk,
+        size_t prk_len, const unsigned char *info,
+        size_t info_len, unsigned char *okm, size_t okm_len );
+
+int hkdf_harden( const mbedtls_md_info_t *md, const unsigned char *salt,
+        size_t salt_len, const unsigned char *ikm, size_t ikm_len,
+        const unsigned char *info, size_t info_len,
+        unsigned char *okm, size_t okm_len );
+
+#endif /* MBEDTLS_HKDF_HARDEN_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/pbkdf2_hmac_harden.h b/harden/src/internal_include/pbkdf2_hmac_harden.h
new file mode 100644
index 0000000..f033ea3
--- /dev/null
+++ b/harden/src/internal_include/pbkdf2_hmac_harden.h
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal header file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#ifndef MBEDTLS_PBKDF2_HMAC_HARDEN_H
+#define MBEDTLS_PBKDF2_HMAC_HARDEN_H
+
+#include "mbedtls/pkcs5.h"
+
+int pbkdf2_hmac_harden_can_do( mbedtls_md_context_t *ctx, unsigned int iteration_count );
+
+int pbkdf2_hmac_harden( mbedtls_md_context_t *ctx,
+        const unsigned char *password,
+        size_t plen, const unsigned char *salt, size_t slen,
+        unsigned int iteration_count,
+        uint32_t key_length, unsigned char *output );
+
+#endif /* MBEDTLS_PBKDF2_HMAC_HARDEN_H */
\ No newline at end of file
diff --git a/harden/src/internal_include/sha1_alt.h b/harden/src/internal_include/sha1_alt.h
new file mode 100644
index 0000000..8c39928
--- /dev/null
+++ b/harden/src/internal_include/sha1_alt.h
@@ -0,0 +1,40 @@
+/* sha1_alt.h with dummy types for MBEDTLS_SHA1_ALT */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef SHA1_ALT_H
+#define SHA1_ALT_H
+
+#include "mbedtls_harden_struct.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct mbedtls_sha1_context
+{
+    mbedtls_alt_hash_clone_ctx clone_ctx;
+    unsigned int result_size;
+}
+mbedtls_sha1_context;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sha1_alt.h */
diff --git a/harden/src/internal_include/sha256_alt.h b/harden/src/internal_include/sha256_alt.h
new file mode 100644
index 0000000..890d1dc
--- /dev/null
+++ b/harden/src/internal_include/sha256_alt.h
@@ -0,0 +1,39 @@
+/* sha256_alt.h with dummy types for MBEDTLS_SHA256_ALT */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef SHA256_ALT_H
+#define SHA256_ALT_H
+
+#include "mbedtls_harden_struct.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct mbedtls_sha256_context
+{
+    mbedtls_alt_hash_clone_ctx clone_ctx;
+    unsigned int result_size;
+}
+mbedtls_sha256_context;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sha256_alt.h */
diff --git a/harden/src/internal_include/sha512_alt.h b/harden/src/internal_include/sha512_alt.h
new file mode 100644
index 0000000..d769ffb
--- /dev/null
+++ b/harden/src/internal_include/sha512_alt.h
@@ -0,0 +1,31 @@
+/* sha512_alt.h with dummy types for MBEDTLS_SHA512_ALT */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef SHA512_ALT_H
+#define SHA512_ALT_H
+
+#include "mbedtls_harden_struct.h"
+
+typedef struct mbedtls_sha512_context
+{
+    mbedtls_alt_hash_clone_ctx clone_ctx;
+    unsigned int result_size;
+}
+mbedtls_sha512_context;
+
+#endif /* sha512_alt.h */
diff --git a/harden/src/pbkdf2_hmac_harden.c b/harden/src/pbkdf2_hmac_harden.c
new file mode 100644
index 0000000..e341041
--- /dev/null
+++ b/harden/src/pbkdf2_hmac_harden.c
@@ -0,0 +1,82 @@
+/**
+ * Copyright (c) CompanyNameMagicTag 2022-2023. All rights reserved.
+ * Description: mbedtls harden adapt internal source file.
+ * Author: CompanyName
+ * Create: 2023-05-10
+*/
+
+#include "pbkdf2_hmac_harden.h"
+#include "cipher_adapt.h"
+#include "mbedtls/error.h"
+#include "hash_harden_common.h"
+#include "mbedtls/platform_util.h"
+#include "dfx.h"
+
+#if defined(MBEDTLS_PBKDF2_HMAC_ALT)
+
+int pbkdf2_hmac_harden_can_do( mbedtls_md_context_t *ctx, unsigned int iteration_count )
+{
+    crypto_hash_type hmac_type = CRYPTO_HASH_TYPE_INVALID;
+
+    if( IS_PBKDF2_FUNC_REGISTERED() != TD_TRUE || ctx == NULL || ctx->MBEDTLS_PRIVATE(md_info) == NULL )
+        return ( 0 );
+
+    if( iteration_count > 0xFFFF )
+        return 0;
+
+    get_hash_info( ctx->MBEDTLS_PRIVATE(md_info)->type, &hmac_type, NULL, NULL );
+
+    return( hmac_type != CRYPTO_HASH_TYPE_INVALID );
+}
+
+int pbkdf2_hmac_harden( mbedtls_md_context_t *ctx,
+        const unsigned char *password,
+        size_t plen, const unsigned char *salt, size_t slen,
+        unsigned int iteration_count,
+        uint32_t key_length, unsigned char *output )
+{
+    int ret;
+    crypto_kdf_pbkdf2_param kdf;
+    crypto_hash_type hmac_type = CRYPTO_HASH_TYPE_INVALID;
+
+    mbedtls_harden_log_func_enter();
+    if( ctx == NULL || ctx->MBEDTLS_PRIVATE(md_info) == NULL )
+        return ( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+
+    get_hash_info( ctx->MBEDTLS_PRIVATE(md_info)->type, &hmac_type, NULL, NULL );
+
+    kdf.count = iteration_count;
+    kdf.password = (unsigned char *)password;
+    kdf.plen = plen;
+    kdf.salt = (unsigned char *)salt;
+    kdf.slen = slen;
+    kdf.hash_type = hmac_type;
+
+    ret = CIPHER_PBKDF2( &kdf, output, key_length );
+    if( ret != MBEDTLS_HARDEN_SUCCESS )
+    {
+        mbedtls_harden_log_err("CIPHER_PBKDF2 failed, ret = 0x%x!\n", ret );
+        mbedtls_platform_zeroize( &kdf, sizeof( crypto_kdf_pbkdf2_param ) );
+        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
+    }
+    mbedtls_platform_zeroize( &kdf, sizeof( crypto_kdf_pbkdf2_param ) );
+
+    mbedtls_harden_log_func_exit();
+
+    return( 0 );
+}
+
+int mbedtls_pkcs5_pbkdf2_hmac( mbedtls_md_context_t *ctx,
+                       const unsigned char *password,
+                       size_t plen, const unsigned char *salt, size_t slen,
+                       unsigned int iteration_count,
+                       uint32_t key_length, unsigned char *output )
+{
+    if( pbkdf2_hmac_harden_can_do( ctx, iteration_count ) )
+    {
+        return pbkdf2_hmac_harden( ctx, password, plen, salt, slen, iteration_count, key_length, output );
+    }
+
+    return( -1 );
+}
+#endif /* MBEDTLS_PBKDF2_HMAC_ALT */
diff --git a/harden/src/sha1_harden.c b/harden/src/sha1_harden.c
new file mode 100644
index 0000000..87ad920
--- /dev/null
+++ b/harden/src/sha1_harden.c
@@ -0,0 +1,86 @@
+#include "mbedtls/sha1.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform_util.h"
+#include "hash_harden_common.h"
+#include "dfx.h"
+#include <string.h>
+#include <securec.h>
+
+#define SHA1_LEN      20
+
+#define SHA1_VALIDATE_RET(cond)                           \
+    MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_SHA1_BAD_INPUT_DATA)
+#define SHA1_VALIDATE(cond)  MBEDTLS_INTERNAL_VALIDATE(cond)
+
+#if defined(MBEDTLS_SHA1_ALT)
+
+void mbedtls_sha1_init(mbedtls_sha1_context *ctx)
+{
+    SHA1_VALIDATE(ctx != NULL);
+    (void)memset_s(ctx, sizeof(mbedtls_sha1_context), 0, sizeof(mbedtls_sha1_context));
+}
+
+void mbedtls_sha1_free(mbedtls_sha1_context *ctx)
+{
+    if (ctx == NULL) {
+        return;
+    }
+    (void)memset_s(ctx, sizeof(mbedtls_sha1_context), 0, sizeof(mbedtls_sha1_context));
+}
+
+void mbedtls_sha1_clone(mbedtls_sha1_context *dst,
+                           const mbedtls_sha1_context *src)
+{
+    SHA1_VALIDATE(dst != NULL);
+    SHA1_VALIDATE(src != NULL);
+
+    (void)memcpy_s(dst, sizeof(mbedtls_sha1_context), src, sizeof(mbedtls_sha1_context));
+}
+
+int mbedtls_sha1_starts(mbedtls_sha1_context *ctx)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+
+    SHA1_VALIDATE_RET(ctx != NULL);
+
+    ctx->result_size = SHA1_LEN;
+    ctx->clone_ctx.hash_type = MBEDTLS_ALT_HASH_TYPE_SHA1;
+    ret = mbedtls_alt_hash_start(&ctx->clone_ctx, ctx->clone_ctx.hash_type);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_sha1_update(mbedtls_sha1_context *ctx, const unsigned char *input, size_t ilen)
+{
+    int ret = -1;
+
+    mbedtls_harden_log_func_enter();
+    SHA1_VALIDATE_RET(ctx != NULL);
+    SHA1_VALIDATE_RET(ilen == 0 || input != NULL);
+
+    if(ilen == 0) {
+        return 0;
+    }
+
+    ret = mbedtls_alt_hash_update(&ctx->clone_ctx, input, ilen);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_sha1_finish(mbedtls_sha1_context *ctx, unsigned char output[20])
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    SHA1_VALIDATE_RET(ctx != NULL);
+    SHA1_VALIDATE_RET((unsigned char *)output != NULL);
+
+    ret = mbedtls_alt_hash_finish(&ctx->clone_ctx, output, ctx->result_size);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+#endif /* MBEDTLS_SHA1_ALT */
diff --git a/harden/src/sha256_harden.c b/harden/src/sha256_harden.c
new file mode 100644
index 0000000..2865722
--- /dev/null
+++ b/harden/src/sha256_harden.c
@@ -0,0 +1,98 @@
+#include "mbedtls/sha256.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform_util.h"
+#include "hash_harden_common.h"
+#include "dfx.h"
+#include <string.h>
+#include <securec.h>
+
+#define SHA224_LEN      28
+#define SHA256_LEN      32
+
+#define SHA256_VALIDATE_RET(cond)                           \
+    MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_SHA256_BAD_INPUT_DATA)
+#define SHA256_VALIDATE(cond)  MBEDTLS_INTERNAL_VALIDATE(cond)
+
+#if defined(MBEDTLS_SHA256_ALT)
+
+void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
+{
+    SHA256_VALIDATE(ctx != NULL);
+    (void)memset_s(ctx, sizeof(mbedtls_sha256_context), 0, sizeof(mbedtls_sha256_context));
+}
+
+void mbedtls_sha256_free(mbedtls_sha256_context *ctx)
+{
+    SHA256_VALIDATE(ctx != NULL);
+    (void)memset_s(ctx, sizeof(mbedtls_sha256_context), 0, sizeof(mbedtls_sha256_context));
+}
+
+void mbedtls_sha256_clone(mbedtls_sha256_context *dst,
+                           const mbedtls_sha256_context *src)
+{
+    SHA256_VALIDATE(dst != NULL);
+    SHA256_VALIDATE(src != NULL);
+
+    (void)memcpy_s(dst, sizeof(mbedtls_sha256_context), src, sizeof(mbedtls_sha256_context));
+}
+
+int mbedtls_sha256_starts(mbedtls_sha256_context *ctx, int is224)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+
+    SHA256_VALIDATE_RET(ctx != NULL);
+#if defined(MBEDTLS_SHA224_C)
+    SHA256_VALIDATE_RET(is224 == 0 || is224 == 1);
+#else
+    SHA256_VALIDATE_RET(is224 == 0);
+#endif
+#if defined(MBEDTLS_SHA224_C)
+    if(is224 == 1) {
+        ctx->result_size = SHA224_LEN;
+        ctx->clone_ctx.hash_type = MBEDTLS_ALT_HASH_TYPE_SHA224;
+    }
+#endif
+    if(is224 == 0) {
+        ctx->result_size = SHA256_LEN;
+        ctx->clone_ctx.hash_type = MBEDTLS_ALT_HASH_TYPE_SHA256;
+    }
+
+    ret = mbedtls_alt_hash_start(&ctx->clone_ctx, ctx->clone_ctx.hash_type);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_sha256_update(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
+{
+    int ret = -1;
+
+    mbedtls_harden_log_func_enter();
+    SHA256_VALIDATE_RET(ctx != NULL);
+    SHA256_VALIDATE_RET(ilen == 0 || input != NULL);
+
+    if(ilen == 0) {
+        return 0;
+    }
+
+    ret = mbedtls_alt_hash_update(&ctx->clone_ctx, input, ilen);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_sha256_finish(mbedtls_sha256_context *ctx, unsigned char *output)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    SHA256_VALIDATE_RET(ctx != NULL);
+    SHA256_VALIDATE_RET((unsigned char *)output != NULL);
+
+    ret = mbedtls_alt_hash_finish(&ctx->clone_ctx, output, ctx->result_size);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+#endif /* MBEDTLS_SHA256_ALT */
diff --git a/harden/src/sha512_harden.c b/harden/src/sha512_harden.c
new file mode 100644
index 0000000..cbbb749
--- /dev/null
+++ b/harden/src/sha512_harden.c
@@ -0,0 +1,98 @@
+#include "mbedtls/sha512.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform_util.h"
+#include "hash_harden_common.h"
+#include "dfx.h"
+#include <string.h>
+#include <securec.h>
+
+#define SHA384_LEN      48
+#define SHA512_LEN      64
+
+#define SHA512_VALIDATE_RET(cond)                           \
+    MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_SHA512_BAD_INPUT_DATA)
+#define SHA512_VALIDATE(cond)  MBEDTLS_INTERNAL_VALIDATE(cond)
+
+#if defined(MBEDTLS_SHA512_ALT)
+
+void mbedtls_sha512_init(mbedtls_sha512_context *ctx)
+{
+    SHA512_VALIDATE(ctx != NULL);
+    (void)memset_s(ctx, sizeof(mbedtls_sha512_context), 0, sizeof(mbedtls_sha512_context));
+}
+
+void mbedtls_sha512_free(mbedtls_sha512_context *ctx)
+{
+    SHA512_VALIDATE(ctx != NULL);
+    (void)memset_s(ctx, sizeof(mbedtls_sha512_context), 0, sizeof(mbedtls_sha512_context));
+}
+
+void mbedtls_sha512_clone(mbedtls_sha512_context *dst,
+                           const mbedtls_sha512_context *src)
+{
+    SHA512_VALIDATE(dst != NULL);
+    SHA512_VALIDATE(src != NULL);
+
+    (void)memcpy_s(dst, sizeof(mbedtls_sha512_context), src, sizeof(mbedtls_sha512_context));
+}
+
+int mbedtls_sha512_starts(mbedtls_sha512_context *ctx, int is384)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+
+    SHA512_VALIDATE_RET(ctx != NULL);
+#if defined(MBEDTLS_SHA384_C)
+    SHA512_VALIDATE_RET(is384 == 0 || is384 == 1);
+#else
+    SHA512_VALIDATE_RET(is384 == 0);
+#endif
+#if defined(MBEDTLS_SHA384_C)
+    if(is384 == 1) {
+        ctx->result_size = SHA384_LEN;
+        ctx->clone_ctx.hash_type = MBEDTLS_ALT_HASH_TYPE_SHA384;
+    }
+#endif
+    if(is384 == 0) {
+        ctx->result_size = SHA512_LEN;
+        ctx->clone_ctx.hash_type = MBEDTLS_ALT_HASH_TYPE_SHA512;
+    }
+
+    ret = mbedtls_alt_hash_start(&ctx->clone_ctx, ctx->clone_ctx.hash_type);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_sha512_update(mbedtls_sha512_context *ctx, const unsigned char *input, size_t ilen)
+{
+    int ret = -1;
+
+    mbedtls_harden_log_func_enter();
+    SHA512_VALIDATE_RET(ctx != NULL);
+    SHA512_VALIDATE_RET(ilen == 0 || input != NULL);
+
+    if(ilen == 0) {
+        return 0;
+    }
+
+    ret = mbedtls_alt_hash_update(&ctx->clone_ctx, input, ilen);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+int mbedtls_sha512_finish(mbedtls_sha512_context *ctx, unsigned char *output)
+{
+    int ret = -1;
+    mbedtls_harden_log_func_enter();
+    SHA512_VALIDATE_RET(ctx != NULL);
+    SHA512_VALIDATE_RET((unsigned char *)output != NULL);
+
+    ret = mbedtls_alt_hash_finish(&ctx->clone_ctx, output, ctx->result_size);
+
+    mbedtls_harden_log_func_exit();
+    return ret;
+}
+
+#endif /* MBEDTLS_SHA512_ALT */
diff --git a/include/mbedtls/blowfish.h b/include/mbedtls/blowfish.h
new file mode 100644
index 0000000..0e0f2ce
--- /dev/null
+++ b/include/mbedtls/blowfish.h
@@ -0,0 +1,274 @@
+/**
+ * \file blowfish.h
+ *
+ * \brief Blowfish block cipher
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+#ifndef MBEDTLS_BLOWFISH_H
+#define MBEDTLS_BLOWFISH_H
+#include "mbedtls/private_access.h"
+#include "mbedtls/build_info.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "mbedtls/platform_util.h"
+
+#define MBEDTLS_BLOWFISH_ENCRYPT     1
+#define MBEDTLS_BLOWFISH_DECRYPT     0
+#define MBEDTLS_BLOWFISH_MAX_KEY_BITS     448
+#define MBEDTLS_BLOWFISH_MIN_KEY_BITS     32
+#define MBEDTLS_BLOWFISH_ROUNDS      16         /**< Rounds to use. When increasing this value, make sure to extend the initialisation vectors */
+#define MBEDTLS_BLOWFISH_BLOCKSIZE   8          /* Blowfish uses 64 bit blocks */
+
+#define MBEDTLS_ERR_BLOWFISH_BAD_INPUT_DATA -0xA016 /**< Bad input data. */
+
+#define MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH -0xA018 /**< Invalid data input length. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !defined(MBEDTLS_BLOWFISH_ALT)
+// Regular implementation
+//
+
+/**
+ * \brief          Blowfish context structure
+ */
+typedef struct mbedtls_blowfish_context
+{
+    uint32_t MBEDTLS_PRIVATE(P)[MBEDTLS_BLOWFISH_ROUNDS + 2];    /*!<  Blowfish round keys    */
+    uint32_t MBEDTLS_PRIVATE(S)[4][256];                 /*!<  key dependent S-boxes  */
+}
+mbedtls_blowfish_context;
+
+#else  /* MBEDTLS_BLOWFISH_ALT */
+#include "blowfish_alt.h"
+#endif /* MBEDTLS_BLOWFISH_ALT */
+
+/**
+ * \brief          Initialize a Blowfish context.
+ *
+ * \param ctx      The Blowfish context to be initialized.
+ *                 This must not be \c NULL.
+ */
+void mbedtls_blowfish_init( mbedtls_blowfish_context *ctx );
+
+/**
+ * \brief          Clear a Blowfish context.
+ *
+ * \param ctx      The Blowfish context to be cleared.
+ *                 This may be \c NULL, in which case this function
+ *                 returns immediately. If it is not \c NULL, it must
+ *                 point to an initialized Blowfish context.
+ */
+void mbedtls_blowfish_free( mbedtls_blowfish_context *ctx );
+
+/**
+ * \brief          Perform a Blowfish key schedule operation.
+ *
+ * \param ctx      The Blowfish context to perform the key schedule on.
+ * \param key      The encryption key. This must be a readable buffer of
+ *                 length \p keybits Bits.
+ * \param keybits  The length of \p key in Bits. This must be between
+ *                 \c 32 and \c 448 and a multiple of \c 8.
+ *
+ * \return         \c 0 if successful.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_blowfish_setkey( mbedtls_blowfish_context *ctx, const unsigned char *key,
+                     unsigned int keybits );
+
+/**
+ * \brief          Perform a Blowfish-ECB block encryption/decryption operation.
+ *
+ * \param ctx      The Blowfish context to use. This must be initialized
+ *                 and bound to a key.
+ * \param mode     The mode of operation. Possible values are
+ *                 #MBEDTLS_BLOWFISH_ENCRYPT for encryption, or
+ *                 #MBEDTLS_BLOWFISH_DECRYPT for decryption.
+ * \param input    The input block. This must be a readable buffer
+ *                 of size \c 8 Bytes.
+ * \param output   The output block. This must be a writable buffer
+ *                 of size \c 8 Bytes.
+ *
+ * \return         \c 0 if successful.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_blowfish_crypt_ecb( mbedtls_blowfish_context *ctx,
+                        int mode,
+                        const unsigned char input[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                        unsigned char output[MBEDTLS_BLOWFISH_BLOCKSIZE] );
+
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+/**
+ * \brief          Perform a Blowfish-CBC buffer encryption/decryption operation.
+ *
+ * \note           Upon exit, the content of the IV is updated so that you can
+ *                 call the function same function again on the following
+ *                 block(s) of data and get the same result as if it was
+ *                 encrypted in one call. This allows a "streaming" usage.
+ *                 If on the other hand you need to retain the contents of the
+ *                 IV, you should either save it manually or use the cipher
+ *                 module instead.
+ *
+ * \param ctx      The Blowfish context to use. This must be initialized
+ *                 and bound to a key.
+ * \param mode     The mode of operation. Possible values are
+ *                 #MBEDTLS_BLOWFISH_ENCRYPT for encryption, or
+ *                 #MBEDTLS_BLOWFISH_DECRYPT for decryption.
+ * \param length   The length of the input data in Bytes. This must be
+ *                 multiple of \c 8.
+ * \param iv       The initialization vector. This must be a read/write buffer
+ *                 of length \c 8 Bytes. It is updated by this function.
+ * \param input    The input data. This must be a readable buffer of length
+ *                 \p length Bytes.
+ * \param output   The output data. This must be a writable buffer of length
+ *                 \p length Bytes.
+ *
+ * \return         \c 0 if successful.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_blowfish_crypt_cbc( mbedtls_blowfish_context *ctx,
+                        int mode,
+                        size_t length,
+                        unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                        const unsigned char *input,
+                        unsigned char *output );
+#endif /* MBEDTLS_CIPHER_MODE_CBC */
+
+#if defined(MBEDTLS_CIPHER_MODE_CFB)
+/**
+ * \brief          Perform a Blowfish CFB buffer encryption/decryption operation.
+ *
+ * \note           Upon exit, the content of the IV is updated so that you can
+ *                 call the function same function again on the following
+ *                 block(s) of data and get the same result as if it was
+ *                 encrypted in one call. This allows a "streaming" usage.
+ *                 If on the other hand you need to retain the contents of the
+ *                 IV, you should either save it manually or use the cipher
+ *                 module instead.
+ *
+ * \param ctx      The Blowfish context to use. This must be initialized
+ *                 and bound to a key.
+ * \param mode     The mode of operation. Possible values are
+ *                 #MBEDTLS_BLOWFISH_ENCRYPT for encryption, or
+ *                 #MBEDTLS_BLOWFISH_DECRYPT for decryption.
+ * \param length   The length of the input data in Bytes.
+ * \param iv_off   The offset in the initialiation vector.
+ *                 The value pointed to must be smaller than \c 8 Bytes.
+ *                 It is updated by this function to support the aforementioned
+ *                 streaming usage.
+ * \param iv       The initialization vector. This must be a read/write buffer
+ *                 of size \c 8 Bytes. It is updated after use.
+ * \param input    The input data. This must be a readable buffer of length
+ *                 \p length Bytes.
+ * \param output   The output data. This must be a writable buffer of length
+ *                 \p length Bytes.
+ *
+ * \return         \c 0 if successful.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_blowfish_crypt_cfb64( mbedtls_blowfish_context *ctx,
+                          int mode,
+                          size_t length,
+                          size_t *iv_off,
+                          unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                          const unsigned char *input,
+                          unsigned char *output );
+#endif /*MBEDTLS_CIPHER_MODE_CFB */
+
+#if defined(MBEDTLS_CIPHER_MODE_CTR)
+/**
+ * \brief      Perform a Blowfish-CTR buffer encryption/decryption operation.
+ *
+ * \warning    You must never reuse a nonce value with the same key. Doing so
+ *             would void the encryption for the two messages encrypted with
+ *             the same nonce and key.
+ *
+ *             There are two common strategies for managing nonces with CTR:
+ *
+ *             1. You can handle everything as a single message processed over
+ *             successive calls to this function. In that case, you want to
+ *             set \p nonce_counter and \p nc_off to 0 for the first call, and
+ *             then preserve the values of \p nonce_counter, \p nc_off and \p
+ *             stream_block across calls to this function as they will be
+ *             updated by this function.
+ *
+ *             With this strategy, you must not encrypt more than 2**64
+ *             blocks of data with the same key.
+ *
+ *             2. You can encrypt separate messages by dividing the \p
+ *             nonce_counter buffer in two areas: the first one used for a
+ *             per-message nonce, handled by yourself, and the second one
+ *             updated by this function internally.
+ *
+ *             For example, you might reserve the first 4 bytes for the
+ *             per-message nonce, and the last 4 bytes for internal use. In that
+ *             case, before calling this function on a new message you need to
+ *             set the first 4 bytes of \p nonce_counter to your chosen nonce
+ *             value, the last 4 to 0, and \p nc_off to 0 (which will cause \p
+ *             stream_block to be ignored). That way, you can encrypt at most
+ *             2**32 messages of up to 2**32 blocks each with the same key.
+ *
+ *             The per-message nonce (or information sufficient to reconstruct
+ *             it) needs to be communicated with the ciphertext and must be unique.
+ *             The recommended way to ensure uniqueness is to use a message
+ *             counter.
+ *
+ *             Note that for both stategies, sizes are measured in blocks and
+ *             that a Blowfish block is 8 bytes.
+ *
+ * \warning    Upon return, \p stream_block contains sensitive data. Its
+ *             content must not be written to insecure storage and should be
+ *             securely discarded as soon as it's no longer needed.
+ *
+ * \param ctx           The Blowfish context to use. This must be initialized
+ *                      and bound to a key.
+ * \param length        The length of the input data in Bytes.
+ * \param nc_off        The offset in the current stream_block (for resuming
+ *                      within current cipher stream). The offset pointer
+ *                      should be \c 0 at the start of a stream and must be
+ *                      smaller than \c 8. It is updated by this function.
+ * \param nonce_counter The 64-bit nonce and counter. This must point to a
+ *                      read/write buffer of length \c 8 Bytes.
+ * \param stream_block  The saved stream-block for resuming. This must point to
+ *                      a read/write buffer of length \c 8 Bytes.
+ * \param input         The input data. This must be a readable buffer of
+ *                      length \p length Bytes.
+ * \param output        The output data. This must be a writable buffer of
+ *                      length \p length Bytes.
+ *
+ * \return              \c 0 if successful.
+ * \return              A negative error code on failure.
+ */
+int mbedtls_blowfish_crypt_ctr( mbedtls_blowfish_context *ctx,
+                        size_t length,
+                        size_t *nc_off,
+                        unsigned char nonce_counter[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                        unsigned char stream_block[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                        const unsigned char *input,
+                        unsigned char *output );
+#endif /* MBEDTLS_CIPHER_MODE_CTR */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* blowfish.h */
diff --git a/include/mbedtls/config_adjust_legacy_crypto.h b/include/mbedtls/config_adjust_legacy_crypto.h
index 9b06041..d76b0d8 100644
--- a/include/mbedtls/config_adjust_legacy_crypto.h
+++ b/include/mbedtls/config_adjust_legacy_crypto.h
@@ -174,6 +174,9 @@
 #define MBEDTLS_MD_CAN_SHA512
 #define MBEDTLS_MD_SOME_LEGACY
 #endif
+#if defined(MBEDTLS_SM3_C)
+#define MBEDTLS_MD_CAN_SM3
+#endif
 #if defined(MBEDTLS_SHA3_C)
 #define MBEDTLS_MD_CAN_SHA3_224
 #define MBEDTLS_MD_CAN_SHA3_256
diff --git a/include/mbedtls/crypto_api.h b/include/mbedtls/crypto_api.h
new file mode 100644
index 0000000..1a878c4
--- /dev/null
+++ b/include/mbedtls/crypto_api.h
@@ -0,0 +1,6 @@
+#ifndef MBEDTLS_CRYPTO_API_H
+#define MBEDTLS_CRYPTO_API_H
+
+#include "hw_polarssl_api.h"
+
+#endif
\ No newline at end of file
diff --git a/include/mbedtls/ecp.h b/include/mbedtls/ecp.h
index d8f73ae..57e9477 100644
--- a/include/mbedtls/ecp.h
+++ b/include/mbedtls/ecp.h
@@ -62,7 +62,8 @@
     defined(MBEDTLS_ECP_DP_BP512R1_ENABLED) || \
     defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) || \
     defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) || \
-    defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
+    defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED) || \
+    defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED)
 #define MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED
 #endif
 #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED) || \
@@ -114,6 +115,7 @@ typedef enum {
     MBEDTLS_ECP_DP_SECP224K1,      /*!< Domain parameters for 224-bit "Koblitz" curve. */
     MBEDTLS_ECP_DP_SECP256K1,      /*!< Domain parameters for 256-bit "Koblitz" curve. */
     MBEDTLS_ECP_DP_CURVE448,       /*!< Domain parameters for Curve448. */
+    MBEDTLS_ECP_DP_SM2P256V1,      /*!< Domain parameters for the 256-bit curve defined by SM2. */
 } mbedtls_ecp_group_id;
 
 /**
@@ -337,6 +339,8 @@ mbedtls_ecp_group;
 #define MBEDTLS_ECP_MAX_BITS 256
 #elif defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED)
 #define MBEDTLS_ECP_MAX_BITS 256
+#elif defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED)
+#define MBEDTLS_ECP_MAX_BITS 256
 #elif defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
 #define MBEDTLS_ECP_MAX_BITS 255
 #elif defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED)
diff --git a/include/mbedtls/hw_mbedtls_config.h b/include/mbedtls/hw_mbedtls_config.h
new file mode 100644
index 0000000..747663f
--- /dev/null
+++ b/include/mbedtls/hw_mbedtls_config.h
@@ -0,0 +1,52 @@
+/*
+ * 版权所有 (c) 华为技术有限公司 2014-2022
+ * 生成日期: 2022年7月20日
+ * 功能描述: 在mbedtls库中，适配polarssl的API接口。
+ * 使用编译宏HUAWEI_POLARSSL_API_C进行隔离。
+ */
+#ifndef HW_MBEDTLS_CONFIG_H
+#define HW_MBEDTLS_CONFIG_H
+
+/*****************************************************************************
+ * \brief 配置使能
+ * 
+******************************************************************************/
+#define HW_MBEDTLS_CONFIG_DISABLE   (0)
+
+/*****************************************************************************
+ * \brief 配置不使能
+ * 
+******************************************************************************/
+#define HW_MBEDTLS_CONFIG_ENABLE    (1)
+
+/*****************************************************************************
+ * \brief 华为定制修改，用于动态调整mbedtls库的功能。
+ * 
+******************************************************************************/
+typedef enum HW_MBEDTLS_CONFIG_TYPES_en {
+    HW_MBEDTLS_CONFIG_NONE = 0,             /* 无效值 */
+    HW_MBEDTLS_CHECK_CERT_DATE = 1,         /* SSL协议栈校验证书有效期，mbedtls库默认校验 */
+    HW_MBEDTLS_CHECK_CERT_ISSUE_NAME = 2,   /* X.509证书校验发生者名字，mbedtls库默认校验 */
+    HW_MBEDTLS_DISABLE_MD2 = 3,             /* 禁用MD2，默认为1，不使用MD2 */
+    HW_MBEDTLS_DISABLE_MD4 = 4,             /* 禁用MD4，默认为1，不使用MD4 */
+    HW_MBEDTLS_CONFIG_BUTT
+} HW_MBEDTLS_CONFIG_TYPES;
+
+/*****************************************************************************
+ * \brief 配置mbedtls动态开关。
+ * 
+ * \param type 需要修改的特性名。
+ * \param value 0表示关闭此特性，非0表示打开此特性。
+ * \return int 0表示设置成功，非0表示设置失败。
+******************************************************************************/
+int hw_mbedtls_set_config(HW_MBEDTLS_CONFIG_TYPES type, int value);
+
+/*****************************************************************************
+ * \brief 获取mbedtls定制特性的动态值。
+ * 
+ * \param type 需要查询的特性名。
+ * \return int 返回此特性的值：0表示没有开启；1表示开启；-1表示处理错误，未知状态。
+******************************************************************************/
+int hw_mbedtls_get_config(HW_MBEDTLS_CONFIG_TYPES type);
+
+#endif
diff --git a/include/mbedtls/hw_polarssl_api.h b/include/mbedtls/hw_polarssl_api.h
new file mode 100644
index 0000000..76dcb30
--- /dev/null
+++ b/include/mbedtls/hw_polarssl_api.h
@@ -0,0 +1,335 @@
+/*
+ * ��Ȩ���� (c) ��Ϊ�������޹�˾ 2014-2022
+ * ��������: 2022��7��20��
+ * ��������: ��mbedtls���У�����polarssl��API�ӿڡ�
+ * ʹ�ñ����HUAWEI_POLARSSL_API_C���и��롣
+ */
+#ifndef HW_POLARSSL_API_H
+#define HW_POLARSSL_API_H
+
+#include "mbedtls/debug.h"
+#include "mbedtls/x509_crt.h"
+#include "mbedtls/ssl.h"
+#include "mbedtls/platform.h"
+#include "mbedtls/net_sockets.h"
+#include "mbedtls/entropy.h"
+#include "mbedtls/ctr_drbg.h"
+#include "mbedtls/pem.h"
+#include "mbedtls/des.h"
+#include "mbedtls/ssl_cache.h"
+#include "mbedtls/pkcs5.h"
+#include "mbedtls/md5.h"
+#include "mbedtls/sha1.h"
+#include "mbedtls/dhm.h"
+#include "mbedtls/oid.h"
+#include "mbedtls/pk.h"
+
+/* ��һģ�� ����cyassl��ʹ�÷�ʽ */
+typedef struct {
+    mbedtls_ssl_config * config;
+    mbedtls_entropy_context * entropy;
+    mbedtls_ctr_drbg_context * ctr_drbg;
+    mbedtls_x509_crt * pubcert;
+    mbedtls_pk_context *prv;
+    mbedtls_x509_crt * chainHead; /* calist */
+    mbedtls_ssl_cache_context *cache;
+} mbedtls_ssl_config_adapt;
+
+typedef struct {
+    mbedtls_ssl_context *ssl;
+    mbedtls_net_context bio;
+    mbedtls_ssl_session *saved_session;
+} mbedtls_ssl_adapt;
+
+/* polarssl Ĭ��������hostname�ͷ���sni �˲�����Ҫ���� */
+#define MAX_SNI_LEN 256
+typedef struct {
+    int send_sni;
+    char hostname[MAX_SNI_LEN];
+} mbedtls_ssl_sni;
+
+#if !defined(CIVETWEB_SSL)
+/* ���仪Ϊ���� */
+#define POLAR_SSL mbedtls_ssl_adapt
+#define POLAR_SSL_CFG mbedtls_ssl_config_adapt
+#define POLAR_CRT  mbedtls_x509_crt
+#define POLAR_PUBKEY  mbedtls_pk_context
+#define POLAR_RSA mbedtls_rsa_context
+#define POLAR_MD_CTX mbedtls_md_context_t
+#define SSL_CTX POLAR_SSL_CFG
+#define SSL POLAR_SSL
+#define DH_KEY mbedtls_dhm_context
+#define AES_KEY mbedtls_aes_context
+#define PEM_CRT mbedtls_pem_context
+#define POLAR_MPI mbedtls_mpi
+#endif
+
+/* ���仪Ϊ����ģʽ */
+#define Polarssl_New_Ssl polarssl_new_ssl
+#define Polarssl_New_Ctx_Ssl_Conf polarssl_new_ctx_ssl_conf
+#define Polarssl_Ssl_Set_Bio polarssl_ssl_set_bio
+#define Polarssl_Enable_Ca_Update polarssl_enable_ca_update
+#define Polarssl_Ssl_Get_Ciphersuite polarssl_ssl_get_ciphersuite
+#define Polarssl_Conf_SetCaList polarssl_conf_setCaList
+#define Polarssl_Rsassl_Vertify polarssl_rsassl_vertify
+#define Polarssl_Ssl_Get_Version polarssl_ssl_get_version
+#define Polarssl_Ssl_Write polarssl_ssl_write
+#define Polarssl_Ssl_Read polarssl_ssl_read
+#define Polarssl_Set_Pub_Prv_To_Conf polarssl_set_pub_prv_to_conf
+#define Polarssl_Pk_Parse_Subpubkey polarssl_pk_parse_subpubkey
+#define Polarssl_X509_Crt_Parse_File polarssl_x509_crt_parse_file
+#define Polarssl_Hmac_With_Sha256 polarssl_hmac_with_sha256
+#define Polarssl_Conf_Authmode polarssl_conf_authmode
+#define Polarssl_Free_Config_Adapt polarssl_free_config_adapt
+#define Polarssl_Free polarssl_free
+#define Polarssl_Accept polarssl_accept
+#define Polarssl_Connect polarssl_connect
+#define Polarssl_X509_Crt_Free polarssl_x509_crt_free
+#define Polarssl_X509_Crt_Check_Date polarssl_x509_crt_check_date
+#define Polarssl_Shutdown polarssl_shutdown
+#define Polarssl_Set_Hostname polarssl_ssl_set_hostname
+#define Polarssl_Dgst polarssl_dgst
+#define Polarssl_Dgst_Init polarssl_dgst_init
+#define Polarssl_Dgst_Update polarssl_dgst_update
+#define Polarssl_Dgst_Final polarssl_dgst_final
+#define Polarssl_Md_Hmac512 polarssl_md_hmac512
+#define Polarssl_Md_Hmacsha1 polarssl_hmac_with_sha1
+#define Polarssl_Sha512 polarssl_sha512
+#define PolarssL_Pk_Free polarssl_pk_free
+#define Polarssl_Dhm_Free polarssl_dhm_free
+#define Polarssl_Dhm_Init polarssl_dhm_init
+#define Polarssl_Mpi_Read_String polarssl_mpi_read_string
+#define Polarssl_Mpi_Size polarssl_mpi_size
+#define Polarssl_Dhm_Make_Public polarssl_dhm_make_public
+#define Polarssl_Aes_Init polarssl_aes_init
+#define Polarssl_Aes_SetKey_Dec polarssl_aes_setkey_dec
+#define Polarssl_Aes_Crypt_Cbc polarssl_aes_crypt_cbc
+#define Polarssl_Aes_SetKey_Enc polarssl_aes_setkey_enc
+#define Polarssl_Mpi_Write_Binary polarssl_mpi_write_binary
+#define Polarssl_Mpi_Read_Binary polarssl_mpi_read_binary
+#define Polarssl_Dhm_Calc_Secret polarssl_dhm_calc_secret
+#define Polarssl_Ssl_Conf_Ciphersuites polarssl_ssl_conf_ciphersuites
+#define Polarssl_Pem_Read_Buffer polarssl_pem_read_buffer
+#define Polarssl_Pem_Free polarssl_pem_free
+#define Polarssl_Set_Sni polarssl_ssl_set_sni
+#define Polarssl_SetIgnoreTime SetIgnoreTime
+
+/* AES�ļ���ģ���СΪ16�ֽ� */
+#define AES_BLOCK_SIZE 16
+
+/* ����sni */
+int polarssl_ssl_set_sni(mbedtls_ssl_adapt *ssl, const char *hostname);
+
+/* hmac��װ��ժҪ����Ϊsha1 */
+int polarssl_hmac_with_sha1(const unsigned char *key, size_t keylen,
+                            const unsigned char *input, size_t ilen,
+                            unsigned char *output,size_t *outlen);
+
+/* free */
+void polarssl_pem_free(mbedtls_pem_context *ctx);
+
+/* ����PUBLIC KEY֤�� */
+int polarssl_pem_read_buffer(mbedtls_pem_context *pem,unsigned char *pub);
+
+/* ����Э��ʱ���㷨����,�ⲿ��ʹ�þ�̬���� */
+void polarssl_ssl_conf_ciphersuites(mbedtls_ssl_config_adapt *conf, const int *ciphersuites);
+
+/* Derive and export the shared secret (G^Y)^X mod P */
+int polarssl_dhm_calc_secret(mbedtls_dhm_context *ctx,
+                             unsigned char *output, size_t output_size, unsigned int *olen);
+
+/* Import X from unsigned binary data, big endian */
+int polarssl_mpi_read_binary(mbedtls_mpi *X, const unsigned char *buf, unsigned int buflen);
+
+/* Export X into unsigned binary data, big endian */
+int polarssl_mpi_write_binary(const mbedtls_mpi *X, unsigned char *buf, size_t buflen);
+
+/* setAesKey */
+int polarssl_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *key, unsigned int keybits);
+
+/* AES-CBC buffer encryption/decryption */
+int polarssl_aes_crypt_cbc(mbedtls_aes_context *ctx, int mode, unsigned int length,
+                           unsigned char iv[16], const unsigned char *input, unsigned char *output);
+
+/* setAesKey */
+int polarssl_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *key, unsigned int keybits);
+
+/* init the para */
+void polarssl_aes_init(mbedtls_aes_context *ctx);
+
+/* Create own private value X and export G^X */
+int polarssl_dhm_make_public(mbedtls_dhm_context *ctx, int x_size, unsigned char *output, size_t olen);
+
+/* Return the total size in bytes */
+size_t polarssl_mpi_size(const mbedtls_mpi *X);
+
+/* Import from an ASCII string */
+int polarssl_mpi_read_string(mbedtls_mpi *X, int radix, const char *s);
+
+/* init the dh */
+void polarssl_dhm_init(mbedtls_dhm_context *ctx);
+
+/* Free the components of a DHM key */
+void polarssl_dhm_free(mbedtls_dhm_context *ctx);
+
+/* free pk */
+void polarssl_pk_free(mbedtls_pk_context *ctx);
+
+/* sha512 */
+void polarssl_sha512(const unsigned char *input, size_t ilen, unsigned char output[64], int is384);
+
+/* hmac512 */
+int polarssl_md_hmac512(const unsigned char *key, size_t keylen, const unsigned char *input, size_t ilen,
+                        unsigned char *output);
+
+/* ���cyasslģ�ʹ���ssl���� */
+mbedtls_ssl_adapt *polarssl_new_ssl(mbedtls_ssl_config_adapt * config);
+
+/* ���cyassl����ģ�� ���亯�� */
+mbedtls_ssl_config_adapt *polarssl_new_ctx_ssl_conf(int connect_type);
+
+/* ��socket���õ�ssl������ */
+void polarssl_ssl_set_bio(mbedtls_ssl_adapt *ssl, int fd);
+
+/* scp�е�����ҵ������ */
+void polarssl_enable_ca_update(int enable);
+
+int polarssl_get_caupdate(void);
+
+/* ��ȡssl������ʹ�õļ����㷨 */
+const char *polarssl_ssl_get_ciphersuite(const mbedtls_ssl_adapt *ssl);
+
+/* ��cafile��cadirĿ¼�µ������ļ����õ�conf��ȥ,û����Ч֤����ʧ�� */
+int polarssl_conf_setCaList(mbedtls_ssl_config_adapt *conf, char *cafile, char *cadir, char *crlFile);
+
+/* hash256 ժҪ�� x509 rsa֤��У���ж� */;
+int polarssl_rsassl_vertify(unsigned char *sig, unsigned int siglen,
+                            unsigned char *data, unsigned int datalen,
+                            mbedtls_rsa_context	* rsa);
+/* SSL��ȡversion */
+const char *polarssl_ssl_get_version(const mbedtls_ssl_adapt *ssl);
+
+/* SSL��write���� */
+int polarssl_ssl_write(mbedtls_ssl_adapt *ssl, const unsigned char *buf, size_t len);
+
+/* SSL��read���� */
+int polarssl_ssl_read(mbedtls_ssl_adapt *ssl, unsigned char *buf, size_t len);
+
+/* ��һ��pub/priv key���õ����� */
+int polarssl_set_pub_prv_to_conf(mbedtls_ssl_config_adapt *conf, const char *prvPath,
+                                 const char *pubPath, const char *prvPassword);
+
+/* ��der��ʽ�Ĺ�Կ�н�����N/E rsa key��Ҫ��der��ʽ��ֻ������һ�� */
+int polarssl_pk_parse_subpubkey(unsigned char *buf, int len, mbedtls_pk_context *pk);
+
+/* �����ļ�����crt/der��ʽ��֤�� */
+mbedtls_x509_crt *polarssl_x509_crt_parse_file(const char *path);
+
+/* hmac��װ��ժҪ����Ϊsha256 */
+int polarssl_hmac_with_sha256(const unsigned char *key, size_t keylen,
+                              const unsigned char *input, size_t ilen,
+                              unsigned char *output, size_t outlen);
+/* ������֤ģʽ */
+void polarssl_conf_authmode(mbedtls_ssl_config_adapt *conf, int authmode);
+
+/* SSL���ñ����ͷ� */
+void polarssl_free_config_adapt(mbedtls_ssl_config_adapt *conf);
+
+/* SSL free���� */
+void polarssl_free(mbedtls_ssl_adapt *ssl);
+
+/* SSL accept���� */
+int polarssl_accept(mbedtls_ssl_adapt *ssl);
+
+/* SSL accept���� */
+int polarssl_connect(mbedtls_ssl_adapt *ssl);
+
+/* free crt ֤�� */
+void polarssl_x509_crt_free(mbedtls_x509_crt *crt);
+
+/* У��֤�������Ƿ���Ч */
+int polarssl_x509_crt_check_date(const char* filename);
+
+/* ֪ͨ�Զ˹ر����� */
+int polarssl_shutdown(mbedtls_ssl_adapt *ssl);
+
+/* ����CN��������������У��,ͬʱ�ᷢ��SNI */
+int polarssl_ssl_set_hostname(mbedtls_ssl_adapt *ssl, const char *hostname);
+
+/* ժҪ�㷨�ϼ�ռʱ֧��md5/sha1 */
+void polarssl_dgst(int type, unsigned char *input, size_t ilen, unsigned char *output, size_t *olen);
+
+/* ����init/update/finalժҪ�㷨��ʽ�ϼ� */
+int polarssl_dgst_init(mbedtls_md_context_t *ctx, int type);
+
+/* ����init/update/finalժҪ�㷨��ʽ�ϼ� */
+void polarssl_dgst_update(mbedtls_md_context_t *ctx, unsigned char *input, size_t ilen);
+
+/* ����init/update/finalժҪ�㷨��ʽ�ϼ� */
+void polarssl_dgst_final(mbedtls_md_context_t *ctx, unsigned char *output);
+
+/* ���ò�У��ʱ���־ */
+int SetIgnoreTime(int value);
+int polarssl_get_checktime(void);
+
+int polarssl_ischeck_crttime(mbedtls_x509_crt *crt);
+/* ��Ʒ������Ƿ�ҪУ��֤��ʱ��ĺ�����ҪУ�鷵��1����У����0 */
+typedef int (*PdtCertTimeCheckFunc)(const mbedtls_x509_crt *crt);
+int SetPdtCertTimeCheckFunc(PdtCertTimeCheckFunc func);
+
+int polarssl_ischeck_crltime(mbedtls_x509_crl *crl);
+/* ��Ʒ������Ƿ�ҪУ��CRLʱ��ĺ�����ҪУ�鷵��1����У����0 */
+typedef int (*PdtCrlTimeCheckFunc)(const mbedtls_x509_crl *crl);
+int SetPdtCrlTimeCheckFunc(PdtCrlTimeCheckFunc func);
+
+int x509_info_subject_alt_name(char **buf, size_t *size, const mbedtls_x509_sequence *subject_alt_name, const char *prefix );
+
+/* ����dh���� */
+int  polarssl_ssl_conf_dh_param_ctx(mbedtls_ssl_config_adapt *conf, mbedtls_dhm_context *ctx);
+
+/* ���㹲����Կ */
+int polarssl_ssl_calc_key(const unsigned char *pw, unsigned int pwLen, const unsigned char *salt, unsigned int saltLen,
+    unsigned char *key, unsigned int keyLen);
+
+/* ���ù�����Կ */
+void polarssl_ssl_conf_psk(mbedtls_ssl_config_adapt *ctx, unsigned char *key, unsigned int keyLen,
+    const unsigned char *ident, unsigned int identLen);
+
+/* aes�ӽ��� */
+int mbedtls_aescrypt2( int mode, const char *filein, const char *fileout, unsigned char *key, size_t keylen );
+
+/* ʹ�ܷ���˻��� */
+void polarssl_enable_server_cache(mbedtls_ssl_config_adapt *conf, uint32_t cache_num, uint32_t timeout);
+
+/* ʹ�ܿͻ��˻��� */
+void polarssl_enable_client_cache(mbedtls_ssl_adapt *ssl);
+
+int polarssl_pk_parse_keyfile(mbedtls_pk_context *ctx, const char *path, const char *password);
+
+int polarssl_pk_parse_key(mbedtls_pk_context *ctx, const unsigned char *key, size_t keylen,
+    const unsigned char *pwd, size_t pwdlen);
+
+int polarssl_pk_check_pair(const mbedtls_pk_context *pub, const mbedtls_pk_context *prv);
+
+int polarss_feather_support(char *featureName);
+
+int ssl_deprecated_kexsize_support(void);
+
+void mbedtls_set_udm_ssl_conf(mbedtls_ssl_config_adapt *config);
+
+// ��x509_crt.h���ƹ�����API
+int mbedtls_x509_crt_check_date(const char* filename);
+
+// ��pk.h���ƹ�����API
+int mbedtls_pk_write_crypt_key_pem(mbedtls_pk_context *key, const unsigned char *pwd, unsigned char *buf, size_t size);
+
+// ��pem.h���ƹ�����API
+int mbedtls_pem_write_crypt_buffer(const char *header, const char *footer,
+                                   unsigned char *der_data, size_t der_len,
+                                   const unsigned char * pwd, size_t pwdlen, 
+                                   unsigned char *buf, size_t buf_len, size_t *olen);
+
+/*?????? md2,md4?????? */
+int polarssl_dgst_check(mbedtls_md_type_t md_alg);
+
+#endif
diff --git a/include/mbedtls/mbedtls_config.h b/include/mbedtls/mbedtls_config.h
index 3592141..51f4ea5 100644
--- a/include/mbedtls/mbedtls_config.h
+++ b/include/mbedtls/mbedtls_config.h
@@ -2434,6 +2434,15 @@
  */
 #define MBEDTLS_BIGNUM_C
 
+/**
+ * \def MBEDTLS_BLOWFISH_C
+ *
+ * Enable the Blowfish block cipher.
+ *
+ * Module:  library/blowfish.c
+ */
+//#define MBEDTLS_BLOWFISH_C
+
 /**
  * \def MBEDTLS_CAMELLIA_C
  *
@@ -2931,6 +2940,40 @@
  */
 #define MBEDTLS_MD_C
 
+/**
+ * \def MBEDTLS_MD2_C
+ *
+ * Enable the MD2 hash algorithm.
+ *
+ * Module:  library/md2.c
+ * Caller:
+ *
+ * Uncomment to enable support for (rare) MD2-signed X.509 certs.
+ *
+ * \warning   MD2 is considered a weak message digest and its use constitutes a
+ *            security risk. If possible, we recommend avoiding dependencies on
+ *            it, and considering stronger message digests instead.
+ *
+ */
+//#define MBEDTLS_MD2_C
+
+/**
+ * \def MBEDTLS_MD4_C
+ *
+ * Enable the MD4 hash algorithm.
+ *
+ * Module:  library/md4.c
+ * Caller:
+ *
+ * Uncomment to enable support for (rare) MD4-signed X.509 certs.
+ *
+ * \warning   MD4 is considered a weak message digest and its use constitutes a
+ *            security risk. If possible, we recommend avoiding dependencies on
+ *            it, and considering stronger message digests instead.
+ *
+ */
+//#define MBEDTLS_MD4_C
+
 /**
  * \def MBEDTLS_MD5_C
  *
diff --git a/include/mbedtls/md.h b/include/mbedtls/md.h
index 478e9f7..156ad02 100644
--- a/include/mbedtls/md.h
+++ b/include/mbedtls/md.h
@@ -36,7 +36,7 @@ extern "C" {
 /**
  * \brief     Supported message digests.
  *
- * \warning   MD5 and SHA-1 are considered weak message digests and
+ * \warning   MD2,MD4,MD5 and SHA-1 are considered weak message digests and
  *            their use constitutes a security risk. We recommend considering
  *            stronger message digests instead.
  *
@@ -46,6 +46,12 @@ extern "C" {
  * This is tested by md_to_from_psa() in test_suite_md. */
 typedef enum {
     MBEDTLS_MD_NONE=0,    /**< None. */
+#if defined(MBEDTLS_MD2_C)    
+    MBEDTLS_MD_MD2,       /**< The MD2 message digest. */
+#endif
+#if defined(MBEDTLS_MD4_C)    
+    MBEDTLS_MD_MD4,       /**< The MD4 message digest. */
+#endif
     MBEDTLS_MD_MD5=0x03,       /**< The MD5 message digest. */
     MBEDTLS_MD_RIPEMD160=0x04, /**< The RIPEMD-160 message digest. */
     MBEDTLS_MD_SHA1=0x05,      /**< The SHA-1 message digest. */
@@ -53,6 +59,7 @@ typedef enum {
     MBEDTLS_MD_SHA256=0x09,    /**< The SHA-256 message digest. */
     MBEDTLS_MD_SHA384=0x0a,    /**< The SHA-384 message digest. */
     MBEDTLS_MD_SHA512=0x0b,    /**< The SHA-512 message digest. */
+    MBEDTLS_MD_SM3=0x0c,       /**< The SM3 message digest. */
     MBEDTLS_MD_SHA3_224=0x10,  /**< The SHA3-224 message digest. */
     MBEDTLS_MD_SHA3_256=0x11,  /**< The SHA3-256 message digest. */
     MBEDTLS_MD_SHA3_384=0x12,  /**< The SHA3-384 message digest. */
diff --git a/include/mbedtls/md2.h b/include/mbedtls/md2.h
new file mode 100644
index 0000000..ee346eb
--- /dev/null
+++ b/include/mbedtls/md2.h
@@ -0,0 +1,200 @@
+/**
+ * \file md2.h
+ *
+ * \brief MD2 message digest algorithm (hash function)
+ *
+ * \warning MD2 is considered a weak message digest and its use constitutes a
+ *          security risk. We recommend considering stronger message digests
+ *          instead.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ */
+#ifndef MBEDTLS_MD2_H
+#define MBEDTLS_MD2_H
+#include "mbedtls/private_access.h"
+#include "mbedtls/build_info.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !defined(MBEDTLS_MD2_ALT)
+// Regular implementation
+//
+
+/**
+ * \brief          MD2 context structure
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+typedef struct mbedtls_md2_context
+{
+    unsigned char MBEDTLS_PRIVATE(cksum)[16];    /*!< checksum of the data block */
+    unsigned char MBEDTLS_PRIVATE(state)[48];    /*!< intermediate digest state  */
+    unsigned char MBEDTLS_PRIVATE(buffer)[16];   /*!< data block being processed */
+    size_t MBEDTLS_PRIVATE(left);                /*!< amount of data in buffer   */
+}
+mbedtls_md2_context;
+
+#else  /* MBEDTLS_MD2_ALT */
+#include "md2_alt.h"
+#endif /* MBEDTLS_MD2_ALT */
+
+/**
+ * \brief          Initialize MD2 context
+ *
+ * \param ctx      MD2 context to be initialized
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+void mbedtls_md2_init( mbedtls_md2_context *ctx );
+
+/**
+ * \brief          Clear MD2 context
+ *
+ * \param ctx      MD2 context to be cleared
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+void mbedtls_md2_free( mbedtls_md2_context *ctx );
+
+/**
+ * \brief          Clone (the state of) an MD2 context
+ *
+ * \param dst      The destination context
+ * \param src      The context to be cloned
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+void mbedtls_md2_clone( mbedtls_md2_context *dst,
+                        const mbedtls_md2_context *src );
+
+/**
+ * \brief          MD2 context setup
+ *
+ * \param ctx      context to be initialized
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md2_starts( mbedtls_md2_context *ctx );
+
+/**
+ * \brief          MD2 process buffer
+ *
+ * \param ctx      MD2 context
+ * \param input    buffer holding the data
+ * \param ilen     length of the input data
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md2_update( mbedtls_md2_context *ctx,
+                        const unsigned char *input,
+                        size_t ilen );
+
+/**
+ * \brief          MD2 final digest
+ *
+ * \param ctx      MD2 context
+ * \param output   MD2 checksum result
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md2_finish( mbedtls_md2_context *ctx,
+                        unsigned char output[16] );
+
+/**
+ * \brief          MD2 process data block (internal use only)
+ *
+ * \param ctx      MD2 context
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_internal_md2_process( mbedtls_md2_context *ctx );
+
+/**
+ * \brief          Output = MD2( input buffer )
+ *
+ * \param input    buffer holding the data
+ * \param ilen     length of the input data
+ * \param output   MD2 checksum result
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md2( const unsigned char *input,
+                 size_t ilen,
+                 unsigned char output[16] );
+
+#if defined(MBEDTLS_SELF_TEST)
+
+/**
+ * \brief          Checkup routine
+ *
+ * \return         0 if successful, or 1 if the test failed
+ *
+ * \warning        MD2 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md2_self_test( int verbose );
+
+#endif /* MBEDTLS_SELF_TEST */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* mbedtls_md2.h */
\ No newline at end of file
diff --git a/include/mbedtls/md4.h b/include/mbedtls/md4.h
new file mode 100644
index 0000000..a8d2452
--- /dev/null
+++ b/include/mbedtls/md4.h
@@ -0,0 +1,202 @@
+/**
+ * \file md4.h
+ *
+ * \brief MD4 message digest algorithm (hash function)
+ *
+ * \warning MD4 is considered a weak message digest and its use constitutes a
+ *          security risk. We recommend considering stronger message digests
+ *          instead.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ */
+#ifndef MBEDTLS_MD4_H
+#define MBEDTLS_MD4_H
+#include "mbedtls/private_access.h"
+#include "mbedtls/build_info.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !defined(MBEDTLS_MD4_ALT)
+// Regular implementation
+//
+
+/**
+ * \brief          MD4 context structure
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+typedef struct mbedtls_md4_context
+{
+    uint32_t MBEDTLS_PRIVATE(total)[2];          /*!< number of bytes processed  */
+    uint32_t MBEDTLS_PRIVATE(state)[4];          /*!< intermediate digest state  */
+    unsigned char MBEDTLS_PRIVATE(buffer)[64];   /*!< data block being processed */
+}
+mbedtls_md4_context;
+
+#else  /* MBEDTLS_MD4_ALT */
+#include "md4_alt.h"
+#endif /* MBEDTLS_MD4_ALT */
+
+/**
+ * \brief          Initialize MD4 context
+ *
+ * \param ctx      MD4 context to be initialized
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+void mbedtls_md4_init( mbedtls_md4_context *ctx );
+
+/**
+ * \brief          Clear MD4 context
+ *
+ * \param ctx      MD4 context to be cleared
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+void mbedtls_md4_free( mbedtls_md4_context *ctx );
+
+/**
+ * \brief          Clone (the state of) an MD4 context
+ *
+ * \param dst      The destination context
+ * \param src      The context to be cloned
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+void mbedtls_md4_clone( mbedtls_md4_context *dst,
+                        const mbedtls_md4_context *src );
+
+/**
+ * \brief          MD4 context setup
+ *
+ * \param ctx      context to be initialized
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ */
+int mbedtls_md4_starts( mbedtls_md4_context *ctx );
+
+/**
+ * \brief          MD4 process buffer
+ *
+ * \param ctx      MD4 context
+ * \param input    buffer holding the data
+ * \param ilen     length of the input data
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md4_update( mbedtls_md4_context *ctx,
+                        const unsigned char *input,
+                        size_t ilen );
+
+/**
+ * \brief          MD4 final digest
+ *
+ * \param ctx      MD4 context
+ * \param output   MD4 checksum result
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md4_finish( mbedtls_md4_context *ctx,
+                        unsigned char output[16] );
+
+/**
+ * \brief          MD4 process data block (internal use only)
+ *
+ * \param ctx      MD4 context
+ * \param data     buffer holding one block of data
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_internal_md4_process( mbedtls_md4_context *ctx,
+                                  const unsigned char data[64] );
+
+/**
+ * \brief          Output = MD4( input buffer )
+ *
+ * \param input    buffer holding the data
+ * \param ilen     length of the input data
+ * \param output   MD4 checksum result
+ *
+ * \return         0 if successful
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md4( const unsigned char *input,
+                 size_t ilen,
+                 unsigned char output[16] );
+
+#if defined(MBEDTLS_SELF_TEST)
+
+/**
+ * \brief          Checkup routine
+ *
+ * \return         0 if successful, or 1 if the test failed
+ *
+ * \warning        MD4 is considered a weak message digest and its use
+ *                 constitutes a security risk. We recommend considering
+ *                 stronger message digests instead.
+ *
+ */
+int mbedtls_md4_self_test( int verbose );
+
+#endif /* MBEDTLS_SELF_TEST */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* mbedtls_md4.h */
diff --git a/include/mbedtls/oid.h b/include/mbedtls/oid.h
index fdc25eb..0af7b1b 100644
--- a/include/mbedtls/oid.h
+++ b/include/mbedtls/oid.h
@@ -228,6 +228,8 @@
  * PKCS#1 OIDs
  */
 #define MBEDTLS_OID_PKCS1_RSA           MBEDTLS_OID_PKCS1 "\x01" /**< rsaEncryption OBJECT IDENTIFIER ::= { pkcs-1 1 } */
+#define MBEDTLS_OID_PKCS1_MD2           MBEDTLS_OID_PKCS1 "\x02" /**< md2WithRSAEncryption ::= { pkcs-1 2 } */
+#define MBEDTLS_OID_PKCS1_MD4           MBEDTLS_OID_PKCS1 "\x03" /**< md4WithRSAEncryption ::= { pkcs-1 3 } */
 #define MBEDTLS_OID_PKCS1_MD5           MBEDTLS_OID_PKCS1 "\x04" /**< md5WithRSAEncryption ::= { pkcs-1 4 } */
 #define MBEDTLS_OID_PKCS1_SHA1          MBEDTLS_OID_PKCS1 "\x05" /**< sha1WithRSAEncryption ::= { pkcs-1 5 } */
 #define MBEDTLS_OID_PKCS1_SHA224        MBEDTLS_OID_PKCS1 "\x0e" /**< sha224WithRSAEncryption ::= { pkcs-1 14 } */
@@ -246,6 +248,8 @@
 /*
  * Digest algorithms
  */
+#define MBEDTLS_OID_DIGEST_ALG_MD2              MBEDTLS_OID_RSA_COMPANY "\x02\x02" /**< id-mbedtls_md2 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 2 } */
+#define MBEDTLS_OID_DIGEST_ALG_MD4              MBEDTLS_OID_RSA_COMPANY "\x02\x04" /**< id-mbedtls_md4 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 4 } */
 #define MBEDTLS_OID_DIGEST_ALG_MD5              MBEDTLS_OID_RSA_COMPANY "\x02\x05" /**< id-mbedtls_md5 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 5 } */
 #define MBEDTLS_OID_DIGEST_ALG_SHA1             MBEDTLS_OID_ISO_IDENTIFIED_ORG \
         MBEDTLS_OID_OIW_SECSIG_SHA1                                                                        /**< id-mbedtls_sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2) 26 } */
@@ -322,6 +326,8 @@
 /*
  * PKCS#5 PBES1 algorithms
  */
+#define MBEDTLS_OID_PKCS5_PBE_MD2_DES_CBC       MBEDTLS_OID_PKCS5 "\x01" /**< pbeWithMD2AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 1} */
+#define MBEDTLS_OID_PKCS5_PBE_MD2_RC2_CBC       MBEDTLS_OID_PKCS5 "\x04" /**< pbeWithMD2AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 4} */
 #define MBEDTLS_OID_PKCS5_PBE_MD5_DES_CBC       MBEDTLS_OID_PKCS5 "\x03" /**< pbeWithMD5AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 3} */
 #define MBEDTLS_OID_PKCS5_PBE_MD5_RC2_CBC       MBEDTLS_OID_PKCS5 "\x06" /**< pbeWithMD5AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 6} */
 #define MBEDTLS_OID_PKCS5_PBE_SHA1_DES_CBC      MBEDTLS_OID_PKCS5 "\x0a" /**< pbeWithSHA1AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 10} */
diff --git a/include/mbedtls/platform_util.h b/include/mbedtls/platform_util.h
index 1b371ef..362d5eb 100644
--- a/include/mbedtls/platform_util.h
+++ b/include/mbedtls/platform_util.h
@@ -23,6 +23,23 @@
 extern "C" {
 #endif
 
+/* Internal macros meant to be called only from within the library. */
+#define MBEDTLS_INTERNAL_VALIDATE_RET( cond, ret )  \
+    do {                                            \
+        if( !(cond) )                               \
+        {                                           \
+            return( ret );                          \
+        }                                           \
+    } while( 0 )
+
+#define MBEDTLS_INTERNAL_VALIDATE( cond )           \
+    do {                                            \
+        if( !(cond) )                               \
+        {                                           \
+            return;                                 \
+        }                                           \
+    } while( 0 )
+
 /* Internal helper macros for deprecating API constants. */
 #if !defined(MBEDTLS_DEPRECATED_REMOVED)
 #if defined(MBEDTLS_DEPRECATED_WARNING)
diff --git a/include/mbedtls/sm2dsa.h b/include/mbedtls/sm2dsa.h
new file mode 100644
index 0000000..2107182
--- /dev/null
+++ b/include/mbedtls/sm2dsa.h
@@ -0,0 +1,181 @@
+/**
+ * \file sm2dsa.h
+ *
+ * \brief This file contains SM2 ECDSA definitions and functions.
+ *
+ * The SM2 Elliptic Curve Digital Signature Algorithm (ECDSA) is
+ * defined in GB/T 32918.2-2016.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef MBEDTLS_SM2DSA_H
+#define MBEDTLS_SM2DSA_H
+#include "mbedtls/private_access.h"
+
+#include "mbedtls/build_info.h"
+
+#include "mbedtls/ecp.h"
+#include "mbedtls/md.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief               This function computes message hash for the SM2DSA signature
+ *                      and verification.
+ *
+ * \param grp           The context for the elliptic curve to use.
+ *                      This must be initialized and have group parameters
+ *                      set, for example through mbedtls_ecp_group_load().
+ *                      with MBEDTLS_ECP_DP_SM2P256V1.
+ * \param pk            The public key. This must be initialized.
+ *                      This must not be \c NULL.
+ * \param id            The device id. It must be readable. This must not be \c NULL.
+ * \param id_len        The id length must less than or equal to 0x1FFF.
+ * \param buf           The buffer holding the input data.
+ *                      It must be readable and of size \p blen Bytes.
+ * \param blen          The length of \p buf in Bytes.
+ * \param hash          The hash buffer where the output data will be written.
+ *                      It must be writeable.
+ * \param hashlen       The length of \p hash in Bytes.
+ * \param md_alg        The hash algorithm used to hash the original data.
+ *
+ * \return              \c 0 on success.
+ * \return              An \c MBEDTLS_ERR_ECP_XXX
+ *                      or \c MBEDTLS_ERR_MD_XXX error code on failure.
+ */
+int mbedtls_sm2dsa_calc_hash( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pk,
+                              const unsigned char *id, size_t id_len,
+                              const unsigned char *buf, size_t blen,
+                              unsigned char *hash, unsigned char hashlen,
+                              mbedtls_md_type_t md_alg );
+
+/**
+ * \brief               This function computes device-info hash z for the SM2DSA signature
+ *                      and verification. This function is for internal use only.
+ *
+ * \param grp           The context for the elliptic curve to use.
+ *                      This must be initialized and have group parameters
+ *                      set, for example through mbedtls_ecp_group_load().
+ *                      with MBEDTLS_ECP_DP_SM2P256V1.
+ * \param pk            The public key. This must be initialized.
+ *                      This must not be \c NULL.
+ * \param id            The device id. It must be readable. This must not be \c NULL.
+ * \param id_len        The id length must less than or equal to 0x1FFF.
+ * \param z             The device-info hash buffer where the output data will be written.
+ *                      It must be writeable.
+ * \param zlen          The length of \p device-info hash in Bytes.
+ * \param md_info       The information structure of the message-digest algorithm
+ *                      to use.
+ *
+ * \return              \c 0 on success.
+ * \return              An \c MBEDTLS_ERR_ECP_XXX
+ *                      or \c MBEDTLS_ERR_MD_XXX error code on failure.
+ */
+int sm2dsa_calc_z_internal( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pk,
+                            const unsigned char *id, size_t id_len,
+                            unsigned char *z, size_t zlen,
+                            const mbedtls_md_info_t *md_info );
+
+/**
+ * \brief               This function computes the SM2DSA signature of a
+ *                      previously-hashed message. This function is for
+ *                      internal use only.
+ *
+ * \note                If the bitlength of the message hash is larger than the
+ *                      bitlength of the group order, then the hash is truncated
+ *                      as defined in <em>Standards for Efficient Cryptography Group
+ *                      (SECG): SEC1 Elliptic Curve Cryptography</em>, section
+ *                      4.1.3, step 5.
+ *
+ * \see                 ecp.h
+ *
+ * \param grp           The context for the elliptic curve to use.
+ *                      This must be initialized and have group parameters
+ *                      set, for example through mbedtls_ecp_group_load().
+ * \param r             The MPI context in which to store the first part
+ *                      the signature. This must be initialized.
+ * \param s             The MPI context in which to store the second part
+ *                      the signature. This must be initialized.
+ * \param d             The private signing key. This must be initialized
+ *                      and setup, for example through mbedtls_ecp_gen_privkey().
+ * \param buf           The hashed content to be signed. This must be a readable
+ *                      buffer of length \p blen Bytes. It may be \c NULL if
+ *                      \p blen is zero.
+ * \param blen          The length of \p buf in Bytes.
+ * \param f_rng         The RNG function. This must not be \c NULL.
+ * \param p_rng         The RNG parameter to be passed to \p f_rng. This may be
+ *                      \c NULL if \p f_rng doesn't need a context argument.
+ * \param f_rng_blind   The RNG function used for blinding. This must not be
+ *                      \c NULL.
+ * \param p_rng_blind   The RNG context to be passed to \p f_rng. This may be
+ *                      \c NULL if \p f_rng doesn't need a context parameter.
+ *
+ * \return              \c 0 on success.
+ * \return              An \c MBEDTLS_ERR_ECP_XXX
+ *                      or \c MBEDTLS_MPI_XXX error code on failure.
+ */
+int sm2dsa_sign_internal( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
+                          const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
+                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
+                          int (*f_rng_blind)(void *, unsigned char *, size_t), void *p_rng_blind );
+
+/**
+ * \brief               This function verifies the SM2DSA signature of a
+ *                      previously-hashed message. This function is for
+ *                      internal use only.
+ *
+ * \note                If the bitlength of the message hash is larger than the
+ *                      bitlength of the group order, then the hash is truncated as
+ *                      defined in <em>Standards for Efficient Cryptography Group
+ *                      (SECG): SEC1 Elliptic Curve Cryptography</em>, section
+ *                      4.1.4, step 3.
+ *
+ * \see                 ecp.h
+ *
+ * \param grp           The ECP group to use.
+ *                      This must be initialized and have group parameters
+ *                      set, for example through mbedtls_ecp_group_load().
+ * \param buf           The hashed content that was signed. This must be a readable
+ *                      buffer of length \p blen Bytes. It may be \c NULL if
+ *                      \p blen is zero.
+ * \param blen          The length of \p buf in Bytes.
+ * \param Q             The public key to use for verification. This must be
+ *                      initialized and setup.
+ * \param r             The first integer of the signature.
+ *                      This must be initialized.
+ * \param s             The second integer of the signature.
+ *                      This must be initialized.
+ *
+ * \return              \c 0 on success.
+ * \return              #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the signature
+ *                      is invalid.
+ * \return              An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX
+ *                      error code on failure for any other reason.
+ */
+int sm2dsa_verify_internal( mbedtls_ecp_group *grp,
+                            const unsigned char *buf, size_t blen,
+                            const mbedtls_ecp_point *Q, const mbedtls_mpi *r,
+                            const mbedtls_mpi *s);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sm2dsa.h */
diff --git a/include/mbedtls/sm3.h b/include/mbedtls/sm3.h
new file mode 100644
index 0000000..cb380f0
--- /dev/null
+++ b/include/mbedtls/sm3.h
@@ -0,0 +1,162 @@
+/**
+ * \file sm3.h
+ *
+ * \brief SM3 message digest algorithm (hash function)
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+#ifndef MBEDTLS_SM3_H
+#define MBEDTLS_SM3_H
+#include "mbedtls/private_access.h"
+
+#include "mbedtls/build_info.h"
+#include "mbedtls/platform_util.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define MBEDTLS_ERR_SM3_BAD_INPUT_DATA                    -0x0076  /**< SM3 input data was malformed. */
+
+#if !defined(MBEDTLS_SM3_ALT)
+// Regular implementation
+//
+
+/**
+ * \brief          SM3 context structure
+ */
+typedef struct mbedtls_sm3_context
+{
+    uint32_t MBEDTLS_PRIVATE(total)[2];          /*!< number of bytes processed  */
+    uint32_t MBEDTLS_PRIVATE(state)[8];          /*!< intermediate digest state, 32 Bytes, 256 bits */
+    unsigned char MBEDTLS_PRIVATE(buffer)[64];   /*!< data block being processed */
+}
+mbedtls_sm3_context;
+
+#else  /* MBEDTLS_SM3_ALT */
+#include PATH_SM3_ALT_H
+#endif /* MBEDTLS_SM3_ALT */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief          Initialize SM3 context
+ *
+ * \param ctx      The SM3 context to initialize. This must not be \c NULL.
+ */
+void mbedtls_sm3_init( mbedtls_sm3_context *ctx );
+
+/**
+ * \brief          This function clears a SM3 context.
+ *
+ * \param ctx      The SM3 context to clear. This may be \c NULL, in which
+ *                 case this function returns immediately. If it is not \c NULL,
+ *                 it must point to an initialized SM3 context.
+ */
+void mbedtls_sm3_free( mbedtls_sm3_context *ctx );
+
+/**
+ * \brief          This function clones the state of a SM3 context.
+ *
+ * \param dst      The destination context. This must be initialized.
+ * \param src      The context to clone. This must be initialized.
+ */
+void mbedtls_sm3_clone( mbedtls_sm3_context *dst,
+                        const mbedtls_sm3_context *src );
+
+/**
+ * \brief          This function starts a SM3 checksum calculation.
+ *
+ * \param ctx      The context to use. This must be initialized.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_sm3_starts( mbedtls_sm3_context *ctx );
+
+/**
+ * \brief          This function feeds an input buffer into an ongoing
+ *                 SM3 checksum calculation.
+ *
+ * \param ctx      The SM3 context. This must be initialized
+ *                 and have a hash operation started.
+ * \param input    The buffer holding the data. This must be a readable
+ *                 buffer of length \p ilen Bytes.
+ * \param ilen     The length of the input data in Bytes.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_sm3_update( mbedtls_sm3_context *ctx,
+                            const unsigned char *input,
+                            size_t ilen );
+
+/**
+ * \brief          This function finishes the SM3 operation, and writes
+ *                 the result to the output buffer.
+ *
+ * \param ctx      The SM3 context. This must be initialized
+ *                 and have a hash operation started.
+ * \param output   The SM3 checksum result.
+ *                 This must be a writable buffer of length \c 32 Bytes.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_sm3_finish( mbedtls_sm3_context *ctx,
+                            unsigned char output[32] );
+
+/**
+ * \brief          This function processes a single data block within
+ *                 the ongoing SM3 computation. This function is for
+ *                 internal use only.
+ *
+ * \param ctx      The SM3 context. This must be initialized.
+ * \param data     The buffer holding one block of data. This must
+ *                 be a readable buffer of length \c 64 Bytes.
+ *
+ * \return         \c 0 on success.
+ * \return         A negative error code on failure.
+ */
+int mbedtls_internal_sm3_process( mbedtls_sm3_context *ctx,
+                                  const unsigned char data[64] );
+
+/**
+ * \brief          This function calculates the SM3 checksum of a buffer.
+ *
+ *                 The function allocates the context, performs the
+ *                 calculation, and frees the context.
+ *
+ *                 The SM3 result is calculated as
+ *                 output = SM3(input buffer).
+ *
+ * \param input    The buffer holding the data. This must be a readable
+ *                 buffer of length \p ilen Bytes.
+ * \param ilen     The length of the input data in Bytes.
+ * \param output   The SM3 checksum result. This must
+ *                 be a writable buffer of length \c 32 Bytes.
+ */
+int mbedtls_sm3( const unsigned char *input,
+                      size_t ilen,
+                      unsigned char output[32] );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* mbedtls_sm3.h */
diff --git a/include/mbedtls/sm4.h b/include/mbedtls/sm4.h
new file mode 100644
index 0000000..7706dd7
--- /dev/null
+++ b/include/mbedtls/sm4.h
@@ -0,0 +1,454 @@
+/**
+ * \file sm4.h
+ *
+ * \brief This file contains SM4 definitions and functions.
+ *
+ * \warning    The SM4 algorithm is a symmetric block cipher that can
+ *             encrypt and decrypt information.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+#ifndef MBEDTLS_SM4_H
+#define MBEDTLS_SM4_H
+#include "mbedtls/private_access.h"
+
+#include "mbedtls/build_info.h"
+#include "mbedtls/platform_util.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define MBEDTLS_SM4_ENCRYPT     1 /**< SM4 encryption. */
+#define MBEDTLS_SM4_DECRYPT     0 /**< SM4 decryption. */
+
+/* Error codes in range 0x004B-0x004D */
+#define MBEDTLS_ERR_SM4_INVALID_KEY_LENGTH                -0x004B  /**< Invalid key length. */
+#define MBEDTLS_ERR_SM4_INVALID_INPUT_LENGTH              -0x004D  /**< Invalid data input length. */
+
+/* Error codes in range 0x0077-0x0079 */
+#define MBEDTLS_ERR_SM4_BAD_INPUT_DATA                    -0x0077  /**< Invalid input data. */
+
+#if !defined(MBEDTLS_SM4_ALT)
+// Regular implementation
+//
+
+/**
+ * \brief The SM4 context-type definition.
+ */
+typedef struct mbedtls_sm4_context
+{
+    int MBEDTLS_PRIVATE(nr);                     /*!< The number of rounds. */
+    uint32_t MBEDTLS_PRIVATE(rk)[32];            /*!< SM4 round keys. */
+}
+mbedtls_sm4_context;
+
+#else  /* MBEDTLS_SM4_ALT */
+#include PATH_SM4_ALT_H
+#endif /* MBEDTLS_SM4_ALT */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief          This function initializes the specified SM4 context.
+ *
+ *                 It must be the first API called before using
+ *                 the context.
+ *
+ * \param ctx      The SM4 context to initialize. This must not be \c NULL.
+ */
+void mbedtls_sm4_init( mbedtls_sm4_context *ctx );
+
+/**
+ * \brief          This function releases and clears the specified SM4 context.
+ *
+ * \param ctx      The SM4 context to clear.
+ *                 If this is \c NULL, this function does nothing.
+ *                 Otherwise, the context must have been at least initialized.
+ */
+void mbedtls_sm4_free( mbedtls_sm4_context *ctx );
+
+/**
+ * \brief          This function sets the cryption key.
+ *
+ * \param ctx      The SM4 context to which the key should be bound.
+ *                 It must be initialized.
+ * \param key      The encryption or decryption key.
+ *                 This must be a readable buffer of size \p keybits bits.
+ * \param keybits  The size of data passed in bits. It must be 128 bits.
+ *
+ * \return         \c 0 on success.
+ * \return         #MBEDTLS_ERR_SM4_BAD_INPUT_DATA on failure.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_sm4_setkey( mbedtls_sm4_context *ctx, const unsigned char *key,
+                    unsigned int keybits );
+
+/**
+ * \brief          This function performs an SM4 single-block encryption or
+ *                 decryption operation.
+ *
+ *                 It performs the operation defined in the \p mode parameter
+ *                 (encrypt or decrypt), on the input data buffer defined in
+ *                 the \p input parameter.
+ *
+ *                 mbedtls_sm4_init(), and mbedtls_sm4_setkey() must be called
+ *                 before the first call to this API with the same context.
+ *
+ * \param ctx      The SM4 context to use for encryption or decryption.
+ *                 It must be initialized and bound to a key.
+ * \param mode     The SM4 operation: #MBEDTLS_SM4_ENCRYPT or
+ *                 #MBEDTLS_SM4_DECRYPT.
+ * \param input    The buffer holding the input data.
+ *                 It must be readable and at least \c 16 Bytes long.
+ * \param output   The buffer where the output data will be written.
+ *                 It must be writeable and at least \c 16 Bytes long.
+
+ * \return         \c 0 on success.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_sm4_crypt_ecb( mbedtls_sm4_context *ctx,
+                           int mode,
+                           const unsigned char input[16],
+                           unsigned char output[16] );
+
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+/**
+ * \brief  This function performs an SM4-CBC encryption or decryption operation
+ *         on full blocks.
+ *
+ *         It performs the operation defined in the \p mode
+ *         parameter (encrypt/decrypt), on the input data buffer defined in
+ *         the \p input parameter.
+ *
+ *         It can be called as many times as needed, until all the input
+ *         data is processed. mbedtls_sm4_init(), and mbedtls_sm4_setkey() must
+ *         be called before the first call to this API with the same context.
+ *
+ * \note   This function operates on full blocks, that is, the input size
+ *         must be a multiple of the SM4 block size of \c 16 Bytes.
+ *
+ * \note   Upon exit, the content of the IV is updated so that you can
+ *         call the same function again on the next
+ *         block(s) of data and get the same result as if it was
+ *         encrypted in one call. This allows a "streaming" usage.
+ *         If you need to retain the contents of the IV, you should
+ *         either save it manually or use the cipher module instead.
+ *
+ *
+ * \param ctx      The SM4 context to use for encryption or decryption.
+ *                 It must be initialized and bound to a key.
+ * \param mode     The SM4 operation: #MBEDTLS_SM4_ENCRYPT or
+ *                 #MBEDTLS_SM4_DECRYPT.
+ * \param length   The length of the input data in Bytes. This must be a
+ *                 multiple of the block size (\c 16 Bytes).
+ * \param iv       Initialization vector (updated after use).
+ *                 It must be a readable and writeable buffer of \c 16 Bytes.
+ * \param input    The buffer holding the input data.
+ *                 It must be readable and of size \p length Bytes.
+ * \param output   The buffer holding the output data.
+ *                 It must be writeable and of size \p length Bytes.
+ *
+ * \return         \c 0 on success.
+ * \return         #MBEDTLS_ERR_SM4_INVALID_INPUT_LENGTH
+ *                 on failure.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_sm4_crypt_cbc( mbedtls_sm4_context *ctx,
+                           int mode,
+                           size_t length,
+                           unsigned char iv[16],
+                           const unsigned char *input,
+                           unsigned char *output );
+#endif /* MBEDTLS_CIPHER_MODE_CBC */
+
+#if defined(MBEDTLS_CIPHER_MODE_CFB)
+/**
+ * \brief This function performs an SM4-CFB128 encryption or decryption
+ *        operation.
+ *
+ *        It performs the operation defined in the \p mode
+ *        parameter (encrypt or decrypt), on the input data buffer
+ *        defined in the \p input parameter.
+ *
+ *        For CFB, you must set up the context with mbedtls_sm4_setkey(),
+ *        regardless of whether you are performing an encryption or decryption
+ *        operation, that is, regardless of the \p mode parameter. This is
+ *        because CFB mode uses the same key schedule for encryption and
+ *        decryption.
+ *
+ * \note  Upon exit, the content of the IV is updated so that you can
+ *        call the same function again on the next
+ *        block(s) of data and get the same result as if it was
+ *        encrypted in one call. This allows a "streaming" usage.
+ *        If you need to retain the contents of the
+ *        IV, you must either save it manually or use the cipher
+ *        module instead.
+ *
+ *
+ * \param ctx      The SM4 context to use for encryption or decryption.
+ *                 It must be initialized and bound to a key.
+ * \param mode     The SM4 operation: #MBEDTLS_SM4_ENCRYPT or
+ *                 #MBEDTLS_SM4_DECRYPT.
+ * \param length   The length of the input data in Bytes.
+ * \param iv_off   The offset in IV (updated after use).
+ *                 It must point to a valid \c size_t.
+ * \param iv       The initialization vector (updated after use).
+ *                 It must be a readable and writeable buffer of \c 16 Bytes.
+ * \param input    The buffer holding the input data.
+ *                 It must be readable and of size \p length Bytes.
+ * \param output   The buffer holding the output data.
+ *                 It must be writeable and of size \p length Bytes.
+ *
+ * \return         \c 0 on success.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_sm4_crypt_cfb128( mbedtls_sm4_context *ctx,
+                              int mode,
+                              size_t length,
+                              size_t *iv_off,
+                              unsigned char iv[16],
+                              const unsigned char *input,
+                              unsigned char *output );
+
+/**
+ * \brief This function performs an SM4-CFB8 encryption or decryption
+ *        operation.
+ *
+ *        It performs the operation defined in the \p mode
+ *        parameter (encrypt/decrypt), on the input data buffer defined
+ *        in the \p input parameter.
+ *
+ *        Due to the nature of CFB, you must use the same key schedule for
+ *        both encryption and decryption operations. Therefore, you must
+ *        use the context initialized with mbedtls_sm4_setkey() for
+ *        both #MBEDTLS_SM4_ENCRYPT and #MBEDTLS_SM4_DECRYPT.
+ *
+ * \note  Upon exit, the content of the IV is updated so that you can
+ *        call the same function again on the next
+ *        block(s) of data and get the same result as if it was
+ *        encrypted in one call. This allows a "streaming" usage.
+ *        If you need to retain the contents of the
+ *        IV, you should either save it manually or use the cipher
+ *        module instead.
+ *
+ *
+ * \param ctx      The SM4 context to use for encryption or decryption.
+ *                 It must be initialized and bound to a key.
+ * \param mode     The SM4 operation: #MBEDTLS_SM4_ENCRYPT or
+ *                 #MBEDTLS_SM4_DECRYPT
+ * \param length   The length of the input data.
+ * \param iv       The initialization vector (updated after use).
+ *                 It must be a readable and writeable buffer of \c 16 Bytes.
+ * \param input    The buffer holding the input data.
+ *                 It must be readable and of size \p length Bytes.
+ * \param output   The buffer holding the output data.
+ *                 It must be writeable and of size \p length Bytes.
+ *
+ * \return         \c 0 on success.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_sm4_crypt_cfb8( mbedtls_sm4_context *ctx,
+                            int mode,
+                            size_t length,
+                            unsigned char iv[16],
+                            const unsigned char *input,
+                            unsigned char *output );
+#endif /*MBEDTLS_CIPHER_MODE_CFB */
+
+#if defined(MBEDTLS_CIPHER_MODE_OFB)
+/**
+ * \brief       This function performs an SM4-OFB (Output Feedback Mode)
+ *              encryption or decryption operation.
+ *
+ *              For OFB, you must set up the context with
+ *              mbedtls_sm4_setkey(), regardless of whether you are
+ *              performing an encryption or decryption operation. This is
+ *              because OFB mode uses the same key schedule for encryption and
+ *              decryption.
+ *
+ *              The OFB operation is identical for encryption or decryption,
+ *              therefore no operation mode needs to be specified.
+ *
+ * \note        Upon exit, the content of iv, the Initialisation Vector, is
+ *              updated so that you can call the same function again on the next
+ *              block(s) of data and get the same result as if it was encrypted
+ *              in one call. This allows a "streaming" usage, by initialising
+ *              iv_off to 0 before the first call, and preserving its value
+ *              between calls.
+ *
+ *              For non-streaming use, the iv should be initialised on each call
+ *              to a unique value, and iv_off set to 0 on each call.
+ *
+ *              If you need to retain the contents of the initialisation vector,
+ *              you must either save it manually or use the cipher module
+ *              instead.
+ *
+ * \warning     For the OFB mode, the initialisation vector must be unique
+ *              every encryption operation. Reuse of an initialisation vector
+ *              will compromise security.
+ *
+ * \param ctx      The SM4 context to use for encryption or decryption.
+ *                 It must be initialized and bound to a key.
+ * \param length   The length of the input data.
+ * \param iv_off   The offset in IV (updated after use).
+ *                 It must point to a valid \c size_t.
+ * \param iv       The initialization vector (updated after use).
+ *                 It must be a readable and writeable buffer of \c 16 Bytes.
+ * \param input    The buffer holding the input data.
+ *                 It must be readable and of size \p length Bytes.
+ * \param output   The buffer holding the output data.
+ *                 It must be writeable and of size \p length Bytes.
+ *
+ * \return         \c 0 on success.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_sm4_crypt_ofb( mbedtls_sm4_context *ctx,
+                           size_t length,
+                           size_t *iv_off,
+                           unsigned char iv[16],
+                           const unsigned char *input,
+                           unsigned char *output );
+
+#endif /* MBEDTLS_CIPHER_MODE_OFB */
+
+#if defined(MBEDTLS_CIPHER_MODE_CTR)
+/**
+ * \brief      This function performs an SM4-CTR encryption or decryption
+ *             operation.
+ *
+ *             This function performs the operation defined in the \p mode
+ *             parameter (encrypt/decrypt), on the input data buffer
+ *             defined in the \p input parameter.
+ *
+ *             Due to the nature of CTR, you must use the same key schedule
+ *             for both encryption and decryption operations. Therefore, you
+ *             must use the context initialized with mbedtls_sm4_setkey()
+ *             for both #MBEDTLS_SM4_ENCRYPT and #MBEDTLS_SM4_DECRYPT.
+ *
+ * \warning    You must never reuse a nonce value with the same key. Doing so
+ *             would void the encryption for the two messages encrypted with
+ *             the same nonce and key.
+ *
+ *             There are two common strategies for managing nonces with CTR:
+ *
+ *             1. You can handle everything as a single message processed over
+ *             successive calls to this function. In that case, you want to
+ *             set \p nonce_counter and \p nc_off to 0 for the first call, and
+ *             then preserve the values of \p nonce_counter, \p nc_off and \p
+ *             stream_block across calls to this function as they will be
+ *             updated by this function.
+ *
+ *             With this strategy, you must not encrypt more than 2**128
+ *             blocks of data with the same key.
+ *
+ *             2. You can encrypt separate messages by dividing the \p
+ *             nonce_counter buffer in two areas: the first one used for a
+ *             per-message nonce, handled by yourself, and the second one
+ *             updated by this function internally.
+ *
+ *             For example, you might reserve the first 12 bytes for the
+ *             per-message nonce, and the last 4 bytes for internal use. In that
+ *             case, before calling this function on a new message you need to
+ *             set the first 12 bytes of \p nonce_counter to your chosen nonce
+ *             value, the last 4 to 0, and \p nc_off to 0 (which will cause \p
+ *             stream_block to be ignored). That way, you can encrypt at most
+ *             2**96 messages of up to 2**32 blocks each with the same key.
+ *
+ *             The per-message nonce (or information sufficient to reconstruct
+ *             it) needs to be communicated with the ciphertext and must be unique.
+ *             The recommended way to ensure uniqueness is to use a message
+ *             counter. An alternative is to generate random nonces, but this
+ *             limits the number of messages that can be securely encrypted:
+ *             for example, with 96-bit random nonces, you should not encrypt
+ *             more than 2**32 messages with the same key.
+ *
+ *             Note that for both stategies, sizes are measured in blocks and
+ *             that an SM4 block is 16 bytes.
+ *
+ * \warning    Upon return, \p stream_block contains sensitive data. Its
+ *             content must not be written to insecure storage and should be
+ *             securely discarded as soon as it's no longer needed.
+ *
+ * \param ctx              The SM4 context to use for encryption or decryption.
+ *                         It must be initialized and bound to a key.
+ * \param length           The length of the input data.
+ * \param nc_off           The offset in the current \p stream_block, for
+ *                         resuming within the current cipher stream. The
+ *                         offset pointer should be 0 at the start of a stream.
+ *                         It must point to a valid \c size_t.
+ * \param nonce_counter    The 128-bit nonce and counter.
+ *                         It must be a readable-writeable buffer of \c 16 Bytes.
+ * \param stream_block     The saved stream block for resuming. This is
+ *                         overwritten by the function.
+ *                         It must be a readable-writeable buffer of \c 16 Bytes.
+ * \param input            The buffer holding the input data.
+ *                         It must be readable and of size \p length Bytes.
+ * \param output           The buffer holding the output data.
+ *                         It must be writeable and of size \p length Bytes.
+ *
+ * \return                 \c 0 on success.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_sm4_crypt_ctr( mbedtls_sm4_context *ctx,
+                           size_t length,
+                           size_t *nc_off,
+                           unsigned char nonce_counter[16],
+                           unsigned char stream_block[16],
+                           const unsigned char *input,
+                           unsigned char *output );
+#endif /* MBEDTLS_CIPHER_MODE_CTR */
+
+/**
+ * \brief           Internal SM4 block encryption function. This is only
+ *                  exposed to allow overriding it using
+ *                  \c MBEDTLS_SM4_ENCRYPT_ALT.
+ *
+ * \param ctx       The SM4 context to use for encryption.
+ * \param input     The plaintext block.
+ * \param output    The output (ciphertext) block.
+ *
+ * \return          \c 0 on success.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_internal_sm4_encrypt( mbedtls_sm4_context *ctx,
+                                  const unsigned char input[16],
+                                  unsigned char output[16] );
+
+/**
+ * \brief           Internal SM4 block decryption function. This is only
+ *                  exposed to allow overriding it using see
+ *                  \c MBEDTLS_SM4_DECRYPT_ALT.
+ *
+ * \param ctx       The SM4 context to use for decryption.
+ * \param input     The ciphertext block.
+ * \param output    The output (plaintext) block.
+ *
+ * \return          \c 0 on success.
+ */
+MBEDTLS_CHECK_RETURN_TYPICAL
+int mbedtls_internal_sm4_decrypt( mbedtls_sm4_context *ctx,
+                                  const unsigned char input[16],
+                                  unsigned char output[16] );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sm4.h */
+
diff --git a/include/mbedtls/x509_crt.h b/include/mbedtls/x509_crt.h
index 1ce0d23..5353b01 100644
--- a/include/mbedtls/x509_crt.h
+++ b/include/mbedtls/x509_crt.h
@@ -1201,6 +1201,40 @@ int mbedtls_x509write_crt_pem(mbedtls_x509write_cert *ctx, unsigned char *buf, s
 
 /** \} addtogroup x509_module */
 
+
+#if defined(HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C)
+
+/*****************************************************************************
+ * \brief 校验证书有效期的回调函数原型
+ * 
+******************************************************************************/
+typedef int (*hw_mbedtls_cert_date_checker)(mbedtls_x509_crt *crt);
+
+/*****************************************************************************
+ * \brief 校验CRL有效期的回调函数原型
+ * 
+******************************************************************************/
+typedef int (*hw_mbedtls_crl_date_checker)(mbedtls_x509_crl *crl);
+
+/*****************************************************************************
+ * \brief 
+ * 
+ * \param checker 
+ * \return int 
+******************************************************************************/
+int hw_mbedtls_regist_cert_date_chcker(hw_mbedtls_cert_date_checker checker);
+
+/*****************************************************************************
+ * \brief 
+ * 
+ * \param checker 
+ * \return int 
+******************************************************************************/
+int hw_mbedtls_regist_crl_date_chcker(hw_mbedtls_crl_date_checker checker);
+
+#endif  //HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/psa/crypto_values.h b/include/psa/crypto_values.h
index 1d678db..5ee32a2 100644
--- a/include/psa/crypto_values.h
+++ b/include/psa/crypto_values.h
@@ -912,6 +912,10 @@
 /* *INDENT-ON* */
 
 #define PSA_ALG_HASH_MASK                       ((psa_algorithm_t) 0x000000ff)
+/** MD2*/
+#define PSA_ALG_MD2                             ((psa_algorithm_t) 0x02000001)
+/** MD4*/
+#define PSA_ALG_MD4                             ((psa_algorithm_t) 0x02000002)
 /** MD5 */
 #define PSA_ALG_MD5                             ((psa_algorithm_t) 0x02000003)
 /** PSA_ALG_RIPEMD160 */
diff --git a/library/bignum.c b/library/bignum.c
index c45fd5b..a0ba75b 100644
--- a/library/bignum.c
+++ b/library/bignum.c
@@ -37,7 +37,9 @@
 
 #include "mbedtls/platform.h"
 
-
+#if defined(MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE) || defined(MBEDTLS_BIGNUM_MOD_USE_HARDWARE)
+#include "bignum_harden.h"
+#endif /* MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE || MBEDTLS_BIGNUM_MOD_USE_HARDWARE */
 
 /*
  * Conditionally select an MPI sign in constant time.
@@ -1538,6 +1540,13 @@ int mbedtls_mpi_mod_mpi(mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi
         return MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
     }
 
+    #if defined(MBEDTLS_BIGNUM_MOD_USE_HARDWARE)
+        if( check_mod_harden_can_do( A, B ) == 1 )
+        {
+            return mod_harden( R, A, B );
+        }
+    #endif /* MBEDTLS_BIGNUM_MOD_USE_HARDWARE */
+
     MBEDTLS_MPI_CHK(mbedtls_mpi_div_mpi(NULL, R, A, B));
 
     while (mbedtls_mpi_cmp_int(R, 0) < 0) {
@@ -1629,6 +1638,13 @@ int mbedtls_mpi_exp_mod(mbedtls_mpi *X, const mbedtls_mpi *A,
         return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
     }
 
+    #if defined(MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE)
+        if( check_exp_mod_harden_can_do( A, E, N ) == 1 )
+        {
+            return exp_mod_harden( X, A, E, N );
+        }
+    #endif /* MBEDTLS_BIGNUM_EXP_MOD_USE_HARDWARE */
+
     /*
      * Ensure that the exponent that we are passing to the core is not NULL.
      */
diff --git a/library/blowfish.c b/library/blowfish.c
new file mode 100644
index 0000000..17511e6
--- /dev/null
+++ b/library/blowfish.c
@@ -0,0 +1,690 @@
+/*
+ *  Blowfish implementation
+ *
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+/*
+ *  The Blowfish block cipher was designed by Bruce Schneier in 1993.
+ *  http://www.schneier.com/blowfish.html
+ *  http://en.wikipedia.org/wiki/Blowfish_%28cipher%29
+ *
+ */
+
+#include "common.h"
+
+#if defined(MBEDTLS_BLOWFISH_C)
+
+#include "mbedtls/blowfish.h"
+#include "mbedtls/platform_util.h"
+
+#include <string.h>
+
+#if !defined(MBEDTLS_BLOWFISH_ALT)
+
+/* Parameter validation macros */
+#define BLOWFISH_VALIDATE_RET( cond )                                       \
+    MBEDTLS_INTERNAL_VALIDATE_RET( cond, MBEDTLS_ERR_BLOWFISH_BAD_INPUT_DATA )
+#define BLOWFISH_VALIDATE( cond )                                           \
+    MBEDTLS_INTERNAL_VALIDATE( cond )
+
+/*
+ * 32-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_UINT32_BE
+#define GET_UINT32_BE(n,b,i)                            \
+{                                                       \
+    (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
+        | ( (uint32_t) (b)[(i) + 1] << 16 )             \
+        | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
+        | ( (uint32_t) (b)[(i) + 3]       );            \
+}
+#endif
+
+#ifndef PUT_UINT32_BE
+#define PUT_UINT32_BE(n,b,i)                            \
+{                                                       \
+    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (unsigned char) ( (n)       );       \
+}
+#endif
+
+static const uint32_t P[MBEDTLS_BLOWFISH_ROUNDS + 2] = {
+        0x243F6A88L, 0x85A308D3L, 0x13198A2EL, 0x03707344L,
+        0xA4093822L, 0x299F31D0L, 0x082EFA98L, 0xEC4E6C89L,
+        0x452821E6L, 0x38D01377L, 0xBE5466CFL, 0x34E90C6CL,
+        0xC0AC29B7L, 0xC97C50DDL, 0x3F84D5B5L, 0xB5470917L,
+        0x9216D5D9L, 0x8979FB1BL
+};
+
+/* declarations of data at the end of this file */
+static const uint32_t S[4][256];
+
+static uint32_t F( mbedtls_blowfish_context *ctx, uint32_t x )
+{
+   unsigned short a, b, c, d;
+   uint32_t  y;
+
+   d = (unsigned short)(x & 0xFF);
+   x >>= 8;
+   c = (unsigned short)(x & 0xFF);
+   x >>= 8;
+   b = (unsigned short)(x & 0xFF);
+   x >>= 8;
+   a = (unsigned short)(x & 0xFF);
+   y = ctx->S[0][a] + ctx->S[1][b];
+   y = y ^ ctx->S[2][c];
+   y = y + ctx->S[3][d];
+
+   return( y );
+}
+
+static void blowfish_enc( mbedtls_blowfish_context *ctx, uint32_t *xl, uint32_t *xr )
+{
+    uint32_t  Xl, Xr, temp;
+    short i;
+
+    Xl = *xl;
+    Xr = *xr;
+
+    for( i = 0; i < MBEDTLS_BLOWFISH_ROUNDS; ++i )
+    {
+        Xl = Xl ^ ctx->P[i];
+        Xr = F( ctx, Xl ) ^ Xr;
+
+        temp = Xl;
+        Xl = Xr;
+        Xr = temp;
+    }
+
+    temp = Xl;
+    Xl = Xr;
+    Xr = temp;
+
+    Xr = Xr ^ ctx->P[MBEDTLS_BLOWFISH_ROUNDS];
+    Xl = Xl ^ ctx->P[MBEDTLS_BLOWFISH_ROUNDS + 1];
+
+    *xl = Xl;
+    *xr = Xr;
+}
+
+static void blowfish_dec( mbedtls_blowfish_context *ctx, uint32_t *xl, uint32_t *xr )
+{
+    uint32_t  Xl, Xr, temp;
+    short i;
+
+    Xl = *xl;
+    Xr = *xr;
+
+    for( i = MBEDTLS_BLOWFISH_ROUNDS + 1; i > 1; --i )
+    {
+        Xl = Xl ^ ctx->P[i];
+        Xr = F( ctx, Xl ) ^ Xr;
+
+        temp = Xl;
+        Xl = Xr;
+        Xr = temp;
+    }
+
+    temp = Xl;
+    Xl = Xr;
+    Xr = temp;
+
+    Xr = Xr ^ ctx->P[1];
+    Xl = Xl ^ ctx->P[0];
+
+    *xl = Xl;
+    *xr = Xr;
+}
+
+void mbedtls_blowfish_init( mbedtls_blowfish_context *ctx )
+{
+    BLOWFISH_VALIDATE( ctx != NULL );
+    memset( ctx, 0, sizeof( mbedtls_blowfish_context ) );
+}
+
+void mbedtls_blowfish_free( mbedtls_blowfish_context *ctx )
+{
+    if( ctx == NULL )
+        return;
+
+    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_blowfish_context ) );
+}
+
+/*
+ * Blowfish key schedule
+ */
+int mbedtls_blowfish_setkey( mbedtls_blowfish_context *ctx,
+                             const unsigned char *key,
+                             unsigned int keybits )
+{
+    unsigned int i, j, k;
+    uint32_t data, datal, datar;
+    BLOWFISH_VALIDATE_RET( ctx != NULL );
+    BLOWFISH_VALIDATE_RET( key != NULL );
+
+    if( keybits < MBEDTLS_BLOWFISH_MIN_KEY_BITS    ||
+        keybits > MBEDTLS_BLOWFISH_MAX_KEY_BITS    ||
+        keybits % 8 != 0 )
+    {
+        return( MBEDTLS_ERR_BLOWFISH_BAD_INPUT_DATA );
+    }
+
+    keybits >>= 3;
+
+    for( i = 0; i < 4; i++ )
+    {
+        for( j = 0; j < 256; j++ )
+            ctx->S[i][j] = S[i][j];
+    }
+
+    j = 0;
+    for( i = 0; i < MBEDTLS_BLOWFISH_ROUNDS + 2; ++i )
+    {
+        data = 0x00000000;
+        for( k = 0; k < 4; ++k )
+        {
+            data = ( data << 8 ) | key[j++];
+            if( j >= keybits )
+                j = 0;
+        }
+        ctx->P[i] = P[i] ^ data;
+    }
+
+    datal = 0x00000000;
+    datar = 0x00000000;
+
+    for( i = 0; i < MBEDTLS_BLOWFISH_ROUNDS + 2; i += 2 )
+    {
+        blowfish_enc( ctx, &datal, &datar );
+        ctx->P[i] = datal;
+        ctx->P[i + 1] = datar;
+    }
+
+    for( i = 0; i < 4; i++ )
+    {
+       for( j = 0; j < 256; j += 2 )
+       {
+            blowfish_enc( ctx, &datal, &datar );
+            ctx->S[i][j] = datal;
+            ctx->S[i][j + 1] = datar;
+        }
+    }
+    return( 0 );
+}
+
+/*
+ * Blowfish-ECB block encryption/decryption
+ */
+int mbedtls_blowfish_crypt_ecb( mbedtls_blowfish_context *ctx,
+                    int mode,
+                    const unsigned char input[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                    unsigned char output[MBEDTLS_BLOWFISH_BLOCKSIZE] )
+{
+    uint32_t X0, X1;
+    BLOWFISH_VALIDATE_RET( ctx != NULL );
+    BLOWFISH_VALIDATE_RET( mode == MBEDTLS_BLOWFISH_ENCRYPT ||
+                           mode == MBEDTLS_BLOWFISH_DECRYPT );
+    BLOWFISH_VALIDATE_RET( input  != NULL );
+    BLOWFISH_VALIDATE_RET( output != NULL );
+
+    GET_UINT32_BE( X0, input,  0 );
+    GET_UINT32_BE( X1, input,  4 );
+
+    if( mode == MBEDTLS_BLOWFISH_DECRYPT )
+    {
+        blowfish_dec( ctx, &X0, &X1 );
+    }
+    else /* MBEDTLS_BLOWFISH_ENCRYPT */
+    {
+        blowfish_enc( ctx, &X0, &X1 );
+    }
+
+    PUT_UINT32_BE( X0, output,  0 );
+    PUT_UINT32_BE( X1, output,  4 );
+
+    return( 0 );
+}
+
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+/*
+ * Blowfish-CBC buffer encryption/decryption
+ */
+int mbedtls_blowfish_crypt_cbc( mbedtls_blowfish_context *ctx,
+                    int mode,
+                    size_t length,
+                    unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                    const unsigned char *input,
+                    unsigned char *output )
+{
+    int i;
+    unsigned char temp[MBEDTLS_BLOWFISH_BLOCKSIZE];
+    BLOWFISH_VALIDATE_RET( ctx != NULL );
+    BLOWFISH_VALIDATE_RET( mode == MBEDTLS_BLOWFISH_ENCRYPT ||
+                           mode == MBEDTLS_BLOWFISH_DECRYPT );
+    BLOWFISH_VALIDATE_RET( iv != NULL );
+    BLOWFISH_VALIDATE_RET( length == 0 || input  != NULL );
+    BLOWFISH_VALIDATE_RET( length == 0 || output != NULL );
+
+    if( length % MBEDTLS_BLOWFISH_BLOCKSIZE )
+        return( MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH );
+
+    if( mode == MBEDTLS_BLOWFISH_DECRYPT )
+    {
+        while( length > 0 )
+        {
+            memcpy( temp, input, MBEDTLS_BLOWFISH_BLOCKSIZE );
+            mbedtls_blowfish_crypt_ecb( ctx, mode, input, output );
+
+            for( i = 0; i < MBEDTLS_BLOWFISH_BLOCKSIZE;i++ )
+                output[i] = (unsigned char)( output[i] ^ iv[i] );
+
+            memcpy( iv, temp, MBEDTLS_BLOWFISH_BLOCKSIZE );
+
+            input  += MBEDTLS_BLOWFISH_BLOCKSIZE;
+            output += MBEDTLS_BLOWFISH_BLOCKSIZE;
+            length -= MBEDTLS_BLOWFISH_BLOCKSIZE;
+        }
+    }
+    else
+    {
+        while( length > 0 )
+        {
+            for( i = 0; i < MBEDTLS_BLOWFISH_BLOCKSIZE; i++ )
+                output[i] = (unsigned char)( input[i] ^ iv[i] );
+
+            mbedtls_blowfish_crypt_ecb( ctx, mode, output, output );
+            memcpy( iv, output, MBEDTLS_BLOWFISH_BLOCKSIZE );
+
+            input  += MBEDTLS_BLOWFISH_BLOCKSIZE;
+            output += MBEDTLS_BLOWFISH_BLOCKSIZE;
+            length -= MBEDTLS_BLOWFISH_BLOCKSIZE;
+        }
+    }
+
+    return( 0 );
+}
+#endif /* MBEDTLS_CIPHER_MODE_CBC */
+
+#if defined(MBEDTLS_CIPHER_MODE_CFB)
+/*
+ * Blowfish CFB buffer encryption/decryption
+ */
+int mbedtls_blowfish_crypt_cfb64( mbedtls_blowfish_context *ctx,
+                       int mode,
+                       size_t length,
+                       size_t *iv_off,
+                       unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                       const unsigned char *input,
+                       unsigned char *output )
+{
+    int c;
+    size_t n;
+
+    BLOWFISH_VALIDATE_RET( ctx != NULL );
+    BLOWFISH_VALIDATE_RET( mode == MBEDTLS_BLOWFISH_ENCRYPT ||
+                           mode == MBEDTLS_BLOWFISH_DECRYPT );
+    BLOWFISH_VALIDATE_RET( iv     != NULL );
+    BLOWFISH_VALIDATE_RET( iv_off != NULL );
+    BLOWFISH_VALIDATE_RET( length == 0 || input  != NULL );
+    BLOWFISH_VALIDATE_RET( length == 0 || output != NULL );
+
+    n = *iv_off;
+    if( n >= 8 )
+        return( MBEDTLS_ERR_BLOWFISH_BAD_INPUT_DATA );
+
+    if( mode == MBEDTLS_BLOWFISH_DECRYPT )
+    {
+        while( length-- )
+        {
+            if( n == 0 )
+                mbedtls_blowfish_crypt_ecb( ctx, MBEDTLS_BLOWFISH_ENCRYPT, iv, iv );
+
+            c = *input++;
+            *output++ = (unsigned char)( c ^ iv[n] );
+            iv[n] = (unsigned char) c;
+
+            n = ( n + 1 ) % MBEDTLS_BLOWFISH_BLOCKSIZE;
+        }
+    }
+    else
+    {
+        while( length-- )
+        {
+            if( n == 0 )
+                mbedtls_blowfish_crypt_ecb( ctx, MBEDTLS_BLOWFISH_ENCRYPT, iv, iv );
+
+            iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );
+
+            n = ( n + 1 ) % MBEDTLS_BLOWFISH_BLOCKSIZE;
+        }
+    }
+
+    *iv_off = n;
+
+    return( 0 );
+}
+#endif /*MBEDTLS_CIPHER_MODE_CFB */
+
+#if defined(MBEDTLS_CIPHER_MODE_CTR)
+/*
+ * Blowfish CTR buffer encryption/decryption
+ */
+int mbedtls_blowfish_crypt_ctr( mbedtls_blowfish_context *ctx,
+                       size_t length,
+                       size_t *nc_off,
+                       unsigned char nonce_counter[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                       unsigned char stream_block[MBEDTLS_BLOWFISH_BLOCKSIZE],
+                       const unsigned char *input,
+                       unsigned char *output )
+{
+    int c, i;
+    size_t n;
+    BLOWFISH_VALIDATE_RET( ctx != NULL );
+    BLOWFISH_VALIDATE_RET( nonce_counter != NULL );
+    BLOWFISH_VALIDATE_RET( stream_block  != NULL );
+    BLOWFISH_VALIDATE_RET( nc_off != NULL );
+    BLOWFISH_VALIDATE_RET( length == 0 || input  != NULL );
+    BLOWFISH_VALIDATE_RET( length == 0 || output != NULL );
+
+    n = *nc_off;
+    if( n >= 8 )
+        return( MBEDTLS_ERR_BLOWFISH_BAD_INPUT_DATA );
+
+    while( length-- )
+    {
+        if( n == 0 ) {
+            mbedtls_blowfish_crypt_ecb( ctx, MBEDTLS_BLOWFISH_ENCRYPT, nonce_counter,
+                                stream_block );
+
+            for( i = MBEDTLS_BLOWFISH_BLOCKSIZE; i > 0; i-- )
+                if( ++nonce_counter[i - 1] != 0 )
+                    break;
+        }
+        c = *input++;
+        *output++ = (unsigned char)( c ^ stream_block[n] );
+
+        n = ( n + 1 ) % MBEDTLS_BLOWFISH_BLOCKSIZE;
+    }
+
+    *nc_off = n;
+
+    return( 0 );
+}
+#endif /* MBEDTLS_CIPHER_MODE_CTR */
+
+static const uint32_t S[4][256] = {
+    {   0xD1310BA6L, 0x98DFB5ACL, 0x2FFD72DBL, 0xD01ADFB7L,
+        0xB8E1AFEDL, 0x6A267E96L, 0xBA7C9045L, 0xF12C7F99L,
+        0x24A19947L, 0xB3916CF7L, 0x0801F2E2L, 0x858EFC16L,
+        0x636920D8L, 0x71574E69L, 0xA458FEA3L, 0xF4933D7EL,
+        0x0D95748FL, 0x728EB658L, 0x718BCD58L, 0x82154AEEL,
+        0x7B54A41DL, 0xC25A59B5L, 0x9C30D539L, 0x2AF26013L,
+        0xC5D1B023L, 0x286085F0L, 0xCA417918L, 0xB8DB38EFL,
+        0x8E79DCB0L, 0x603A180EL, 0x6C9E0E8BL, 0xB01E8A3EL,
+        0xD71577C1L, 0xBD314B27L, 0x78AF2FDAL, 0x55605C60L,
+        0xE65525F3L, 0xAA55AB94L, 0x57489862L, 0x63E81440L,
+        0x55CA396AL, 0x2AAB10B6L, 0xB4CC5C34L, 0x1141E8CEL,
+        0xA15486AFL, 0x7C72E993L, 0xB3EE1411L, 0x636FBC2AL,
+        0x2BA9C55DL, 0x741831F6L, 0xCE5C3E16L, 0x9B87931EL,
+        0xAFD6BA33L, 0x6C24CF5CL, 0x7A325381L, 0x28958677L,
+        0x3B8F4898L, 0x6B4BB9AFL, 0xC4BFE81BL, 0x66282193L,
+        0x61D809CCL, 0xFB21A991L, 0x487CAC60L, 0x5DEC8032L,
+        0xEF845D5DL, 0xE98575B1L, 0xDC262302L, 0xEB651B88L,
+        0x23893E81L, 0xD396ACC5L, 0x0F6D6FF3L, 0x83F44239L,
+        0x2E0B4482L, 0xA4842004L, 0x69C8F04AL, 0x9E1F9B5EL,
+        0x21C66842L, 0xF6E96C9AL, 0x670C9C61L, 0xABD388F0L,
+        0x6A51A0D2L, 0xD8542F68L, 0x960FA728L, 0xAB5133A3L,
+        0x6EEF0B6CL, 0x137A3BE4L, 0xBA3BF050L, 0x7EFB2A98L,
+        0xA1F1651DL, 0x39AF0176L, 0x66CA593EL, 0x82430E88L,
+        0x8CEE8619L, 0x456F9FB4L, 0x7D84A5C3L, 0x3B8B5EBEL,
+        0xE06F75D8L, 0x85C12073L, 0x401A449FL, 0x56C16AA6L,
+        0x4ED3AA62L, 0x363F7706L, 0x1BFEDF72L, 0x429B023DL,
+        0x37D0D724L, 0xD00A1248L, 0xDB0FEAD3L, 0x49F1C09BL,
+        0x075372C9L, 0x80991B7BL, 0x25D479D8L, 0xF6E8DEF7L,
+        0xE3FE501AL, 0xB6794C3BL, 0x976CE0BDL, 0x04C006BAL,
+        0xC1A94FB6L, 0x409F60C4L, 0x5E5C9EC2L, 0x196A2463L,
+        0x68FB6FAFL, 0x3E6C53B5L, 0x1339B2EBL, 0x3B52EC6FL,
+        0x6DFC511FL, 0x9B30952CL, 0xCC814544L, 0xAF5EBD09L,
+        0xBEE3D004L, 0xDE334AFDL, 0x660F2807L, 0x192E4BB3L,
+        0xC0CBA857L, 0x45C8740FL, 0xD20B5F39L, 0xB9D3FBDBL,
+        0x5579C0BDL, 0x1A60320AL, 0xD6A100C6L, 0x402C7279L,
+        0x679F25FEL, 0xFB1FA3CCL, 0x8EA5E9F8L, 0xDB3222F8L,
+        0x3C7516DFL, 0xFD616B15L, 0x2F501EC8L, 0xAD0552ABL,
+        0x323DB5FAL, 0xFD238760L, 0x53317B48L, 0x3E00DF82L,
+        0x9E5C57BBL, 0xCA6F8CA0L, 0x1A87562EL, 0xDF1769DBL,
+        0xD542A8F6L, 0x287EFFC3L, 0xAC6732C6L, 0x8C4F5573L,
+        0x695B27B0L, 0xBBCA58C8L, 0xE1FFA35DL, 0xB8F011A0L,
+        0x10FA3D98L, 0xFD2183B8L, 0x4AFCB56CL, 0x2DD1D35BL,
+        0x9A53E479L, 0xB6F84565L, 0xD28E49BCL, 0x4BFB9790L,
+        0xE1DDF2DAL, 0xA4CB7E33L, 0x62FB1341L, 0xCEE4C6E8L,
+        0xEF20CADAL, 0x36774C01L, 0xD07E9EFEL, 0x2BF11FB4L,
+        0x95DBDA4DL, 0xAE909198L, 0xEAAD8E71L, 0x6B93D5A0L,
+        0xD08ED1D0L, 0xAFC725E0L, 0x8E3C5B2FL, 0x8E7594B7L,
+        0x8FF6E2FBL, 0xF2122B64L, 0x8888B812L, 0x900DF01CL,
+        0x4FAD5EA0L, 0x688FC31CL, 0xD1CFF191L, 0xB3A8C1ADL,
+        0x2F2F2218L, 0xBE0E1777L, 0xEA752DFEL, 0x8B021FA1L,
+        0xE5A0CC0FL, 0xB56F74E8L, 0x18ACF3D6L, 0xCE89E299L,
+        0xB4A84FE0L, 0xFD13E0B7L, 0x7CC43B81L, 0xD2ADA8D9L,
+        0x165FA266L, 0x80957705L, 0x93CC7314L, 0x211A1477L,
+        0xE6AD2065L, 0x77B5FA86L, 0xC75442F5L, 0xFB9D35CFL,
+        0xEBCDAF0CL, 0x7B3E89A0L, 0xD6411BD3L, 0xAE1E7E49L,
+        0x00250E2DL, 0x2071B35EL, 0x226800BBL, 0x57B8E0AFL,
+        0x2464369BL, 0xF009B91EL, 0x5563911DL, 0x59DFA6AAL,
+        0x78C14389L, 0xD95A537FL, 0x207D5BA2L, 0x02E5B9C5L,
+        0x83260376L, 0x6295CFA9L, 0x11C81968L, 0x4E734A41L,
+        0xB3472DCAL, 0x7B14A94AL, 0x1B510052L, 0x9A532915L,
+        0xD60F573FL, 0xBC9BC6E4L, 0x2B60A476L, 0x81E67400L,
+        0x08BA6FB5L, 0x571BE91FL, 0xF296EC6BL, 0x2A0DD915L,
+        0xB6636521L, 0xE7B9F9B6L, 0xFF34052EL, 0xC5855664L,
+        0x53B02D5DL, 0xA99F8FA1L, 0x08BA4799L, 0x6E85076AL   },
+    {   0x4B7A70E9L, 0xB5B32944L, 0xDB75092EL, 0xC4192623L,
+        0xAD6EA6B0L, 0x49A7DF7DL, 0x9CEE60B8L, 0x8FEDB266L,
+        0xECAA8C71L, 0x699A17FFL, 0x5664526CL, 0xC2B19EE1L,
+        0x193602A5L, 0x75094C29L, 0xA0591340L, 0xE4183A3EL,
+        0x3F54989AL, 0x5B429D65L, 0x6B8FE4D6L, 0x99F73FD6L,
+        0xA1D29C07L, 0xEFE830F5L, 0x4D2D38E6L, 0xF0255DC1L,
+        0x4CDD2086L, 0x8470EB26L, 0x6382E9C6L, 0x021ECC5EL,
+        0x09686B3FL, 0x3EBAEFC9L, 0x3C971814L, 0x6B6A70A1L,
+        0x687F3584L, 0x52A0E286L, 0xB79C5305L, 0xAA500737L,
+        0x3E07841CL, 0x7FDEAE5CL, 0x8E7D44ECL, 0x5716F2B8L,
+        0xB03ADA37L, 0xF0500C0DL, 0xF01C1F04L, 0x0200B3FFL,
+        0xAE0CF51AL, 0x3CB574B2L, 0x25837A58L, 0xDC0921BDL,
+        0xD19113F9L, 0x7CA92FF6L, 0x94324773L, 0x22F54701L,
+        0x3AE5E581L, 0x37C2DADCL, 0xC8B57634L, 0x9AF3DDA7L,
+        0xA9446146L, 0x0FD0030EL, 0xECC8C73EL, 0xA4751E41L,
+        0xE238CD99L, 0x3BEA0E2FL, 0x3280BBA1L, 0x183EB331L,
+        0x4E548B38L, 0x4F6DB908L, 0x6F420D03L, 0xF60A04BFL,
+        0x2CB81290L, 0x24977C79L, 0x5679B072L, 0xBCAF89AFL,
+        0xDE9A771FL, 0xD9930810L, 0xB38BAE12L, 0xDCCF3F2EL,
+        0x5512721FL, 0x2E6B7124L, 0x501ADDE6L, 0x9F84CD87L,
+        0x7A584718L, 0x7408DA17L, 0xBC9F9ABCL, 0xE94B7D8CL,
+        0xEC7AEC3AL, 0xDB851DFAL, 0x63094366L, 0xC464C3D2L,
+        0xEF1C1847L, 0x3215D908L, 0xDD433B37L, 0x24C2BA16L,
+        0x12A14D43L, 0x2A65C451L, 0x50940002L, 0x133AE4DDL,
+        0x71DFF89EL, 0x10314E55L, 0x81AC77D6L, 0x5F11199BL,
+        0x043556F1L, 0xD7A3C76BL, 0x3C11183BL, 0x5924A509L,
+        0xF28FE6EDL, 0x97F1FBFAL, 0x9EBABF2CL, 0x1E153C6EL,
+        0x86E34570L, 0xEAE96FB1L, 0x860E5E0AL, 0x5A3E2AB3L,
+        0x771FE71CL, 0x4E3D06FAL, 0x2965DCB9L, 0x99E71D0FL,
+        0x803E89D6L, 0x5266C825L, 0x2E4CC978L, 0x9C10B36AL,
+        0xC6150EBAL, 0x94E2EA78L, 0xA5FC3C53L, 0x1E0A2DF4L,
+        0xF2F74EA7L, 0x361D2B3DL, 0x1939260FL, 0x19C27960L,
+        0x5223A708L, 0xF71312B6L, 0xEBADFE6EL, 0xEAC31F66L,
+        0xE3BC4595L, 0xA67BC883L, 0xB17F37D1L, 0x018CFF28L,
+        0xC332DDEFL, 0xBE6C5AA5L, 0x65582185L, 0x68AB9802L,
+        0xEECEA50FL, 0xDB2F953BL, 0x2AEF7DADL, 0x5B6E2F84L,
+        0x1521B628L, 0x29076170L, 0xECDD4775L, 0x619F1510L,
+        0x13CCA830L, 0xEB61BD96L, 0x0334FE1EL, 0xAA0363CFL,
+        0xB5735C90L, 0x4C70A239L, 0xD59E9E0BL, 0xCBAADE14L,
+        0xEECC86BCL, 0x60622CA7L, 0x9CAB5CABL, 0xB2F3846EL,
+        0x648B1EAFL, 0x19BDF0CAL, 0xA02369B9L, 0x655ABB50L,
+        0x40685A32L, 0x3C2AB4B3L, 0x319EE9D5L, 0xC021B8F7L,
+        0x9B540B19L, 0x875FA099L, 0x95F7997EL, 0x623D7DA8L,
+        0xF837889AL, 0x97E32D77L, 0x11ED935FL, 0x16681281L,
+        0x0E358829L, 0xC7E61FD6L, 0x96DEDFA1L, 0x7858BA99L,
+        0x57F584A5L, 0x1B227263L, 0x9B83C3FFL, 0x1AC24696L,
+        0xCDB30AEBL, 0x532E3054L, 0x8FD948E4L, 0x6DBC3128L,
+        0x58EBF2EFL, 0x34C6FFEAL, 0xFE28ED61L, 0xEE7C3C73L,
+        0x5D4A14D9L, 0xE864B7E3L, 0x42105D14L, 0x203E13E0L,
+        0x45EEE2B6L, 0xA3AAABEAL, 0xDB6C4F15L, 0xFACB4FD0L,
+        0xC742F442L, 0xEF6ABBB5L, 0x654F3B1DL, 0x41CD2105L,
+        0xD81E799EL, 0x86854DC7L, 0xE44B476AL, 0x3D816250L,
+        0xCF62A1F2L, 0x5B8D2646L, 0xFC8883A0L, 0xC1C7B6A3L,
+        0x7F1524C3L, 0x69CB7492L, 0x47848A0BL, 0x5692B285L,
+        0x095BBF00L, 0xAD19489DL, 0x1462B174L, 0x23820E00L,
+        0x58428D2AL, 0x0C55F5EAL, 0x1DADF43EL, 0x233F7061L,
+        0x3372F092L, 0x8D937E41L, 0xD65FECF1L, 0x6C223BDBL,
+        0x7CDE3759L, 0xCBEE7460L, 0x4085F2A7L, 0xCE77326EL,
+        0xA6078084L, 0x19F8509EL, 0xE8EFD855L, 0x61D99735L,
+        0xA969A7AAL, 0xC50C06C2L, 0x5A04ABFCL, 0x800BCADCL,
+        0x9E447A2EL, 0xC3453484L, 0xFDD56705L, 0x0E1E9EC9L,
+        0xDB73DBD3L, 0x105588CDL, 0x675FDA79L, 0xE3674340L,
+        0xC5C43465L, 0x713E38D8L, 0x3D28F89EL, 0xF16DFF20L,
+        0x153E21E7L, 0x8FB03D4AL, 0xE6E39F2BL, 0xDB83ADF7L   },
+    {   0xE93D5A68L, 0x948140F7L, 0xF64C261CL, 0x94692934L,
+        0x411520F7L, 0x7602D4F7L, 0xBCF46B2EL, 0xD4A20068L,
+        0xD4082471L, 0x3320F46AL, 0x43B7D4B7L, 0x500061AFL,
+        0x1E39F62EL, 0x97244546L, 0x14214F74L, 0xBF8B8840L,
+        0x4D95FC1DL, 0x96B591AFL, 0x70F4DDD3L, 0x66A02F45L,
+        0xBFBC09ECL, 0x03BD9785L, 0x7FAC6DD0L, 0x31CB8504L,
+        0x96EB27B3L, 0x55FD3941L, 0xDA2547E6L, 0xABCA0A9AL,
+        0x28507825L, 0x530429F4L, 0x0A2C86DAL, 0xE9B66DFBL,
+        0x68DC1462L, 0xD7486900L, 0x680EC0A4L, 0x27A18DEEL,
+        0x4F3FFEA2L, 0xE887AD8CL, 0xB58CE006L, 0x7AF4D6B6L,
+        0xAACE1E7CL, 0xD3375FECL, 0xCE78A399L, 0x406B2A42L,
+        0x20FE9E35L, 0xD9F385B9L, 0xEE39D7ABL, 0x3B124E8BL,
+        0x1DC9FAF7L, 0x4B6D1856L, 0x26A36631L, 0xEAE397B2L,
+        0x3A6EFA74L, 0xDD5B4332L, 0x6841E7F7L, 0xCA7820FBL,
+        0xFB0AF54EL, 0xD8FEB397L, 0x454056ACL, 0xBA489527L,
+        0x55533A3AL, 0x20838D87L, 0xFE6BA9B7L, 0xD096954BL,
+        0x55A867BCL, 0xA1159A58L, 0xCCA92963L, 0x99E1DB33L,
+        0xA62A4A56L, 0x3F3125F9L, 0x5EF47E1CL, 0x9029317CL,
+        0xFDF8E802L, 0x04272F70L, 0x80BB155CL, 0x05282CE3L,
+        0x95C11548L, 0xE4C66D22L, 0x48C1133FL, 0xC70F86DCL,
+        0x07F9C9EEL, 0x41041F0FL, 0x404779A4L, 0x5D886E17L,
+        0x325F51EBL, 0xD59BC0D1L, 0xF2BCC18FL, 0x41113564L,
+        0x257B7834L, 0x602A9C60L, 0xDFF8E8A3L, 0x1F636C1BL,
+        0x0E12B4C2L, 0x02E1329EL, 0xAF664FD1L, 0xCAD18115L,
+        0x6B2395E0L, 0x333E92E1L, 0x3B240B62L, 0xEEBEB922L,
+        0x85B2A20EL, 0xE6BA0D99L, 0xDE720C8CL, 0x2DA2F728L,
+        0xD0127845L, 0x95B794FDL, 0x647D0862L, 0xE7CCF5F0L,
+        0x5449A36FL, 0x877D48FAL, 0xC39DFD27L, 0xF33E8D1EL,
+        0x0A476341L, 0x992EFF74L, 0x3A6F6EABL, 0xF4F8FD37L,
+        0xA812DC60L, 0xA1EBDDF8L, 0x991BE14CL, 0xDB6E6B0DL,
+        0xC67B5510L, 0x6D672C37L, 0x2765D43BL, 0xDCD0E804L,
+        0xF1290DC7L, 0xCC00FFA3L, 0xB5390F92L, 0x690FED0BL,
+        0x667B9FFBL, 0xCEDB7D9CL, 0xA091CF0BL, 0xD9155EA3L,
+        0xBB132F88L, 0x515BAD24L, 0x7B9479BFL, 0x763BD6EBL,
+        0x37392EB3L, 0xCC115979L, 0x8026E297L, 0xF42E312DL,
+        0x6842ADA7L, 0xC66A2B3BL, 0x12754CCCL, 0x782EF11CL,
+        0x6A124237L, 0xB79251E7L, 0x06A1BBE6L, 0x4BFB6350L,
+        0x1A6B1018L, 0x11CAEDFAL, 0x3D25BDD8L, 0xE2E1C3C9L,
+        0x44421659L, 0x0A121386L, 0xD90CEC6EL, 0xD5ABEA2AL,
+        0x64AF674EL, 0xDA86A85FL, 0xBEBFE988L, 0x64E4C3FEL,
+        0x9DBC8057L, 0xF0F7C086L, 0x60787BF8L, 0x6003604DL,
+        0xD1FD8346L, 0xF6381FB0L, 0x7745AE04L, 0xD736FCCCL,
+        0x83426B33L, 0xF01EAB71L, 0xB0804187L, 0x3C005E5FL,
+        0x77A057BEL, 0xBDE8AE24L, 0x55464299L, 0xBF582E61L,
+        0x4E58F48FL, 0xF2DDFDA2L, 0xF474EF38L, 0x8789BDC2L,
+        0x5366F9C3L, 0xC8B38E74L, 0xB475F255L, 0x46FCD9B9L,
+        0x7AEB2661L, 0x8B1DDF84L, 0x846A0E79L, 0x915F95E2L,
+        0x466E598EL, 0x20B45770L, 0x8CD55591L, 0xC902DE4CL,
+        0xB90BACE1L, 0xBB8205D0L, 0x11A86248L, 0x7574A99EL,
+        0xB77F19B6L, 0xE0A9DC09L, 0x662D09A1L, 0xC4324633L,
+        0xE85A1F02L, 0x09F0BE8CL, 0x4A99A025L, 0x1D6EFE10L,
+        0x1AB93D1DL, 0x0BA5A4DFL, 0xA186F20FL, 0x2868F169L,
+        0xDCB7DA83L, 0x573906FEL, 0xA1E2CE9BL, 0x4FCD7F52L,
+        0x50115E01L, 0xA70683FAL, 0xA002B5C4L, 0x0DE6D027L,
+        0x9AF88C27L, 0x773F8641L, 0xC3604C06L, 0x61A806B5L,
+        0xF0177A28L, 0xC0F586E0L, 0x006058AAL, 0x30DC7D62L,
+        0x11E69ED7L, 0x2338EA63L, 0x53C2DD94L, 0xC2C21634L,
+        0xBBCBEE56L, 0x90BCB6DEL, 0xEBFC7DA1L, 0xCE591D76L,
+        0x6F05E409L, 0x4B7C0188L, 0x39720A3DL, 0x7C927C24L,
+        0x86E3725FL, 0x724D9DB9L, 0x1AC15BB4L, 0xD39EB8FCL,
+        0xED545578L, 0x08FCA5B5L, 0xD83D7CD3L, 0x4DAD0FC4L,
+        0x1E50EF5EL, 0xB161E6F8L, 0xA28514D9L, 0x6C51133CL,
+        0x6FD5C7E7L, 0x56E14EC4L, 0x362ABFCEL, 0xDDC6C837L,
+        0xD79A3234L, 0x92638212L, 0x670EFA8EL, 0x406000E0L  },
+    {   0x3A39CE37L, 0xD3FAF5CFL, 0xABC27737L, 0x5AC52D1BL,
+        0x5CB0679EL, 0x4FA33742L, 0xD3822740L, 0x99BC9BBEL,
+        0xD5118E9DL, 0xBF0F7315L, 0xD62D1C7EL, 0xC700C47BL,
+        0xB78C1B6BL, 0x21A19045L, 0xB26EB1BEL, 0x6A366EB4L,
+        0x5748AB2FL, 0xBC946E79L, 0xC6A376D2L, 0x6549C2C8L,
+        0x530FF8EEL, 0x468DDE7DL, 0xD5730A1DL, 0x4CD04DC6L,
+        0x2939BBDBL, 0xA9BA4650L, 0xAC9526E8L, 0xBE5EE304L,
+        0xA1FAD5F0L, 0x6A2D519AL, 0x63EF8CE2L, 0x9A86EE22L,
+        0xC089C2B8L, 0x43242EF6L, 0xA51E03AAL, 0x9CF2D0A4L,
+        0x83C061BAL, 0x9BE96A4DL, 0x8FE51550L, 0xBA645BD6L,
+        0x2826A2F9L, 0xA73A3AE1L, 0x4BA99586L, 0xEF5562E9L,
+        0xC72FEFD3L, 0xF752F7DAL, 0x3F046F69L, 0x77FA0A59L,
+        0x80E4A915L, 0x87B08601L, 0x9B09E6ADL, 0x3B3EE593L,
+        0xE990FD5AL, 0x9E34D797L, 0x2CF0B7D9L, 0x022B8B51L,
+        0x96D5AC3AL, 0x017DA67DL, 0xD1CF3ED6L, 0x7C7D2D28L,
+        0x1F9F25CFL, 0xADF2B89BL, 0x5AD6B472L, 0x5A88F54CL,
+        0xE029AC71L, 0xE019A5E6L, 0x47B0ACFDL, 0xED93FA9BL,
+        0xE8D3C48DL, 0x283B57CCL, 0xF8D56629L, 0x79132E28L,
+        0x785F0191L, 0xED756055L, 0xF7960E44L, 0xE3D35E8CL,
+        0x15056DD4L, 0x88F46DBAL, 0x03A16125L, 0x0564F0BDL,
+        0xC3EB9E15L, 0x3C9057A2L, 0x97271AECL, 0xA93A072AL,
+        0x1B3F6D9BL, 0x1E6321F5L, 0xF59C66FBL, 0x26DCF319L,
+        0x7533D928L, 0xB155FDF5L, 0x03563482L, 0x8ABA3CBBL,
+        0x28517711L, 0xC20AD9F8L, 0xABCC5167L, 0xCCAD925FL,
+        0x4DE81751L, 0x3830DC8EL, 0x379D5862L, 0x9320F991L,
+        0xEA7A90C2L, 0xFB3E7BCEL, 0x5121CE64L, 0x774FBE32L,
+        0xA8B6E37EL, 0xC3293D46L, 0x48DE5369L, 0x6413E680L,
+        0xA2AE0810L, 0xDD6DB224L, 0x69852DFDL, 0x09072166L,
+        0xB39A460AL, 0x6445C0DDL, 0x586CDECFL, 0x1C20C8AEL,
+        0x5BBEF7DDL, 0x1B588D40L, 0xCCD2017FL, 0x6BB4E3BBL,
+        0xDDA26A7EL, 0x3A59FF45L, 0x3E350A44L, 0xBCB4CDD5L,
+        0x72EACEA8L, 0xFA6484BBL, 0x8D6612AEL, 0xBF3C6F47L,
+        0xD29BE463L, 0x542F5D9EL, 0xAEC2771BL, 0xF64E6370L,
+        0x740E0D8DL, 0xE75B1357L, 0xF8721671L, 0xAF537D5DL,
+        0x4040CB08L, 0x4EB4E2CCL, 0x34D2466AL, 0x0115AF84L,
+        0xE1B00428L, 0x95983A1DL, 0x06B89FB4L, 0xCE6EA048L,
+        0x6F3F3B82L, 0x3520AB82L, 0x011A1D4BL, 0x277227F8L,
+        0x611560B1L, 0xE7933FDCL, 0xBB3A792BL, 0x344525BDL,
+        0xA08839E1L, 0x51CE794BL, 0x2F32C9B7L, 0xA01FBAC9L,
+        0xE01CC87EL, 0xBCC7D1F6L, 0xCF0111C3L, 0xA1E8AAC7L,
+        0x1A908749L, 0xD44FBD9AL, 0xD0DADECBL, 0xD50ADA38L,
+        0x0339C32AL, 0xC6913667L, 0x8DF9317CL, 0xE0B12B4FL,
+        0xF79E59B7L, 0x43F5BB3AL, 0xF2D519FFL, 0x27D9459CL,
+        0xBF97222CL, 0x15E6FC2AL, 0x0F91FC71L, 0x9B941525L,
+        0xFAE59361L, 0xCEB69CEBL, 0xC2A86459L, 0x12BAA8D1L,
+        0xB6C1075EL, 0xE3056A0CL, 0x10D25065L, 0xCB03A442L,
+        0xE0EC6E0EL, 0x1698DB3BL, 0x4C98A0BEL, 0x3278E964L,
+        0x9F1F9532L, 0xE0D392DFL, 0xD3A0342BL, 0x8971F21EL,
+        0x1B0A7441L, 0x4BA3348CL, 0xC5BE7120L, 0xC37632D8L,
+        0xDF359F8DL, 0x9B992F2EL, 0xE60B6F47L, 0x0FE3F11DL,
+        0xE54CDA54L, 0x1EDAD891L, 0xCE6279CFL, 0xCD3E7E6FL,
+        0x1618B166L, 0xFD2C1D05L, 0x848FD2C5L, 0xF6FB2299L,
+        0xF523F357L, 0xA6327623L, 0x93A83531L, 0x56CCCD02L,
+        0xACF08162L, 0x5A75EBB5L, 0x6E163697L, 0x88D273CCL,
+        0xDE966292L, 0x81B949D0L, 0x4C50901BL, 0x71C65614L,
+        0xE6C6C7BDL, 0x327A140AL, 0x45E1D006L, 0xC3F27B9AL,
+        0xC9AA53FDL, 0x62A80F00L, 0xBB25BFE2L, 0x35BDD2F6L,
+        0x71126905L, 0xB2040222L, 0xB6CBCF7CL, 0xCD769C2BL,
+        0x53113EC0L, 0x1640E3D3L, 0x38ABBD60L, 0x2547ADF0L,
+        0xBA38209CL, 0xF746CE76L, 0x77AFA1C5L, 0x20756060L,
+        0x85CBFE4EL, 0x8AE88DD8L, 0x7AAAF9B0L, 0x4CF9AA7EL,
+        0x1948C25CL, 0x02FB8A8CL, 0x01C36AE4L, 0xD6EBE1F9L,
+        0x90D4F869L, 0xA65CDEA0L, 0x3F09252DL, 0xC208E69FL,
+        0xB74E6132L, 0xCE77E25BL, 0x578FDFE3L, 0x3AC372E6L  }
+};
+
+#endif /* !MBEDTLS_BLOWFISH_ALT */
+#endif /* MBEDTLS_BLOWFISH_C */
diff --git a/library/ccm.c b/library/ccm.c
index 45ed697..a9b6aaf 100644
--- a/library/ccm.c
+++ b/library/ccm.c
@@ -505,6 +505,7 @@ int mbedtls_ccm_finish(mbedtls_ccm_context *ctx,
 
     return 0;
 }
+#endif /* !MBEDTLS_CCM_ALT */
 
 /*
  * Authenticated encryption or decryption
@@ -626,7 +627,6 @@ int mbedtls_ccm_auth_decrypt(mbedtls_ccm_context *ctx, size_t length,
                             iv, iv_len, add, add_len,
                             input, output, tag, tag_len);
 }
-#endif /* !MBEDTLS_CCM_ALT */
 
 #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_CCM_GCM_CAN_AES)
 /*
diff --git a/library/ecdsa.c b/library/ecdsa.c
index 2f7a996..7c5ff27 100644
--- a/library/ecdsa.c
+++ b/library/ecdsa.c
@@ -18,6 +18,10 @@
 #include "mbedtls/ecdsa.h"
 #include "mbedtls/asn1write.h"
 
+#if defined(MBEDTLS_SM2DSA_C)
+#include "mbedtls/sm2dsa.h"
+#endif
+
 #include <string.h>
 
 #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
@@ -264,6 +268,14 @@ int mbedtls_ecdsa_sign_restartable(mbedtls_ecp_group *grp,
         return MBEDTLS_ERR_ECP_INVALID_KEY;
     }
 
+#if defined(MBEDTLS_SM2DSA_C)
+    if( grp->id == MBEDTLS_ECP_DP_SM2P256V1 )
+    {
+        return( sm2dsa_sign_internal( grp, r, s, d, buf, blen,
+                                      f_rng, p_rng, f_rng_blind, p_rng_blind ) );
+    }
+#endif
+
     mbedtls_ecp_point_init(&R);
     mbedtls_mpi_init(&k); mbedtls_mpi_init(&e); mbedtls_mpi_init(&t);
 
@@ -506,6 +518,13 @@ int mbedtls_ecdsa_verify_restartable(mbedtls_ecp_group *grp,
         return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
     }
 
+#if defined(MBEDTLS_SM2DSA_C)
+    if( grp->id == MBEDTLS_ECP_DP_SM2P256V1 )
+    {
+        return( sm2dsa_verify_internal( grp, buf, blen, Q, r, s ) );
+    }
+#endif
+
     ECDSA_RS_ENTER(ver);
 
 #if defined(MBEDTLS_ECP_RESTARTABLE)
diff --git a/library/ecp.c b/library/ecp.c
index 427059b..e5d4ebb 100644
--- a/library/ecp.c
+++ b/library/ecp.c
@@ -361,6 +361,9 @@ static const mbedtls_ecp_curve_info ecp_supported_curves[] =
 #if defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
     { MBEDTLS_ECP_DP_SECP256K1,    22,     256,    "secp256k1"         },
 #endif
+#if defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED)
+    { MBEDTLS_ECP_DP_SM2P256V1,    41,     256,    "sm2p256v1"         },
+#endif
 #if defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)
     { MBEDTLS_ECP_DP_BP256R1,      26,     256,    "brainpoolP256r1"   },
 #endif
@@ -2694,6 +2697,7 @@ cleanup:
 /*
  * Restartable multiplication R = m * P
  */
+#if !defined(MBEDTLS_ECP_MUL_ALT)
 int mbedtls_ecp_mul_restartable(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
                                 const mbedtls_mpi *m, const mbedtls_ecp_point *P,
                                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
@@ -2705,6 +2709,7 @@ int mbedtls_ecp_mul_restartable(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
 
     return ecp_mul_restartable_internal(grp, R, m, P, f_rng, p_rng, rs_ctx);
 }
+#endif  /* MBEDTLS_ECP_MUL_ALT */
 
 /*
  * Multiplication R = m * P
@@ -3158,6 +3163,7 @@ int mbedtls_ecp_gen_privkey(const mbedtls_ecp_group *grp,
 /*
  * Generate a keypair with configurable base point
  */
+#if !defined(MBEDTLS_ECC_GEN_KEY_ALT)
 int mbedtls_ecp_gen_keypair_base(mbedtls_ecp_group *grp,
                                  const mbedtls_ecp_point *G,
                                  mbedtls_mpi *d, mbedtls_ecp_point *Q,
@@ -3182,6 +3188,7 @@ int mbedtls_ecp_gen_keypair(mbedtls_ecp_group *grp,
 {
     return mbedtls_ecp_gen_keypair_base(grp, &grp->G, d, Q, f_rng, p_rng);
 }
+#endif /* !MBEDTLS_ECC_GEN_KEY_ALT */
 
 /*
  * Generate a keypair, prettier wrapper
diff --git a/library/ecp_curves.c b/library/ecp_curves.c
index c3cd33f..8acaedc 100644
--- a/library/ecp_curves.c
+++ b/library/ecp_curves.c
@@ -43,7 +43,8 @@
     defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)   ||   \
     defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) ||   \
     defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) ||   \
-    defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
+    defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED) ||   \
+    defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED)
 /* For these curves, we build the group parameters dynamically. */
 #define ECP_LOAD_GROUP
 static const mbedtls_mpi_uint mpi_one[] = { 1 };
@@ -4486,6 +4487,254 @@ static const mbedtls_ecp_point brainpoolP512r1_T[32] = {
 #endif
 #endif /* MBEDTLS_ECP_DP_BP512R1_ENABLED */
 
+#if defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED)
+static const mbedtls_mpi_uint sm2p256v1_p[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF ),
+};
+static const mbedtls_mpi_uint sm2p256v1_b[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x93, 0x0E, 0x94, 0x4D, 0x41, 0xBD, 0xBC, 0xDD ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x92, 0x8F, 0xAB, 0x15, 0xF5, 0x89, 0x97, 0xF3 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA7, 0x09, 0x65, 0xCF, 0x4B, 0x9E, 0x5A, 0x4D ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x34, 0x5E, 0x9F, 0x9D, 0x9E, 0xFA, 0xE9, 0x28 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_gx[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC7, 0x74, 0x4C, 0x33, 0x89, 0x45, 0x5A, 0x71 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE1, 0x0B, 0x66, 0xF2, 0xBF, 0x0B, 0xE3, 0x8F ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x94, 0xC9, 0x39, 0x6A, 0x46, 0x04, 0x99, 0x5F ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x19, 0x81, 0x19, 0x1F, 0x2C, 0xAE, 0xC4, 0x32 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_gy[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA0, 0xF0, 0x39, 0x21, 0xE5, 0x32, 0xDF, 0x02 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x40, 0x47, 0x2A, 0xC6, 0x7C, 0x87, 0xA9, 0xD0 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x53, 0x21, 0x69, 0x6B, 0xE3, 0xCE, 0xBD, 0x59 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x9C, 0x77, 0xF6, 0xF4, 0xA2, 0x36, 0x37, 0xBC ),
+};
+static const mbedtls_mpi_uint sm2p256v1_n[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x23, 0x41, 0xD5, 0x39, 0x09, 0xF4, 0xBB, 0x53 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x2B, 0x05, 0xC6, 0x21, 0x6B, 0xDF, 0x03, 0x72 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF ),
+};
+
+#if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1
+static const mbedtls_mpi_uint sm2p256v1_T_0_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC7, 0x74, 0x4C, 0x33, 0x89, 0x45, 0x5A, 0x71 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE1, 0x0B, 0x66, 0xF2, 0xBF, 0x0B, 0xE3, 0x8F ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x94, 0xC9, 0x39, 0x6A, 0x46, 0x04, 0x99, 0x5F ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x19, 0x81, 0x19, 0x1F, 0x2C, 0xAE, 0xC4, 0x32 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_0_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA0, 0xF0, 0x39, 0x21, 0xE5, 0x32, 0xDF, 0x02 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x40, 0x47, 0x2A, 0xC6, 0x7C, 0x87, 0xA9, 0xD0 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x53, 0x21, 0x69, 0x6B, 0xE3, 0xCE, 0xBD, 0x59 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x9C, 0x77, 0xF6, 0xF4, 0xA2, 0x36, 0x37, 0xBC ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_1_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xDD, 0x42, 0xA2, 0x95, 0xEA, 0x3B, 0xE8, 0x1F ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xEE, 0xEC, 0x47, 0x9A, 0xCC, 0x1A, 0x77, 0x8C ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x81, 0x0D, 0x2B, 0x6A, 0xBE, 0x65, 0x51, 0x62 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x56, 0x0C, 0x2A, 0xA8, 0x7C, 0x30, 0x3C, 0xD7 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_1_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xDA, 0x65, 0xF5, 0xFD, 0x92, 0x8D, 0x68, 0x38 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x7E, 0x4E, 0x24, 0x85, 0xDE, 0x1D, 0xDA, 0x12 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x55, 0x4C, 0x9D, 0x5F, 0xC7, 0x91, 0xA1, 0xB6 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x59, 0xC7, 0xB1, 0x4C, 0x2B, 0xBF, 0xE7, 0x0D ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_2_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x29, 0x10, 0x00, 0x45, 0x54, 0xF3, 0x59, 0xAE ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x51, 0xBB, 0x3F, 0x48, 0x96, 0xE2, 0xBF, 0xB6 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xDC, 0x9E, 0x52, 0x19, 0x8E, 0x1B, 0x95, 0x41 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x7F, 0xDE, 0xB1, 0x1E, 0x24, 0xE8, 0xF1, 0xDF ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_2_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x35, 0x05, 0x01, 0x27, 0x88, 0xC6, 0x71, 0x85 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA3, 0x9C, 0x9E, 0xDE, 0xE6, 0x12, 0x43, 0x9D ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x73, 0x98, 0x5D, 0x7C, 0xC7, 0x89, 0x42, 0x05 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA2, 0xFD, 0xFD, 0x13, 0xFC, 0x27, 0xFB, 0x3D ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_3_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x72, 0x32, 0xA7, 0x8F, 0xCF, 0x87, 0x85, 0xAF ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x40, 0xDE, 0x3A, 0x06, 0x26, 0xC9, 0xEC, 0xA8 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xF6, 0xE5, 0x4D, 0xB7, 0xD1, 0x66, 0xD9, 0x96 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x2C, 0x1A, 0xFE, 0x4D, 0x34, 0x8B, 0x34, 0xC5 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_3_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x16, 0xE1, 0x6C, 0x68, 0xDB, 0x0D, 0xA3, 0xB0 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x15, 0x93, 0x76, 0x6B, 0x32, 0x4F, 0xF8, 0x2B ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x80, 0x83, 0xB6, 0xB5, 0x22, 0xC7, 0xF6, 0xE8 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xCC, 0xB4, 0xFD, 0x2E, 0xF6, 0xD3, 0x9F, 0xAA ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_4_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x26, 0x06, 0xC8, 0x02, 0x98, 0x20, 0x2A, 0xA9 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xEB, 0x56, 0x75, 0xB9, 0x4B, 0xDC, 0x21, 0xA6 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xAE, 0x09, 0x43, 0x37, 0x41, 0x74, 0x13, 0x0C ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x1C, 0x69, 0x77, 0xEC, 0xEC, 0xC5, 0x02, 0x43 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_4_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x9D, 0xDB, 0x76, 0x42, 0x4A, 0x60, 0x5A, 0x21 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xBB, 0xDD, 0x0A, 0x36, 0x05, 0x36, 0xB8, 0xB2 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xCB, 0x97, 0xF0, 0x41, 0x09, 0xD2, 0xF4, 0xB7 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA2, 0xAF, 0x18, 0xF6, 0xD9, 0xA3, 0x41, 0x2E ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_5_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x89, 0x17, 0xF1, 0x25, 0x3E, 0xB6, 0xFA, 0x26 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC2, 0x9D, 0x85, 0x38, 0x23, 0xE7, 0xE0, 0x9D ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xCF, 0xCA, 0x7B, 0xF9, 0xD2, 0xAC, 0x4D, 0x5F ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xB2, 0xEF, 0x56, 0x97, 0x61, 0xA4, 0x9A, 0x0A ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_5_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x6E, 0x06, 0xF1, 0x29, 0x69, 0xE6, 0xCD, 0xC8 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x2E, 0x17, 0x4B, 0x07, 0x30, 0xFD, 0xAB, 0x54 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x08, 0x95, 0x43, 0xEC, 0x01, 0x47, 0xCF, 0x81 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x9A, 0x8A, 0x4A, 0x2C, 0xF0, 0xA4, 0xC9, 0x2F ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_6_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xDC, 0x71, 0xF5, 0x6A, 0xB1, 0x04, 0x23, 0x1C ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE9, 0xDF, 0x9D, 0x20, 0x1A, 0xAC, 0x3D, 0x6F ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x41, 0x59, 0xC5, 0xF7, 0xEF, 0xA5, 0xA2, 0x07 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x4B, 0xCE, 0xF2, 0xFA, 0x6E, 0x14, 0xA7, 0x55 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_6_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x27, 0xE6, 0x3E, 0x7D, 0x5F, 0xBA, 0x09, 0x71 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x95, 0x80, 0xE8, 0x12, 0x05, 0xB6, 0xDB, 0xC8 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xF2, 0x8C, 0xF3, 0x7E, 0x0A, 0x68, 0xB2, 0x63 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x7E, 0x0F, 0x53, 0x9E, 0x15, 0x28, 0x11, 0x51 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_7_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xCF, 0xE4, 0x2E, 0x34, 0xAA, 0x4E, 0x42, 0xB7 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xCF, 0x4A, 0x64, 0x7E, 0x98, 0xD9, 0x42, 0xB3 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x17, 0xF1, 0x67, 0x5D, 0xD4, 0x31, 0xC7, 0x5C ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x5F, 0x9C, 0x80, 0xBF, 0x98, 0x08, 0xC5, 0xD5 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_7_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x16, 0x3C, 0x4A, 0x31, 0xD1, 0x19, 0xCB, 0xF1 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC8, 0x4D, 0xB0, 0x64, 0xDE, 0x46, 0xE3, 0x49 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xBC, 0x30, 0x3D, 0x78, 0xD6, 0xD3, 0xA0, 0x43 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xB5, 0x28, 0x00, 0x8C, 0x51, 0x52, 0x58, 0x9A ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_8_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xD7, 0xE4, 0x37, 0x09, 0x04, 0x81, 0x15, 0x26 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC6, 0x3D, 0xAE, 0x5E, 0xB8, 0x06, 0xC3, 0xA5 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xF2, 0xC9, 0x1A, 0xDA, 0x03, 0xE7, 0x00, 0x91 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x25, 0x3C, 0xAE, 0x52, 0x34, 0xBE, 0xB0, 0xEE ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_8_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xD2, 0x7C, 0x03, 0xCD, 0xCB, 0x27, 0x28, 0xAF ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x8E, 0xAB, 0x12, 0xB2, 0x00, 0xCC, 0xAD, 0x43 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x82, 0x62, 0x80, 0xE8, 0xFB, 0x88, 0x7D, 0x85 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xCF, 0xFF, 0xBC, 0x5D, 0x7C, 0xC8, 0xB1, 0xBC ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_9_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xD3, 0xCB, 0xDC, 0xE9, 0x8B, 0x0C, 0x9E, 0xBF ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x46, 0x47, 0x63, 0x4E, 0x25, 0x6C, 0x73, 0x5E ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xEA, 0x72, 0x77, 0xAC, 0x0A, 0x8C, 0x03, 0x4C ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x6E, 0xEF, 0x4B, 0xB4, 0xD6, 0x09, 0xFC, 0xFE ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_9_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC8, 0x10, 0xBE, 0x34, 0xC3, 0x7F, 0x05, 0x51 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x70, 0x69, 0x15, 0x89, 0x3D, 0xCF, 0xFA, 0x74 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x3D, 0x0B, 0x2F, 0x35, 0x3A, 0x4E, 0xE7, 0xFD ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x76, 0xA6, 0x47, 0x01, 0x42, 0x27, 0x89, 0x43 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_10_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x40, 0x05, 0xFB, 0x17, 0x39, 0xEA, 0x4C, 0xB3 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x38, 0xFB, 0xE0, 0x31, 0x7E, 0x58, 0x11, 0xF7 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xEC, 0x62, 0x78, 0x15, 0xB0, 0x46, 0x22, 0x1B ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA5, 0x45, 0xC9, 0x0C, 0x94, 0xF4, 0x3F, 0x13 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_10_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x97, 0x58, 0x40, 0x52, 0x96, 0xA1, 0xB5, 0xA7 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x10, 0xB9, 0xF5, 0x6F, 0xFF, 0x5D, 0xD5, 0x71 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE7, 0x11, 0x96, 0xF0, 0x38, 0x8A, 0x18, 0xF4 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x62, 0xD7, 0x9E, 0x63, 0x02, 0x10, 0xEB, 0xA9 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_11_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x15, 0xC5, 0xED, 0x5A, 0xC3, 0x65, 0x61, 0x9B ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x9A, 0x3A, 0x9C, 0xAD, 0x5E, 0x59, 0xD1, 0x74 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xB1, 0x92, 0x04, 0xD9, 0x24, 0x58, 0xF5, 0xC0 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE0, 0xEE, 0xAE, 0xD1, 0x3D, 0x08, 0xA8, 0xB7 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_11_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x79, 0x16, 0x5E, 0x1A, 0x27, 0x47, 0xA5, 0x72 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA6, 0x71, 0xFD, 0x3C, 0x8B, 0x7A, 0xED, 0xC5 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xB0, 0xA6, 0x49, 0x2B, 0xC5, 0x30, 0xB6, 0xDE ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x2F, 0x19, 0x99, 0x7D, 0xF3, 0xDA, 0x2F, 0x39 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_12_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x4F, 0xF5, 0xA0, 0x08, 0x02, 0x1B, 0xF0, 0x7D ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE1, 0x10, 0xD3, 0x71, 0xC8, 0x5B, 0x51, 0x0D ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE3, 0x45, 0xA9, 0x3B, 0x50, 0x2C, 0x93, 0x51 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x1A, 0xEF, 0x6C, 0xB5, 0x95, 0x00, 0x6F, 0x62 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_12_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x14, 0xAA, 0x3E, 0x30, 0xF0, 0x0B, 0x5F, 0x99 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x98, 0xA4, 0x9B, 0xF9, 0x59, 0x85, 0xAC, 0x20 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC0, 0x71, 0x6E, 0x7E, 0x94, 0xD7, 0x31, 0x67 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE5, 0xBE, 0x47, 0x14, 0x13, 0x68, 0xCF, 0x7D ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_13_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xE9, 0xF5, 0x5D, 0x18, 0xEA, 0x45, 0x98, 0x5D ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xD9, 0x00, 0x28, 0xCC, 0x4A, 0xCC, 0xFB, 0x5D ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA9, 0x66, 0x35, 0xC8, 0xE4, 0x5A, 0x0D, 0x09 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xEF, 0x1E, 0x71, 0x22, 0x36, 0x86, 0x30, 0x39 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_13_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x62, 0x20, 0xF9, 0x6B, 0x4B, 0xF3, 0x52, 0xFD ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xDB, 0x8B, 0xA8, 0x89, 0x60, 0x19, 0xE1, 0x3E ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xAA, 0x0C, 0xFF, 0x0E, 0xC9, 0x78, 0x83, 0x40 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x0D, 0x07, 0x4F, 0xF8, 0x93, 0xFB, 0xBC, 0x19 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_14_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x24, 0x53, 0x7F, 0x57, 0x83, 0x72, 0x3B, 0x01 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xD9, 0x53, 0x3D, 0xBB, 0xF0, 0xB5, 0x10, 0x86 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x68, 0x05, 0xA2, 0x68, 0x28, 0xFB, 0xE0, 0x26 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xBE, 0x3A, 0x74, 0x63, 0x62, 0x10, 0x8B, 0x81 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_14_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA6, 0x53, 0x14, 0x64, 0x4F, 0x94, 0x44, 0x47 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x06, 0x17, 0xB5, 0xDA, 0xD3, 0xD7, 0x4F, 0x01 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x74, 0x46, 0x50, 0xE6, 0x07, 0x21, 0x7B, 0xC5 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xF2, 0xE0, 0x37, 0x6D, 0x85, 0x46, 0x7F, 0xF1 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_15_X[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xD5, 0xF2, 0x1C, 0xDF, 0x44, 0x5B, 0x6F, 0x40 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC8, 0x46, 0xE6, 0x82, 0x42, 0x0C, 0x4B, 0x8E ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xEC, 0x16, 0x7B, 0xEF, 0xE5, 0x21, 0x32, 0x89 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x3F, 0xE9, 0x76, 0xAE, 0xBE, 0x89, 0x23, 0x28 ),
+};
+static const mbedtls_mpi_uint sm2p256v1_T_15_Y[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8( 0x06, 0xA4, 0x0C, 0x1D, 0xBC, 0xFD, 0x23, 0xCC ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xA8, 0xB4, 0xDF, 0x0A, 0x35, 0xE9, 0xC7, 0x1C ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xC9, 0xEA, 0x09, 0x3C, 0x81, 0x24, 0x4F, 0xE1 ),
+    MBEDTLS_BYTES_TO_T_UINT_8( 0xB7, 0x14, 0x0E, 0x71, 0xEA, 0x2E, 0x03, 0xC9 ),
+};
+static const mbedtls_ecp_point sm2p256v1_T[16] = {
+    ECP_POINT_INIT_XY_Z1(sm2p256v1_T_0_X, sm2p256v1_T_0_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_1_X, sm2p256v1_T_1_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_2_X, sm2p256v1_T_2_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_3_X, sm2p256v1_T_3_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_4_X, sm2p256v1_T_4_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_5_X, sm2p256v1_T_5_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_6_X, sm2p256v1_T_6_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_7_X, sm2p256v1_T_7_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_8_X, sm2p256v1_T_8_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_9_X, sm2p256v1_T_9_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_10_X, sm2p256v1_T_10_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_11_X, sm2p256v1_T_11_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_12_X, sm2p256v1_T_12_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_13_X, sm2p256v1_T_13_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_14_X, sm2p256v1_T_14_Y),
+    ECP_POINT_INIT_XY_Z0(sm2p256v1_T_15_X, sm2p256v1_T_15_Y),
+};
+#else
+#define sm2p256v1_T NULL
+#endif
+#endif /* MBEDTLS_ECP_DP_SM2P256V1_ENABLED */
+
 #if defined(ECP_LOAD_GROUP)
 /*
  * Create an MPI from embedded constants
@@ -4565,8 +4814,17 @@ static int ecp_mod_p521(mbedtls_mpi *);
 #endif
 
 #define NIST_MODP(P)      grp->modp = ecp_mod_ ## P;
+
+#if defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED) && defined(MBEDTLS_ECP_SM2P256_OPTIM)
+static int ecp_mod_sm2p256( mbedtls_mpi * );
+#define SM2P256_MODP        grp->modp = ecp_mod_sm2p256;
+#else
+#define SM2P256_MODP
+#endif /* MBEDTLS_ECP_DP_SM2P256V1_ENABLED && MBEDTLS_ECP_SM2P256_OPTIM */
+
 #else
 #define NIST_MODP(P)
+#define SM2P256_MODP
 #endif /* MBEDTLS_ECP_NIST_OPTIM */
 
 /* Additional forward declarations */
@@ -4798,6 +5056,12 @@ int mbedtls_ecp_group_load(mbedtls_ecp_group *grp, mbedtls_ecp_group_id id)
             return ecp_use_curve448(grp);
 #endif /* MBEDTLS_ECP_DP_CURVE448_ENABLED */
 
+#if defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED)
+        case MBEDTLS_ECP_DP_SM2P256V1:
+            SM2P256_MODP;
+            return( LOAD_GROUP( sm2p256v1 ) );
+#endif /* MBEDTLS_ECP_DP_SM2P256V1_ENABLED */
+
         default:
             grp->id = MBEDTLS_ECP_DP_NONE;
             return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
@@ -4888,7 +5152,8 @@ cleanup:
 
 #if defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED) ||   \
     defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) ||   \
-    defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED)
+    defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED) ||   \
+    defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED)
 /*
  * The reader is advised to first understand ecp_mod_p192() since the same
  * general structure is used here, but with additional complications:
@@ -5115,6 +5380,56 @@ cleanup:
 }
 #endif /* MBEDTLS_ECP_DP_SECP384R1_ENABLED */
 
+#if defined(MBEDTLS_ECP_DP_SM2P256V1_ENABLED) && defined(MBEDTLS_ECP_SM2P256_OPTIM)
+/**
+ * A0 = A0 + A8 + A9 + A10 + A11 + A12 + 2*A13 + 2*A14 + 2*A15
+ *
+ * A1 = A1 + A9 + A10 + A11 + A12 + A13 + 2*A14 + 2*A15
+ *
+ * A2 = A2 - A8 - A9 - A13 - A14
+ *
+ * A3 = A3 + A8 + A11 + A12 + 2*A13 + A14 + A15
+ *
+ * A4 = A4 + A9 + A12 + A13 + 2*A14 + A15
+ *
+ * A5 = A5 + A10 + A13 + A14 + 2*A15
+ *
+ * A6 = A6 + A11 + A14 + A15
+ *
+ * A7 = A7 + A8 + A9 + A10 + A11 + 2*A12 + 2*A13 + 2*A14 + 3*A15
+ */
+static int ecp_mod_sm2p256( mbedtls_mpi *N )
+{
+    INIT( 256 );
+
+    ADD(  8 ); ADD(  9 ); ADD( 10 ); ADD( 11 );
+    ADD( 12 ); ADD( 13 ); ADD( 13 ); ADD( 14 );
+    ADD( 14 ); ADD( 15 ); ADD( 15 );                        NEXT; // A0
+
+    ADD(  9 ); ADD( 10 ); ADD( 11 ); ADD( 12 ); ADD( 13 );
+    ADD( 14 ); ADD( 14 ); ADD( 15 ); ADD( 15 );             NEXT; // A1
+
+    SUB(  8 ); SUB(  9 ); SUB( 13 ); SUB( 14 );             NEXT; // A2
+
+    ADD(  8 ); ADD( 11 ); ADD( 12 ); ADD( 13 ); ADD( 13 );
+    ADD( 14 ); ADD( 15 );                                   NEXT; // A3
+
+    ADD(  9 ); ADD( 12 ); ADD( 13 ); ADD( 14 ); ADD( 14 );
+    ADD( 15 );                                              NEXT; // A4
+
+    ADD( 10 ); ADD( 13 ); ADD( 14 ); ADD( 15 ); ADD( 15 );  NEXT; // A5
+
+    ADD( 11 ); ADD( 14 ); ADD( 15 );                        NEXT; // A6
+
+    ADD(  8 ); ADD(  9 ); ADD( 10 ); ADD( 11 ); ADD( 12 );
+    ADD( 12 ); ADD( 13 ); ADD( 13 ); ADD( 14 ); ADD( 14 );
+    ADD( 15 ); ADD( 15 ); ADD( 15 );                        LAST; // A7
+
+cleanup:
+    return( ret );
+}
+#endif /* MBEDTLS_ECP_DP_SM2P256V1_ENABLED */
+
 #undef A
 #undef LOAD32
 #undef STORE32
@@ -5125,7 +5440,8 @@ cleanup:
 
 #endif /* MBEDTLS_ECP_DP_SECP224R1_ENABLED ||
           MBEDTLS_ECP_DP_SECP256R1_ENABLED ||
-          MBEDTLS_ECP_DP_SECP384R1_ENABLED */
+          MBEDTLS_ECP_DP_SECP384R1_ENABLED ||
+          MBEDTLS_ECP_DP_SM2P256V1_ENABLED */
 
 #if defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED)
 /*
diff --git a/library/error.c b/library/error.c
index 84b637a..ef8faeb 100644
--- a/library/error.c
+++ b/library/error.c
@@ -38,6 +38,10 @@
 #include "mbedtls/bignum.h"
 #endif
 
+#if defined(MBEDTLS_BLOWFISH_C)
+#include "mbedtls/blowfish.h"
+#endif
+
 #if defined(MBEDTLS_CAMELLIA_C)
 #include "mbedtls/camellia.h"
 #endif
@@ -604,6 +608,13 @@ const char *mbedtls_low_level_strerr(int error_code)
             return( "BIGNUM - Memory allocation failed" );
 #endif /* MBEDTLS_BIGNUM_C */
 
+#if defined(MBEDTLS_BLOWFISH_C)
+        case -(MBEDTLS_ERR_BLOWFISH_BAD_INPUT_DATA):
+            return( "BLOWFISH - Bad input data" );
+        case -(MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH):
+            return( "BLOWFISH - Invalid data input length" );
+#endif /* MBEDTLS_BLOWFISH_C */
+
 #if defined(MBEDTLS_CAMELLIA_C)
         case -(MBEDTLS_ERR_CAMELLIA_BAD_INPUT_DATA):
             return( "CAMELLIA - Bad input data" );
diff --git a/library/hw_aescrypt2.c b/library/hw_aescrypt2.c
new file mode 100644
index 0000000..d41b74b
--- /dev/null
+++ b/library/hw_aescrypt2.c
@@ -0,0 +1,404 @@
+/*
+ *  \brief  AES-256 file encryption program.
+ *
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#include "common.h"
+
+#if defined(HUAWEI_ONT_AESCRYPT2_API_C)
+
+/* Enable definition of fileno() even when compiling with -std=c99. Must be
+ * set before mbedtls_config.h, which pulls in glibc's features.h indirectly.
+ * Harmless on other platforms. */
+#define _POSIX_C_SOURCE 200112L
+
+#include "mbedtls/build_info.h"
+
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#define mbedtls_fprintf         fprintf
+#define mbedtls_printf          printf
+#define mbedtls_exit            exit
+#define MBEDTLS_EXIT_SUCCESS    EXIT_SUCCESS
+#define MBEDTLS_EXIT_FAILURE    EXIT_FAILURE
+#endif /* MBEDTLS_PLATFORM_C */
+
+#include "mbedtls/aes.h"
+#include "mbedtls/md.h"
+#include "mbedtls/platform_util.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if defined(_WIN32)
+#include <windows.h>
+#if !defined(_WIN32_WCE)
+#include <io.h>
+#endif
+#else
+#include <sys/types.h>
+#include <unistd.h>
+#endif
+
+#define MODE_ENCRYPT    0
+#define MODE_DECRYPT    1
+
+#define USAGE   \
+    "\n  aescrypt2 <mode> <input filename> <output filename> <key>\n" \
+    "\n   <mode>: 0 = encrypt, 1 = decrypt\n" \
+    "\n  example: aescrypt2 0 file file.aes hex:E76B2413958B00E193\n" \
+    "\n"
+
+#if !defined(MBEDTLS_AES_C) || !defined(MBEDTLS_SHA256_C) || \
+    !defined(MBEDTLS_FS_IO) || !defined(MBEDTLS_MD_C)
+int mbedtls_aescrypt2( int mode, const char *filein, const char *fileout, unsigned char *key, size_t keylen )
+{
+    mbedtls_printf("MBEDTLS_AES_C and/or MBEDTLS_SHA256_C "
+                    "and/or MBEDTLS_FS_IO and/or MBEDTLS_MD_C "
+                    "not defined.\n");
+    mbedtls_exit( 0 );
+}
+#else
+int mbedtls_aescrypt2( int mode, const char *filein, const char *fileout, unsigned char *key, size_t keylen )
+{
+    int ret = 0;
+    int exit_code = MBEDTLS_EXIT_FAILURE;
+
+    unsigned int i, n;
+    int lastn;
+    FILE *fin = NULL, *fout = NULL;
+
+    const char *p;
+
+    unsigned char IV[16];
+    unsigned char tmp[16];
+    unsigned char digest[32];
+    unsigned char buffer[1024];
+    unsigned char diff;
+
+    mbedtls_aes_context aes_ctx;
+    mbedtls_md_context_t sha_ctx;
+
+#if defined(_WIN32_WCE)
+    long filesize, offset;
+#elif defined(_WIN32)
+       LARGE_INTEGER li_size;
+    __int64 filesize, offset;
+#else
+      off_t filesize, offset;
+#endif
+
+    mbedtls_aes_init( &aes_ctx );
+    mbedtls_md_init( &sha_ctx );
+
+    ret = mbedtls_md_setup( &sha_ctx, mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 ), 1 );
+    if( ret != 0 )
+    {
+        mbedtls_printf( "  ! mbedtls_md_setup() returned -0x%04x\n", -ret );
+        goto exit;
+    }
+
+    memset( IV,     0, sizeof( IV ) );
+    memset( digest, 0, sizeof( digest ) );
+    memset( buffer, 0, sizeof( buffer ) );
+
+    if( mode != MODE_ENCRYPT && mode != MODE_DECRYPT )
+    {
+        mbedtls_fprintf( stderr, "invalide operation mode\n" );
+        goto exit;
+    }
+
+    if( ( fin = fopen( filein, "rb" ) ) == NULL )
+    {
+        mbedtls_fprintf( stderr, "fopen(%s,rb) failed\n", filein );
+        goto exit;
+    }
+
+    if( ( fout = fopen( fileout, "wb+" ) ) == NULL )
+    {
+        mbedtls_fprintf( stderr, "fopen(%s,wb+) failed\n", fileout );
+        goto exit;
+    }
+
+#if defined(_WIN32_WCE)
+    filesize = fseek( fin, 0L, SEEK_END );
+#else
+#if defined(_WIN32)
+    /*
+     * Support large files (> 2Gb) on Win32
+     */
+    li_size.QuadPart = 0;
+    li_size.LowPart  =
+        SetFilePointer( (HANDLE) _get_osfhandle( _fileno( fin ) ),
+                        li_size.LowPart, &li_size.HighPart, FILE_END );
+
+    if( li_size.LowPart == 0xFFFFFFFF && GetLastError() != NO_ERROR )
+    {
+        mbedtls_fprintf( stderr, "SetFilePointer(0,FILE_END) failed\n" );
+        goto exit;
+    }
+
+    filesize = li_size.QuadPart;
+#else
+    if( ( filesize = lseek( fileno( fin ), 0, SEEK_END ) ) < 0 )
+    {
+        perror( "lseek" );
+        goto exit;
+    }
+#endif
+#endif
+
+    if( fseek( fin, 0, SEEK_SET ) < 0 )
+    {
+        mbedtls_fprintf( stderr, "fseek(0,SEEK_SET) failed\n" );
+        goto exit;
+    }
+
+    if( mode == MODE_ENCRYPT )
+    {
+        /*
+         * Generate the initialization vector as:
+         * IV = SHA-256( filesize || filename )[0..15]
+         */
+        for( i = 0; i < 8; i++ )
+            buffer[i] = (unsigned char)( filesize >> ( i << 3 ) );
+
+        p = filein;
+
+        mbedtls_md_starts( &sha_ctx );
+        mbedtls_md_update( &sha_ctx, buffer, 8 );
+        mbedtls_md_update( &sha_ctx, (unsigned char *) p, strlen( p ) );
+        mbedtls_md_finish( &sha_ctx, digest );
+
+        memcpy( IV, digest, 16 );
+
+        /*
+         * The last four bits in the IV are actually used
+         * to store the file size modulo the AES block size.
+         */
+        lastn = (int)( filesize & 0x0F );
+
+        IV[15] = (unsigned char)
+            ( ( IV[15] & 0xF0 ) | lastn );
+
+        /*
+         * Append the IV at the beginning of the output.
+         */
+        if( fwrite( IV, 1, 16, fout ) != 16 )
+        {
+            mbedtls_fprintf( stderr, "fwrite(%d bytes) failed\n", 16 );
+            goto exit;
+        }
+
+        /*
+         * Hash the IV and the secret key together 8192 times
+         * using the result to setup the AES context and HMAC.
+         */
+        memset( digest, 0,  32 );
+        memcpy( digest, IV, 16 );
+
+        for( i = 0; i < 8192; i++ )
+        {
+            mbedtls_md_starts( &sha_ctx );
+            mbedtls_md_update( &sha_ctx, digest, 32 );
+            mbedtls_md_update( &sha_ctx, key, keylen );
+            mbedtls_md_finish( &sha_ctx, digest );
+        }
+
+        mbedtls_aes_setkey_enc( &aes_ctx, digest, 256 );
+        mbedtls_md_hmac_starts( &sha_ctx, digest, 32 );
+
+        /*
+         * Encrypt and write the ciphertext.
+         */
+        for( offset = 0; offset < filesize; offset += 16 )
+        {
+            n = ( filesize - offset > 16 ) ? 16 : (int)
+                ( filesize - offset );
+
+            if( fread( buffer, 1, n, fin ) != (size_t) n )
+            {
+                mbedtls_fprintf( stderr, "fread(%d bytes) failed\n", n );
+                goto exit;
+            }
+
+            for( i = 0; i < 16; i++ )
+                buffer[i] = (unsigned char)( buffer[i] ^ IV[i] );
+
+            mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_ENCRYPT, buffer, buffer );
+            mbedtls_md_hmac_update( &sha_ctx, buffer, 16 );
+
+            if( fwrite( buffer, 1, 16, fout ) != 16 )
+            {
+                mbedtls_fprintf( stderr, "fwrite(%d bytes) failed\n", 16 );
+                goto exit;
+            }
+
+            memcpy( IV, buffer, 16 );
+        }
+
+        /*
+         * Finally write the HMAC.
+         */
+        mbedtls_md_hmac_finish( &sha_ctx, digest );
+
+        if( fwrite( digest, 1, 32, fout ) != 32 )
+        {
+            mbedtls_fprintf( stderr, "fwrite(%d bytes) failed\n", 16 );
+            goto exit;
+        }
+    }
+
+    if( mode == MODE_DECRYPT )
+    {
+        /*
+         *  The encrypted file must be structured as follows:
+         *
+         *        00 .. 15              Initialization Vector
+         *        16 .. 31              AES Encrypted Block #1
+         *           ..
+         *      N*16 .. (N+1)*16 - 1    AES Encrypted Block #N
+         *  (N+1)*16 .. (N+1)*16 + 32   HMAC-SHA-256(ciphertext)
+         */
+        if( filesize < 48 )
+        {
+            mbedtls_fprintf( stderr, "File too short to be encrypted.\n" );
+            goto exit;
+        }
+
+        if( ( filesize & 0x0F ) != 0 )
+        {
+            mbedtls_fprintf( stderr, "File size not a multiple of 16.\n" );
+            goto exit;
+        }
+
+        /*
+         * Subtract the IV + HMAC length.
+         */
+        filesize -= ( 16 + 32 );
+
+        /*
+         * Read the IV and original filesize modulo 16.
+         */
+        if( fread( buffer, 1, 16, fin ) != 16 )
+        {
+            mbedtls_fprintf( stderr, "fread(%d bytes) failed\n", 16 );
+            goto exit;
+        }
+
+        memcpy( IV, buffer, 16 );
+        lastn = IV[15] & 0x0F;
+
+        /*
+         * Hash the IV and the secret key together 8192 times
+         * using the result to setup the AES context and HMAC.
+         */
+        memset( digest, 0,  32 );
+        memcpy( digest, IV, 16 );
+
+        for( i = 0; i < 8192; i++ )
+        {
+            mbedtls_md_starts( &sha_ctx );
+            mbedtls_md_update( &sha_ctx, digest, 32 );
+            mbedtls_md_update( &sha_ctx, key, keylen );
+            mbedtls_md_finish( &sha_ctx, digest );
+        }
+
+        mbedtls_aes_setkey_dec( &aes_ctx, digest, 256 );
+        mbedtls_md_hmac_starts( &sha_ctx, digest, 32 );
+
+        /*
+         * Decrypt and write the plaintext.
+         */
+        for( offset = 0; offset < filesize; offset += 16 )
+        {
+            if( fread( buffer, 1, 16, fin ) != 16 )
+            {
+                mbedtls_fprintf( stderr, "fread(%d bytes) failed\n", 16 );
+                goto exit;
+            }
+
+            memcpy( tmp, buffer, 16 );
+
+            mbedtls_md_hmac_update( &sha_ctx, buffer, 16 );
+            mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_DECRYPT, buffer, buffer );
+
+            for( i = 0; i < 16; i++ )
+                buffer[i] = (unsigned char)( buffer[i] ^ IV[i] );
+
+            memcpy( IV, tmp, 16 );
+
+            n = ( lastn > 0 && offset == filesize - 16 )
+                ? lastn : 16;
+
+            if( fwrite( buffer, 1, n, fout ) != (size_t) n )
+            {
+                mbedtls_fprintf( stderr, "fwrite(%d bytes) failed\n", n );
+                goto exit;
+            }
+        }
+
+        /*
+         * Verify the message authentication code.
+         */
+        mbedtls_md_hmac_finish( &sha_ctx, digest );
+
+        if( fread( buffer, 1, 32, fin ) != 32 )
+        {
+            mbedtls_fprintf( stderr, "fread(%d bytes) failed\n", 32 );
+            goto exit;
+        }
+
+        /* Use constant-time buffer comparison */
+        diff = 0;
+        for( i = 0; i < 32; i++ )
+            diff |= digest[i] ^ buffer[i];
+
+        if( diff != 0 )
+        {
+            mbedtls_fprintf( stderr, "HMAC check failed: wrong key, "
+                             "or file corrupted.\n" );
+            goto exit;
+        }
+    }
+
+    exit_code = MBEDTLS_EXIT_SUCCESS;
+
+exit:
+    if( fin )
+        fclose( fin );
+    if( fout )
+        fclose( fout );
+
+    mbedtls_platform_zeroize( IV,     sizeof( IV ) );
+    mbedtls_platform_zeroize( tmp,    sizeof( tmp ) );
+    mbedtls_platform_zeroize( buffer, sizeof( buffer ) );
+    mbedtls_platform_zeroize( digest, sizeof( digest ) );
+
+    mbedtls_aes_free( &aes_ctx );
+    mbedtls_md_free( &sha_ctx );
+
+    return exit_code;
+}
+#endif /* MBEDTLS_AES_C && MBEDTLS_SHA256_C && MBEDTLS_FS_IO */
+
+#endif  //#if defined(HUAWEI_ONT_AESCRYPT2_API_C)
+
diff --git a/library/hw_mbedtls_config.c b/library/hw_mbedtls_config.c
new file mode 100644
index 0000000..bfaa363
--- /dev/null
+++ b/library/hw_mbedtls_config.c
@@ -0,0 +1,56 @@
+/*
+ * 版权所有 (c) 华为技术有限公司 2014-2022
+ * 生成日期: 2022年7月25日
+ * 功能描述: 在mbedtls库中，增加一个动态配置的能力。
+ * 提供一个初始化API，如果产品需要修改默认的配置，则通过重载相关API处理。
+ * 
+ */
+#include "common.h"
+
+#if defined(HUAWEI_CUSTOMIZE_CONFIGS_C)
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "mbedtls/hw_mbedtls_config.h"
+
+/*****************************************************************************
+ * \brief mbedtls华为定制特性，支持一些特性的动态修改与调整。
+ * 默认所有的特性按mbedtls官方的能力处理。
+******************************************************************************/
+HW_MBEDTLS_CONFIG_TYPES g_mbedtls_configs[HW_MBEDTLS_CONFIG_BUTT] = {HW_MBEDTLS_CONFIG_DISABLE};
+
+/*****************************************************************************
+ * \brief 配置mbedtls动态开关。
+ * 
+ * \param type 需要修改的特性名。
+ * \param value 0表示关闭此特性，非0表示打开此特性。
+ * \return int 0表示设置成功，非0表示设置失败。
+ * 产品在使用mbedtls库时，需要根据业务诉求，修改一些默认配置。
+******************************************************************************/
+int hw_mbedtls_set_config(HW_MBEDTLS_CONFIG_TYPES type, int value)
+{
+    if ((type <= HW_MBEDTLS_CONFIG_NONE) || (type >= HW_MBEDTLS_CONFIG_BUTT)){
+        /* 错误的特性类型 */
+        return -1;
+    }
+    g_mbedtls_configs[type] = (value == 0 ? HW_MBEDTLS_CONFIG_DISABLE : HW_MBEDTLS_CONFIG_ENABLE);
+    return 0;
+}
+
+/*****************************************************************************
+ * \brief 获取mbedtls定制特性的动态值。
+ * 
+ * \param type 需要查询的特性名。
+ * \return int 返回此特性的值：0表示没有开启；1表示开启；-1表示处理错误，未知状态。
+******************************************************************************/
+int hw_mbedtls_get_config(HW_MBEDTLS_CONFIG_TYPES type)
+{
+    if ((type <= HW_MBEDTLS_CONFIG_NONE) || (type >= HW_MBEDTLS_CONFIG_BUTT)){
+        /* 错误的特性类型 */
+        return -1;
+    }    
+    return g_mbedtls_configs[type];
+}
+
+#endif
diff --git a/library/hw_polarssl_api.c b/library/hw_polarssl_api.c
new file mode 100644
index 0000000..1ed9412
--- /dev/null
+++ b/library/hw_polarssl_api.c
@@ -0,0 +1,1530 @@
+/*
+ * 版权所有 (c) 华为技术有限公司 2014-2022
+ * 生成日期: 2022年7月20日
+ * 功能描述: 在mbedtls库中，适配polarssl的API接口。 
+ * 华为家庭网络产品接口适配文件。适配polarssl的API接口。
+ * 使用编译宏HUAWEI_POLARSSL_API_C进行隔离。
+ */
+#include "common.h"
+#if defined(HUAWEI_POLARSSL_API_C)
+#include "mbedtls/x509_crl.h"
+#include "mbedtls/hw_polarssl_api.h"
+#include "mbedtls/debug.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform.h"
+#include "ssl_misc.h"
+#include <stdio.h>
+#include <memory.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+
+#ifndef O_NONBLOCK
+#define O_NONBLOCK        00004000
+#endif
+
+typedef struct {
+    unsigned int versions[4];
+    unsigned int cipher_conf;
+    unsigned int version_conf;
+    unsigned int kex_size_conf;
+    unsigned int new_board_conf;
+} ssl_config_data_s;
+
+/* 配置的版本信息，分别为TLSv1_2 TLSv1_3 */
+static ssl_config_data_s gst_ssl_config = { {1, 1, 1, 1}, 1 , 1, 0, 0 };
+
+mbedtls_ssl_sni sni_use;
+static int g_enable_caupdate = 0;  /* CA证书更新功能的开关 */
+static int g_ignore_checktime = 1;
+static PdtCertTimeCheckFunc g_pdtCertTimeCheckFunc = NULL;
+static PdtCrlTimeCheckFunc g_pdtCrlTimeCheckFunc = NULL;
+
+/* 设置sni */
+int polarssl_ssl_set_sni(mbedtls_ssl_adapt *ssl, const char *hostname)
+{
+    (void)ssl;
+    if (strlen(hostname) >= MAX_SNI_LEN) {
+        return 1;
+    }
+    sni_use.send_sni = 1;
+    strncpy(sni_use.hostname, hostname, sizeof(sni_use.hostname) - 1);
+    return 0;
+}
+
+/* 清理sni */
+static void polarssl_ssl_clear_sni()
+{
+    memset(&sni_use, 0 , sizeof(mbedtls_ssl_sni));
+}
+
+static int ssl_deprecated_cipher_support(void)
+{
+    return gst_ssl_config.cipher_conf;
+}
+
+int ssl_deprecated_kexsize_support(void)
+{
+    return gst_ssl_config.kex_size_conf;
+}
+
+static int ssl_deprecated_newboard_support(void)
+{
+    return gst_ssl_config.new_board_conf;
+}
+
+int ssl_init_version(void)
+{
+    ssl_config_data_s ssl_config = { 0 };
+    FILE *file = fopen("/var/hw_ssl_version", "r");
+    if (file == NULL) {
+        return 0;
+    }
+
+    (void)fread(&ssl_config, sizeof(ssl_config_data_s), 1, file);
+    fclose(file);
+
+    (void)memcpy(&gst_ssl_config, &ssl_config, sizeof(ssl_config));
+
+    return 0;
+}
+
+/* 设置不校验时间标志 */
+int SetIgnoreTime(int value)
+{
+    g_ignore_checktime = value;
+    return 0;
+}
+
+int polarssl_get_checktime(void)
+{
+    /* 如果产品没有通过sntp或者olt完成时间同步，直接返回0认为时间校验通过 */
+    if (access("/var/timesyncflag", F_OK) != 0) {
+        return 0;
+    }
+
+    return 1;
+}
+
+/* 校验证书有效期的回调函数 */
+int polarssl_cert_date_checker(mbedtls_x509_crt *crt)
+{
+    mbedtls_printf( "Use custome CRT time verification callback" );
+
+    if ( polarssl_ischeck_crttime( crt ) == 0 )
+        return 0;
+
+    if( mbedtls_x509_time_is_past( &crt->valid_to ) )
+        return MBEDTLS_X509_BADCERT_EXPIRED;
+
+    if( mbedtls_x509_time_is_future( &crt->valid_from ) )
+        return MBEDTLS_X509_BADCERT_FUTURE;
+
+    return 0;
+}
+
+/* 校验CRL有效期的回调函数 */
+int polarssl_crl_date_checker(mbedtls_x509_crl *crl)
+{
+    mbedtls_printf( "Use custome CRL time verification callback" );
+
+    if ( polarssl_ischeck_crltime( crl ) == 0 )
+        return 0;
+
+    if( mbedtls_x509_time_is_past( &crl->next_update ) )
+        return MBEDTLS_X509_BADCRL_EXPIRED;
+
+    if( mbedtls_x509_time_is_future( &crl->this_update ) )
+        return MBEDTLS_X509_BADCRL_FUTURE;
+
+    return 0;
+}
+
+int SetPdtCertTimeCheckFunc(PdtCertTimeCheckFunc func)
+{
+    g_pdtCertTimeCheckFunc = func;
+    hw_mbedtls_regist_cert_date_chcker( polarssl_cert_date_checker );
+    return 0;
+}
+
+int polarssl_ischeck_crttime(mbedtls_x509_crt *crt)
+{
+    /* 如果没有设置产品决策函数，则默认校验证书时间 */
+    if (g_pdtCertTimeCheckFunc == NULL) {
+        return 1;
+    }
+
+    return g_pdtCertTimeCheckFunc((const mbedtls_x509_crt *)crt);
+}
+
+int SetPdtCrlTimeCheckFunc(PdtCrlTimeCheckFunc func)
+{
+    g_pdtCrlTimeCheckFunc = func;
+    hw_mbedtls_regist_crl_date_chcker( polarssl_crl_date_checker );
+    return 0;
+}
+
+int polarssl_ischeck_crltime(mbedtls_x509_crl *crl)
+{
+    /* 如果没有设置产品决策函数，则默认校验证书吊销文件时间 */
+    if (g_pdtCrlTimeCheckFunc == NULL) {
+        return 1;
+    }
+
+    return g_pdtCrlTimeCheckFunc((const mbedtls_x509_crl *)crl);
+}
+
+/* 安全随机函数 */
+unsigned int get_random()
+{
+    /* 首先从random中获取，若没有就从urandom中获取 */
+    const char *randomPath[] = {
+        "/dev/random",
+        "/dev/urandom"
+    };
+    int randomFlag[] = {
+        O_RDONLY | O_NONBLOCK, /* 对于/dev/random 要设置非阻塞方式 */
+        O_RDONLY /* /dev/urandom 本来就是非阻塞的, 直接读取就行了 */
+    };
+
+    unsigned int random = 0;
+    for (unsigned int loop = 0; loop < 2; loop++) {
+        int fd = open(randomPath[loop], randomFlag[loop], 0);
+        if (fd != -1) {
+            int readBytes = read(fd, (void *)&random, sizeof(unsigned int));
+            close(fd);
+            if (readBytes == (int)sizeof(unsigned int)) {
+                break;
+            }
+        }
+    }
+
+    return random;
+}
+
+/* random函数 */
+static int myrand( void *rng_state, unsigned char *output, size_t len )
+{
+    size_t use_len;
+    int rnd;
+
+    if (rng_state != NULL)
+        rng_state = NULL;
+
+    while (len > 0) {
+        use_len = len;
+        if (use_len > sizeof(int))
+            use_len = sizeof(int);
+
+        rnd = (int)get_random();
+        memcpy(output, &rnd, use_len);
+        output += use_len;
+        len -= use_len;
+    }
+
+    return 0;
+}
+
+/* 设置协商时的算法集合,外部请使用静态变量 */
+void polarssl_ssl_conf_ciphersuites(mbedtls_ssl_config_adapt *conf, const int *ciphersuites)
+{
+    if (conf == NULL || ciphersuites == NULL) {
+        return ;
+    }
+
+    mbedtls_ssl_conf_ciphersuites(conf->config, ciphersuites);
+}
+
+/*
+ * Derive and export the shared secret (G^Y)^X mod P
+ */
+int polarssl_dhm_calc_secret(mbedtls_dhm_context *ctx, unsigned char *output, size_t output_size, unsigned int *olen)
+{
+    return mbedtls_dhm_calc_secret(ctx, output, output_size, (size_t*)olen, myrand, NULL);
+}
+
+/*
+ * Import X from unsigned binary data, big endian
+ */
+int polarssl_mpi_read_binary(mbedtls_mpi *X, const unsigned char *buf, unsigned int buflen)
+{
+    return mbedtls_mpi_read_binary(X, buf, buflen);
+}
+
+/*
+ * Export X into unsigned binary data, big endian
+ */
+int polarssl_mpi_write_binary(const mbedtls_mpi *X, unsigned char *buf, size_t buflen)
+{
+    return mbedtls_mpi_write_binary(X, buf, buflen);
+}
+
+/* setAesKey */
+int polarssl_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *key, unsigned int keybits)
+{
+    return mbedtls_aes_setkey_enc(ctx, key, keybits);
+}
+
+/*
+ * AES-CBC buffer encryption/decryption
+ */
+int polarssl_aes_crypt_cbc(mbedtls_aes_context *ctx, int mode, unsigned int length, unsigned char iv[16],
+                           const unsigned char *input, unsigned char *output)
+{
+
+    return mbedtls_aes_crypt_cbc(ctx,mode,length,iv,input,output);
+}
+
+/* setAesKey */
+int polarssl_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *key, unsigned int keybits)
+{
+
+    return mbedtls_aes_setkey_dec(ctx, key, keybits);
+}
+
+
+/* init the para */
+void polarssl_aes_init(mbedtls_aes_context *ctx)
+{
+    mbedtls_aes_init(ctx);
+}
+
+/*
+ * Create own private value X and export G^X
+ */
+int polarssl_dhm_make_public(mbedtls_dhm_context *ctx, int x_size, unsigned char *output, size_t olen)
+{
+    return mbedtls_dhm_make_public(ctx, x_size, output, olen, myrand, NULL);
+}
+
+/*
+ * Return the total size in bytes
+ */
+size_t polarssl_mpi_size(const mbedtls_mpi *X)
+{
+    return mbedtls_mpi_size(X);
+}
+
+/*
+ * Import from an ASCII string
+ */
+int polarssl_mpi_read_string(mbedtls_mpi *X, int radix, const char *s)
+{
+    return mbedtls_mpi_read_string(X, radix, s);
+}
+
+/* init the dh */
+void polarssl_dhm_init(mbedtls_dhm_context *ctx)
+{
+    mbedtls_dhm_init(ctx);
+}
+
+/*
+ * Free the components of a DHM key
+ */
+void polarssl_dhm_free(mbedtls_dhm_context *ctx)
+{
+    mbedtls_dhm_free(ctx);
+}
+
+/* free pk */
+void polarssl_pk_free(mbedtls_pk_context *ctx)
+{
+    mbedtls_pk_free(ctx);
+}
+
+/* sha512 */
+void polarssl_sha512(const unsigned char *input, size_t ilen, unsigned char output[64], int is384)
+{
+    mbedtls_sha512(input, ilen, output, is384);
+}
+
+
+/* hmac512 */
+int polarssl_md_hmac512(const unsigned char *key, size_t keylen, const unsigned char *input, size_t ilen,
+                        unsigned char *output)
+{
+    return mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA512), key, keylen, input, ilen, output);
+}
+
+/* 通知对端关闭连接 */
+int polarssl_shutdown(mbedtls_ssl_adapt *ssl)
+{
+    if (ssl == NULL) {
+        return -1;
+    }
+    return mbedtls_ssl_close_notify(ssl->ssl);
+}
+
+/* 校验证书日期是否有效 */
+int polarssl_x509_crt_check_date(const char* filename)
+{
+    return mbedtls_x509_crt_check_date(filename);
+}
+
+/* free crt 证书 */
+void polarssl_x509_crt_free(mbedtls_x509_crt *crt)
+{
+    if (crt == NULL) {
+        return ;
+    }
+    mbedtls_x509_crt_free(crt);
+    mbedtls_free(crt);
+    crt = NULL;
+}
+
+/* 获取debug Level等级 */
+static int polarssl_get_debug_level()
+{
+    int debug_level = 0;
+
+    FILE *fp=fopen("/var/ssl_debug_level", "r");
+    if (!fp) {
+        return debug_level;
+    }
+    fscanf(fp, "%d", &debug_level);
+    fclose(fp);
+    
+    return debug_level;
+}
+
+/* SSL accept函数 */
+int polarssl_accept(mbedtls_ssl_adapt *ssl)
+{
+    if (ssl == NULL) {
+        return -1;
+    }
+#if defined(HUAWEI_POLARSSL_API_DEBUG_C)
+    mbedtls_debug_set_threshold(polarssl_get_debug_level());
+#endif
+    return mbedtls_ssl_handshake(ssl->ssl);
+}
+
+/* SSL accept函数 */
+int polarssl_connect(mbedtls_ssl_adapt *ssl)
+{
+    if (ssl == NULL) {
+        return -1;
+    }
+#if defined(HUAWEI_POLARSSL_API_DEBUG_C)
+    mbedtls_debug_set_threshold(polarssl_get_debug_level());
+#endif
+
+    /* 如果使能的缓存恢复缓存 */
+    if (ssl->saved_session != NULL) {
+        mbedtls_ssl_set_session(ssl->ssl, ssl->saved_session);
+    }
+
+    int32_t ret = mbedtls_ssl_handshake(ssl->ssl);
+    if (ret == 0) {
+        /* 成功则记录下缓存 */
+        if (ssl->saved_session != NULL) {
+            mbedtls_ssl_get_session(ssl->ssl, ssl->saved_session);
+        }
+    }
+
+    return ret;
+}
+
+/* SSL free函数 */
+void polarssl_free(mbedtls_ssl_adapt *ssl)
+{
+    if (ssl == NULL) {
+        return;
+    }
+
+    if (ssl->saved_session != NULL) {
+        mbedtls_ssl_session_free(ssl->saved_session);
+        mbedtls_free(ssl->saved_session);
+        ssl->saved_session = NULL;
+    }
+
+
+    mbedtls_ssl_free(ssl->ssl);
+    mbedtls_free(ssl->ssl);
+    ssl->ssl = NULL;
+    mbedtls_free(ssl);
+    ssl = NULL;
+}
+
+/* SSL 配置设置 */
+static int polarssl_ssl_config_defaults(mbedtls_ssl_config *conf, int type)
+{
+  return  mbedtls_ssl_config_defaults(conf, type, MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT);
+}
+
+/* 使能服务端的缓存,失败也不影响功能 */
+void polarssl_enable_server_cache(mbedtls_ssl_config_adapt *conf, uint32_t cache_num, uint32_t timeout)
+{
+    if (conf == NULL || conf->config == NULL) {
+        return;
+    }
+
+    if (conf->cache == NULL) {
+        conf->cache = (mbedtls_ssl_cache_context *)mbedtls_calloc(1, sizeof(mbedtls_ssl_cache_context));
+        if (conf->cache != NULL) {
+            mbedtls_ssl_cache_init(conf->cache);
+            mbedtls_ssl_cache_set_max_entries(conf->cache, cache_num);
+            mbedtls_ssl_cache_set_timeout(conf->cache, timeout);
+            mbedtls_ssl_conf_session_cache(conf->config, conf->cache, mbedtls_ssl_cache_get, mbedtls_ssl_cache_set);
+        }
+    }
+
+}
+
+/* 使能客户端缓存 */
+void polarssl_enable_client_cache(mbedtls_ssl_adapt *ssl)
+{
+    if (ssl->saved_session == NULL) {
+        /* calloc会memset 0 */
+        ssl->saved_session = mbedtls_calloc(1, sizeof(mbedtls_ssl_session));
+    }
+
+}
+
+/* SSL配置变量释放 */
+void polarssl_free_config_adapt(mbedtls_ssl_config_adapt *conf)
+{  
+    if (conf == NULL) {
+        return;
+    }
+
+    if (conf->config != NULL) {
+        if (conf->config->MBEDTLS_PRIVATE(ca_crl) != NULL) {
+            mbedtls_x509_crl_free(conf->config->MBEDTLS_PRIVATE(ca_crl));
+            mbedtls_free(conf->config->MBEDTLS_PRIVATE(ca_crl));
+            conf->config->MBEDTLS_PRIVATE(ca_crl) = NULL;
+        }
+        mbedtls_ssl_config_free(conf->config);
+        mbedtls_free(conf->config);
+        conf->config = NULL;
+    }
+
+    if (conf->entropy != NULL) {
+        mbedtls_entropy_free(conf->entropy);
+        mbedtls_free(conf->entropy);
+        conf->entropy = NULL;
+    }
+
+    if (conf->ctr_drbg != NULL) {
+        mbedtls_ctr_drbg_free(conf->ctr_drbg);
+        mbedtls_free(conf->ctr_drbg);
+        conf->ctr_drbg = NULL;
+    }
+
+    if (conf->prv != NULL) {
+        mbedtls_pk_free(conf->prv);
+        mbedtls_free(conf->prv);
+        conf->prv = NULL;
+    }
+
+    if (conf->pubcert != NULL) {
+        mbedtls_x509_crt_free(conf->pubcert);
+        mbedtls_free(conf->pubcert);
+        conf->pubcert = NULL;
+    }
+
+    if (conf->chainHead != NULL) {
+        mbedtls_x509_crt_free(conf->chainHead);
+        mbedtls_free(conf->chainHead);
+        conf->chainHead = NULL;
+    }
+
+    if (conf->cache != NULL) {
+        mbedtls_ssl_cache_free(conf->cache);
+        mbedtls_free(conf->cache);
+        conf->cache = NULL;
+    }
+
+    mbedtls_free(conf);
+    conf = NULL;
+}
+
+/* 设置CN域名，后面会继续校验,同时会发送SNI */
+int polarssl_ssl_set_hostname(mbedtls_ssl_adapt *ssl, const char *hostname)
+{
+   if (ssl == NULL) {
+       return -1;
+   }
+   return mbedtls_ssl_set_hostname(ssl->ssl,hostname);
+}
+
+/* 设置认证模式 */
+void polarssl_conf_authmode(mbedtls_ssl_config_adapt *conf, int authmode)
+{
+    if (conf == NULL) {
+        return ;
+    }    
+    mbedtls_ssl_conf_authmode(conf->config, authmode);
+}
+
+/* hmac包装，摘要方法为sha1 */
+int polarssl_hmac_with_sha1(const unsigned char *key, size_t keylen,
+                            const unsigned char *input, size_t ilen,
+                            unsigned char *output,size_t * outlen)
+{
+    *outlen = 20;
+    return mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), key, keylen, input, ilen, output);
+}
+
+/* hmac包装，摘要方法为sha256 */
+int polarssl_hmac_with_sha256(const unsigned char *key, size_t keylen,
+                              const unsigned char *input, size_t ilen,
+                              unsigned char *output,size_t outlen)
+{
+    outlen = outlen;
+    return mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), key, keylen, input, ilen, output);
+}
+
+/* 根据文件解析crt/der格式的证书,chain是个链表，如果已存在放在则放在其next里面 */
+mbedtls_x509_crt *polarssl_x509_crt_parse_file(const char *path)
+{
+    mbedtls_x509_crt *crt = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
+    if (crt == NULL) {
+        return NULL;
+    }
+
+    memset(crt, 0, sizeof(mbedtls_x509_crt));
+    int ret = mbedtls_x509_crt_parse_file(crt, path);
+    if (ret != 0) {
+        mbedtls_free(crt);
+        crt = NULL;
+    }
+
+    return crt;
+}
+
+void polarssl_pem_free(mbedtls_pem_context *ctx)
+{
+    mbedtls_pem_free(ctx);  
+}
+
+/* 解析PUBLIC KEY证书 */
+int polarssl_pem_read_buffer(mbedtls_pem_context *pem, unsigned char *pub)
+{
+    size_t use_len = 0;
+    return mbedtls_pem_read_buffer(pem, "-----BEGIN PUBLIC KEY-----", "-----END PUBLIC KEY-----",
+        pub, NULL, 0, &use_len);
+}
+
+
+/* 从der格式的公钥中解析出N/E rsa key，要求der格式简单，只有最内一层 */
+int polarssl_pk_parse_subpubkey(unsigned char *buf, int len, mbedtls_pk_context *pk)
+{
+    return mbedtls_pk_parse_subpubkey(&buf, buf + len, pk);
+}
+
+/* 将一套pub/priv key设置到其中 */
+int polarssl_set_pub_prv_to_conf(mbedtls_ssl_config_adapt *conf, const char *prvPath,const char *pubPath,const char *prvPassword)
+{
+    if (conf == NULL) {
+        return -1;
+    }
+
+    conf->pubcert = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
+    if (conf->pubcert == NULL) {
+        return MBEDTLS_ERR_SSL_ALLOC_FAILED;
+    }
+
+    conf->prv = mbedtls_calloc(1, sizeof(mbedtls_pk_context));
+    if(conf->prv == NULL) {
+        mbedtls_free(conf->pubcert);
+        return MBEDTLS_ERR_SSL_ALLOC_FAILED;
+    }
+
+    int ret  = mbedtls_x509_crt_parse_file(conf->pubcert, pubPath);
+    ret |= mbedtls_pk_parse_keyfile(conf->prv, prvPath, prvPassword, mbedtls_ctr_drbg_random, conf->ctr_drbg);
+    ret |= mbedtls_ssl_conf_own_cert(conf->config, conf->pubcert, conf->prv);
+
+    return ret;
+}
+
+/* SSL的read函数 */
+int polarssl_ssl_read(mbedtls_ssl_adapt *ssl, unsigned char *buf, size_t len)
+{
+    if (ssl == NULL) {
+        return -1;
+    }
+    return mbedtls_ssl_read(ssl->ssl, buf, len);
+}
+
+/* SSL的write函数 */
+int polarssl_ssl_write(mbedtls_ssl_adapt *ssl, const unsigned char *buf, size_t len)
+{
+    if (ssl == NULL) {
+        return -1;
+    }
+    return mbedtls_ssl_write(ssl->ssl, buf, len);
+}
+
+/* SSL获取version */
+const char *polarssl_ssl_get_version(const mbedtls_ssl_adapt *ssl)
+{
+    if (ssl == NULL) {
+        return NULL;
+    }
+    return mbedtls_ssl_get_version(ssl->ssl);
+}
+
+/* hash256 摘要下 x509 rsa证书校验判断 */
+int polarssl_rsassl_vertify(unsigned char *sig, unsigned int siglen, unsigned char *data, unsigned int datalen,
+                            mbedtls_rsa_context *rsa)
+{
+    unsigned char hash[1024] = {0}; /* Enough for any hash */
+    siglen = siglen;
+    datalen= datalen;
+
+    int ret = mbedtls_md(mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), data, datalen, hash);
+    if (ret != 0) {
+        return ret;
+    }
+
+    return mbedtls_rsa_pkcs1_verify(rsa, MBEDTLS_MD_SHA256, 32, hash, sig);
+}
+
+/* 将cafile和cadir目录下的所有文件设置到conf中去,没有有效证书则失败 */
+int polarssl_conf_setCaList(mbedtls_ssl_config_adapt *conf, char *cafile, char *cadir, char *crlFile)
+{
+    if (conf == NULL) {
+        return -1;
+    }
+
+    conf->chainHead = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
+    if (conf->chainHead == NULL) {
+        return MBEDTLS_ERR_SSL_ALLOC_FAILED;
+    }
+
+    if (cafile != NULL) {
+        mbedtls_x509_crt_parse_file(conf->chainHead, cafile);
+    }
+
+    if (cadir != NULL) {
+        void *dir = opendir(cadir);
+        if (dir == NULL) {
+            return 1;
+        }
+
+        char path[512] = {0};
+        struct dirent *filename = NULL;
+        while ((filename = readdir(dir)) != NULL) {
+            memset(path, 0, sizeof(path));
+            if(!strcmp(filename->d_name,".") || !strcmp(filename->d_name,".."))
+                continue;
+            (void)sprintf(path,"%s/%s",cadir,filename->d_name);
+            mbedtls_x509_crt_parse_file(conf->chainHead, path);
+        }
+
+        closedir(dir);
+    }
+
+    mbedtls_x509_crl *crl = NULL;
+    if ((crlFile != NULL) && (access(crlFile, F_OK) == 0)) { /* crl 文件存在 */
+        crl = mbedtls_calloc(1, sizeof(mbedtls_x509_crl));
+        if (crl == NULL) {
+            return MBEDTLS_ERR_SSL_ALLOC_FAILED;
+        }
+
+        mbedtls_x509_crl_init(crl);
+        int32_t rc = mbedtls_x509_crl_parse_file(crl, crlFile);
+        if (rc != 0) {
+            mbedtls_free(crl);
+            return rc;
+        }
+    }
+
+    mbedtls_ssl_conf_ca_chain(conf->config, conf->chainHead, crl);
+
+    return 0;
+}
+
+/* 获取ssl连接中使用的加密算法 */
+const char *polarssl_ssl_get_ciphersuite(const mbedtls_ssl_adapt *ssl)
+{
+    if (ssl == NULL) {
+        return NULL;
+    }
+
+    return mbedtls_ssl_get_ciphersuite(ssl->ssl);
+}
+
+/* scp中的特殊业务流程 */
+void polarssl_enable_ca_update(int enable)
+{
+     g_enable_caupdate = enable;
+}
+
+int polarssl_get_caupdate(void)
+{
+    return g_enable_caupdate;
+}
+
+/* 将socket设置到ssl连接中 */
+void polarssl_ssl_set_bio(mbedtls_ssl_adapt *ssl, int fd)
+{
+     if (ssl == NULL) {
+         return ;
+     }
+     ssl->bio.fd = fd;
+     mbedtls_ssl_set_bio(ssl->ssl,&ssl->bio, mbedtls_net_send, mbedtls_net_recv, NULL);
+}
+
+/* debug函数 */
+static void mbedtls_debug(void *ctx, int level, const char *file, int line, const char *str)
+{
+    ((void)level);
+
+    mbedtls_fprintf((FILE *) ctx, "%s:%04d: %s", file, line, str);
+    fflush((FILE *)ctx);
+}
+
+/* 证书校验适配放开,不然证书算法太弱会拒绝连接 */
+const mbedtls_x509_crt_profile easyConnect = {
+    /* 根据需要适当限制，当前放开 */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA1 ) |
+
+#if defined(MBEDTLS_MD2_C) 
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_MD2 ) |
+#endif
+#if defined(MBEDTLS_MD4_C) 
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_MD4 ) |
+#endif
+
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_MD5 ) |
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 ) |
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ) |
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA512 ),
+    0xFFFFFFF, /* Any PK alg    */
+    0xFFFFFFF, /* Any curve     */
+    2048, /* 3.1.0版本，rsa最小支持2048bit */ 
+};
+
+/* 默认 */
+const int ssl_ciphers[] = {
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA,    
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256 ,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
+    0
+};
+
+/* 符合公司安全默认用加密套件 */
+const int g_sslSafeCiphers[] = {
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
+    0
+};
+
+const int g_sslUdmCiphers[] = {
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
+    0
+};
+
+/* TLS1.3 加密套件 */
+const int g_tls13Ciphers[] = {
+    MBEDTLS_TLS1_3_AES_128_GCM_SHA256,
+    MBEDTLS_TLS1_3_AES_256_GCM_SHA384,
+    0
+};
+
+/* 按照公司要求，新单板删除CBC加密套， 保留GCM加密套 */
+const int g_sslGcmCiphers[] = {
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+    0
+};
+
+/* 埃及VDF要求支持安全等级高且算法长度大于128的算法 */
+const int g_sslHighCiphers[] = {
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+    0
+};
+
+void mbedtls_set_udm_ssl_conf(mbedtls_ssl_config_adapt *config)
+{
+    if (config == NULL) {
+        return;
+    }
+ 
+    mbedtls_ssl_conf_ciphersuites(config->config, g_sslUdmCiphers);
+    return;
+}
+
+/* 配合cyassl连接模型 适配函数 */
+mbedtls_ssl_config_adapt *polarssl_new_ctx_ssl_conf(int connect_type)
+{
+    const char *pers = (connect_type == MBEDTLS_SSL_IS_CLIENT) ? "ssl_client":"ssl_server";
+
+    mbedtls_ssl_config_adapt *config = mbedtls_calloc(1, sizeof(mbedtls_ssl_config_adapt));
+    if (config == NULL) {
+        return NULL;
+    }
+
+    config->entropy = mbedtls_calloc(1, sizeof(mbedtls_entropy_context));
+    if (config->entropy == NULL) {
+        mbedtls_free(config);
+        return NULL;
+    }
+
+    config->ctr_drbg = mbedtls_calloc(1, sizeof(mbedtls_ctr_drbg_context));
+    if (config->ctr_drbg == NULL) {
+        mbedtls_free(config->entropy);
+        mbedtls_free(config);
+        return NULL;
+    }
+
+    config->config = mbedtls_calloc(1, sizeof(mbedtls_ssl_config));
+    if (config->config == NULL) {
+        mbedtls_free(config->ctr_drbg);
+        mbedtls_free(config->entropy);
+        mbedtls_free(config);
+        return NULL;
+    }
+
+    /* 初始化协议 */
+    ssl_init_version();
+    /* 清理sni */
+    polarssl_ssl_clear_sni();
+
+    mbedtls_entropy_init(config->entropy);
+    mbedtls_ctr_drbg_init(config->ctr_drbg);
+    mbedtls_ssl_config_init(config->config);
+    (void)polarssl_ssl_config_defaults(config->config,connect_type);
+    (void)mbedtls_ssl_conf_cert_profile(config->config, &easyConnect);
+    (void)mbedtls_ctr_drbg_seed(config->ctr_drbg, mbedtls_entropy_func, config->entropy,
+        (const unsigned char *)pers, strlen(pers));
+
+    if (polarss_feather_support("FT_SSL_CIPHERSUITE_HIGH")) {
+        mbedtls_ssl_conf_ciphersuites(config->config, g_sslHighCiphers);
+    } else {
+        if (ssl_deprecated_newboard_support()) {
+            mbedtls_ssl_conf_ciphersuites(config->config, g_sslGcmCiphers);
+        } else {
+            /* 设置默认算法合集 */
+            mbedtls_ssl_conf_ciphersuites(config->config, g_sslSafeCiphers);
+
+            /* 特性开关打开则打开,rc4 */
+            if (ssl_deprecated_cipher_support()) {
+                /* 特性开关控制设置兼容过时算法合集 */
+                mbedtls_ssl_conf_ciphersuites(config->config, ssl_ciphers);
+            }
+        }
+    }
+
+    /* dh算法长度校验 */
+    if (ssl_deprecated_kexsize_support() == 1) {
+        mbedtls_ssl_conf_dhm_min_bitlen(config->config, 0);
+    }
+
+    /* mbedtls 只能使用TLS1.2或者TLS1.3  服务端暂不支持1.3， 客户端支持 */
+    mbedtls_ssl_conf_max_version(config->config, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_3);
+    mbedtls_ssl_conf_min_version(config->config, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_3);
+    if ((access("/var/force_tls13", F_OK) == 0) && (connect_type == MBEDTLS_SSL_IS_CLIENT)) {
+        mbedtls_ssl_conf_ciphersuites(config->config, g_tls13Ciphers);
+        mbedtls_ssl_conf_max_version(config->config, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_4);
+        mbedtls_ssl_conf_min_version(config->config, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_4);
+    }
+
+    /* 设置随机函数 */
+    mbedtls_ssl_conf_rng( config->config, mbedtls_ctr_drbg_random, config->ctr_drbg );
+
+    /* 调试手段 */
+    mbedtls_ssl_conf_dbg( config->config, mbedtls_debug, stdout );
+
+    /* 设置随机dm */
+    mbedtls_dhm_context dhm;
+    mbedtls_dhm_init(&dhm);
+    int ret = mbedtls_dhm_parse_dhmfile(&dhm, "/mnt/jffs2/dhparams.pem");
+    if (ret == 0) {
+        mbedtls_ssl_conf_dh_param_ctx(config->config, &dhm);
+    }
+    mbedtls_dhm_free(&dhm);
+
+    return config;
+}
+
+/* 配合cyassl模型创建ssl连接 */
+mbedtls_ssl_adapt *polarssl_new_ssl(mbedtls_ssl_config_adapt * config)
+{
+    if (config == NULL) {
+        return NULL;
+    }
+
+    mbedtls_ssl_adapt *ssl = mbedtls_calloc(1, sizeof(mbedtls_ssl_adapt));
+    if (ssl == NULL) {
+        return NULL;
+    }
+
+    ssl->ssl = mbedtls_calloc(1, sizeof(mbedtls_ssl_context));
+    if (ssl->ssl == NULL) {
+        mbedtls_free(ssl);
+        return NULL;
+    }
+
+    mbedtls_ssl_init(ssl->ssl);
+    (void)mbedtls_ssl_setup(ssl->ssl, config->config);
+
+    return ssl;
+}
+
+/* 摘要算法合集 */
+void polarssl_dgst(int type, unsigned char *input, size_t ilen, unsigned char * output,size_t * olen)
+{
+    switch (type) {
+        case MBEDTLS_MD_MD5:
+             mbedtls_md5(input, ilen, output);
+             *olen = 16;
+             break;
+        case MBEDTLS_MD_SHA1:
+             mbedtls_sha1(input, ilen, output);
+             *olen = 20;
+             break;
+        default:
+            break;
+    }
+
+    return ;
+}
+
+/* 适配init/update/final摘要算法格式合集 */
+int polarssl_dgst_init(mbedtls_md_context_t *ctx, int type)
+{
+    mbedtls_md_init(ctx);
+
+    int ret = mbedtls_md_setup(ctx, mbedtls_md_info_from_type(type), 0);
+    if (ret != 0) {
+        return ret;
+    }
+    mbedtls_md_starts(ctx);
+
+    return 0;
+}
+
+/* 适配init/update/final摘要算法格式合集 */
+void polarssl_dgst_update(mbedtls_md_context_t *ctx, unsigned char *input, size_t ilen)
+{
+    mbedtls_md_update(ctx, input, ilen);
+}
+
+/* 适配init/update/final摘要算法格式合集 */
+void polarssl_dgst_final(mbedtls_md_context_t *ctx, unsigned char *output)
+{
+    mbedtls_md_finish(ctx, output);
+    mbedtls_md_free(ctx);
+}
+
+#if defined(HUAWEI_POLARSSL_API_FT_C)
+#define FT_MAX_LEN 32
+/* FEATURE ioctl数据结构 */
+typedef struct {
+    uint32_t Ret;
+    uint8_t EnableFlag; /* 使能和初始化标志 */
+    char CustomDefine;        /* 是否支持运营商定制 */
+    uint16_t FtID;      /* 最大支持65535个特性开关 */
+    char FtName[FT_MAX_LEN];
+} HW_OPEN_FT_IOCTL_INFO;
+
+#define HW_FT_CMD_MAGIC 'X'
+#define HW_OPEN_FT_IOCTL_CMD_BY_NAME _IOWR(HW_FT_CMD_MAGIC, 4, HW_OPEN_FT_IOCTL_INFO)
+
+/* 特性开关判断 */
+int polarss_feather_support(char *featureName)
+{
+    int fd = open("/proc/wap_proc/feature", O_RDONLY, 0);
+    if (fd < 0) {
+        return 0;
+    }
+
+    HW_OPEN_FT_IOCTL_INFO ft = {0};
+    strncpy(ft.FtName, featureName, sizeof(ft.FtName) - 1);
+
+    int ret = ioctl(fd, HW_OPEN_FT_IOCTL_CMD_BY_NAME, &ft);
+    close(fd);
+    if (ret < 0 || ft.Ret != 0) {
+        return 0;
+    }
+
+    return ft.EnableFlag;
+}
+
+#else
+int polarss_feather_support(char *featureName){
+    (void)featureName;
+    return 0;
+}
+#endif
+
+/*摘要算法校验 md2,md4算法是否支持 */
+int polarssl_dgst_check(mbedtls_md_type_t md_alg)
+{
+    (void)md_alg;
+
+    /* 不同市场算法不一 特性开关开启的条件下 做校验 -1表示禁止*/
+#if defined(MBEDTLS_MD2_C) 
+    if (md_alg == MBEDTLS_MD_MD2 || md_alg == MBEDTLS_MD_MD4) {
+        if (polarss_feather_support("FT_OLD_MD_DDGST_FORBIDDEN")) {
+            return -1;
+        }
+    }    
+#endif
+
+#if defined(MBEDTLS_MD4_C) 
+    if (md_alg == MBEDTLS_MD_MD4) {
+        if (polarss_feather_support("FT_OLD_MD_DDGST_FORBIDDEN")) {
+            return -1;
+        }
+    }
+#endif
+
+    return 0;
+}
+
+/* 配置dh参数 */
+int  polarssl_ssl_conf_dh_param_ctx(mbedtls_ssl_config_adapt *conf, mbedtls_dhm_context *ctx)
+{
+    if (conf == NULL || ctx == NULL) {
+        return -1;
+    }
+
+    return mbedtls_ssl_conf_dh_param_ctx(conf->config, ctx);
+}
+
+/* 计算共享密钥 */
+int polarssl_ssl_calc_key(const unsigned char *pw, unsigned int pwLen, const unsigned char *salt, unsigned int saltLen,
+    unsigned char *key, unsigned int keyLen)
+{
+    mbedtls_md_context_t shaCtx;
+    const mbedtls_md_info_t *shaInfo = NULL;
+
+    mbedtls_md_init(&shaCtx);
+    shaInfo = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
+    if (shaInfo == NULL) {
+        return -1;
+    }
+
+    int ret = mbedtls_md_setup(&shaCtx, shaInfo, 1);
+    if (ret != 0) {
+        mbedtls_md_free(&shaCtx);
+        return ret;
+    }
+
+    /* pks count至少10000，与服务端保持一致 */
+    ret = mbedtls_pkcs5_pbkdf2_hmac(&shaCtx, pw, pwLen, salt, saltLen, 10000, keyLen, key);
+    if (ret != 0) {
+        mbedtls_md_free(&shaCtx);
+        return ret;
+    }
+
+    mbedtls_md_free(&shaCtx);
+
+    return (ret);
+}
+
+/* 配置共享密钥 */
+void polarssl_ssl_conf_psk(mbedtls_ssl_config_adapt *ctx, unsigned char *key, unsigned int keyLen,
+    const unsigned char *ident, unsigned int identLen)
+{
+    (void)mbedtls_ssl_conf_psk(ctx->config, key, keyLen, ident, identLen);
+}
+
+int polarssl_pk_parse_keyfile(mbedtls_pk_context *ctx, const char *path, const char *password)
+{
+    return mbedtls_pk_parse_keyfile(ctx, path, password, myrand, NULL);
+}
+
+int polarssl_pk_parse_key(mbedtls_pk_context *ctx, const unsigned char *key, size_t keylen,
+    const unsigned char *pwd, size_t pwdlen)
+{
+    return mbedtls_pk_parse_key(ctx, key, keylen, pwd, pwdlen, myrand, NULL);
+}
+
+int polarssl_pk_check_pair(const mbedtls_pk_context *pub, const mbedtls_pk_context *prv)
+{
+    return mbedtls_pk_check_pair(pub, prv, myrand, NULL);
+}
+
+
+static int pem_pbkdf1( unsigned char *key, size_t keylen,
+                       unsigned char *iv,
+                       const unsigned char *pwd, size_t pwdlen )
+{
+    mbedtls_md5_context md5_ctx;
+    unsigned char md5sum[16];
+    size_t use_len;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    mbedtls_md5_init( &md5_ctx );
+
+    /*
+     * key[ 0..15] = MD5(pwd || IV)
+     */
+    if( ( ret = mbedtls_md5_starts( &md5_ctx ) ) != 0 )
+        goto exit;
+    if( ( ret = mbedtls_md5_update( &md5_ctx, pwd, pwdlen ) ) != 0 )
+        goto exit;
+    if( ( ret = mbedtls_md5_update( &md5_ctx, iv,  8 ) ) != 0 )
+        goto exit;
+    if( ( ret = mbedtls_md5_finish( &md5_ctx, md5sum ) ) != 0 )
+        goto exit;
+
+    if( keylen <= 16 )
+    {
+        memcpy( key, md5sum, keylen );
+        goto exit;
+    }
+
+    memcpy( key, md5sum, 16 );
+
+    /*
+     * key[16..23] = MD5(key[ 0..15] || pwd || IV])
+     */
+    if( ( ret = mbedtls_md5_starts( &md5_ctx ) ) != 0 )
+        goto exit;
+    if( ( ret = mbedtls_md5_update( &md5_ctx, md5sum, 16 ) ) != 0 )
+        goto exit;
+    if( ( ret = mbedtls_md5_update( &md5_ctx, pwd, pwdlen ) ) != 0 )
+        goto exit;
+    if( ( ret = mbedtls_md5_update( &md5_ctx, iv, 8 ) ) != 0 )
+        goto exit;
+    if( ( ret = mbedtls_md5_finish( &md5_ctx, md5sum ) ) != 0 )
+        goto exit;
+
+    use_len = 16;
+    if( keylen < 32 )
+        use_len = keylen - 16;
+
+    memcpy( key + 16, md5sum, use_len );
+
+exit:
+    mbedtls_md5_free( &md5_ctx );
+    mbedtls_platform_zeroize( md5sum, 16 );
+
+    return( ret );
+}
+
+
+static int pem_aes_encrypt(unsigned char *aes_iv, unsigned int keylen, unsigned char *buf, size_t buflen, 
+                           const unsigned char *pwd, size_t pwdlen)
+{
+    int ret;
+    unsigned char aes_key[32];
+    mbedtls_aes_context aes_ctx;
+
+    mbedtls_aes_init(&aes_ctx);
+
+    ret = pem_pbkdf1(aes_key, keylen, aes_iv, pwd, pwdlen);
+    if (ret != 0 )
+        goto exit;
+
+    ret = mbedtls_aes_setkey_enc(&aes_ctx, aes_key, keylen * 8);
+    if (ret != 0)
+        goto exit;
+
+    ret = mbedtls_aes_crypt_cbc(&aes_ctx, MBEDTLS_AES_ENCRYPT, buflen, aes_iv, buf, buf);
+
+exit:
+    mbedtls_aes_free(&aes_ctx);
+    mbedtls_platform_zeroize(aes_key, keylen);
+
+    return ret;
+}
+
+
+static int mbedtls_pem_generate_iv(unsigned char *iv, int len)
+{
+    int ret;
+    mbedtls_entropy_context entropy;
+    mbedtls_ctr_drbg_context drbgCtx;
+
+    mbedtls_ctr_drbg_init(&drbgCtx);
+    mbedtls_entropy_init(&entropy);
+
+    ret = mbedtls_ctr_drbg_seed(&drbgCtx, mbedtls_entropy_func, &entropy, NULL, 0);
+    if (ret != 0)
+        goto cleanup;
+
+    ret = mbedtls_ctr_drbg_random(&drbgCtx, iv, len);
+    if (ret != 0)
+        goto cleanup;
+
+cleanup:
+    mbedtls_ctr_drbg_free(&drbgCtx);
+    mbedtls_entropy_free(&entropy);
+    return ret;
+}
+
+int mbedtls_pem_write_crypt_buffer(const char *header, const char *footer,
+                                   unsigned char *der_data, size_t der_len,
+                                   const unsigned char * pwd, size_t pwdlen, 
+                                   unsigned char *buf, size_t buf_len, size_t *olen)
+{
+    int i;
+    int ret;
+    char head[256];
+    char iv[33];
+    unsigned char aes_iv[17];
+
+    ret = mbedtls_pem_generate_iv(aes_iv, 16);
+    if (ret != 0)
+        return ret;
+
+    memset(iv, 0x00, sizeof(iv));
+    for (i = 0; i < 16; i++)
+        sprintf(iv + i * 2, "%02X", aes_iv[i]);
+
+    ret = pem_aes_encrypt(aes_iv, 32, der_data, der_len, pwd, pwdlen);
+    if (ret != 0)
+        return ret;
+
+    memset(buf, 0, buf_len);
+    sprintf(head, "%s%s\n\n", header, iv);
+    ret = mbedtls_pem_write_buffer(head, footer, der_data, der_len, buf, buf_len, olen);
+
+    return ret;
+}
+
+int mbedtls_x509_crt_check_date(const char* filename)
+{
+    int ret = 0;
+    mbedtls_x509_crt crt ;
+
+    memset( &crt, 0, sizeof( mbedtls_x509_crt ) );
+    ret = mbedtls_x509_crt_parse_file( &crt, filename );
+    if( ret != 0 )
+        return ( ret );
+
+    if(polarssl_ischeck_crttime(&crt) && mbedtls_x509_time_is_past(&crt.valid_to))
+    {
+        mbedtls_x509_crt_free( &crt );
+        return ( MBEDTLS_X509_BADCERT_EXPIRED );
+    }
+
+    if(polarssl_ischeck_crttime(&crt) && mbedtls_x509_time_is_future(&crt.valid_from))
+    {
+        mbedtls_x509_crt_free(&crt);
+        return ( MBEDTLS_X509_BADCERT_FUTURE );
+    }
+    mbedtls_x509_crt_free(&crt);
+
+    return ( 0 );
+}
+
+
+#define PEM_ENCRYPT_BEGIN_PRIVATE_KEY_RSA   "-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-256-CBC,"
+#define PEM_END_PRIVATE_KEY_RSA     "-----END RSA PRIVATE KEY-----"
+#define PEM_ENCRYPT_BEGIN_PRIVATE_KEY_EC    "-----BEGIN EC PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-256-CBC,"
+#define PEM_END_PRIVATE_KEY_EC      "-----END EC PRIVATE KEY-----"
+
+#if defined(MBEDTLS_RSA_C)
+    #define MPI_MAX_SIZE_2          ( MBEDTLS_MPI_MAX_SIZE / 2 + MBEDTLS_MPI_MAX_SIZE % 2 )
+    #define RSA_PRV_DER_MAX_BYTES   ( 47 + 3 * MBEDTLS_MPI_MAX_SIZE + 5 * MPI_MAX_SIZE_2 )
+#else /* MBEDTLS_RSA_C */
+    #define RSA_PRV_DER_MAX_BYTES   0
+#endif /* MBEDTLS_RSA_C */
+#if defined(MBEDTLS_ECP_C)
+    #define ECP_PRV_DER_MAX_BYTES   ( 29 + 3 * MBEDTLS_ECP_MAX_BYTES )
+#else /* MBEDTLS_ECP_C */
+    #define ECP_PRV_DER_MAX_BYTES   0
+#endif /* MBEDTLS_ECP_C */
+#define PRV_DER_MAX_BYTES   ( RSA_PRV_DER_MAX_BYTES > ECP_PRV_DER_MAX_BYTES ? RSA_PRV_DER_MAX_BYTES : ECP_PRV_DER_MAX_BYTES )
+
+int mbedtls_pk_write_crypt_key_pem(mbedtls_pk_context *key, const unsigned char *pwd, unsigned char *buf, size_t size )
+{
+    int ret;
+    int i;
+    size_t olen = 0;
+    int plain_len;
+    int pad_len;
+    unsigned char output_buf[PRV_DER_MAX_BYTES];
+    unsigned char plain[PRV_DER_MAX_BYTES];
+    const char *begin, *end;
+
+    if ((key == NULL) || (pwd == NULL) || (buf == NULL) || (size == 0))
+        return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
+
+    ret = mbedtls_pk_write_key_der(key, output_buf, sizeof(output_buf));
+    if (ret < 0)
+        return ret;
+
+    plain_len = (ret % 16) == 0 ? ret : ((ret / 16 + 1) * 16);
+    memset(plain, 0x00, sizeof(plain));
+    memcpy(plain, output_buf + sizeof(output_buf) - ret, ret);
+    pad_len = plain_len - ret;
+
+    for (i = 0; i < pad_len; i++)
+        plain[ret + i] = pad_len;
+
+    if ( mbedtls_pk_get_type( key ) == MBEDTLS_PK_RSA )
+    {
+        begin = PEM_ENCRYPT_BEGIN_PRIVATE_KEY_RSA;
+        end = PEM_END_PRIVATE_KEY_RSA;
+    } 
+    else if ( mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
+    {
+        begin = PEM_ENCRYPT_BEGIN_PRIVATE_KEY_EC;
+        end = PEM_END_PRIVATE_KEY_EC;
+    }
+    else {
+        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
+    }
+
+    return mbedtls_pem_write_crypt_buffer(begin, end, plain, plain_len,
+                                          pwd, strlen((const char*)pwd), buf, size, &olen );
+}
+
+int x509_info_subject_alt_name( char **buf, size_t *size,
+                                const mbedtls_x509_sequence *subject_alt_name,
+                                const char *prefix )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t n = *size;
+    char *p = *buf;
+    const mbedtls_x509_sequence *cur = subject_alt_name;
+    mbedtls_x509_subject_alternative_name san;
+    int parse_ret;
+
+    while( cur != NULL )
+    {
+        memset( &san, 0, sizeof( san ) );
+        parse_ret = mbedtls_x509_parse_subject_alt_name( &cur->buf, &san );
+        if( parse_ret != 0 )
+        {
+            if( parse_ret == MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE )
+            {
+                ret = mbedtls_snprintf( p, n, "\n%s    <unsupported>", prefix );
+                MBEDTLS_X509_SAFE_SNPRINTF;
+            }
+            else
+            {
+                ret = mbedtls_snprintf( p, n, "\n%s    <malformed>", prefix );
+                MBEDTLS_X509_SAFE_SNPRINTF;
+            }
+            cur = cur->next;
+            continue;
+        }
+
+        switch( san.type )
+        {
+            /*
+             * otherName
+             */
+            case MBEDTLS_X509_SAN_OTHER_NAME:
+            {
+                mbedtls_x509_san_other_name *other_name = &san.san.other_name;
+
+                ret = mbedtls_snprintf( p, n, "\n%s    otherName :", prefix );
+                MBEDTLS_X509_SAFE_SNPRINTF;
+
+                if( MBEDTLS_OID_CMP( MBEDTLS_OID_ON_HW_MODULE_NAME,
+                                     &other_name->value.hardware_module_name.oid ) != 0 )
+                {
+                    ret = mbedtls_snprintf( p, n, "\n%s        hardware module name :", prefix );
+                    MBEDTLS_X509_SAFE_SNPRINTF;
+                    ret = mbedtls_snprintf( p, n, "\n%s            hardware type          : ", prefix );
+                    MBEDTLS_X509_SAFE_SNPRINTF;
+
+                    ret = mbedtls_oid_get_numeric_string( p, n, &other_name->value.hardware_module_name.oid );
+                    MBEDTLS_X509_SAFE_SNPRINTF;
+
+                    ret = mbedtls_snprintf( p, n, "\n%s            hardware serial number : ", prefix );
+                    MBEDTLS_X509_SAFE_SNPRINTF;
+
+                    if( other_name->value.hardware_module_name.val.len >= n )
+                    {
+                        *p = '\0';
+                        return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );
+                    }
+
+                    memcpy( p, other_name->value.hardware_module_name.val.p,
+                            other_name->value.hardware_module_name.val.len );
+                    p += other_name->value.hardware_module_name.val.len;
+
+                    n -= other_name->value.hardware_module_name.val.len;
+
+                }/* MBEDTLS_OID_ON_HW_MODULE_NAME */
+            }
+            break;
+
+            /*
+             * dNSName
+             */
+            case MBEDTLS_X509_SAN_DNS_NAME:
+            {
+                ret = mbedtls_snprintf( p, n, "\n%s    dNSName : ", prefix );
+                MBEDTLS_X509_SAFE_SNPRINTF;
+                if( san.san.unstructured_name.len >= n )
+                {
+                    *p = '\0';
+                    return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );
+                }
+
+                memcpy( p, san.san.unstructured_name.p, san.san.unstructured_name.len );
+                p += san.san.unstructured_name.len;
+                n -= san.san.unstructured_name.len;
+            }
+            break;
+
+            /*
+             * Type not supported, skip item.
+             */
+            default:
+                ret = mbedtls_snprintf( p, n, "\n%s    <unsupported>", prefix );
+                MBEDTLS_X509_SAFE_SNPRINTF;
+                break;
+        }
+
+        cur = cur->next;
+    }
+
+    *p = '\0';
+
+    *size = n;
+    *buf = p;
+
+    return( 0 );
+}
+#endif
+
diff --git a/library/md.c b/library/md.c
index 12a3ea2..94dd3f9 100644
--- a/library/md.c
+++ b/library/md.c
@@ -34,13 +34,23 @@
 #include "mbedtls/platform_util.h"
 #include "mbedtls/error.h"
 
+#if defined(MBEDTLS_MD2_C)
+#include "mbedtls/md2.h"
+#endif
+
+#if defined(MBEDTLS_MD4_C)
+#include "mbedtls/md4.h"
+#endif
+
 #include "mbedtls/md5.h"
 #include "mbedtls/ripemd160.h"
 #include "mbedtls/sha1.h"
 #include "mbedtls/sha256.h"
 #include "mbedtls/sha512.h"
 #include "mbedtls/sha3.h"
-
+#if defined(MBEDTLS_SM3_C)
+#include "mbedtls/sm3.h"
+#endif
 #if defined(MBEDTLS_PSA_CRYPTO_C)
 #include <psa/crypto.h>
 #include "md_psa.h"
@@ -70,6 +80,22 @@
 #define MD_INFO(type, out_size, block_size) type, out_size,
 #endif
 
+#if defined(HW_MBEDTLS_CONFIG_C)
+#include "mbedtls/hw_mbedtls_config.h"
+#endif
+
+#if defined(MBEDTLS_MD2_C)
+static const mbedtls_md_info_t mbedtls_md2_info = {
+    MD_INFO(MBEDTLS_MD_MD2, 16, 16)
+};
+#endif
+
+#if defined(MBEDTLS_MD4_C)
+static const mbedtls_md_info_t mbedtls_md4_info = {
+    MD_INFO(MBEDTLS_MD_MD4, 16, 64)
+};
+#endif
+
 #if defined(MBEDTLS_MD_CAN_MD5)
 static const mbedtls_md_info_t mbedtls_md5_info = {
     MD_INFO(MBEDTLS_MD_MD5, 16, 64)
@@ -112,6 +138,12 @@ static const mbedtls_md_info_t mbedtls_sha512_info = {
 };
 #endif
 
+#if defined(MBEDTLS_SM3_C)
+const mbedtls_md_info_t mbedtls_sm3_info = {
+    MD_INFO(MBEDTLS_MD_SM3, 32, 64)
+};
+#endif
+
 #if defined(MBEDTLS_MD_CAN_SHA3_224)
 static const mbedtls_md_info_t mbedtls_sha3_224_info = {
     MD_INFO(MBEDTLS_MD_SHA3_224, 28, 144)
@@ -139,6 +171,14 @@ static const mbedtls_md_info_t mbedtls_sha3_512_info = {
 const mbedtls_md_info_t *mbedtls_md_info_from_type(mbedtls_md_type_t md_type)
 {
     switch (md_type) {
+#if defined(MBEDTLS_MD2_C)
+        case MBEDTLS_MD_MD2:
+            return &mbedtls_md2_info;
+#endif
+#if defined(MBEDTLS_MD4_C)
+        case MBEDTLS_MD_MD4:
+            return &mbedtls_md4_info;
+#endif
 #if defined(MBEDTLS_MD_CAN_MD5)
         case MBEDTLS_MD_MD5:
             return &mbedtls_md5_info;
@@ -167,6 +207,10 @@ const mbedtls_md_info_t *mbedtls_md_info_from_type(mbedtls_md_type_t md_type)
         case MBEDTLS_MD_SHA512:
             return &mbedtls_sha512_info;
 #endif
+#if defined(MBEDTLS_MD_CAN_SM3)
+        case MBEDTLS_MD_SM3:
+            return( &mbedtls_sm3_info );
+#endif
 #if defined(MBEDTLS_MD_CAN_SHA3_224)
         case MBEDTLS_MD_SHA3_224:
             return &mbedtls_sha3_224_info;
@@ -192,6 +236,32 @@ const mbedtls_md_info_t *mbedtls_md_info_from_type(mbedtls_md_type_t md_type)
 static psa_algorithm_t psa_alg_of_md(const mbedtls_md_info_t *info)
 {
     switch (info->type) {
+#if defined(MBEDTLS_MD2_C)
+        case MBEDTLS_MD_MD2:
+#if defined(HW_MBEDTLS_CONFIG_C)
+            if (hw_mbedtls_get_config(HW_MBEDTLS_DISABLE_MD2) == HW_MBEDTLS_CONFIG_ENABLE) {
+                return( &mbedtls_md2_info );
+            } else {
+                return NULL;
+            }
+#else            
+            return PSA_ALG_MD2;
+#endif
+#endif
+
+#if defined(MBEDTLS_MD4_C)
+        case MBEDTLS_MD_MD4:
+#if defined(HW_MBEDTLS_CONFIG_C)
+            if (hw_mbedtls_get_config(HW_MBEDTLS_DISABLE_MD4) == HW_MBEDTLS_CONFIG_ENABLE) {
+                return( &mbedtls_md4_info );
+            } else {
+                return NULL;
+            }
+#else
+            return PSA_ALG_MD4;
+#endif
+#endif
+
 #if defined(MBEDTLS_MD_MD5_VIA_PSA)
         case MBEDTLS_MD_MD5:
             return PSA_ALG_MD5;
@@ -271,6 +341,16 @@ void mbedtls_md_free(mbedtls_md_context_t *ctx)
         } else
 #endif
         switch (ctx->md_info->type) {
+#if defined(MBEDTLS_MD2_C)
+            case MBEDTLS_MD_MD2:
+                mbedtls_md2_free( ctx->md_ctx );
+                break;
+#endif
+#if defined(MBEDTLS_MD4_C)
+            case MBEDTLS_MD_MD4:
+                mbedtls_md4_free( ctx->md_ctx );
+                break;
+#endif
 #if defined(MBEDTLS_MD5_C)
             case MBEDTLS_MD_MD5:
                 mbedtls_md5_free(ctx->md_ctx);
@@ -356,6 +436,16 @@ int mbedtls_md_clone(mbedtls_md_context_t *dst,
 #endif
 
     switch (src->md_info->type) {
+#if defined(MBEDTLS_MD2_C)
+        case MBEDTLS_MD_MD2:
+            mbedtls_md2_clone( dst->md_ctx, src->md_ctx );
+            break;
+#endif
+#if defined(MBEDTLS_MD4_C)
+        case MBEDTLS_MD_MD4:
+            mbedtls_md4_clone( dst->md_ctx, src->md_ctx );
+            break;
+#endif
 #if defined(MBEDTLS_MD5_C)
         case MBEDTLS_MD_MD5:
             mbedtls_md5_clone(dst->md_ctx, src->md_ctx);
@@ -446,6 +536,16 @@ int mbedtls_md_setup(mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info
     } else
 #endif
     switch (md_info->type) {
+#if defined(MBEDTLS_MD2_C)
+        case MBEDTLS_MD_MD2:
+            ALLOC(md2);
+            break;
+#endif
+#if defined(MBEDTLS_MD4_C)
+        case MBEDTLS_MD_MD4:
+            ALLOC(md4);
+            break;
+#endif
 #if defined(MBEDTLS_MD5_C)
         case MBEDTLS_MD_MD5:
             ALLOC(md5);
@@ -481,6 +581,11 @@ int mbedtls_md_setup(mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info
             ALLOC(sha512);
             break;
 #endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            ALLOC(sm3);
+            break;
+#endif
 #if defined(MBEDTLS_SHA3_C)
         case MBEDTLS_MD_SHA3_224:
         case MBEDTLS_MD_SHA3_256:
@@ -525,6 +630,14 @@ int mbedtls_md_starts(mbedtls_md_context_t *ctx)
 #endif
 
     switch (ctx->md_info->type) {
+#if defined(MBEDTLS_MD2_C)
+        case MBEDTLS_MD_MD2:
+            return mbedtls_md2_starts(ctx->md_ctx);
+#endif
+#if defined(MBEDTLS_MD4_C)
+        case MBEDTLS_MD_MD4:
+            return mbedtls_md4_starts(ctx->md_ctx);
+#endif
 #if defined(MBEDTLS_MD5_C)
         case MBEDTLS_MD_MD5:
             return mbedtls_md5_starts(ctx->md_ctx);
@@ -553,6 +666,10 @@ int mbedtls_md_starts(mbedtls_md_context_t *ctx)
         case MBEDTLS_MD_SHA512:
             return mbedtls_sha512_starts(ctx->md_ctx, 0);
 #endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return mbedtls_sm3_starts(ctx->md_ctx);
+#endif
 #if defined(MBEDTLS_SHA3_C)
         case MBEDTLS_MD_SHA3_224:
             return mbedtls_sha3_starts(ctx->md_ctx, MBEDTLS_SHA3_224);
@@ -584,6 +701,14 @@ int mbedtls_md_update(mbedtls_md_context_t *ctx, const unsigned char *input, siz
 #endif
 
     switch (ctx->md_info->type) {
+#if defined(MBEDTLS_MD2_C)
+        case MBEDTLS_MD_MD2:
+            return mbedtls_md2_update(ctx->md_ctx, input, ilen);
+#endif
+#if defined(MBEDTLS_MD4_C)
+        case MBEDTLS_MD_MD4:
+            return mbedtls_md4_update(ctx->md_ctx, input, ilen);
+#endif
 #if defined(MBEDTLS_MD5_C)
         case MBEDTLS_MD_MD5:
             return mbedtls_md5_update(ctx->md_ctx, input, ilen);
@@ -612,6 +737,10 @@ int mbedtls_md_update(mbedtls_md_context_t *ctx, const unsigned char *input, siz
         case MBEDTLS_MD_SHA512:
             return mbedtls_sha512_update(ctx->md_ctx, input, ilen);
 #endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return mbedtls_sm3_update(ctx->md_ctx, input, ilen);
+#endif
 #if defined(MBEDTLS_SHA3_C)
         case MBEDTLS_MD_SHA3_224:
         case MBEDTLS_MD_SHA3_256:
@@ -642,6 +771,14 @@ int mbedtls_md_finish(mbedtls_md_context_t *ctx, unsigned char *output)
 #endif
 
     switch (ctx->md_info->type) {
+#if defined(MBEDTLS_MD2_C)
+        case MBEDTLS_MD_MD2:
+            return mbedtls_md2_finish(ctx->md_ctx, output);
+#endif
+#if defined(MBEDTLS_MD4_C)
+        case MBEDTLS_MD_MD4:
+            return mbedtls_md4_finish(ctx->md_ctx, output);
+#endif
 #if defined(MBEDTLS_MD5_C)
         case MBEDTLS_MD_MD5:
             return mbedtls_md5_finish(ctx->md_ctx, output);
@@ -670,6 +807,10 @@ int mbedtls_md_finish(mbedtls_md_context_t *ctx, unsigned char *output)
         case MBEDTLS_MD_SHA512:
             return mbedtls_sha512_finish(ctx->md_ctx, output);
 #endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return mbedtls_sm3_finish(ctx->md_ctx, output);
+#endif
 #if defined(MBEDTLS_SHA3_C)
         case MBEDTLS_MD_SHA3_224:
         case MBEDTLS_MD_SHA3_256:
@@ -700,6 +841,14 @@ int mbedtls_md(const mbedtls_md_info_t *md_info, const unsigned char *input, siz
 #endif
 
     switch (md_info->type) {
+#if defined(MBEDTLS_MD2_C)
+        case MBEDTLS_MD_MD2:
+            return mbedtls_md2(input, ilen, output);
+#endif
+#if defined(MBEDTLS_MD4_C)
+        case MBEDTLS_MD_MD4:
+            return mbedtls_md4(input, ilen, output);
+#endif
 #if defined(MBEDTLS_MD5_C)
         case MBEDTLS_MD_MD5:
             return mbedtls_md5(input, ilen, output);
@@ -728,6 +877,10 @@ int mbedtls_md(const mbedtls_md_info_t *md_info, const unsigned char *input, siz
         case MBEDTLS_MD_SHA512:
             return mbedtls_sha512(input, ilen, output, 0);
 #endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return mbedtls_sm3(input, ilen, output);
+#endif
 #if defined(MBEDTLS_SHA3_C)
         case MBEDTLS_MD_SHA3_224:
             return mbedtls_sha3(MBEDTLS_SHA3_224, input, ilen, output, md_info->size);
@@ -824,6 +977,14 @@ static const int supported_digests[] = {
     MBEDTLS_MD_SHA3_512,
 #endif
 
+#if defined(MBEDTLS_MD2_C)
+    MBEDTLS_MD_MD2,
+#endif
+
+#if defined(MBEDTLS_MD4_C)
+    MBEDTLS_MD_MD4,
+#endif
+
     MBEDTLS_MD_NONE
 };
 
diff --git a/library/md2.c b/library/md2.c
new file mode 100644
index 0000000..460044a
--- /dev/null
+++ b/library/md2.c
@@ -0,0 +1,321 @@
+/*
+ *  RFC 1115/1319 compliant MD2 implementation
+ *
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+/*
+ *  The MD2 algorithm was designed by Ron Rivest in 1989.
+ *
+ *  http://www.ietf.org/rfc/rfc1115.txt
+ *  http://www.ietf.org/rfc/rfc1319.txt
+ */
+
+#include "common.h"
+
+#if defined(MBEDTLS_MD2_C)
+
+#include "mbedtls/md2.h"
+#include "mbedtls/platform_util.h"
+#include "mbedtls/error.h"
+
+#include <string.h>
+
+#if defined(MBEDTLS_SELF_TEST)
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
+#include <stdio.h>
+#define mbedtls_printf printf
+#endif /* MBEDTLS_PLATFORM_C */
+#endif /* MBEDTLS_SELF_TEST */
+
+#if !defined(MBEDTLS_MD2_ALT)
+
+static const unsigned char PI_SUBST[256] =
+{
+    0x29, 0x2E, 0x43, 0xC9, 0xA2, 0xD8, 0x7C, 0x01, 0x3D, 0x36,
+    0x54, 0xA1, 0xEC, 0xF0, 0x06, 0x13, 0x62, 0xA7, 0x05, 0xF3,
+    0xC0, 0xC7, 0x73, 0x8C, 0x98, 0x93, 0x2B, 0xD9, 0xBC, 0x4C,
+    0x82, 0xCA, 0x1E, 0x9B, 0x57, 0x3C, 0xFD, 0xD4, 0xE0, 0x16,
+    0x67, 0x42, 0x6F, 0x18, 0x8A, 0x17, 0xE5, 0x12, 0xBE, 0x4E,
+    0xC4, 0xD6, 0xDA, 0x9E, 0xDE, 0x49, 0xA0, 0xFB, 0xF5, 0x8E,
+    0xBB, 0x2F, 0xEE, 0x7A, 0xA9, 0x68, 0x79, 0x91, 0x15, 0xB2,
+    0x07, 0x3F, 0x94, 0xC2, 0x10, 0x89, 0x0B, 0x22, 0x5F, 0x21,
+    0x80, 0x7F, 0x5D, 0x9A, 0x5A, 0x90, 0x32, 0x27, 0x35, 0x3E,
+    0xCC, 0xE7, 0xBF, 0xF7, 0x97, 0x03, 0xFF, 0x19, 0x30, 0xB3,
+    0x48, 0xA5, 0xB5, 0xD1, 0xD7, 0x5E, 0x92, 0x2A, 0xAC, 0x56,
+    0xAA, 0xC6, 0x4F, 0xB8, 0x38, 0xD2, 0x96, 0xA4, 0x7D, 0xB6,
+    0x76, 0xFC, 0x6B, 0xE2, 0x9C, 0x74, 0x04, 0xF1, 0x45, 0x9D,
+    0x70, 0x59, 0x64, 0x71, 0x87, 0x20, 0x86, 0x5B, 0xCF, 0x65,
+    0xE6, 0x2D, 0xA8, 0x02, 0x1B, 0x60, 0x25, 0xAD, 0xAE, 0xB0,
+    0xB9, 0xF6, 0x1C, 0x46, 0x61, 0x69, 0x34, 0x40, 0x7E, 0x0F,
+    0x55, 0x47, 0xA3, 0x23, 0xDD, 0x51, 0xAF, 0x3A, 0xC3, 0x5C,
+    0xF9, 0xCE, 0xBA, 0xC5, 0xEA, 0x26, 0x2C, 0x53, 0x0D, 0x6E,
+    0x85, 0x28, 0x84, 0x09, 0xD3, 0xDF, 0xCD, 0xF4, 0x41, 0x81,
+    0x4D, 0x52, 0x6A, 0xDC, 0x37, 0xC8, 0x6C, 0xC1, 0xAB, 0xFA,
+    0x24, 0xE1, 0x7B, 0x08, 0x0C, 0xBD, 0xB1, 0x4A, 0x78, 0x88,
+    0x95, 0x8B, 0xE3, 0x63, 0xE8, 0x6D, 0xE9, 0xCB, 0xD5, 0xFE,
+    0x3B, 0x00, 0x1D, 0x39, 0xF2, 0xEF, 0xB7, 0x0E, 0x66, 0x58,
+    0xD0, 0xE4, 0xA6, 0x77, 0x72, 0xF8, 0xEB, 0x75, 0x4B, 0x0A,
+    0x31, 0x44, 0x50, 0xB4, 0x8F, 0xED, 0x1F, 0x1A, 0xDB, 0x99,
+    0x8D, 0x33, 0x9F, 0x11, 0x83, 0x14
+};
+
+void mbedtls_md2_init( mbedtls_md2_context *ctx )
+{
+    memset( ctx, 0, sizeof( mbedtls_md2_context ) );
+}
+
+void mbedtls_md2_free( mbedtls_md2_context *ctx )
+{
+    if( ctx == NULL )
+        return;
+
+    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md2_context ) );
+}
+
+void mbedtls_md2_clone( mbedtls_md2_context *dst,
+                        const mbedtls_md2_context *src )
+{
+    *dst = *src;
+}
+
+/*
+ * MD2 context setup
+ */
+int mbedtls_md2_starts( mbedtls_md2_context *ctx )
+{
+    memset( ctx->cksum, 0, 16 );
+    memset( ctx->state, 0, 46 );
+    memset( ctx->buffer, 0, 16 );
+    ctx->left = 0;
+
+    return( 0 );
+}
+
+#if !defined(MBEDTLS_MD2_PROCESS_ALT)
+int mbedtls_internal_md2_process( mbedtls_md2_context *ctx )
+{
+    int i, j;
+    unsigned char t = 0;
+
+    for( i = 0; i < 16; i++ )
+    {
+        ctx->state[i + 16] = ctx->buffer[i];
+        ctx->state[i + 32] =
+            (unsigned char)( ctx->buffer[i] ^ ctx->state[i]);
+    }
+
+    for( i = 0; i < 18; i++ )
+    {
+        for( j = 0; j < 48; j++ )
+        {
+            ctx->state[j] = (unsigned char)
+               ( ctx->state[j] ^ PI_SUBST[t] );
+            t  = ctx->state[j];
+        }
+
+        t = (unsigned char)( t + i );
+    }
+
+    t = ctx->cksum[15];
+
+    for( i = 0; i < 16; i++ )
+    {
+        ctx->cksum[i] = (unsigned char)
+           ( ctx->cksum[i] ^ PI_SUBST[ctx->buffer[i] ^ t] );
+        t  = ctx->cksum[i];
+    }
+
+    /* Zeroise variables to clear sensitive data from memory. */
+    mbedtls_platform_zeroize( &t, sizeof( t ) );
+
+    return( 0 );
+}
+
+#endif /* !MBEDTLS_MD2_PROCESS_ALT */
+
+/*
+ * MD2 process buffer
+ */
+int mbedtls_md2_update( mbedtls_md2_context *ctx,
+                            const unsigned char *input,
+                            size_t ilen )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t fill;
+
+    while( ilen > 0 )
+    {
+        if( ilen > 16 - ctx->left )
+            fill = 16 - ctx->left;
+        else
+            fill = ilen;
+
+        memcpy( ctx->buffer + ctx->left, input, fill );
+
+        ctx->left += fill;
+        input += fill;
+        ilen  -= fill;
+
+        if( ctx->left == 16 )
+        {
+            ctx->left = 0;
+            if( ( ret = mbedtls_internal_md2_process( ctx ) ) != 0 )
+                return( ret );
+        }
+    }
+
+    return( 0 );
+}
+
+/*
+ * MD2 final digest
+ */
+int mbedtls_md2_finish( mbedtls_md2_context *ctx,
+                            unsigned char output[16] )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t i;
+    unsigned char x;
+
+    x = (unsigned char)( 16 - ctx->left );
+
+    for( i = ctx->left; i < 16; i++ )
+        ctx->buffer[i] = x;
+
+    if( ( ret = mbedtls_internal_md2_process( ctx ) ) != 0 )
+        return( ret );
+
+    memcpy( ctx->buffer, ctx->cksum, 16 );
+    if( ( ret = mbedtls_internal_md2_process( ctx ) ) != 0 )
+        return( ret );
+
+    memcpy( output, ctx->state, 16 );
+
+    return( 0 );
+}
+
+#endif /* !MBEDTLS_MD2_ALT */
+
+/*
+ * output = MD2( input buffer )
+ */
+int mbedtls_md2( const unsigned char *input,
+                     size_t ilen,
+                     unsigned char output[16] )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    mbedtls_md2_context ctx;
+
+    mbedtls_md2_init( &ctx );
+
+    if( ( ret = mbedtls_md2_starts( &ctx ) ) != 0 )
+        goto exit;
+
+    if( ( ret = mbedtls_md2_update( &ctx, input, ilen ) ) != 0 )
+        goto exit;
+
+    if( ( ret = mbedtls_md2_finish( &ctx, output ) ) != 0 )
+        goto exit;
+
+exit:
+    mbedtls_md2_free( &ctx );
+
+    return( ret );
+}
+
+#if defined(MBEDTLS_SELF_TEST)
+
+/*
+ * RFC 1319 test vectors
+ */
+static const unsigned char md2_test_str[7][81] =
+{
+    { "" },
+    { "a" },
+    { "abc" },
+    { "message digest" },
+    { "abcdefghijklmnopqrstuvwxyz" },
+    { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" },
+    { "12345678901234567890123456789012345678901234567890123456789012345678901234567890" }
+};
+
+static const size_t md2_test_strlen[7] =
+{
+    0, 1, 3, 14, 26, 62, 80
+};
+
+static const unsigned char md2_test_sum[7][16] =
+{
+    { 0x83, 0x50, 0xE5, 0xA3, 0xE2, 0x4C, 0x15, 0x3D,
+      0xF2, 0x27, 0x5C, 0x9F, 0x80, 0x69, 0x27, 0x73 },
+    { 0x32, 0xEC, 0x01, 0xEC, 0x4A, 0x6D, 0xAC, 0x72,
+      0xC0, 0xAB, 0x96, 0xFB, 0x34, 0xC0, 0xB5, 0xD1 },
+    { 0xDA, 0x85, 0x3B, 0x0D, 0x3F, 0x88, 0xD9, 0x9B,
+      0x30, 0x28, 0x3A, 0x69, 0xE6, 0xDE, 0xD6, 0xBB },
+    { 0xAB, 0x4F, 0x49, 0x6B, 0xFB, 0x2A, 0x53, 0x0B,
+      0x21, 0x9F, 0xF3, 0x30, 0x31, 0xFE, 0x06, 0xB0 },
+    { 0x4E, 0x8D, 0xDF, 0xF3, 0x65, 0x02, 0x92, 0xAB,
+      0x5A, 0x41, 0x08, 0xC3, 0xAA, 0x47, 0x94, 0x0B },
+    { 0xDA, 0x33, 0xDE, 0xF2, 0xA4, 0x2D, 0xF1, 0x39,
+      0x75, 0x35, 0x28, 0x46, 0xC3, 0x03, 0x38, 0xCD },
+    { 0xD5, 0x97, 0x6F, 0x79, 0xD8, 0x3D, 0x3A, 0x0D,
+      0xC9, 0x80, 0x6C, 0x3C, 0x66, 0xF3, 0xEF, 0xD8 }
+};
+
+/*
+ * Checkup routine
+ */
+int mbedtls_md2_self_test( int verbose )
+{
+    int i, ret = 0;
+    unsigned char md2sum[16];
+
+    for( i = 0; i < 7; i++ )
+    {
+        if( verbose != 0 )
+            mbedtls_printf( "  MD2 test #%d: ", i + 1 );
+
+        ret = mbedtls_md2( md2_test_str[i], md2_test_strlen[i], md2sum );
+        if( ret != 0 )
+            goto fail;
+
+        if( memcmp( md2sum, md2_test_sum[i], 16 ) != 0 )
+        {
+            ret = 1;
+            goto fail;
+        }
+
+        if( verbose != 0 )
+            mbedtls_printf( "passed\n" );
+    }
+
+    if( verbose != 0 )
+        mbedtls_printf( "\n" );
+
+    return( 0 );
+
+fail:
+    if( verbose != 0 )
+        mbedtls_printf( "failed\n" );
+
+    return( ret );
+}
+
+#endif /* MBEDTLS_SELF_TEST */
+
+#endif /* MBEDTLS_MD2_C */
\ No newline at end of file
diff --git a/library/md4.c b/library/md4.c
new file mode 100644
index 0000000..75ba74e
--- /dev/null
+++ b/library/md4.c
@@ -0,0 +1,444 @@
+/*
+ *  RFC 1186/1320 compliant MD4 implementation
+ *
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+/*
+ *  The MD4 algorithm was designed by Ron Rivest in 1990.
+ *
+ *  http://www.ietf.org/rfc/rfc1186.txt
+ *  http://www.ietf.org/rfc/rfc1320.txt
+ */
+
+#include "common.h"
+
+#if defined(MBEDTLS_MD4_C)
+
+#include "mbedtls/md4.h"
+#include "mbedtls/platform_util.h"
+#include "mbedtls/error.h"
+
+#include <string.h>
+
+#if defined(MBEDTLS_SELF_TEST)
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
+#include <stdio.h>
+#define mbedtls_printf printf
+#endif /* MBEDTLS_PLATFORM_C */
+#endif /* MBEDTLS_SELF_TEST */
+
+#if !defined(MBEDTLS_MD4_ALT)
+
+/*
+ * 32-bit integer manipulation macros (little endian)
+ */
+#ifndef GET_UINT32_LE
+#define GET_UINT32_LE(n,b,i)                            \
+{                                                       \
+    (n) = ( (uint32_t) (b)[(i)    ]       )             \
+        | ( (uint32_t) (b)[(i) + 1] <<  8 )             \
+        | ( (uint32_t) (b)[(i) + 2] << 16 )             \
+        | ( (uint32_t) (b)[(i) + 3] << 24 );            \
+}
+#endif
+
+#ifndef PUT_UINT32_LE
+#define PUT_UINT32_LE(n,b,i)                                    \
+{                                                               \
+    (b)[(i)    ] = (unsigned char) ( ( (n)       ) & 0xFF );    \
+    (b)[(i) + 1] = (unsigned char) ( ( (n) >>  8 ) & 0xFF );    \
+    (b)[(i) + 2] = (unsigned char) ( ( (n) >> 16 ) & 0xFF );    \
+    (b)[(i) + 3] = (unsigned char) ( ( (n) >> 24 ) & 0xFF );    \
+}
+#endif
+
+void mbedtls_md4_init( mbedtls_md4_context *ctx )
+{
+    memset( ctx, 0, sizeof( mbedtls_md4_context ) );
+}
+
+void mbedtls_md4_free( mbedtls_md4_context *ctx )
+{
+    if( ctx == NULL )
+        return;
+
+    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md4_context ) );
+}
+
+void mbedtls_md4_clone( mbedtls_md4_context *dst,
+                        const mbedtls_md4_context *src )
+{
+    *dst = *src;
+}
+
+/*
+ * MD4 context setup
+ */
+int mbedtls_md4_starts( mbedtls_md4_context *ctx )
+{
+    ctx->total[0] = 0;
+    ctx->total[1] = 0;
+
+    ctx->state[0] = 0x67452301;
+    ctx->state[1] = 0xEFCDAB89;
+    ctx->state[2] = 0x98BADCFE;
+    ctx->state[3] = 0x10325476;
+
+    return( 0 );
+}
+
+#if !defined(MBEDTLS_MD4_PROCESS_ALT)
+int mbedtls_internal_md4_process( mbedtls_md4_context *ctx,
+                                  const unsigned char data[64] )
+{
+    struct
+    {
+        uint32_t X[16], A, B, C, D;
+    } local;
+
+    GET_UINT32_LE( local.X[ 0], data,  0 );
+    GET_UINT32_LE( local.X[ 1], data,  4 );
+    GET_UINT32_LE( local.X[ 2], data,  8 );
+    GET_UINT32_LE( local.X[ 3], data, 12 );
+    GET_UINT32_LE( local.X[ 4], data, 16 );
+    GET_UINT32_LE( local.X[ 5], data, 20 );
+    GET_UINT32_LE( local.X[ 6], data, 24 );
+    GET_UINT32_LE( local.X[ 7], data, 28 );
+    GET_UINT32_LE( local.X[ 8], data, 32 );
+    GET_UINT32_LE( local.X[ 9], data, 36 );
+    GET_UINT32_LE( local.X[10], data, 40 );
+    GET_UINT32_LE( local.X[11], data, 44 );
+    GET_UINT32_LE( local.X[12], data, 48 );
+    GET_UINT32_LE( local.X[13], data, 52 );
+    GET_UINT32_LE( local.X[14], data, 56 );
+    GET_UINT32_LE( local.X[15], data, 60 );
+
+#define S(x,n) (((x) << (n)) | (((x) & 0xFFFFFFFF) >> (32 - (n))))
+
+    local.A = ctx->state[0];
+    local.B = ctx->state[1];
+    local.C = ctx->state[2];
+    local.D = ctx->state[3];
+
+#define F(x, y, z) (((x) & (y)) | ((~(x)) & (z)))
+#define P(a,b,c,d,x,s)                           \
+    do                                           \
+    {                                            \
+        (a) += F((b),(c),(d)) + (x);             \
+        (a) = S((a),(s));                        \
+    } while( 0 )
+
+
+    P( local.A, local.B, local.C, local.D, local.X[ 0],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 1],  7 );
+    P( local.C, local.D, local.A, local.B, local.X[ 2], 11 );
+    P( local.B, local.C, local.D, local.A, local.X[ 3], 19 );
+    P( local.A, local.B, local.C, local.D, local.X[ 4],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 5],  7 );
+    P( local.C, local.D, local.A, local.B, local.X[ 6], 11 );
+    P( local.B, local.C, local.D, local.A, local.X[ 7], 19 );
+    P( local.A, local.B, local.C, local.D, local.X[ 8],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 9],  7 );
+    P( local.C, local.D, local.A, local.B, local.X[10], 11 );
+    P( local.B, local.C, local.D, local.A, local.X[11], 19 );
+    P( local.A, local.B, local.C, local.D, local.X[12],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[13],  7 );
+    P( local.C, local.D, local.A, local.B, local.X[14], 11 );
+    P( local.B, local.C, local.D, local.A, local.X[15], 19 );
+
+#undef P
+#undef F
+
+#define F(x,y,z) (((x) & (y)) | ((x) & (z)) | ((y) & (z)))
+#define P(a,b,c,d,x,s)                          \
+    do                                          \
+    {                                           \
+        (a) += F((b),(c),(d)) + (x) + 0x5A827999;       \
+        (a) = S((a),(s));                               \
+    } while( 0 )
+
+    P( local.A, local.B, local.C, local.D, local.X[ 0],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 4],  5 );
+    P( local.C, local.D, local.A, local.B, local.X[ 8],  9 );
+    P( local.B, local.C, local.D, local.A, local.X[12], 13 );
+    P( local.A, local.B, local.C, local.D, local.X[ 1],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 5],  5 );
+    P( local.C, local.D, local.A, local.B, local.X[ 9],  9 );
+    P( local.B, local.C, local.D, local.A, local.X[13], 13 );
+    P( local.A, local.B, local.C, local.D, local.X[ 2],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 6],  5 );
+    P( local.C, local.D, local.A, local.B, local.X[10],  9 );
+    P( local.B, local.C, local.D, local.A, local.X[14], 13 );
+    P( local.A, local.B, local.C, local.D, local.X[ 3],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 7],  5 );
+    P( local.C, local.D, local.A, local.B, local.X[11],  9 );
+    P( local.B, local.C, local.D, local.A, local.X[15], 13 );
+
+#undef P
+#undef F
+
+#define F(x,y,z) ((x) ^ (y) ^ (z))
+#define P(a,b,c,d,x,s)                                  \
+    do                                                  \
+    {                                                   \
+        (a) += F((b),(c),(d)) + (x) + 0x6ED9EBA1;       \
+        (a) = S((a),(s));                               \
+    } while( 0 )
+
+    P( local.A, local.B, local.C, local.D, local.X[ 0],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 8],  9 );
+    P( local.C, local.D, local.A, local.B, local.X[ 4], 11 );
+    P( local.B, local.C, local.D, local.A, local.X[12], 15 );
+    P( local.A, local.B, local.C, local.D, local.X[ 2],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[10],  9 );
+    P( local.C, local.D, local.A, local.B, local.X[ 6], 11 );
+    P( local.B, local.C, local.D, local.A, local.X[14], 15 );
+    P( local.A, local.B, local.C, local.D, local.X[ 1],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[ 9],  9 );
+    P( local.C, local.D, local.A, local.B, local.X[ 5], 11 );
+    P( local.B, local.C, local.D, local.A, local.X[13], 15 );
+    P( local.A, local.B, local.C, local.D, local.X[ 3],  3 );
+    P( local.D, local.A, local.B, local.C, local.X[11],  9 );
+    P( local.C, local.D, local.A, local.B, local.X[ 7], 11 );
+    P( local.B, local.C, local.D, local.A, local.X[15], 15 );
+
+#undef F
+#undef P
+
+    ctx->state[0] += local.A;
+    ctx->state[1] += local.B;
+    ctx->state[2] += local.C;
+    ctx->state[3] += local.D;
+
+    /* Zeroise variables to clear sensitive data from memory. */
+    mbedtls_platform_zeroize( &local, sizeof( local ) );
+
+    return( 0 );
+}
+
+#endif /* !MBEDTLS_MD4_PROCESS_ALT */
+
+/*
+ * MD4 process buffer
+ */
+int mbedtls_md4_update( mbedtls_md4_context *ctx,
+                            const unsigned char *input,
+                            size_t ilen )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t fill;
+    uint32_t left;
+
+    if( ilen == 0 )
+        return( 0 );
+
+    left = ctx->total[0] & 0x3F;
+    fill = 64 - left;
+
+    ctx->total[0] += (uint32_t) ilen;
+    ctx->total[0] &= 0xFFFFFFFF;
+
+    if( ctx->total[0] < (uint32_t) ilen )
+        ctx->total[1]++;
+
+    if( left && ilen >= fill )
+    {
+        memcpy( (void *) (ctx->buffer + left),
+                (void *) input, fill );
+
+        if( ( ret = mbedtls_internal_md4_process( ctx, ctx->buffer ) ) != 0 )
+            return( ret );
+
+        input += fill;
+        ilen  -= fill;
+        left = 0;
+    }
+
+    while( ilen >= 64 )
+    {
+        if( ( ret = mbedtls_internal_md4_process( ctx, input ) ) != 0 )
+            return( ret );
+
+        input += 64;
+        ilen  -= 64;
+    }
+
+    if( ilen > 0 )
+    {
+        memcpy( (void *) (ctx->buffer + left),
+                (void *) input, ilen );
+    }
+
+    return( 0 );
+}
+
+static const unsigned char md4_padding[64] =
+{
+ 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*
+ * MD4 final digest
+ */
+int mbedtls_md4_finish( mbedtls_md4_context *ctx,
+                            unsigned char output[16] )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    uint32_t last, padn;
+    uint32_t high, low;
+    unsigned char msglen[8];
+
+    high = ( ctx->total[0] >> 29 )
+         | ( ctx->total[1] <<  3 );
+    low  = ( ctx->total[0] <<  3 );
+
+    PUT_UINT32_LE( low,  msglen, 0 );
+    PUT_UINT32_LE( high, msglen, 4 );
+
+    last = ctx->total[0] & 0x3F;
+    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
+
+    ret = mbedtls_md4_update( ctx, (unsigned char *)md4_padding, padn );
+    if( ret != 0 )
+        return( ret );
+
+    if( ( ret = mbedtls_md4_update( ctx, msglen, 8 ) ) != 0 )
+        return( ret );
+
+
+    PUT_UINT32_LE( ctx->state[0], output,  0 );
+    PUT_UINT32_LE( ctx->state[1], output,  4 );
+    PUT_UINT32_LE( ctx->state[2], output,  8 );
+    PUT_UINT32_LE( ctx->state[3], output, 12 );
+
+    return( 0 );
+}
+
+#endif /* !MBEDTLS_MD4_ALT */
+
+/*
+ * output = MD4( input buffer )
+ */
+int mbedtls_md4( const unsigned char *input,
+                     size_t ilen,
+                     unsigned char output[16] )
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    mbedtls_md4_context ctx;
+
+    mbedtls_md4_init( &ctx );
+
+    if( ( ret = mbedtls_md4_starts( &ctx ) ) != 0 )
+        goto exit;
+
+    if( ( ret = mbedtls_md4_update( &ctx, input, ilen ) ) != 0 )
+        goto exit;
+
+    if( ( ret = mbedtls_md4_finish( &ctx, output ) ) != 0 )
+        goto exit;
+
+exit:
+    mbedtls_md4_free( &ctx );
+
+    return( ret );
+}
+
+#if defined(MBEDTLS_SELF_TEST)
+
+/*
+ * RFC 1320 test vectors
+ */
+static const unsigned char md4_test_str[7][81] =
+{
+    { "" },
+    { "a" },
+    { "abc" },
+    { "message digest" },
+    { "abcdefghijklmnopqrstuvwxyz" },
+    { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" },
+    { "12345678901234567890123456789012345678901234567890123456789012345678901234567890" }
+};
+
+static const size_t md4_test_strlen[7] =
+{
+    0, 1, 3, 14, 26, 62, 80
+};
+
+static const unsigned char md4_test_sum[7][16] =
+{
+    { 0x31, 0xD6, 0xCF, 0xE0, 0xD1, 0x6A, 0xE9, 0x31,
+      0xB7, 0x3C, 0x59, 0xD7, 0xE0, 0xC0, 0x89, 0xC0 },
+    { 0xBD, 0xE5, 0x2C, 0xB3, 0x1D, 0xE3, 0x3E, 0x46,
+      0x24, 0x5E, 0x05, 0xFB, 0xDB, 0xD6, 0xFB, 0x24 },
+    { 0xA4, 0x48, 0x01, 0x7A, 0xAF, 0x21, 0xD8, 0x52,
+      0x5F, 0xC1, 0x0A, 0xE8, 0x7A, 0xA6, 0x72, 0x9D },
+    { 0xD9, 0x13, 0x0A, 0x81, 0x64, 0x54, 0x9F, 0xE8,
+      0x18, 0x87, 0x48, 0x06, 0xE1, 0xC7, 0x01, 0x4B },
+    { 0xD7, 0x9E, 0x1C, 0x30, 0x8A, 0xA5, 0xBB, 0xCD,
+      0xEE, 0xA8, 0xED, 0x63, 0xDF, 0x41, 0x2D, 0xA9 },
+    { 0x04, 0x3F, 0x85, 0x82, 0xF2, 0x41, 0xDB, 0x35,
+      0x1C, 0xE6, 0x27, 0xE1, 0x53, 0xE7, 0xF0, 0xE4 },
+    { 0xE3, 0x3B, 0x4D, 0xDC, 0x9C, 0x38, 0xF2, 0x19,
+      0x9C, 0x3E, 0x7B, 0x16, 0x4F, 0xCC, 0x05, 0x36 }
+};
+
+/*
+ * Checkup routine
+ */
+int mbedtls_md4_self_test( int verbose )
+{
+    int i, ret = 0;
+    unsigned char md4sum[16];
+
+    for( i = 0; i < 7; i++ )
+    {
+        if( verbose != 0 )
+            mbedtls_printf( "  MD4 test #%d: ", i + 1 );
+
+        ret = mbedtls_md4( md4_test_str[i], md4_test_strlen[i], md4sum );
+        if( ret != 0 )
+            goto fail;
+
+        if( memcmp( md4sum, md4_test_sum[i], 16 ) != 0 )
+        {
+            ret = 1;
+            goto fail;
+        }
+
+        if( verbose != 0 )
+            mbedtls_printf( "passed\n" );
+    }
+
+    if( verbose != 0 )
+        mbedtls_printf( "\n" );
+
+    return( 0 );
+
+fail:
+    if( verbose != 0 )
+        mbedtls_printf( "failed\n" );
+
+    return( ret );
+}
+
+#endif /* MBEDTLS_SELF_TEST */
+
+#endif /* MBEDTLS_MD4_C */
\ No newline at end of file
diff --git a/library/oid.c b/library/oid.c
index 1d6b1eb..a2793f9 100644
--- a/library/oid.c
+++ b/library/oid.c
@@ -19,6 +19,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#if defined(HUAWEI_POLARSSL_API_C)
+#include "mbedtls/hw_polarssl_api.h"
+#endif
+
 #include "mbedtls/platform.h"
 
 /*
@@ -92,6 +96,7 @@
  * Macro to generate a function for retrieving two attributes from an
  * mbedtls_oid_descriptor_t wrapper.
  */
+#if defined(HUAWEI_POLARSSL_API_C)
 #define FN_OID_GET_ATTR2(FN_NAME, TYPE_T, TYPE_NAME, ATTR1_TYPE, ATTR1,     \
                          ATTR2_TYPE, ATTR2)                                 \
     int FN_NAME(const mbedtls_asn1_buf *oid, ATTR1_TYPE * ATTR1,               \
@@ -101,8 +106,22 @@
         if (data == NULL) return MBEDTLS_ERR_OID_NOT_FOUND;                 \
         *(ATTR1) = data->ATTR1;                                                 \
         *(ATTR2) = data->ATTR2;                                                 \
+    if( polarssl_dgst_check(*(ATTR1)) != 0 ) return( MBEDTLS_ERR_OID_NOT_FOUND );   \
         return 0;                                                            \
     }
+#else
+#define FN_OID_GET_ATTR2(FN_NAME, TYPE_T, TYPE_NAME, ATTR1_TYPE, ATTR1,     \
+                         ATTR2_TYPE, ATTR2)                                 \
+int FN_NAME( const mbedtls_asn1_buf *oid, ATTR1_TYPE * ATTR1,               \
+                                          ATTR2_TYPE * ATTR2 )              \
+{                                                                           \
+    const TYPE_T *data = oid_ ## TYPE_NAME ## _from_asn1( oid );            \
+    if( data == NULL ) return( MBEDTLS_ERR_OID_NOT_FOUND );                 \
+    *(ATTR1) = data->ATTR1;                                                 \
+    *(ATTR2) = data->ATTR2;                                                 \
+    return( 0 );                                                            \
+}
+#endif
 
 /*
  * Macro to generate a function for retrieving the OID based on a single
@@ -127,12 +146,14 @@
  * Macro to generate a function for retrieving the OID based on two
  * attributes from a mbedtls_oid_descriptor_t wrapper.
  */
+#if defined(HUAWEI_POLARSSL_API_C)
 #define FN_OID_GET_OID_BY_ATTR2(FN_NAME, TYPE_T, LIST, ATTR1_TYPE, ATTR1,   \
                                 ATTR2_TYPE, ATTR2)                          \
     int FN_NAME(ATTR1_TYPE ATTR1, ATTR2_TYPE ATTR2, const char **oid,         \
                 size_t *olen)                                                 \
     {                                                                           \
         const TYPE_T *cur = (LIST);                                             \
+    if( polarssl_dgst_check((ATTR2)) != 0 ) return( MBEDTLS_ERR_OID_NOT_FOUND );   \
         while (cur->descriptor.asn1 != NULL) {                                 \
             if (cur->ATTR1 == (ATTR1) && cur->ATTR2 == (ATTR2)) {              \
                 *oid = cur->descriptor.asn1;                                    \
@@ -143,6 +164,24 @@
         }                                                                       \
         return MBEDTLS_ERR_OID_NOT_FOUND;                                   \
     }
+#else
+#define FN_OID_GET_OID_BY_ATTR2(FN_NAME, TYPE_T, LIST, ATTR1_TYPE, ATTR1,   \
+                                ATTR2_TYPE, ATTR2)                          \
+int FN_NAME( ATTR1_TYPE ATTR1, ATTR2_TYPE ATTR2, const char **oid ,         \
+             size_t *olen )                                                 \
+{                                                                           \
+    const TYPE_T *cur = (LIST);                                             \
+    while( cur->descriptor.asn1 != NULL ) {                                 \
+        if( cur->ATTR1 == (ATTR1) && cur->ATTR2 == (ATTR2) ) {              \
+            *oid = cur->descriptor.asn1;                                    \
+            *olen = cur->descriptor.asn1_len;                               \
+            return( 0 );                                                    \
+        }                                                                   \
+        cur++;                                                              \
+    }                                                                       \
+    return( MBEDTLS_ERR_OID_NOT_FOUND );                                   \
+}
+#endif
 
 /*
  * For X520 attribute types
@@ -379,6 +418,18 @@ typedef struct {
 static const oid_sig_alg_t oid_sig_alg[] =
 {
 #if defined(MBEDTLS_RSA_C)
+#if defined(MBEDTLS_MD2_C)
+    {
+        OID_DESCRIPTOR( MBEDTLS_OID_PKCS1_MD2,        "md2WithRSAEncryption",     "RSA with MD2" ),
+        MBEDTLS_MD_MD2,      MBEDTLS_PK_RSA,
+    },
+#endif /* MBEDTLS_MD2_C */
+#if defined(MBEDTLS_MD4_C)
+    {
+        OID_DESCRIPTOR( MBEDTLS_OID_PKCS1_MD4,        "md4WithRSAEncryption",     "RSA with MD4" ),
+        MBEDTLS_MD_MD4,      MBEDTLS_PK_RSA,
+    },
+#endif /* MBEDTLS_MD4_C */
 #if defined(MBEDTLS_MD_CAN_MD5)
     {
         OID_DESCRIPTOR(MBEDTLS_OID_PKCS1_MD5,        "md5WithRSAEncryption",     "RSA with MD5"),
@@ -719,6 +770,18 @@ typedef struct {
 
 static const oid_md_alg_t oid_md_alg[] =
 {
+#if defined(MBEDTLS_MD2_C)
+    {
+        OID_DESCRIPTOR( MBEDTLS_OID_DIGEST_ALG_MD2,       "id-md2",       "MD2" ),
+        MBEDTLS_MD_MD2,
+    },
+#endif /* MBEDTLS_MD2_C */
+#if defined(MBEDTLS_MD4_C)
+    {
+        OID_DESCRIPTOR( MBEDTLS_OID_DIGEST_ALG_MD4,       "id-md4",       "MD4" ),
+        MBEDTLS_MD_MD4,
+    },
+#endif /* MBEDTLS_MD4_C */
 #if defined(MBEDTLS_MD_CAN_MD5)
     {
         OID_DESCRIPTOR(MBEDTLS_OID_DIGEST_ALG_MD5,       "id-md5",       "MD5"),
diff --git a/library/pkcs5.c b/library/pkcs5.c
index c6c5305..b58e5ae 100644
--- a/library/pkcs5.c
+++ b/library/pkcs5.c
@@ -354,7 +354,7 @@ cleanup:
     return ret;
 }
 
-#if !defined(MBEDTLS_DEPRECATED_REMOVED)
+#if !defined(MBEDTLS_DEPRECATED_REMOVED) && !defined(MBEDTLS_PBKDF2_HMAC_ALT)
 int mbedtls_pkcs5_pbkdf2_hmac(mbedtls_md_context_t *ctx,
                               const unsigned char *password,
                               size_t plen, const unsigned char *salt, size_t slen,
@@ -364,7 +364,7 @@ int mbedtls_pkcs5_pbkdf2_hmac(mbedtls_md_context_t *ctx,
     return pkcs5_pbkdf2_hmac(ctx, password, plen, salt, slen, iteration_count,
                              key_length, output);
 }
-#endif
+#endif  /* !MBEDTLS_PBKDF2_HMAC_ALT */
 
 int mbedtls_pkcs5_pbkdf2_hmac_ext(mbedtls_md_type_t md_alg,
                                   const unsigned char *password,
diff --git a/library/rsa.c b/library/rsa.c
index 7eb4a25..e795f63 100644
--- a/library/rsa.c
+++ b/library/rsa.c
@@ -42,8 +42,10 @@
 #include <string.h>
 
 #if defined(MBEDTLS_PKCS1_V15) && !defined(__OpenBSD__) && !defined(__NetBSD__)
+#if !defined(HUAWEI_ONT_RSA_C)
 #include <stdlib.h>
 #endif
+#endif
 
 #include "mbedtls/platform.h"
 
@@ -2141,10 +2143,13 @@ static int rsa_rsassa_pss_sign_no_mode_check(mbedtls_rsa_context *ctx,
         if (exp_hashlen == 0) {
             return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
         }
-
+#if defined(HUAWEI_ONT_RSA_C)
+        hashlen = exp_hashlen;
+#else
         if (hashlen != exp_hashlen) {
             return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
         }
+#endif
     }
 
     hash_id = (mbedtls_md_type_t) ctx->hash_id;
@@ -2326,10 +2331,13 @@ static int rsa_rsassa_pkcs1_v15_encode(mbedtls_md_type_t md_alg,
         if (mbedtls_oid_get_oid_by_md(md_alg, &oid, &oid_size) != 0) {
             return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
         }
-
+        #if defined(HUAWEI_ONT_RSA_C)
+        hashlen = md_size;
+        #else
         if (hashlen != md_size) {
             return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
         }
+        #endif
 
         /* Double-check that 8 + hashlen + oid_size can be used as a
          * 1-byte ASN.1 length encoding and that there's no overflow. */
@@ -2571,10 +2579,13 @@ int mbedtls_rsa_rsassa_pss_verify_ext(mbedtls_rsa_context *ctx,
         if (exp_hashlen == 0) {
             return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
         }
-
+        #if defined(HUAWEI_ONT_RSA_C)
+        hashlen = exp_hashlen;
+        #else
         if (hashlen != exp_hashlen) {
             return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
         }
+        #endif
     }
 
     hlen = mbedtls_md_get_size_from_type(mgf1_hash_id);
diff --git a/library/ssl_client.c b/library/ssl_client.c
index 345e608..130a6a3 100644
--- a/library/ssl_client.c
+++ b/library/ssl_client.c
@@ -23,6 +23,60 @@
 
 #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
 MBEDTLS_CHECK_RETURN_CRITICAL
+
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C) || \
+    defined(HUAWEI_ONT_TLS_CERT_FAILED_NOTICE_C) || \
+    defined(HUAWEI_ONT_SSL_WRITE_HOSTNAME_C)
+#include "mbedtls/crypto_api.h"
+#endif
+
+#if defined(HUAWEI_ONT_SSL_WRITE_HOSTNAME_C)
+extern mbedtls_ssl_sni sni_use;
+int ssl_write_hostname_ext( mbedtls_ssl_context *ssl,
+                                    unsigned char *buf,
+                                    const unsigned char *end,
+                                    size_t *olen )
+{
+    unsigned char *p = buf;
+    size_t hostname_len;
+
+    *olen = 0;
+
+    if( sni_use.send_sni == 0 || strlen(sni_use.hostname) == 0 )
+        return( 0 );
+
+    MBEDTLS_SSL_DEBUG_MSG( 3,
+        ( "client hello, adding server name extension: %s",
+          sni_use.hostname ) );
+
+    hostname_len = strlen( sni_use.hostname );
+
+    MBEDTLS_SSL_CHK_BUF_PTR( p, end, hostname_len + 9 );
+
+    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SERVERNAME, p, 0 );
+    p += 2;
+
+    MBEDTLS_PUT_UINT16_BE( hostname_len + 5, p, 0 );
+    p += 2;
+
+    MBEDTLS_PUT_UINT16_BE( hostname_len + 3, p, 0 );
+    p += 2;
+
+    *p++ = MBEDTLS_BYTE_0( MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME );
+
+    MBEDTLS_PUT_UINT16_BE( hostname_len, p, 0 );
+    p += 2;
+
+    memcpy( p, sni_use.hostname, hostname_len );
+
+    *olen = hostname_len + 9;
+
+#if defined(MBEDTLS_SSL_PROTO_TLS1_3)
+    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_SERVERNAME);
+#endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
+    return 0;
+}
+#else
 static int ssl_write_hostname_ext(mbedtls_ssl_context *ssl,
                                   unsigned char *buf,
                                   const unsigned char *end,
@@ -94,6 +148,7 @@ static int ssl_write_hostname_ext(mbedtls_ssl_context *ssl,
 #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
     return 0;
 }
+#endif
 #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
 
 #if defined(MBEDTLS_SSL_ALPN)
@@ -111,6 +166,16 @@ static int ssl_write_hostname_ext(mbedtls_ssl_context *ssl,
  *
  */
 MBEDTLS_CHECK_RETURN_CRITICAL
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C)
+static int ssl_write_alpn_ext( mbedtls_ssl_context *ssl,
+                               unsigned char *buf,
+                               const unsigned char *end,
+                               size_t *olen )
+{
+    *olen = 0;
+    return( 0 );
+}
+#else
 static int ssl_write_alpn_ext(mbedtls_ssl_context *ssl,
                               unsigned char *buf,
                               const unsigned char *end,
@@ -168,6 +233,7 @@ static int ssl_write_alpn_ext(mbedtls_ssl_context *ssl,
 #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
     return 0;
 }
+#endif
 #endif /* MBEDTLS_SSL_ALPN */
 
 #if defined(MBEDTLS_SSL_TLS1_2_SOME_ECC) || \
diff --git a/library/ssl_tls12_client.c b/library/ssl_tls12_client.c
index eac6a3a..b7a2f83 100644
--- a/library/ssl_tls12_client.c
+++ b/library/ssl_tls12_client.c
@@ -34,6 +34,12 @@ static int local_err_translation(psa_status_t status)
 #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
 #endif /* MBEDTLS_USE_PSA_CRYPTO */
 
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C) || \
+    defined(HUAWEI_ONT_TLS_CERT_FAILED_NOTICE_C) || \
+    defined(HUAWEI_ONT_SSL_WRITE_HOSTNAME_C)
+#include "mbedtls/crypto_api.h"
+#endif
+
 #include <string.h>
 
 #include <stdint.h>
@@ -48,6 +54,19 @@ static int local_err_translation(psa_status_t status)
 
 #if defined(MBEDTLS_SSL_RENEGOTIATION)
 MBEDTLS_CHECK_RETURN_CRITICAL
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C)
+static int ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,
+                                        unsigned char *buf,
+                                        const unsigned char *end,
+                                        size_t *olen )
+{
+    (void)ssl;
+    (void)buf;
+    (void)end;
+    *olen = 0;
+    return( 0 );
+}
+#else
 static int ssl_write_renegotiation_ext(mbedtls_ssl_context *ssl,
                                        unsigned char *buf,
                                        const unsigned char *end,
@@ -85,6 +104,7 @@ static int ssl_write_renegotiation_ext(mbedtls_ssl_context *ssl,
 
     return 0;
 }
+#endif
 #endif /* MBEDTLS_SSL_RENEGOTIATION */
 
 #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
@@ -125,6 +145,16 @@ static int ssl_write_supported_point_formats_ext(mbedtls_ssl_context *ssl,
 
 #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
 MBEDTLS_CHECK_RETURN_CRITICAL
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C)
+static int ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
+                                       unsigned char *buf,
+                                       const unsigned char *end,
+                                       size_t *olen )
+{
+    *olen = 0;
+    return( 0 );
+}
+#else
 static int ssl_write_ecjpake_kkpp_ext(mbedtls_ssl_context *ssl,
                                       unsigned char *buf,
                                       const unsigned char *end,
@@ -209,6 +239,7 @@ static int ssl_write_ecjpake_kkpp_ext(mbedtls_ssl_context *ssl,
 
     return 0;
 }
+#endif
 #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
 
 #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
@@ -256,6 +287,19 @@ static int ssl_write_cid_ext(mbedtls_ssl_context *ssl,
 
 #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
 MBEDTLS_CHECK_RETURN_CRITICAL
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C)
+static int ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
+                                              unsigned char *buf,
+                                              const unsigned char *end,
+                                              size_t *olen )
+{
+    (void)ssl;
+    (void)buf;
+    (void)end;
+    *olen = 0;
+    return( 0 );
+}
+#else
 static int ssl_write_max_fragment_length_ext(mbedtls_ssl_context *ssl,
                                              unsigned char *buf,
                                              const unsigned char *end,
@@ -286,10 +330,21 @@ static int ssl_write_max_fragment_length_ext(mbedtls_ssl_context *ssl,
 
     return 0;
 }
+#endif
 #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
 
 #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
 MBEDTLS_CHECK_RETURN_CRITICAL
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C)
+static int ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
+                                           unsigned char *buf,
+                                           const unsigned char *end,
+                                           size_t *olen )
+{
+    *olen = 0;
+    return( 0 );
+}
+#else
 static int ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context *ssl,
                                           unsigned char *buf,
                                           const unsigned char *end,
@@ -318,10 +373,24 @@ static int ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context *ssl,
 
     return 0;
 }
+#endif
 #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
 
 #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
 MBEDTLS_CHECK_RETURN_CRITICAL
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C)
+static int ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
+                                      unsigned char *buf,
+                                      const unsigned char *end,
+                                      size_t *olen )
+{
+    (void)ssl;
+    (void)buf;
+    (void)end;
+    *olen = 0;
+    return( 0 );
+}
+#else
 static int ssl_write_extended_ms_ext(mbedtls_ssl_context *ssl,
                                      unsigned char *buf,
                                      const unsigned char *end,
@@ -350,10 +419,24 @@ static int ssl_write_extended_ms_ext(mbedtls_ssl_context *ssl,
 
     return 0;
 }
+#endif
 #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
 
 #if defined(MBEDTLS_SSL_SESSION_TICKETS)
 MBEDTLS_CHECK_RETURN_CRITICAL
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C)
+static int ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
+                                         unsigned char *buf,
+                                         const unsigned char *end,
+                                         size_t *olen )
+{
+    (void)ssl;
+    (void)buf;
+    (void)end;
+    *olen = 0;
+    return( 0 );
+}
+#else
 static int ssl_write_session_ticket_ext(mbedtls_ssl_context *ssl,
                                         unsigned char *buf,
                                         const unsigned char *end,
@@ -395,6 +478,7 @@ static int ssl_write_session_ticket_ext(mbedtls_ssl_context *ssl,
 
     return 0;
 }
+#endif
 #endif /* MBEDTLS_SSL_SESSION_TICKETS */
 
 #if defined(MBEDTLS_SSL_DTLS_SRTP)
@@ -1804,6 +1888,13 @@ static int ssl_check_server_ecdh_params(const mbedtls_ssl_context *ssl)
                               mbedtls_ssl_get_curve_name_from_tls_id(tls_id)));
 
     if (mbedtls_ssl_check_curve(ssl, grp_id) != 0) {
+#if defined(HUAWEI_ONT_CUSTOMIZE_SSL_CLIENT_HELLO_C)
+        if ( ssl_deprecated_kexsize_support() == 0)
+        {
+            MBEDTLS_SSL_DEBUG_MSG( 1, ( "mbedtls_ecdh_read_params size error" ) );
+            return ( -1 );
+        }
+#endif
         return -1;
     }
 
@@ -3521,6 +3612,16 @@ int mbedtls_ssl_handshake_client_step(mbedtls_ssl_context *ssl)
 
         case MBEDTLS_SSL_SERVER_CERTIFICATE:
             ret = mbedtls_ssl_parse_certificate(ssl);
+#if defined(HUAWEI_ONT_TLS_CERT_FAILED_NOTICE_C)
+                if ( ( ret != 0 ) && ( polarssl_get_caupdate() != 0 ) )
+                {
+                        MBEDTLS_SSL_DEBUG_MSG( 1, ( "scp [ssl]handshake: failed try to fetch" ) );
+                        FILE *file = fopen("/var/certificatefaild","a+");
+                        if ( file == NULL )
+                            break;
+                        fclose(file);
+                }
+#endif
             break;
 
         case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
diff --git a/library/ssl_tls12_server.c b/library/ssl_tls12_server.c
index b49a8ae..1f7c620 100644
--- a/library/ssl_tls12_server.c
+++ b/library/ssl_tls12_server.c
@@ -21,6 +21,10 @@
 
 #include <string.h>
 
+#if defined(HUAWEI_ONT_TLS_CERT_FAILED_NOTICE_C)
+#include "mbedtls/crypto_api.h"
+#endif
+
 #if defined(MBEDTLS_USE_PSA_CRYPTO)
 /* Define a local translating function to save code size by not using too many
  * arguments in each translating place. */
@@ -833,7 +837,9 @@ static int ssl_ciphersuite_match(mbedtls_ssl_context *ssl, int suite_id,
          ssl->handshake->curves_tls_id[0] == 0)) {
         MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite mismatch: "
                                   "no common elliptic curve"));
-        return 0;
+#if !defined(HUAWEI_ONT_CUSTOMIZE_SSL_CIPHERSUIE_MATCH_C)
+        return ( 0 );
+#endif
     }
 #endif
 
@@ -4348,6 +4354,16 @@ int mbedtls_ssl_handshake_server_step(mbedtls_ssl_context *ssl)
 
         case MBEDTLS_SSL_SERVER_CERTIFICATE:
             ret = mbedtls_ssl_write_certificate(ssl);
+#if defined(HUAWEI_ONT_TLS_CERT_FAILED_NOTICE_C)
+            if ( ( ret != 0 ) && ( polarssl_get_caupdate() != 0 ) )
+            {
+                    MBEDTLS_SSL_DEBUG_MSG( 1, ( "scp [ssl]handshake: failed try to fetch" ) );
+                    FILE *file = fopen("/var/certificatefaild","a+");
+                    if ( file == NULL )
+                        break;
+                    fclose(file);
+            }
+#endif
             break;
 
         case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
diff --git a/library/x509.c b/library/x509.c
index f97fb44..700bf92 100644
--- a/library/x509.c
+++ b/library/x509.c
@@ -43,6 +43,10 @@
 #include <time.h>
 #endif
 
+#if defined(HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C)
+#include "mbedtls/hw_polarssl_api.h"
+#endif
+
 #define CHECK(code)                                     \
     do {                                                \
         if ((ret = (code)) != 0) {                      \
@@ -1036,6 +1040,11 @@ int mbedtls_x509_key_size_helper(char *buf, size_t buf_size, const char *name)
 int mbedtls_x509_time_cmp(const mbedtls_x509_time *t1,
                           const mbedtls_x509_time *t2)
 {
+#if defined(HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C)
+    if (polarssl_get_checktime() == 0) {
+        return -1; // 适配当前逻辑，应返回-1
+    }
+#endif
     int x;
 
     x = (((t1->year << 9) | (t1->mon << 5) | (t1->day)) -
diff --git a/library/x509_crt.c b/library/x509_crt.c
index 2fd56fb..224b67f 100644
--- a/library/x509_crt.c
+++ b/library/x509_crt.c
@@ -69,6 +69,49 @@
 #endif /* !_WIN32 || EFIX64 || EFI32 */
 #endif
 
+/*****************************************************************************
+ * @brief 华为定制特性：支持证书、CRL有效期的有条件忽略。具体的条件由产品自己实现。
+ * 
+******************************************************************************/
+#if defined(HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C)
+
+/*****************************************************************************
+ * @brief 华为定制特性，有条件忽略证书有效期，产品注册回调函数校验。
+ * 
+******************************************************************************/
+hw_mbedtls_cert_date_checker g_mbedtls_customize_cert_date_checker = NULL;
+
+/*****************************************************************************
+ * @brief 华为定制特性，有条件忽略CRL有效期，产品注册回调函数校验。
+ * 
+******************************************************************************/
+hw_mbedtls_crl_date_checker g_mbedtls_customize_crl_date_checker = NULL;
+
+/*****************************************************************************
+ * @brief 
+ * 
+ * @param checker 
+ * @return int 
+******************************************************************************/
+int hw_mbedtls_regist_cert_date_chcker(hw_mbedtls_cert_date_checker checker)
+{
+    g_mbedtls_customize_cert_date_checker = checker;
+    return 0;
+}
+
+/*****************************************************************************
+ * \brief 
+ * 
+ * \param checker 
+ * \return int 
+******************************************************************************/
+int hw_mbedtls_regist_crl_date_chcker(hw_mbedtls_crl_date_checker checker)
+{
+    g_mbedtls_customize_crl_date_checker = checker;
+    return 0;
+}
+#endif
+
 /*
  * Item in a verification chain: cert and flags for it
  */
@@ -2086,6 +2129,25 @@ static int x509_crt_verifycrl(mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,
             break;
         }
 
+#if defined(HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C)
+        /* 华为定制处理，是否定制校验证书有效期，回调业务函数自己处理 */
+        if (g_mbedtls_customize_crl_date_checker != NULL)
+        {
+            flags |= g_mbedtls_customize_crl_date_checker(crl_list);
+        }
+        else    // 没有注册处理函数，按默认规则处理
+        {
+#if defined(MBEDTLS_HAVE_TIME_DATE)
+            if (mbedtls_x509_time_cmp(&crl_list->next_update, now) < 0) {
+                flags |= MBEDTLS_X509_BADCRL_EXPIRED;
+            }
+
+            if (mbedtls_x509_time_cmp(&crl_list->this_update, now) > 0) {
+                flags |= MBEDTLS_X509_BADCRL_FUTURE;
+            }
+#endif
+        }
+#else
 #if defined(MBEDTLS_HAVE_TIME_DATE)
         /*
          * Check for validity of CRL (Do not drop out)
@@ -2099,6 +2161,7 @@ static int x509_crt_verifycrl(mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,
         }
 #else
         ((void) now);
+#endif
 #endif
 
         /*
@@ -2321,6 +2384,38 @@ check_signature:
             continue;
         }
 
+#if defined(HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C)
+        /* 华为定制处理，是否定制校验证书有效期，回调业务函数自己处理 */
+        if (g_mbedtls_customize_cert_date_checker != NULL)
+        {
+            if (g_mbedtls_customize_cert_date_checker(parent) != 0)
+            {
+                if( fallback_parent == NULL )
+                {
+                    fallback_parent = parent;
+                    fallback_signature_is_good = signature_is_good;
+                }
+                continue;
+            }
+        }
+        else /* 如果没有挂回调函数，则按官方默认方式处理 */
+        {
+#if defined(MBEDTLS_HAVE_TIME_DATE)
+            /* optional time check */
+            if (mbedtls_x509_time_cmp(&parent->valid_to, now) < 0 ||    /* past */
+                mbedtls_x509_time_cmp(&parent->valid_from, now) > 0) {  /* future */
+                if (fallback_parent == NULL) {
+                    fallback_parent = parent;
+                    fallback_signature_is_good = signature_is_good;
+                }
+
+                continue;
+            }
+#else
+            ((void) now);
+#endif
+        }
+#else
 #if defined(MBEDTLS_HAVE_TIME_DATE)
         /* optional time check */
         if (mbedtls_x509_time_cmp(&parent->valid_to, now) < 0 ||    /* past */
@@ -2334,6 +2429,7 @@ check_signature:
         }
 #else
         ((void) now);
+#endif
 #endif
 
         *r_parent = parent;
@@ -2560,6 +2656,26 @@ static int x509_crt_verify_chain(
         ver_chain->len++;
         flags = &cur->flags;
 
+#if defined(HUAWEI_CUSTOMISE_CHECK_CERT_DATE_C)
+        /* 华为定制处理，是否定制校验证书有效期，回调业务函数自己处理 */
+        if (g_mbedtls_customize_cert_date_checker != NULL)
+        {
+            *flags |= g_mbedtls_customize_cert_date_checker( child );
+        }
+        else    // 没有注册处理函数，按默认规则处理
+        {
+#if defined(MBEDTLS_HAVE_TIME_DATE)
+            /* Check time-validity (all certificates) */
+            if (mbedtls_x509_time_cmp(&child->valid_to, &now) < 0) {
+                *flags |= MBEDTLS_X509_BADCERT_EXPIRED;
+            }
+
+            if (mbedtls_x509_time_cmp(&child->valid_from, &now) > 0) {
+                *flags |= MBEDTLS_X509_BADCERT_FUTURE;
+            }
+#endif
+        }
+#else
 #if defined(MBEDTLS_HAVE_TIME_DATE)
         /* Check time-validity (all certificates) */
         if (mbedtls_x509_time_cmp(&child->valid_to, &now) < 0) {
@@ -2569,6 +2685,7 @@ static int x509_crt_verify_chain(
         if (mbedtls_x509_time_cmp(&child->valid_from, &now) > 0) {
             *flags |= MBEDTLS_X509_BADCERT_FUTURE;
         }
+#endif
 #endif
 
         /* Stop here for trusted roots (but not for trusted EE certs) */
@@ -2976,6 +3093,46 @@ static int x509_crt_check_san(const mbedtls_x509_sequence *san,
     return -1;
 }
 
+#if defined(HUAWEI_ONT_CHECK_CERT_CN_NAME_C)
+/*****************************************************************************
+ * @brief 华为定制，ONT产品特殊处理，用于校验证书的CN名
+ *        mbedtls默认只校验证书CN，如果不对，则返回错误。
+ *        ONT定制情况下，另外再校验name
+ * @param crt 证书
+ * @param cn CN名
+ * @param flags 输出校验标志
+******************************************************************************/
+static void x509_crt_verify_name( const mbedtls_x509_crt *crt,
+                                  const char *cn,
+                                  uint32_t *flags )
+{
+    const mbedtls_x509_name *name;
+    const mbedtls_x509_sequence *cur = NULL;
+    size_t cn_len = strlen( cn );
+ 
+    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
+    {
+        for( cur = &crt->subject_alt_names; cur != NULL; cur = cur->next )
+        {
+            if( x509_crt_check_san( cur, cn, cn_len ) == 0 )
+                break;
+        }
+    }
+ 
+    for( name = &crt->subject; name != NULL; name = name->next )
+    {
+        if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 &&
+            x509_crt_check_cn( &name->val, cn, cn_len ) == 0 )
+        {
+            break;
+        }
+    }
+ 
+    if( name == NULL && cur == NULL )
+        *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
+}
+#else
+
 /*
  * Verify the requested CN - only call this if cn is not NULL!
  */
@@ -3002,6 +3159,7 @@ static void x509_crt_verify_name(const mbedtls_x509_crt *crt,
 
     *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
 }
+#endif
 
 /*
  * Merge the flags for all certs in the chain, after calling callback
diff --git a/programs/fuzz/Makefile b/programs/fuzz/Makefile
index 828e518..5d3d74d 100644
--- a/programs/fuzz/Makefile
+++ b/programs/fuzz/Makefile
@@ -28,6 +28,11 @@ C_FILES := $(addsuffix .c,$(APPS))
 %.o: %.c
 	$(CC) $(LOCAL_CFLAGS) $(CFLAGS) -c $<	-o $@
 
+ifdef WINDOWS_BUILD
+WIN_LDFLAGS=-lws2_32
+else
+WIN_LDFLAGS=
+endif
 
 ifdef FUZZINGENGINE
 $(BINARIES): %$(EXEXT): %.o common.o $(DEP)
@@ -35,8 +40,8 @@ $(BINARIES): %$(EXEXT): %.o common.o $(DEP)
 	$(CXX) common.o $<	$(LOCAL_LDFLAGS) $(LDFLAGS) -o $@
 else
 $(BINARIES): %$(EXEXT): %.o common.o onefile.o $(DEP)
-	echo " $(CC) common.o onefile.o $< $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@"
-	$(CC) common.o onefile.o $<	$(LOCAL_LDFLAGS) $(LDFLAGS) -o $@
+	echo " $(CC) common.o onefile.o $< $(LOCAL_LDFLAGS) $(LDFLAGS) $(WIN_LDFLAGS) -o $@"
+	$(CC) common.o onefile.o $<	$(LOCAL_LDFLAGS) $(LDFLAGS) $(WIN_LDFLAGS) -o $@
 endif
 
 clean:
diff --git a/programs/test/selftest.c b/programs/test/selftest.c
index 043209b..a518d53 100644
--- a/programs/test/selftest.c
+++ b/programs/test/selftest.c
@@ -14,6 +14,8 @@
 #include "mbedtls/gcm.h"
 #include "mbedtls/ccm.h"
 #include "mbedtls/cmac.h"
+#include "mbedtls/md2.h"
+#include "mbedtls/md4.h"
 #include "mbedtls/md5.h"
 #include "mbedtls/ripemd160.h"
 #include "mbedtls/sha1.h"
@@ -272,6 +274,12 @@ typedef struct {
 const selftest_t selftests[] =
 {
     { "calloc", calloc_self_test },
+#if defined(MBEDTLS_MD2_C)
+    {"md2", mbedtls_md2_self_test},
+#endif
+#if defined(MBEDTLS_MD4_C)
+    {"md4", mbedtls_md4_self_test},
+#endif
 #if defined(MBEDTLS_MD5_C)
     { "md5", mbedtls_md5_self_test },
 #endif
diff --git a/scripts/generate_errors.pl b/scripts/generate_errors.pl
index 0134c94..f8bc7b4 100755
--- a/scripts/generate_errors.pl
+++ b/scripts/generate_errors.pl
@@ -33,7 +33,7 @@ if( @ARGV ) {
 
 my $error_format_file = $data_dir.'/error.fmt';
 
-my @low_level_modules = qw( AES ARIA ASN1 BASE64 BIGNUM
+my @low_level_modules = qw( AES ARIA ASN1 BASE64 BIGNUM BLOWFISH
                             CAMELLIA CCM CHACHA20 CHACHAPOLY CMAC CTR_DRBG DES
                             ENTROPY ERROR GCM HKDF HMAC_DRBG LMS MD5
                             NET OID PADLOCK PBKDF2 PLATFORM POLY1305 RIPEMD160
diff --git a/sizecheck.sh b/sizecheck.sh
new file mode 100644
index 0000000..5e1528c
--- /dev/null
+++ b/sizecheck.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+date > 		./sizelog.txt
+echo "Check size for files:" >> ./sizelog.txt
+find . -name "*.dll" -o -name "*.so" | xargs sha1sum >> ./sizelog.txt
+find . -name "*.a" | grep -v ".dll." | xargs sha1sum >> ./sizelog.txt
+#
+find . -name "*.dll" -o -name "*.so" | xargs ls -l >> ./sizelog.txt
+find . -name "*.a" | grep -v ".dll." | xargs ls -l >> ./sizelog.txt
+#
+find . -name "*.a" | grep -v ".dll." | xargs size >> ./sizelog.txt
+find . -name "*.dll" -o -name "*.so" | xargs size >> ./sizelog.txt
+echo "Size check down!"
